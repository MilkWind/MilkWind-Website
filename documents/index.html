<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/MilkWind-Website/_next/static/css/fe7e5644f748258b.css" data-precedence="next"/><link rel="stylesheet" href="/MilkWind-Website/_next/static/css/38943437573ce53c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/MilkWind-Website/_next/static/chunks/webpack-453b10ff6467cd69.js"/><script src="/MilkWind-Website/_next/static/chunks/4bd1b696-5119e10e90c1bd1b.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/1684-794bcba02d6f7373.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/main-app-c5f95d71e93250dc.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/1899-38fe6771109eb8a8.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/layout-3eed8318d7b0d3da.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/error-dda32be1d095a86c.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/6874-fbe9a08eb79b991c.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/not-found-9ff98b2ccf24cac7.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/206-4f4cbf4d7156f437.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/documents/layout-28408791defde09e.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/2415-689c103fb3d2c28d.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/8925-ba454bc771a09396.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/607-9c8fd2b2031b2032.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/8610-7bd3f91f3cf2a4d6.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/documents/page-a273e598d07a6275.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/documents/loading-1fa3f98b6e5a8e78.js" async=""></script><script src="/MilkWind-Website/_next/static/chunks/app/loading-68f227fb49b3ac8c.js" async=""></script><title>Documents - Interactive Portfolio</title><meta name="description" content="Technical insights, tutorials, and in-depth analysis on web development."/><meta name="author" content="Developer"/><meta name="keywords" content="portfolio,3D,interactive,web development,Three.js,Next.js"/><meta property="og:title" content="Personal Website - Interactive 3D Portfolio"/><meta property="og:description" content="An interactive 3D personal website featuring work showcases and technical insights"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Personal Website - Interactive 3D Portfolio"/><meta name="twitter:description" content="An interactive 3D personal website featuring work showcases and technical insights"/><link rel="icon" href="/MilkWind-Website/favicon.ico" type="image/x-icon" sizes="32x32"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/MilkWind-Website/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_d71c80 __variable_744f1f font-sans antialiased min-h-screen bg-background text-foreground"><div class="fixed inset-0 w-full h-full overflow-hidden pointer-events-none z-0" style="background:linear-gradient(135deg, hsl(210, 80%, 60%), hsl(180, 40%, 50%))"></div><div class="fixed top-20 right-5 z-50"><div class="w-16 h-16 rounded-full backdrop-blur-md border animate-pulse bg-surface/60 border-surface/40"></div></div><!--$--><style>
:root {
  --bprogress-color: #0066cc;
  --bprogress-height: 4px;
  --bprogress-spinner-size: 18px;
  --bprogress-spinner-animation-duration: 400ms;
  --bprogress-spinner-border-size: 2px;
  --bprogress-box-shadow: 0 0 10px #0066cc, 0 0 5px #0066cc;
  --bprogress-z-index: 99999;
  --bprogress-spinner-top: 15px;
  --bprogress-spinner-bottom: auto;
  --bprogress-spinner-right: 15px;
  --bprogress-spinner-left: auto;
}

.bprogress {
  width: 0;
  height: 0;
  pointer-events: none;
  z-index: var(--bprogress-z-index);
}

.bprogress .bar {
  background: var(--bprogress-color);
  position: fixed;
  z-index: var(--bprogress-z-index);
  top: 0;
  left: 0;
  width: 100%;
  height: var(--bprogress-height);
}

/* Fancy blur effect */
.bprogress .peg {
  display: block;
  position: absolute;
  right: 0;
  width: 100px;
  height: 100%;
  box-shadow: var(--bprogress-box-shadow);
  opacity: 1.0;
  transform: rotate(3deg) translate(0px, -4px);
}

/* Remove these to get rid of the spinner */
.bprogress .spinner {
  display: block;
  position: fixed;
  z-index: var(--bprogress-z-index);
  top: var(--bprogress-spinner-top);
  bottom: var(--bprogress-spinner-bottom);
  right: var(--bprogress-spinner-right);
  left: var(--bprogress-spinner-left);
}

.bprogress .spinner-icon {
  width: var(--bprogress-spinner-size);
  height: var(--bprogress-spinner-size);
  box-sizing: border-box;
  border: solid var(--bprogress-spinner-border-size) transparent;
  border-top-color: var(--bprogress-color);
  border-left-color: var(--bprogress-color);
  border-radius: 50%;
  -webkit-animation: bprogress-spinner var(--bprogress-spinner-animation-duration) linear infinite;
  animation: bprogress-spinner var(--bprogress-spinner-animation-duration) linear infinite;
}

.bprogress-custom-parent {
  overflow: hidden;
  position: relative;
}

.bprogress-custom-parent .bprogress .spinner,
.bprogress-custom-parent .bprogress .bar {
  position: absolute;
}

.bprogress .indeterminate {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--bprogress-height);
  overflow: hidden;
}

.bprogress .indeterminate .inc,
.bprogress .indeterminate .dec {
  position: absolute;
  top: 0;
  height: 100%;
  background-color: var(--bprogress-color);
}

.bprogress .indeterminate .inc {
  animation: bprogress-indeterminate-increase 2s infinite;
}

.bprogress .indeterminate .dec {
  animation: bprogress-indeterminate-decrease 2s 0.5s infinite;
}

@-webkit-keyframes bprogress-spinner {
  0%   { -webkit-transform: rotate(0deg); transform: rotate(0deg); }
  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }
}

@keyframes bprogress-spinner {
  0%   { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes bprogress-indeterminate-increase {
  from { left: -5%; width: 5%; }
  to { left: 130%; width: 100%; }
}

@keyframes bprogress-indeterminate-decrease {
  from { left: -80%; width: 80%; }
  to { left: 110%; width: 10%; }
}
</style><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--><!--$--><div class="relative min-h-screen bg-background false"><button class="fixed top-4 left-4 z-50 md:hidden p-3 rounded-full bg-surface/80 backdrop-blur-sm border border-foreground/20 text-foreground hover:text-primary transition-colors" tabindex="0"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button><section class="transition-all duration-1000 opacity-100 absolute top-0"><div class="fixed inset-0 z-50 flex items-center justify-center" style="background:linear-gradient(135deg, #f8fafc 0%, #f1f5f9 50%, #e2e8f0 100%);opacity:0"><div class="absolute inset-0" style="background-color:rgba(255, 255, 255, 0.8);backdrop-filter:blur(20px);opacity:0"></div><div class="relative w-full h-full max-w-3xl max-h-3xl" style="perspective:1400px;opacity:0;transform:scale(0.9)"><div style="position:relative;width:100%;height:100%;perspective:1200px;transform-style:preserve-3d" class="jsx-2a5b65929f990e66 elegant-3d-scene"><div style="position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);transform-style:preserve-3d" class="jsx-2a5b65929f990e66"><div class="elegant-diamond" style="position:relative;width:120px;height:120px;transform-style:preserve-3d;animation:elegantRotate 8s ease-in-out infinite"><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(60px);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(73, 181, 232, 0.8);filter:drop-shadow(0 0 20px rgba(73, 181, 232, 0.3))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(60px) rotateY(90deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(139, 92, 246, 0.8);filter:drop-shadow(0 0 20px rgba(139, 92, 246, 0.3))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(60px) rotateY(180deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(73, 181, 232, 0.8);filter:drop-shadow(0 0 20px rgba(73, 181, 232, 0.3))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(60px) rotateY(270deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(73, 181, 232, 0.8);filter:drop-shadow(0 0 20px rgba(73, 181, 232, 0.3))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(-60px) rotateX(180deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(73, 181, 232, 0.6);filter:drop-shadow(0 0 20px rgba(73, 181, 232, 0.2))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(-60px) rotateX(180deg) rotateY(90deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(139, 92, 246, 0.6);filter:drop-shadow(0 0 20px rgba(139, 92, 246, 0.2))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(-60px) rotateX(180deg) rotateY(180deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(73, 181, 232, 0.6);filter:drop-shadow(0 0 20px rgba(73, 181, 232, 0.2))"></div><div style="position:absolute;width:0;height:0;left:50%;top:50%;transform:translate(-50%, -50%) translateZ(-60px) rotateX(180deg) rotateY(270deg);border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(73, 181, 232, 0.6);filter:drop-shadow(0 0 20px rgba(73, 181, 232, 0.2))"></div></div></div><div class="elegant-particles" style="position:absolute;inset:0;overflow:hidden"></div></div></div><div class="absolute bottom-24 left-1/2 transform -translate-x-1/2 text-center" style="opacity:0;transform:translateY(30px)"><h2 class="text-2xl font-light tracking-[0.2em] mb-6" style="color:#1f2937;font-family:&quot;Inter&quot;, system-ui, sans-serif;text-shadow:0 1px 3px rgba(0, 0, 0, 0.1)">loading.loading</h2><div class="flex justify-center items-center space-x-3"><div class="relative" style="transform:scale(0)"><div class="w-2 h-2 rounded-full relative" style="background:linear-gradient(135deg, rgb(80, 175, 255), rgb(76, 165, 242));box-shadow:0 0 10px rgba(73, 181, 232, 0.4)"></div><div class="absolute inset-0 w-2 h-2 rounded-full" style="background:radial-gradient(circle, rgba(73, 181, 232, 0.6), transparent);filter:blur(4px)"></div></div><div class="relative" style="transform:scale(0)"><div class="w-2 h-2 rounded-full relative" style="background:linear-gradient(135deg, rgb(80, 175, 255), rgb(76, 165, 242));box-shadow:0 0 10px rgba(73, 181, 232, 0.4)"></div><div class="absolute inset-0 w-2 h-2 rounded-full" style="background:radial-gradient(circle, rgba(73, 181, 232, 0.6), transparent);filter:blur(4px)"></div></div><div class="relative" style="transform:scale(0)"><div class="w-2 h-2 rounded-full relative" style="background:linear-gradient(135deg, rgb(80, 175, 255), rgb(76, 165, 242));box-shadow:0 0 10px rgba(73, 181, 232, 0.4)"></div><div class="absolute inset-0 w-2 h-2 rounded-full" style="background:radial-gradient(circle, rgba(73, 181, 232, 0.6), transparent);filter:blur(4px)"></div></div><div class="relative" style="transform:scale(0)"><div class="w-2 h-2 rounded-full relative" style="background:linear-gradient(135deg, rgb(80, 175, 255), rgb(76, 165, 242));box-shadow:0 0 10px rgba(73, 181, 232, 0.4)"></div><div class="absolute inset-0 w-2 h-2 rounded-full" style="background:radial-gradient(circle, rgba(73, 181, 232, 0.6), transparent);filter:blur(4px)"></div></div></div><p class="text-sm font-light tracking-wider mt-4 opacity-60" style="color:#6b7280;opacity:0">loading.preparingExperience</p></div></div></section></div><!--$--><!--/$--><!--$--><!--/$--><!--/$--><!--/$--><script src="/MilkWind-Website/_next/static/chunks/webpack-453b10ff6467cd69.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[38735,[\"1899\",\"static/chunks/1899-38fe6771109eb8a8.js\",\"7177\",\"static/chunks/app/layout-3eed8318d7b0d3da.js\"],\"default\"]\n3:I[19945,[\"1899\",\"static/chunks/1899-38fe6771109eb8a8.js\",\"7177\",\"static/chunks/app/layout-3eed8318d7b0d3da.js\"],\"default\"]\n4:I[65337,[\"1899\",\"static/chunks/1899-38fe6771109eb8a8.js\",\"7177\",\"static/chunks/app/layout-3eed8318d7b0d3da.js\"],\"default\"]\n5:I[96190,[\"1899\",\"static/chunks/1899-38fe6771109eb8a8.js\",\"7177\",\"static/chunks/app/layout-3eed8318d7b0d3da.js\"],\"ClientProviders\"]\n6:I[87555,[],\"\"]\n7:I[51901,[\"8039\",\"static/chunks/app/error-dda32be1d095a86c.js\"],\"default\"]\n8:I[31295,[],\"\"]\n9:I[6874,[\"6874\",\"static/chunks/6874-fbe9a08eb79b991c.js\",\"4345\",\"static/chunks/app/not-found-9ff98b2ccf24cac7.js\"],\"\"]\na:I[94970,[],\"ClientSegmentRoot\"]\nb:I[44065,[\"206\",\"static/chunks/206-4f4cbf4d7156f437.js\",\"3092\",\"static/chunks/app/documents/layout-28408791defde09e.js\"],\"default\"]\nd:I[98645,[\"2415\",\"static/chunks/2415-689c103fb3d2c28d.js\",\"6874\",\"static/chunks/6874-fbe9a08eb79b991c.js\",\"8925\",\"static/chunks/8925-ba454bc771a09396.js\",\"607\",\"static/chunks/607-9c8fd2b2031b2032.js\",\"8610\",\"static/chunks/8610-7bd3f91f3cf2a4d6.js\",\"8875\",\"static/chunks/app/documents/page-a273e598d07a6275.js\"],\"DocumentsLayoutClient\"]\n46:I[59665,[],\"MetadataBoundary\"]\n48:I[59665,[],\"OutletBoundary\"]\n4b:I[74911,[],\"AsyncMetadataOutlet\"]\n4d:I[39460,[\"2415\",\"static/chunks/2415-689c103fb3d2c28d.js\",\"8610\",\"static/chunks/8610-7bd3f91f3cf2a4d6.js\",\"5650\",\"static/chunks/app/documents/loading-1fa3f98b6e5a8e78.js\"],\"default\"]\n4e:I[88610,[\"2415\",\"static/chunks/2415-689c103fb3d2c28d.js\",\"8610\",\"static/chunks/8610-7bd3f91f3cf2a4d6.js\",\"4209\",\"static/chunks/app/loading-68f227fb49b3ac8c.js\"],\"default\"]\n4f:I[59665,[],\"ViewportBoundary\"]\n51:I[26614,[],\"\"]\n:HL[\"/MilkWind-Website/_next/static/css/fe7e5644f748258b.css\",\"style\"]\n:HL[\"/MilkWind-Website/_next/static/css/38943437573ce53c.css\",\"style\"]\ne:T13c49,"])</script><script>self.__next_f.push([1,"\r\n# All-Chat-on-This Configuration Parsing Implementation: Complete Data Flow from Configuration to Messages\r\n\r\nHandling API differences across various AI service providers is like dealing with a \"United Nations of data formats,\" and ACOT is specifically designed to solve this problem.\r\n\r\nThis article will deeply analyze every aspect from the UserConfigDO configuration class to sendMessage message transmission, comprehensively deconstructing this data processing system that unifies different AI service provider APIs.\r\n\r\n## Configuration Class Design: UserConfigDO's Flexible Architecture\r\n\r\nWhen dealing with diverse AI service provider APIs, the main challenge isn't calling the API itself, but designing a sufficiently flexible configuration system to adapt to vastly different authentication methods and data formats.\r\n\r\n### Flexible API Key Placement Strategy\r\n\r\n```java\r\n// API key placement strategy\r\nprivate String apiKeyPlacement; // 'header', 'body', or 'custom_header'\r\nprivate String apiKeyHeader; // Custom header name when apiKeyPlacement='custom_header'\r\nprivate String apiKeyBodyPath; // JSON path when apiKeyPlacement='body'\r\n```\r\n\r\n**Why do we need three strategies?**\r\n\r\nLet's look at the diversity of AI service providers in reality:\r\n\r\n**Header Strategy (Most Common)**:\r\n```http\r\n# OpenAI style\r\nAuthorization: Bearer sk-xxxxxxxxxxxx\r\n\r\n# Anthropic style\r\nx-api-key: sk-ant-xxxxxxxxxxxx\r\n\r\n# Google style\r\nX-Goog-Api-Key: AIzaxxxxxxxxxxxx\r\n```\r\n\r\n**Body Strategy (Embedded)**:\r\n```json\r\n{\r\n\"api_key\": \"sk-xxxxxxxxxxxx\",\r\n\"messages\": [...]\r\n}\r\n```\r\n\r\n**Custom Header Strategy (Personalized)**:\r\n```http\r\nCustom-Auth-Token: xxxxxxxxxxxx\r\nX-Custom-Key: xxxxxxxxxxxx\r\n```\r\n\r\nThe mathematical expression of this design:\r\n$$API Authentication Strategy = \\begin{cases}\r\nHeader \u0026 \\text{if placement = 'header'} \\\\\r\nBody \u0026 \\text{if placement = 'body'} \\\\\r\nCustomHeader \u0026 \\text{if placement = 'custom\\_header'}\r\n\\end{cases}$$\r\n\r\n### JSON Template Design: Unified Processing\r\n\r\n```java\r\n// JSON templates\r\n@TableField(typeHandler = JacksonTypeHandler.class)\r\nprivate Map requestTemplate; // Request JSON template\r\n\r\n@TableField(typeHandler = JacksonTypeHandler.class)\r\nprivate Map responseTemplate; // Response processing JSON template\r\n```\r\n\r\n**Why use JacksonTypeHandler?**\r\n\r\nThis is MyBatis Plus's elegant solution for handling complex objects:\r\n\r\nWrong approach:\r\n```java\r\n// ❌ Manual serialization, error-prone\r\nprivate String requestTemplateJson;\r\n\r\n// Requires manual conversion when used\r\nObjectMapper mapper = new ObjectMapper();\r\nMap template = mapper.readValue(requestTemplateJson, Map.class);\r\n```\r\n\r\nCorrect approach:\r\n```java\r\n// ✅ Automatic serialization, type-safe\r\n@TableField(typeHandler = JacksonTypeHandler.class)\r\nprivate Map requestTemplate;\r\n\r\n// Direct use, no conversion needed\r\ntemplate.put(\"model\", \"gpt-4\");\r\n```\r\n\r\n**Template compatibility measures**:\r\n\r\nDifferent service providers may have vastly different request formats:\r\n\r\n```json\r\n// OpenAI format\r\n{\r\n\"model\": \"gpt-4\",\r\n\"messages\": [...],\r\n\"temperature\": 0.7\r\n}\r\n\r\n// Claude format\r\n{\r\n\"model\": \"claude-3-sonnet-20240229\",\r\n\"max_tokens\": 1024,\r\n\"messages\": [...]\r\n}\r\n\r\n// Custom API format\r\n{\r\n\"engine\": \"custom-model\",\r\n\"prompt\": \"...\",\r\n\"config\": {\r\n\"temperature\": 0.7,\r\n\"max_length\": 2048\r\n}\r\n}\r\n```\r\n\r\nThrough templating, we can preset any format and then dynamically fill in message content.\r\n\r\n### Message Path Configuration Design: Supporting Complex Nested Structures\r\n\r\n```java\r\n// Request and response processing strategies\r\nprivate String requestMessageGroupPath; // JSON path for message groups\r\nprivate String requestRolePathFromGroup; // JSON path for role in message group\r\nprivate String requestTextPathFromGroup; // JSON path for request text\r\nprivate String responseTextPath; // JSON path for response text\r\nprivate String responseThinkingTextPath; // JSON path for thinking text in response\r\n```\r\n\r\n**How does the path system work?**\r\n\r\nTake a complex API format as an example:\r\n\r\n```json\r\n{\r\n\"model\": \"gpt-4\",\r\n\"parameters\": {\r\n\"conversation\": {\r\n\"messages\": [\r\n{\r\n\"role\": \"user\",\r\n\"content\": \"Hello\"\r\n}\r\n]\r\n}\r\n}\r\n}\r\n```\r\n\r\nCorresponding path configuration:\r\n- `requestMessageGroupPath`: `\"parameters.conversation.messages\"`\r\n- `requestRolePathFromGroup`: `\"role\"`\r\n- `requestTextPathFromGroup`: `\"content\"`\r\n\r\n**Mathematical expression of JsonPath**:\r\n\r\nThe path parsing algorithm can be expressed as:\r\n$$JsonPath(object, path) = object[path_0][path_1]...[path_n]$$\r\n\r\nWhere $path = path_0.path_1...path_n$\r\n\r\n### Complete UserConfigDO Structure Diagram\r\n\r\n```mermaid\r\nclassDiagram\r\nclass UserConfigDO {\r\n+Long id\r\n+Boolean isAvailable\r\n+String name\r\n+String apiUrl\r\n+String apiKey\r\n\r\n+String apiKeyPlacement\r\n+String apiKeyHeader\r\n+String apiKeyBodyPath\r\n\r\n+Map requestTemplate\r\n+Map responseTemplate\r\n+Map headers\r\n\r\n+String requestMessageGroupPath\r\n+String requestRolePathFromGroup\r\n+String requestTextPathFromGroup\r\n+String responseTextPath\r\n+String responseThinkingTextPath\r\n\r\n+String requestUserRoleField\r\n+String requestAssistantField\r\n+String requestSystemField\r\n\r\n+LocalDateTime lastUsedTime\r\n+String secretKey\r\n}\r\n```\r\n\r\n## Data Parsing Logic: The Dual Performance of prepareRequestData\r\n\r\nData preparation is the core of the entire system, requiring conversion of user configuration into sendable HTTP requests. ACOT provides two overloaded methods to handle different scenarios.\r\n\r\n### Test Version: Basic Logic for Single Message Processing\r\n\r\n```java\r\npublic static Map prepareRequestData(UserConfigDO config, String messageText) {\r\n// Prepare request headers\r\nMap headers = new HashMap\u003c\u003e(config.getHeaders() != null ? config.getHeaders() : new HashMap\u003c\u003e());\r\n\r\n// Check if API key is encrypted, decrypt if needed\r\nString apiKey = config.getApiKey();\r\nif (apiKey != null \u0026\u0026 apiKey.startsWith(\"enc:\") \u0026\u0026 StringUtils.hasText(config.getSecretKey())) {\r\ntry {\r\napiKey = decryptApiKey(apiKey.substring(4), config.getSecretKey());\r\n} catch (Exception e) {\r\nlog.error(\"Error decrypting API key\", e);\r\nthrow new ServiceException(CONFIG_NOT_EXISTS, \"Failed to decrypt API key: \" + e.getMessage());\r\n}\r\n}\r\n```\r\n\r\n### Triple Dispatch for API Key Placement\r\n\r\n```java\r\n// Add API key to request headers based on placement strategy\r\nif (\"header\".equals(config.getApiKeyPlacement()) || config.getApiKeyPlacement() == null) {\r\nheaders.put(\"Authorization\", \"Bearer \" + apiKey);\r\n} else if (\"custom_header\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyHeader() != null) {\r\nheaders.put(config.getApiKeyHeader(), apiKey);\r\n}\r\n\r\n// Prepare request body by cloning template\r\nMap requestBody = new HashMap\u003c\u003e(config.getRequestTemplate());\r\n\r\n// Add API key to request body if needed\r\nif (\"body\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyBodyPath() != null) {\r\nJsonUtils.setValueByPath(requestBody, config.getApiKeyBodyPath(), apiKey);\r\n}\r\n```\r\n\r\n**Strategy Pattern**:\r\n\r\nEach placement method has its specific processing logic:\r\n\r\n```typescript\r\n// Pseudocode representation of dispatch logic\r\nswitch(apiKeyPlacement) {\r\ncase 'header':\r\nheaders['Authorization'] = 'Bearer ' + apiKey;\r\nbreak;\r\ncase 'custom_header':\r\nheaders[apiKeyHeader] = apiKey;\r\nbreak;\r\ncase 'body':\r\nsetValueByPath(requestBody, apiKeyBodyPath, apiKey);\r\nbreak;\r\n}\r\n```\r\n\r\n**JsonUtils.setValueByPath path setting**:\r\n\r\nThis method can handle complex nested paths:\r\n\r\n```java\r\n// Path \"auth.credentials.api_key\" will be resolved as:\r\n// requestBody.auth.credentials.api_key = apiKey\r\nJsonUtils.setValueByPath(requestBody, \"auth.credentials.api_key\", apiKey);\r\n```\r\n\r\n### Production Version: Conversation History Processing\r\n\r\n```java\r\npublic static Map prepareRequestData(UserConfigDO config, String messageText, List conversationMessages) {\r\n// ... same logic as before\r\n\r\n// Create message group and add conversation history\r\nif (StringUtils.hasText(config.getRequestMessageGroupPath()) \u0026\u0026 (conversationMessages != null || messageText != null)) {\r\nList\u003e messages = new ArrayList\u003c\u003e();\r\n\r\n// Add previous messages\r\nif (conversationMessages != null) {\r\nfor (ConversationMessageDO message : conversationMessages) {\r\n// Skip system messages\r\nif (\"system\".equals(message.getRole())) {\r\ncontinue;\r\n}\r\n```\r\n\r\n**Core algorithm for conversation history processing**:\r\n\r\n```java\r\n// Role mapping strategy\r\nString userRoleValue = StringUtils.hasText(config.getRequestUserRoleField()) ?\r\nconfig.getRequestUserRoleField() : \"user\";\r\n\r\nString assistantRoleValue = StringUtils.hasText(config.getRequestAssistantField()) ?\r\nconfig.getRequestAssistantField() : \"assistant\";\r\n```\r\n\r\nThis mapping mechanism solves the problem of different role field differences among service providers:\r\n\r\n| Service Provider | User Role | Assistant Role |\r\n|------------------|-----------|----------------|\r\n| OpenAI | \"user\" | \"assistant\" |\r\n| Claude | \"user\" | \"assistant\" |\r\n| Custom API | \"human\" | \"ai\" |\r\n| Some APIs | \"customer\" | \"agent\" |\r\n\r\n**Dynamic message object construction**:\r\n\r\n```java\r\nMap messageObj = new HashMap\u003c\u003e();\r\n// Dynamically set role field name\r\nif (\"user\".equals(message.getRole())) {\r\nmessageObj.put(rolePath, userRoleValue);\r\n} else if (\"assistant\".equals(message.getRole())) {\r\nmessageObj.put(rolePath, assistantRoleValue);\r\n}\r\n// Dynamically set content field name\r\nmessageObj.put(textPath, message.getContent());\r\n```\r\n\r\nIf certain APIs have user and AI role fields that aren't the default `user` and `assistant`, this functionality can support custom configuration of user and AI field names.\r\n\r\n## Message Generation and Transmission Logic: Complete Business Process of sendMessage\r\n\r\nMessage transmission is the ultimate goal of the entire system, involving permission verification, data preparation, HTTP calls, response parsing, and other multiple aspects.\r\n\r\n### Permission Verification\r\n\r\n```java\r\n// Verify conversation belongs to this user\r\nConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\nif (conversation == null) {\r\nthrow new ServiceException(CONVERSATION_NOT_EXISTS.getCode(), CONVERSATION_NOT_EXISTS.getMsg());\r\n}\r\n\r\n// Get configuration\r\nUserConfigDO config = userConfigService.getConfig(configId, userId);\r\nif (config == null) {\r\nthrow new ServiceException(CONFIGURATION_NOT_EXISTS.getCode(), CONFIGURATION_NOT_EXISTS.getMsg());\r\n}\r\n```\r\n\r\n**Dual permission verification mechanism**:\r\n\r\n1. **Conversation ownership verification**: Ensures users can only operate their own conversations\r\n2. **Configuration ownership verification**: Ensures users can only use their own configurations\r\n\r\nThis design prevents common security issues:\r\n- **Horizontal privilege escalation**: User A cannot access User B's conversations\r\n- **Configuration leakage**: User A cannot use User B's API configurations\r\n\r\n### Message Creation Strategy: Create First, Save Later\r\n\r\n```java\r\n// Create user message (but don't save yet)\r\nConversationMessageDO userMessageDO = new ConversationMessageDO()\r\n.setConversationId(conversationId)\r\n.setConfigId(configId)\r\n.setRole(\"user\")\r\n.setContent(userMessage);\r\n\r\n// Get historical messages in conversation\r\nList previousMessages = list(new LambdaQueryWrapper()\r\n.eq(ConversationMessageDO::getConversationId, conversationId)\r\n.orderByAsc(ConversationMessageDO::getCreateTime));\r\n\r\n// Generate assistant reply\r\nConversationMessageDO assistantMessageDO = generateAssistantResponse(userMessage, config, conversationId, configId, previousMessages);\r\n\r\n// If execution reaches here, API call was successful, now save user message\r\nsave(userMessageDO);\r\nsave(assistantMessageDO);\r\n```\r\n\r\n**Why create user message first but don't save?**\r\n\r\nThis is a transactional design pattern, following the \"all succeed or all fail\" principle:\r\n\r\nWrong approach:\r\n```java\r\n// ❌ Save user message first, if API call fails, data inconsistency\r\nsave(userMessageDO);\r\ntry {\r\nConversationMessageDO response = callAPI(...);\r\nsave(response);\r\n} catch (Exception e) {\r\n// User message saved but no reply - data inconsistency!\r\nthrow e;\r\n}\r\n```\r\n\r\nCorrect approach:\r\n```java\r\n// ✅ Try API call first, batch save after success\r\nConversationMessageDO userMessageDO = createUserMessage(...);\r\nConversationMessageDO assistantResponse = callAPI(...);\r\n// API successful, batch save\r\nsave(userMessageDO);\r\nsave(assistantResponse);\r\n```\r\n\r\n### generateAssistantResponse: Core Engine for HTTP Calls\r\n\r\n```java\r\nprivate ConversationMessageDO generateAssistantResponse(\r\nString userMessage,\r\nUserConfigDO config,\r\nLong conversationId,\r\nLong configId,\r\nList conversationMessages) {\r\n\r\n// Use general method to prepare request data including conversation history\r\nMap requestData = HttpUtils.prepareRequestData(config, userMessage, conversationMessages);\r\nMap headers = (Map) requestData.get(\"headers\");\r\nMap requestBody = (Map) requestData.get(\"requestBody\");\r\n\r\n// Execute actual HTTP request\r\nString requestBodyStr = JsonUtils.toJsonString(requestBody);\r\nString responseStr = HttpUtils.post(config.getApiUrl(), headers, requestBodyStr);\r\n```\r\n\r\n**Complete data flow of HTTP request**:\r\n\r\n```mermaid\r\nsequenceDiagram\r\nparticipant Service as ConversationService\r\nparticipant Utils as HttpUtils\r\nparticipant API as AI_API\r\nparticipant Parser as JsonUtils\r\n\r\nService-\u003e\u003eUtils: prepareRequestData(config, message, history)\r\nUtils-\u003e\u003eUtils: Decrypt API key\r\nUtils-\u003e\u003eUtils: Build request headers\r\nUtils-\u003e\u003eUtils: Build request body\r\nUtils--\u003e\u003eService: {headers, requestBody}\r\n\r\nService-\u003e\u003eParser: toJsonString(requestBody)\r\nParser--\u003e\u003eService: requestBodyStr\r\n\r\nService-\u003e\u003eUtils: post(url, headers, body)\r\nUtils-\u003e\u003eAPI: HTTP POST\r\nAPI--\u003e\u003eUtils: JSON Response\r\nUtils--\u003e\u003eService: responseStr\r\n\r\nService-\u003e\u003eParser: parseObject(responseStr)\r\nParser--\u003e\u003eService: responseMap\r\n\r\nService-\u003e\u003eParser: extractValueFromPath(responseMap, textPath)\r\nParser--\u003e\u003eService: content\r\n```\r\n\r\n**Dual-path design for response parsing**:\r\n\r\n```java\r\n// Extract content and thinking text from response using specified paths\r\nString content = null;\r\nString thinking = null;\r\n\r\nif (StringUtils.hasText(config.getResponseTextPath())) {\r\ncontent = JsonUtils.extractValueFromPath(responseMap, config.getResponseTextPath());\r\n}\r\n\r\nif (StringUtils.hasText(config.getResponseThinkingTextPath())) {\r\nthinking = JsonUtils.extractValueFromPath(responseMap, config.getResponseThinkingTextPath());\r\n}\r\n```\r\n\r\nThis design supports different service provider response formats:\r\n\r\n```json\r\n// OpenAI format\r\n{\r\n\"choices\": [\r\n{\r\n\"message\": {\r\n\"content\": \"This is the reply content\"\r\n}\r\n}\r\n]\r\n}\r\n// Path: \"choices.0.message.content\"\r\n\r\n// Claude format\r\n{\r\n\"content\": [\r\n{\r\n\"text\": \"This is Claude's reply\"\r\n}\r\n]\r\n}\r\n// Path: \"content.0.text\"\r\n\r\n// Format supporting thinking process\r\n{\r\n\"response\": {\r\n\"content\": \"This is the reply content\",\r\n\"thinking\": \"This is the thinking process\"\r\n}\r\n}\r\n// Content path: \"response.content\"\r\n// Thinking path: \"response.thinking\"\r\n```\r\n\r\n### Transaction Management and Caching Strategy\r\n\r\n```java\r\n@Override\r\n@Transactional\r\n@Caching(evict = {\r\n@CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n})\r\n```\r\n\r\n**@Transactional rollback mechanism**:\r\n\r\nSpring's transaction management ensures data consistency:\r\n\r\n```java\r\n@Transactional\r\npublic ConversationMessageDO sendMessage(...) {\r\ntry {\r\n// 1. Verify permissions\r\nvalidatePermissions();\r\n\r\n// 2. Call API\r\nConversationMessageDO response = callAPI();\r\n\r\n// 3. Save messages\r\nsave(userMessage);\r\nsave(response);\r\n\r\n// 4. Update conversation time\r\nupdateConversation();\r\n\r\nreturn response;\r\n} catch (Exception e) {\r\n// Any exception will trigger rollback, ensuring data consistency\r\nthrow e;\r\n}\r\n}\r\n```\r\n\r\n**Considerations for cache invalidation strategy**:\r\n\r\n```java\r\n@CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n```\r\n\r\nThis annotation ensures that when new messages are generated, related caches are cleared. Cache key design considers:\r\n- **Conversation isolation**: Different conversation caches are independent\r\n- **User isolation**: Different user caches are independent\r\n- **Precise invalidation**: Only clear related caches, don't affect other data\r\n\r\n### Configuration Monitoring: markConfigurationAsAvailable\r\n\r\n```java\r\n// Mark configuration as available because it was successfully used\r\nmarkConfigurationAsAvailable(configId, userId);\r\n\r\n@Override\r\npublic boolean markConfigurationAsAvailable(Long configId, Long userId) {\r\nUserConfigDO config = userConfigService.getConfig(configId, userId);\r\nif (config == null) {\r\nreturn false;\r\n}\r\n\r\n// Set isAvailable to true and set lastUsedTime to current time\r\nuserConfigService.setAvailableAndUpdateLastUsedTime(configId, true);\r\n\r\nreturn true;\r\n}\r\n```\r\n\r\n**Business value of availability marking**:\r\n\r\nThis seemingly simple operation actually carries important business logic:\r\n\r\n1. **Health check**: Successful API calls prove configuration is available\r\n2. **Usage statistics**: Record last usage time for analysis\r\n3. **Auto-repair**: Reactivate configurations previously marked as unavailable\r\n4. **User experience**: Let users know which configurations are available\r\n\r\n**Statistical value of lastUsedTime**:\r\n\r\n```sql\r\n-- Can analyze user usage patterns\r\nSELECT configId, COUNT(*) as usage_count,\r\nMAX(lastUsedTime) as last_used,\r\nAVG(TIMESTAMPDIFF(SECOND, createTime, lastUsedTime)) as avg_response_time\r\nFROM user_config\r\nWHERE userId = ?\r\nGROUP BY configId\r\nORDER BY usage_count DESC;\r\n```\r\n\r\n## JSON Path Parsing Engine: Deep Algorithm Analysis of JsonUtils\r\n\r\n~~The hardest episode.~~\r\n\r\n### Mathematical Model of Path Parsing\r\n\r\nJSON path parsing is essentially a **tree traversal problem**, where we need to convert string paths into object access sequences.\r\n\r\nGiven path `path = \"a.b[0].c.d[1].e\"`, the parsing algorithm can be expressed as:\r\n\r\n$$PathTraversal(object, path) = \\prod_{i=0}^{n} Access(object_i, token_i)$$\r\n\r\nWhere:\r\n- $token_i$ is the i-th access token in the path\r\n- $Access$ function chooses different access strategies based on token type\r\n\r\n### extractValueFromPath: Core Algorithm for Path Extraction\r\n\r\n```java\r\npublic static String extractValueFromPath(Map data, String path) {\r\nString[] parts = path.split(\"\\\\.\"); // Split path by dots\r\nObject current = data; // Current traversed object\r\n\r\nfor (String part : parts) {\r\nif (current == null) {\r\nreturn null; // Defensive check: return immediately if null encountered\r\n}\r\n\r\n// Handle array notation, like choices[0]\r\nif (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n// Algorithm core: parse array name and index\r\nString arrayName = part.substring(0, part.indexOf('['));\r\nint index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n```\r\n\r\n**Algorithm analysis of array index parsing**:\r\n\r\n```java\r\n// Time complexity analysis of string parsing\r\n// part = \"choices[0]\"\r\nString arrayName = part.substring(0, part.indexOf('[')); // O(n)\r\nint index = Integer.parseInt(part.substring(...)); // O(1)\r\n```\r\n\r\n**Type-safe access strategy**:\r\n\r\n```java\r\nif (current instanceof Map) {\r\nMap map = (Map) current;\r\nif (map.containsKey(arrayName) \u0026\u0026 map.get(arrayName) instanceof List) {\r\nList array = (List) map.get(arrayName);\r\nif (index \u003c array.size()) {\r\ncurrent = array.get(index); // Safe array element access\r\n} else {\r\nreturn null; // Index out of bounds, return null\r\n}\r\n} else {\r\nreturn null; // Field doesn't exist or type mismatch\r\n}\r\n} else {\r\nreturn null; // Current object is not Map type\r\n}\r\n```\r\n\r\n**Why do we need so many type checks?**\r\n\r\nIn the dynamically typed JSON world, we cannot guarantee data structure consistency:\r\n\r\nWrong approach:\r\n```java\r\n// ❌ Dangerous direct access\r\nList array = (List) ((Map) current).get(arrayName);\r\ncurrent = array.get(index); // May throw NullPointerException, ClassCastException, IndexOutOfBoundsException\r\n```\r\n\r\nCorrect approach:\r\n```java\r\n// ✅ Multiple protective checks\r\nif (current instanceof Map) { // Type check\r\nMap map = (Map) current;\r\nif (map.containsKey(arrayName) \u0026\u0026 // Existence check\r\nmap.get(arrayName) instanceof List) { // Type check\r\nList array = (List) map.get(arrayName);\r\nif (index \u003c array.size()) { // Boundary check\r\ncurrent = array.get(index);\r\n}\r\n}\r\n}\r\n```\r\n\r\n### setValueByPath: Intelligent Construction for Path Setting\r\n\r\nCompared to the read-only access of `extractValueFromPath`, `setValueByPath` needs to solve a more complex problem: **how to intelligently construct paths in incomplete JSON structures**.\r\n\r\n```java\r\npublic static void setValueByPath(Map data, String path, Object value) {\r\nString[] parts = path.split(\"\\\\.\");\r\nMap current = data;\r\n\r\n// Step 1: Traverse path, ensure intermediate structures exist\r\nfor (int i = 0; i \u003c parts.length - 1; i++) {\r\nString part = parts[i];\r\n\r\n// Handle array path segments\r\nif (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\nString arrayName = part.substring(0, part.indexOf('['));\r\nint index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n```\r\n\r\n**Intelligent array construction algorithm**:\r\n\r\n```java\r\n// Create new array if it doesn't exist\r\nif (!current.containsKey(arrayName) || !(current.get(arrayName) instanceof List)) {\r\ncurrent.put(arrayName, new ArrayList\u003c\u003e());\r\n}\r\n\r\nList array = (List) current.get(arrayName);\r\n\r\n// Core algorithm: array expansion to ensure index accessibility\r\nwhile (array.size() \u003c= index) {\r\narray.add(new HashMap()); // Fill with empty objects\r\n}\r\n\r\n// Ensure index position is Map object (prepare for next level path)\r\nif (!(array.get(index) instanceof Map)) {\r\narray.set(index, new HashMap());\r\n}\r\n\r\ncurrent = (Map) array.get(index);\r\n```\r\n\r\n**Mathematical analysis of array expansion**:\r\n\r\nAssuming current array length is $n$, target index is $k$, then:\r\n\r\n$$Expansion Count = \\max(0, k - n + 1)$$\r\n\r\n**Why fill with HashMap instead of null?**\r\n\r\nThis is a design trade-off:\r\n\r\nWrong approach:\r\n```java\r\n// ❌ Fill with null\r\nwhile (array.size() \u003c= index) {\r\narray.add(null);\r\n}\r\n// May cause NullPointerException on next access\r\n```\r\n\r\nCorrect approach:\r\n```java\r\n// ✅ Fill with empty objects\r\nwhile (array.size() \u003c= index) {\r\narray.add(new HashMap());\r\n}\r\n// Ensure subsequent paths can continue building\r\n```\r\n\r\n### Practical Application Scenarios of Path Parsing\r\n\r\n**Scenario 1: OpenAI Response Parsing**\r\n\r\n```json\r\n{\r\n\"choices\": [\r\n{\r\n\"message\": {\r\n\"content\": \"This is AI's reply\",\r\n\"role\": \"assistant\"\r\n}\r\n}\r\n]\r\n}\r\n```\r\n\r\n```java\r\n// Extract reply content\r\nString content = JsonUtils.extractValueFromPath(response, \"choices[0].message.content\");\r\n// Result: \"This is AI's reply\"\r\n```\r\n\r\n**Scenario 2: Claude Response Parsing**\r\n\r\n```json\r\n{\r\n\"content\": [\r\n{\r\n\"text\": \"This is Claude's reply\"\r\n}\r\n]\r\n}\r\n```\r\n\r\n```java\r\n// Extract reply content\r\nString content = JsonUtils.extractValueFromPath(response, \"content[0].text\");\r\n// Result: \"This is Claude's reply\"\r\n```\r\n\r\n**Scenario 3: Complex Request Body Construction**\r\n\r\n```java\r\n// Build complex request body\r\nMap requestBody = new HashMap\u003c\u003e();\r\n\r\n// Set model information\r\nJsonUtils.setValueByPath(requestBody, \"model\", \"gpt-4\");\r\n\r\n// Set message array\r\nJsonUtils.setValueByPath(requestBody, \"messages[0].role\", \"user\");\r\nJsonUtils.setValueByPath(requestBody, \"messages[0].content\", \"Hello\");\r\n\r\n// Set configuration parameters\r\nJsonUtils.setValueByPath(requestBody, \"config.temperature\", 0.7);\r\nJsonUtils.setValueByPath(requestBody, \"config.max_tokens\", 1000);\r\n\r\n// Result:\r\n{\r\n\"model\": \"gpt-4\",\r\n\"messages\": [\r\n{\r\n\"role\": \"user\",\r\n\"content\": \"Hello\"\r\n}\r\n],\r\n\"config\": {\r\n\"temperature\": 0.7,\r\n\"max_tokens\": 1000\r\n}\r\n}\r\n```\r\n\r\n### Defensive Design for Edge Case Handling\r\n\r\n**Case 1: Path doesn't exist**\r\n\r\n```java\r\n// Input: {\"user\": {\"name\": \"Zhang San\"}}\r\n// Path: user.age\r\nString age = JsonUtils.extractValueFromPath(data, \"user.age\");\r\n// Result: null (no exception thrown)\r\n```\r\n\r\n**Case 2: Type mismatch**\r\n\r\n```java\r\n// Input: {\"user\": \"Zhang San\"} (user is string, not object)\r\n// Path: user.name\r\nString name = JsonUtils.extractValueFromPath(data, \"user.name\");\r\n// Result: null (no exception thrown)\r\n```\r\n\r\n**Case 3: Array index out of bounds**\r\n\r\n```java\r\n// Input: {\"items\": [1, 2, 3]}\r\n// Path: items[10]\r\nString item = JsonUtils.extractValueFromPath(data, \"items[10]\");\r\n// Result: null (no exception thrown)\r\n```\r\n\r\n### Complete Method Architecture Diagram of JsonUtils\r\n\r\n```mermaid\r\ngraph TB\r\nA[JsonUtils Utility Class] --\u003e B[Basic Serialization]\r\nA --\u003e C[Path Parsing]\r\nA --\u003e D[Type Conversion]\r\n\r\nB --\u003e B1[toJsonString]\r\nB --\u003e B2[parseObject]\r\nB --\u003e B3[parseArray]\r\n\r\nC --\u003e C1[extractValueFromPath]\r\nC --\u003e C2[setValueByPath]\r\n\r\nD --\u003e D1[Type-safe Conversion]\r\nD --\u003e D2[Silent Parsing]\r\n\r\nC1 --\u003e E[Path Splitting]\r\nC1 --\u003e F[Type Checking]\r\nC1 --\u003e G[Array Index Parsing]\r\n\r\nC2 --\u003e H[Intelligent Construction]\r\nC2 --\u003e I[Array Expansion]\r\nC2 --\u003e J[Recursive Path Creation]\r\n\r\nE --\u003e E1[\"path.split('\\\\.')\"]\r\nF --\u003e F1[instanceof Check]\r\nG --\u003e G1[String substring]\r\n\r\nH --\u003e H1[Defensive Creation]\r\nI --\u003e I2[While Loop Expansion]\r\nJ --\u003e J1[Recursive Map Creation]\r\n```\r\n\r\nThrough this path parsing mechanism, ACOT achieves true **API format independence**. No matter how AI service providers change their response formats, they can be\r\n\r\n## Complete System Architecture Diagram\r\n\r\n```mermaid\r\ngraph TB\r\n    A[User Request] --\u003e B[sendMessage Method]\r\n    B --\u003e C[Permission Verification]\r\n    C --\u003e D[Configuration Retrieval]\r\n    D --\u003e E[Message History Query]\r\n    E --\u003e F[prepareRequestData]\r\n    \r\n    F --\u003e G[API Key Decryption]\r\n    G --\u003e H[Request Header Construction]\r\n    H --\u003e I[Request Body Construction]\r\n    I --\u003e J[Message Group Assembly]\r\n    \r\n    J --\u003e K[HTTP POST Call]\r\n    K --\u003e L[Response Parsing]\r\n    L --\u003e M[JsonUtils Path Extraction]\r\n    M --\u003e N[Message Saving]\r\n    N --\u003e O[Cache Update]\r\n    O --\u003e P[Configuration Marking]\r\n    P --\u003e Q[Return Result]\r\n    \r\n    subgraph \"Configuration System\"\r\n        D1[UserConfigDO]\r\n        D2[Flexible Key Placement]\r\n        D3[JSON Templating]\r\n        D4[Path Configuration]\r\n    end\r\n    \r\n    subgraph \"Encryption System\"  \r\n        G1[CryptoJS Compatible]\r\n        G2[EVP_BytesToKey]\r\n        G3[AES/CBC Decryption]\r\n    end\r\n    \r\n    subgraph \"Data Processing\"\r\n        F1[Test Version prepareRequestData]\r\n        F2[Production Version prepareRequestData]\r\n        F3[Message History Processing]\r\n        F4[Role Mapping]\r\n    end\r\n    \r\n    subgraph \"JSON Parsing Engine\"\r\n        M1[extractValueFromPath]\r\n        M2[setValueByPath]\r\n        M3[Path Splitting Algorithm]\r\n        M4[Type Safety Check]\r\n        M5[Array Index Parsing]\r\n        M6[Intelligent Structure Building]\r\n    end\r\n```\r\n\r\n## Performance Optimization\r\n\r\n### Hierarchical Cache Strategy Design\r\n\r\n```java\r\n@Cacheable(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\npublic List\u003cConversationMessageDO\u003e getMessages(Long conversationId, Long userId) {\r\n    // Cache conversation message list, reduce database queries\r\n}\r\n\r\n@Cacheable(key = \"'id:' + #id + ':user:' + #userId\") \r\npublic ConversationMessageDO getMessage(Long id, Long userId) {\r\n    // Cache single message, support fast loading for detail pages\r\n}\r\n```\r\n\r\n**Cache key design considerations**:\r\n- **Uniqueness**: Ensure different data has different keys\r\n- **Predictability**: Easy to manually clear specific caches\r\n- **Hierarchy**: Support batch clearing of related caches\r\n\r\n### Exception Handling\r\n\r\n```java\r\ntry {\r\n    ConversationMessageDO assistantMessageDO = generateAssistantResponse(...);\r\n    save(userMessageDO);\r\n    save(assistantMessageDO);\r\n    return assistantMessageDO;\r\n} catch (Exception e) {\r\n    log.error(\"Error sending message\", e);\r\n    \r\n    // No longer create error messages, throw exception directly\r\n    if (e instanceof ServiceException) {\r\n        throw e;\r\n    }\r\n    throw new ServiceException(MESSAGE_SEND_FAILED.getCode(), e.getMessage());\r\n}\r\n```\r\n\r\n**Exception handling principles**:\r\n1. **Fail fast**: Terminate immediately when errors are found\r\n2. **Information preservation**: Record detailed error logs\r\n3. **Type preservation**: Maintain ServiceException type\r\n4. **Avoid dirty data**: Don't save incomplete conversations\r\n\r\n## Complete Code Analysis\r\n\r\n### JsonUtils: Complete Implementation of JSON Parsing Utility Class\r\n\r\n```java\r\npackage com.chat.allchatonthis.common.util.json;\r\n\r\nimport cn.hutool.core.util.ArrayUtil;\r\nimport cn.hutool.core.util.StrUtil;\r\nimport cn.hutool.json.JSONUtil;\r\nimport com.fasterxml.jackson.annotation.JsonInclude;\r\nimport com.fasterxml.jackson.core.type.TypeReference;\r\nimport com.fasterxml.jackson.databind.DeserializationFeature;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport lombok.SneakyThrows;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Type;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * JSON Utility Class - ACOT's Core Data Parsing Engine\r\n */\r\n@Slf4j\r\npublic class JsonUtils {\r\n\r\n    // ==================== Core Configuration ====================\r\n    \r\n    /** Global ObjectMapper instance - Singleton pattern, thread-safe */\r\n    private static ObjectMapper objectMapper = new ObjectMapper();\r\n\r\n    static {\r\n        // Configure serialization behavior: don't fail on empty beans\r\n        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\r\n        // Configure deserialization behavior: ignore unknown properties\r\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n        // Ignore null values, reduce data transmission volume\r\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n        // Support Java 8 time types\r\n        objectMapper.registerModules(new JavaTimeModule());\r\n    }\r\n\r\n    /**\r\n     * Initialize ObjectMapper - Support Spring Boot auto-configuration\r\n     * \r\n     * @param objectMapper Spring-managed ObjectMapper Bean\r\n     */\r\n    public static void init(ObjectMapper objectMapper) {\r\n        JsonUtils.objectMapper = objectMapper;\r\n    }\r\n\r\n    // ==================== Basic Serialization Methods ====================\r\n\r\n    /**\r\n     * Object to JSON string - Most commonly used serialization method\r\n     * \r\n     * @param object Object to serialize\r\n     * @return JSON string\r\n     */\r\n    @SneakyThrows\r\n    public static String toJsonString(Object object) {\r\n        return objectMapper.writeValueAsString(object);\r\n    }\r\n\r\n    /**\r\n     * Object to JSON byte array - Suitable for network transmission\r\n     * \r\n     * @param object Object to serialize\r\n     * @return JSON byte array\r\n     */\r\n    @SneakyThrows\r\n    public static byte[] toJsonByte(Object object) {\r\n        return objectMapper.writeValueAsBytes(object);\r\n    }\r\n\r\n    /**\r\n     * Object to formatted JSON string - Suitable for debugging and logging\r\n     * \r\n     * @param object Object to serialize\r\n     * @return Formatted JSON string\r\n     */\r\n    @SneakyThrows\r\n    public static String toJsonPrettyString(Object object) {\r\n        return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(object);\r\n    }\r\n\r\n    // ==================== Basic Deserialization Methods ====================\r\n\r\n    /**\r\n     * JSON string to object - Core deserialization method\r\n     * \r\n     * @param text JSON string\r\n     * @param clazz Target type\r\n     * @return Deserialized object\r\n     */\r\n    public static \u003cT\u003e T parseObject(String text, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return null;\r\n        }\r\n        try {\r\n            return objectMapper.readValue(text, clazz);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON parsing failed, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse object from specified path in JSON string - Support nested extraction\r\n     * \r\n     * @param text JSON string\r\n     * @param path Path (e.g., \"data.user\")\r\n     * @param clazz Target type\r\n     * @return Parsed object\r\n     */\r\n    public static \u003cT\u003e T parseObject(String text, String path, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return null;\r\n        }\r\n        try {\r\n            JsonNode treeNode = objectMapper.readTree(text);\r\n            JsonNode pathNode = treeNode.path(path);\r\n            return objectMapper.readValue(pathNode.toString(), clazz);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON path parsing failed, json:{}, path:{}\", text, path, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Byte array to object - Suitable for network transmission data\r\n     * \r\n     * @param bytes JSON byte array\r\n     * @param clazz Target type\r\n     * @return Deserialized object\r\n     */\r\n    public static \u003cT\u003e T parseObject(byte[] bytes, Class\u003cT\u003e clazz) {\r\n        if (ArrayUtil.isEmpty(bytes)) {\r\n            return null;\r\n        }\r\n        try {\r\n            return objectMapper.readValue(bytes, clazz);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON byte array parsing failed\", e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse complex types using TypeReference - Support generics\r\n     * \r\n     * @param text JSON string\r\n     * @param typeReference Type reference\r\n     * @return Parsed object\r\n     */\r\n    public static \u003cT\u003e T parseObject(String text, TypeReference\u003cT\u003e typeReference) {\r\n        try {\r\n            return objectMapper.readValue(text, typeReference);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON TypeReference parsing failed, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Silent parsing - Return null instead of throwing exception when parsing fails\r\n     * \r\n     * @param text JSON string\r\n     * @param typeReference Type reference\r\n     * @return Parsed object or null\r\n     */\r\n    public static \u003cT\u003e T parseObjectQuietly(String text, TypeReference\u003cT\u003e typeReference) {\r\n        try {\r\n            return objectMapper.readValue(text, typeReference);\r\n        } catch (IOException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // ==================== Array Parsing Methods ====================\r\n\r\n    /**\r\n     * JSON string to List - Handle array types\r\n     * \r\n     * @param text JSON string\r\n     * @param clazz Array element type\r\n     * @return List object\r\n     */\r\n    public static \u003cT\u003e List\u003cT\u003e parseArray(String text, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n        try {\r\n            return objectMapper.readValue(text, \r\n                objectMapper.getTypeFactory().constructCollectionType(List.class, clazz));\r\n        } catch (IOException e) {\r\n            log.error(\"JSON array parsing failed, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse array from specified path - Support nested array extraction\r\n     * \r\n     * @param text JSON string\r\n     * @param path Path (e.g., \"data.items\")\r\n     * @param clazz Array element type\r\n     * @return List object\r\n     */\r\n    public static \u003cT\u003e List\u003cT\u003e parseArray(String text, String path, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return null;\r\n        }\r\n        try {\r\n            JsonNode treeNode = objectMapper.readTree(text);\r\n            JsonNode pathNode = treeNode.path(path);\r\n            return objectMapper.readValue(pathNode.toString(), \r\n                objectMapper.getTypeFactory().constructCollectionType(List.class, clazz));\r\n        } catch (IOException e) {\r\n            log.error(\"JSON path array parsing failed, json:{}, path:{}\", text, path, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    // ==================== Tree Structure Parsing Methods ====================\r\n\r\n    /**\r\n     * Parse to JsonNode tree structure - Support dynamic access\r\n     * \r\n     * @param text JSON string\r\n     * @return JsonNode tree\r\n     */\r\n    public static JsonNode parseTree(String text) {\r\n        try {\r\n            return objectMapper.readTree(text);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON tree parsing failed, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse byte array to JsonNode tree structure\r\n     * \r\n     * @param text JSON byte array\r\n     * @return JsonNode tree\r\n     */\r\n    public static JsonNode parseTree(byte[] text) {\r\n        try {\r\n            return objectMapper.readTree(text);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON byte array tree parsing failed\", e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    // ==================== Utility Methods ====================\r\n\r\n    /**\r\n     * Check if string is JSON format\r\n     * \r\n     * @param text String to check\r\n     * @return Whether it's JSON\r\n     */\r\n    public static boolean isJson(String text) {\r\n        return JSONUtil.isTypeJSON(text);\r\n    }\r\n\r\n    /**\r\n     * Check if string is JSON object format\r\n     * \r\n     * @param str String to check\r\n     * @return Whether it's JSON object\r\n     */\r\n    public static boolean isJsonObject(String str) {\r\n        return JSONUtil.isTypeJSONObject(str);\r\n    }\r\n\r\n    // ==================== Core Path Parsing Methods ====================\r\n\r\n    /**\r\n     * Extract value from nested JSON structure - ACOT's core functionality\r\n     * \r\n     * Supported path formats:\r\n     * - Simple path: user.name\r\n     * - Array path: choices[0].message.content\r\n     * - Mixed path: data.items[0].details.info\r\n     * \r\n     * @param data Data structure\r\n     * @param path Dot-separated path (supports array subscripts)\r\n     * @return String representation of extracted value, returns null if not found\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static String extractValueFromPath(Map\u003cString, Object\u003e data, String path) {\r\n        // Step 1: Path splitting\r\n        String[] parts = path.split(\"\\\\.\");\r\n        Object current = data;\r\n\r\n        // Step 2: Traverse path level by level\r\n        for (String part : parts) {\r\n            // Defensive check: return immediately if null encountered\r\n            if (current == null) {\r\n                return null;\r\n            }\r\n\r\n            // Step 3: Parse current path segment\r\n            if (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n                // Array access pattern: choices[0]\r\n                String arrayName = part.substring(0, part.indexOf('['));\r\n                int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n\r\n                // Type-safe array access\r\n                if (current instanceof Map) {\r\n                    Map\u003cString, Object\u003e map = (Map\u003cString, Object\u003e) current;\r\n                    if (map.containsKey(arrayName) \u0026\u0026 map.get(arrayName) instanceof List) {\r\n                        List\u003cObject\u003e array = (List\u003cObject\u003e) map.get(arrayName);\r\n                        if (index \u003c array.size()) {\r\n                            current = array.get(index);\r\n                        } else {\r\n                            return null;  // Array out of bounds\r\n                        }\r\n                    } else {\r\n                        return null;  // Field doesn't exist or type mismatch\r\n                    }\r\n                } else {\r\n                    return null;  // Current object is not Map type\r\n                }\r\n            } else {\r\n                // Ordinary property access pattern: user.name\r\n                if (current instanceof Map) {\r\n                    current = ((Map\u003cString, Object\u003e) current).get(part);\r\n                } else {\r\n                    return null;  // Current object is not Map type\r\n                }\r\n            }\r\n        }\r\n\r\n        // Step 4: Return result\r\n        return current != null ? current.toString() : null;\r\n    }\r\n\r\n    /**\r\n     * Set value in nested JSON structure - ACOT's core functionality\r\n     * \r\n     * Features:\r\n     * - Intelligent path building: Automatically create non-existent intermediate paths\r\n     * - Array auto-expansion: Ensure array index accessibility\r\n     * - Type safety: Prevent type conflicts\r\n     * \r\n     * @param data Data structure to modify\r\n     * @param path Dot-separated path (supports array subscripts)\r\n     * @param value Value to set\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static void setValueByPath(Map\u003cString, Object\u003e data, String path, Object value) {\r\n        // Step 1: Path splitting\r\n        String[] parts = path.split(\"\\\\.\");\r\n        Map\u003cString, Object\u003e current = data;\r\n\r\n        // Step 2: Traverse path, ensure intermediate structures exist\r\n        for (int i = 0; i \u003c parts.length - 1; i++) {\r\n            String part = parts[i];\r\n\r\n            if (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n                // Array path processing\r\n                String arrayName = part.substring(0, part.indexOf('['));\r\n                int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n\r\n                // Create array (if doesn't exist)\r\n                if (!current.containsKey(arrayName) || !(current.get(arrayName) instanceof List)) {\r\n                    current.put(arrayName, new ArrayList\u003c\u003e());\r\n                }\r\n\r\n                List\u003cObject\u003e array = (List\u003cObject\u003e) current.get(arrayName);\r\n\r\n                // Array expansion: ensure index accessibility\r\n                while (array.size() \u003c= index) {\r\n                    array.add(new HashMap\u003cString, Object\u003e());\r\n                }\r\n\r\n                // Ensure array element is Map object (prepare for next level path)\r\n                if (!(array.get(index) instanceof Map)) {\r\n                    array.set(index, new HashMap\u003cString, Object\u003e());\r\n                }\r\n\r\n                current = (Map\u003cString, Object\u003e) array.get(index);\r\n            } else {\r\n                // Ordinary property path processing\r\n                if (!current.containsKey(part) || !(current.get(part) instanceof Map)) {\r\n                    current.put(part, new HashMap\u003cString, Object\u003e());\r\n                }\r\n                current = (Map\u003cString, Object\u003e) current.get(part);\r\n            }\r\n        }\r\n\r\n        // Step 3: Set final value\r\n        String lastPart = parts[parts.length - 1];\r\n\r\n        if (lastPart.contains(\"[\") \u0026\u0026 lastPart.contains(\"]\")) {\r\n            // Final path is array element\r\n            String arrayName = lastPart.substring(0, lastPart.indexOf('['));\r\n            int index = Integer.parseInt(lastPart.substring(lastPart.indexOf('[') + 1, lastPart.indexOf(']')));\r\n\r\n            // Create array (if doesn't exist)\r\n            if (!current.containsKey(arrayName) || !(current.get(arrayName) instanceof List)) {\r\n                current.put(arrayName, new ArrayList\u003c\u003e());\r\n            }\r\n\r\n            List\u003cObject\u003e array = (List\u003cObject\u003e) current.get(arrayName);\r\n\r\n            // Array expansion: ensure index accessibility\r\n            while (array.size() \u003c= index) {\r\n                array.add(null);\r\n            }\r\n\r\n            // Set array element value\r\n            array.set(index, value);\r\n        } else {\r\n            // Final path is ordinary property\r\n            current.put(lastPart, value);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### UserConfigDO：配置类的完整实现\r\n\r\n```java\r\npackage com.chat.allchatonthis.entity.dataobject;\r\n\r\nimport com.baomidou.mybatisplus.annotation.*;\r\nimport com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;\r\nimport com.chat.allchatonthis.config.mybatis.core.dataobject.BaseDO;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Data;\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.NoArgsConstructor;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.Map;\r\n\r\n/**\r\n * 用户配置数据对象 - 支持多样化AI服务商API配置\r\n * \r\n * 设计目标：\r\n * 1. 灵活适配不同AI服务商的认证方式\r\n * 2. 支持复杂嵌套的JSON请求/响应格式\r\n * 3. 提供完整的消息路径映射功能\r\n * 4. 确保配置的安全性和可用性监控\r\n */\r\n@EqualsAndHashCode(callSuper = true)\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Accessors(chain = true)  // Support chained calls, improve code readability\r\n@TableName(value = \"user_config\", autoResultMap = true)\r\npublic class UserConfigDO extends BaseDO {\r\n    \r\n    // ==================== Basic Configuration Fields ====================\r\n    \r\n    @TableId(type = IdType.AUTO)\r\n    private Long id;\r\n    \r\n    /** Whether configuration is available - Used for health checks and UI display */\r\n    private Boolean isAvailable;\r\n    \r\n    /** Foreign key: Associated user ID, implements multi-user isolation */\r\n    private Long userId;\r\n    \r\n    /** Configuration name - User-defined, convenient for managing multiple configurations */\r\n    private String name;\r\n    \r\n    /** API request URL - Endpoint addresses of different service providers */\r\n    private String apiUrl;\r\n    \r\n    /** API key - Supports plaintext and encrypted storage (enc: prefix identifies encryption) */\r\n    private String apiKey;\r\n\r\n    // ==================== API Key Placement Strategy ====================\r\n    \r\n    /** \r\n     * API key placement strategy:\r\n     * - 'header': Place in Authorization header (default, suitable for OpenAI, etc.)\r\n     * - 'body': Embed in request body (suitable for some custom APIs)\r\n     * - 'custom_header': Place in custom header (suitable for Anthropic, etc.)\r\n     */\r\n    private String apiKeyPlacement;\r\n    \r\n    /** Custom header name - Used when apiKeyPlacement='custom_header' */\r\n    private String apiKeyHeader;\r\n    \r\n    /** JSON path - When apiKeyPlacement='body', specifies the position of API key in request body */\r\n    private String apiKeyBodyPath;\r\n\r\n    // ==================== JSON Template System ====================\r\n    \r\n    /** \r\n     * Request template - Predefined JSON structure\r\n     * Uses JacksonTypeHandler to automatically handle Map\u003c-\u003eJSON conversion\r\n     * Supports arbitrarily complex nested structures\r\n     */\r\n    @TableField(typeHandler = JacksonTypeHandler.class)\r\n    private Map\u003cString, Object\u003e requestTemplate;\r\n\r\n    /** \r\n     * Response template - Used for response format validation and processing\r\n     * Currently mainly used for documentation, can be extended to response validation in the future\r\n     */\r\n    @TableField(typeHandler = JacksonTypeHandler.class)\r\n    private Map\u003cString, Object\u003e responseTemplate;\r\n\r\n    /** \r\n     * Custom HTTP headers - Support adding additional request headers\r\n     * Examples: User-Agent, Referer, custom authentication headers, etc.\r\n     */\r\n    @TableField(typeHandler = JacksonTypeHandler.class)\r\n    private Map\u003cString, String\u003e headers;\r\n\r\n    // ==================== Role Field Mapping ====================\r\n    \r\n    /** User role field name - Field name for user role in different APIs (e.g., user, human, customer) */\r\n    private String requestUserRoleField;\r\n    \r\n    /** Assistant role field name - Field name for assistant role in different APIs (e.g., assistant, ai, agent) */\r\n    private String requestAssistantField;\r\n    \r\n    /** System role field name - Field name for system message role (e.g., system, instruction) */\r\n    private String requestSystemField;\r\n\r\n    // ==================== Message Path Configuration System ====================\r\n    \r\n    /** \r\n     * Message group path - Specifies the position of message array in request JSON\r\n     * Examples: 'messages' or 'conversation.messages' or 'data.chat.messages'\r\n     */\r\n    private String requestMessageGroupPath;\r\n    \r\n    /** \r\n     * Role path - Specifies the name of role field in individual message objects\r\n     * Examples: 'role' or 'speaker' or 'type'\r\n     */\r\n    private String requestRolePathFromGroup;\r\n    \r\n    /** \r\n     * Text path - Specifies the name of content field in individual message objects\r\n     * Examples: 'content' or 'text' or 'message'\r\n     */\r\n    private String requestTextPathFromGroup;\r\n    \r\n    /** \r\n     * Response text path - Specifies how to extract AI reply content from response JSON\r\n     * Examples: 'choices.0.message.content' or 'response.text'\r\n     */\r\n    private String responseTextPath;\r\n    \r\n    /** \r\n     * Thinking text path - Specifies how to extract AI's thinking process (if supported)\r\n     * Examples: 'choices.0.message.thinking' or 'response.reasoning'\r\n     */\r\n    private String responseThinkingTextPath;\r\n\r\n    // ==================== Monitoring and Statistics Fields ====================\r\n    \r\n    /** Last usage time - Used for statistical analysis and health checks */\r\n    private LocalDateTime lastUsedTime;\r\n\r\n    // ==================== Temporary Fields ====================\r\n    \r\n    /** \r\n     * Decryption key - Temporary field, not persisted to database\r\n     * Used to decrypt encrypted API keys at runtime\r\n     */\r\n    @TableField(exist = false)\r\n    private String secretKey;\r\n}\r\n```\r\n\r\n### HttpUtils: Complete Implementation of HTTP Request Processing\r\n\r\n```java\r\npackage com.chat.allchatonthis.common.util.http;\r\n\r\nimport cn.hutool.core.codec.Base64;\r\nimport cn.hutool.core.map.TableMap;\r\nimport cn.hutool.core.net.url.UrlBuilder;\r\nimport cn.hutool.core.util.ReflectUtil;\r\nimport cn.hutool.core.util.StrUtil;\r\nimport cn.hutool.http.HttpRequest;\r\nimport cn.hutool.http.HttpResponse;\r\nimport com.chat.allchatonthis.common.exception.ServiceException;\r\nimport com.chat.allchatonthis.common.util.json.JsonUtils;\r\nimport com.chat.allchatonthis.entity.dataobject.ConversationMessageDO;\r\nimport com.chat.allchatonthis.entity.dataobject.UserConfigDO;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.util.StringUtils;\r\n\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.spec.SecretKeySpec;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport static com.chat.allchatonthis.common.enums.ErrorCodeConstants.CONFIG_NOT_EXISTS;\r\n\r\n/**\r\n * HTTP Utility Class - Core logic for processing API requests\r\n */\r\n@Slf4j\r\npublic class HttpUtils {\r\n\r\n    /**\r\n     * Prepare request data (simple version) - Process single message\r\n     * \r\n     * @param config User configuration\r\n     * @param messageText Message text\r\n     * @return Map containing headers and requestBody\r\n     */\r\n    public static Map\u003cString, Object\u003e prepareRequestData(UserConfigDO config, String messageText) {\r\n        // ==================== Step 1: Build request headers ====================\r\n        \r\n        // Defensive copy: avoid modifying original configuration, ensure thread safety\r\n        Map\u003cString, String\u003e headers = new HashMap\u003c\u003e(\r\n            config.getHeaders() != null ? config.getHeaders() : new HashMap\u003c\u003e()\r\n        );\r\n\r\n        // ==================== Step 2: Handle API key decryption ====================\r\n        \r\n        String apiKey = config.getApiKey();\r\n        \r\n        // Check if it's an encrypted key (enc: prefix) and has decryption key\r\n        if (apiKey != null \u0026\u0026 apiKey.startsWith(\"enc:\") \u0026\u0026 StringUtils.hasText(config.getSecretKey())) {\r\n            try {\r\n                // Remove enc: prefix, call decryption method\r\n                apiKey = decryptApiKey(apiKey.substring(4), config.getSecretKey());\r\n            } catch (Exception e) {\r\n                log.error(\"API key decryption failed\", e);\r\n                throw new ServiceException(CONFIG_NOT_EXISTS, \"API key decryption failed: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        // ==================== Step 3: Place API key according to strategy ====================\r\n        \r\n        // Strategy 1: Place in Authorization header (default strategy)\r\n        if (\"header\".equals(config.getApiKeyPlacement()) || config.getApiKeyPlacement() == null) {\r\n            headers.put(\"Authorization\", \"Bearer \" + apiKey);\r\n        } \r\n        // Strategy 2: Place in custom header (like x-api-key)\r\n        else if (\"custom_header\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyHeader() != null) {\r\n            headers.put(config.getApiKeyHeader(), apiKey);\r\n        }\r\n\r\n        // Ensure Content-Type exists (default is application/json)\r\n        if (!headers.containsKey(\"Content-Type\")) {\r\n            headers.put(\"Content-Type\", \"application/json\");\r\n        }\r\n\r\n        // ==================== Step 4: Build request body ====================\r\n        \r\n        // Clone request template, avoid modifying original configuration\r\n        Map\u003cString, Object\u003e requestBody = new HashMap\u003c\u003e(config.getRequestTemplate());\r\n\r\n        // Strategy 3: Place API key in request body\r\n        if (\"body\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyBodyPath() != null) {\r\n            JsonUtils.setValueByPath(requestBody, config.getApiKeyBodyPath(), apiKey);\r\n        }\r\n\r\n        // ==================== Step 5: Process message content ====================\r\n        \r\n        // If there's message text and message group path, create message object\r\n        if (StringUtils.hasText(messageText) \u0026\u0026 StringUtils.hasText(config.getRequestMessageGroupPath())) {\r\n            \r\n            // Get field name configuration (with defaults)\r\n            String rolePath = StringUtils.hasText(config.getRequestRolePathFromGroup()) ?\r\n                    config.getRequestRolePathFromGroup() : \"role\";\r\n            String textPath = StringUtils.hasText(config.getRequestTextPathFromGroup()) ?\r\n                    config.getRequestTextPathFromGroup() : \"content\";\r\n            String roleValue = StringUtils.hasText(config.getRequestUserRoleField()) ?\r\n                    config.getRequestUserRoleField() : \"user\";\r\n\r\n            // Build message object\r\n            Map\u003cString, Object\u003e messageObj = new HashMap\u003c\u003e();\r\n            messageObj.put(rolePath, roleValue);\r\n            messageObj.put(textPath, messageText);\r\n\r\n            // Create message array and set to request body\r\n            List\u003cMap\u003cString, Object\u003e\u003e messages = new ArrayList\u003c\u003e();\r\n            messages.add(messageObj);\r\n            JsonUtils.setValueByPath(requestBody, config.getRequestMessageGroupPath(), messages);\r\n        }\r\n\r\n        // ==================== Step 6: Return result ====================\r\n        \r\n        Map\u003cString, Object\u003e result = new HashMap\u003c\u003e();\r\n        result.put(\"headers\", headers);\r\n        result.put(\"requestBody\", requestBody);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 准备请求数据（完整版本）- 处理对话历史\r\n     * \r\n     * @param config 用户配置\r\n     * @param messageText 新消息文本\r\n     * @param conversationMessages 对话历史\r\n     * @return 包含headers和requestBody的Map\r\n     */\r\n    public static Map\u003cString, Object\u003e prepareRequestData(UserConfigDO config, String messageText, \r\n                                                        List\u003cConversationMessageDO\u003e conversationMessages) {\r\n        // ==================== 步骤1-4：复用简单版本的逻辑 ====================\r\n        \r\n        // 构建请求头\r\n        Map\u003cString, String\u003e headers = new HashMap\u003c\u003e(\r\n            config.getHeaders() != null ? config.getHeaders() : new HashMap\u003c\u003e()\r\n        );\r\n\r\n        // 处理API密钥解密\r\n        String apiKey = config.getApiKey();\r\n        if (apiKey != null \u0026\u0026 apiKey.startsWith(\"enc:\") \u0026\u0026 StringUtils.hasText(config.getSecretKey())) {\r\n            try {\r\n                apiKey = decryptApiKey(apiKey.substring(4), config.getSecretKey());\r\n            } catch (Exception e) {\r\n                log.error(\"API密钥解密失败\", e);\r\n                throw new ServiceException(CONFIG_NOT_EXISTS, \"API密钥解密失败: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        // 根据策略放置API密钥\r\n        if (\"header\".equals(config.getApiKeyPlacement()) || config.getApiKeyPlacement() == null) {\r\n            headers.put(\"Authorization\", \"Bearer \" + apiKey);\r\n        } else if (\"custom_header\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyHeader() != null) {\r\n            headers.put(config.getApiKeyHeader(), apiKey);\r\n        }\r\n\r\n        if (!headers.containsKey(\"Content-Type\")) {\r\n            headers.put(\"Content-Type\", \"application/json\");\r\n        }\r\n\r\n        // 构建请求体\r\n        Map\u003cString, Object\u003e requestBody = new HashMap\u003c\u003e(config.getRequestTemplate());\r\n\r\n        if (\"body\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyBodyPath() != null) {\r\n            JsonUtils.setValueByPath(requestBody, config.getApiKeyBodyPath(), apiKey);\r\n        }\r\n\r\n        // ==================== 步骤5：处理对话历史（核心逻辑） ====================\r\n        \r\n        // 获取字段名配置\r\n        String rolePath = StringUtils.hasText(config.getRequestRolePathFromGroup()) ?\r\n                config.getRequestRolePathFromGroup() : \"role\";\r\n        String textPath = StringUtils.hasText(config.getRequestTextPathFromGroup()) ?\r\n                config.getRequestTextPathFromGroup() : \"content\";\r\n        String userRoleValue = StringUtils.hasText(config.getRequestUserRoleField()) ?\r\n                config.getRequestUserRoleField() : \"user\";\r\n        String assistantRoleValue = StringUtils.hasText(config.getRequestAssistantField()) ?\r\n                config.getRequestAssistantField() : \"assistant\";\r\n\r\n        // 构建完整的消息组\r\n        if (StringUtils.hasText(config.getRequestMessageGroupPath()) \u0026\u0026 \r\n            (conversationMessages != null || messageText != null)) {\r\n            \r\n            List\u003cMap\u003cString, Object\u003e\u003e messages = new ArrayList\u003c\u003e();\r\n\r\n            // 添加历史消息\r\n            if (conversationMessages != null) {\r\n                for (ConversationMessageDO message : conversationMessages) {\r\n                    // 跳过系统消息（系统消息通常不参与对话流）\r\n                    if (\"system\".equals(message.getRole())) {\r\n                        continue;\r\n                    }\r\n\r\n                    Map\u003cString, Object\u003e messageObj = new HashMap\u003c\u003e();\r\n                    \r\n                    // 角色映射：将数据库中的角色映射为API所需的角色\r\n                    if (\"user\".equals(message.getRole())) {\r\n                        messageObj.put(rolePath, userRoleValue);\r\n                    } else if (\"assistant\".equals(message.getRole())) {\r\n                        messageObj.put(rolePath, assistantRoleValue);\r\n                    } else {\r\n                        // 其他角色保持原样\r\n                        messageObj.put(rolePath, message.getRole());\r\n                    }\r\n                    \r\n                    // 设置消息内容\r\n                    messageObj.put(textPath, message.getContent());\r\n                    messages.add(messageObj);\r\n                }\r\n            }\r\n\r\n            // 添加新的用户消息\r\n            if (messageText != null) {\r\n                Map\u003cString, Object\u003e userMessage = new HashMap\u003c\u003e();\r\n                userMessage.put(rolePath, userRoleValue);\r\n                userMessage.put(textPath, messageText);\r\n                messages.add(userMessage);\r\n            }\r\n\r\n            // 将消息组设置到请求体中\r\n            JsonUtils.setValueByPath(requestBody, config.getRequestMessageGroupPath(), messages);\r\n        }\r\n        // 向后兼容：如果没有消息组路径，直接设置文本\r\n        else if (messageText != null \u0026\u0026 StringUtils.hasText(config.getRequestTextPathFromGroup())) {\r\n            JsonUtils.setValueByPath(requestBody, config.getRequestTextPathFromGroup(), messageText);\r\n        }\r\n\r\n        // ==================== 步骤6：返回结果 ====================\r\n        \r\n        Map\u003cString, Object\u003e result = new HashMap\u003c\u003e();\r\n        result.put(\"headers\", headers);\r\n        result.put(\"requestBody\", requestBody);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 解密API密钥 - 兼容CryptoJS的AES解密\r\n     * \r\n     * @param encryptedApiKey 加密的API密钥（Base64格式）\r\n     * @param secretKey 解密密钥\r\n     * @return 解密后的API密钥\r\n     */\r\n    public static String decryptApiKey(String encryptedApiKey, String secretKey) {\r\n        try {\r\n            // ==================== 步骤1：Base64解码 ====================\r\n            \r\n            // CryptoJS使用Base64编码传输加密数据\r\n            byte[] cipherData = java.util.Base64.getDecoder().decode(encryptedApiKey);\r\n\r\n            // ==================== 步骤2：解析OpenSSL格式 ====================\r\n            \r\n            // CryptoJS默认使用OpenSSL格式: \"Salted__\" + 8字节盐 + 密文\r\n            // 总共16字节的前缀（8字节\"Salted__\" + 8字节盐值）\r\n            byte[] saltBytes = new byte[8];\r\n            byte[] cipherBytes = new byte[cipherData.length - 16];\r\n\r\n            // 提取盐值（跳过前8字节的\"Salted__\"）\r\n            System.arraycopy(cipherData, 8, saltBytes, 0, 8);\r\n            // 提取实际密文（跳过前16字节）\r\n            System.arraycopy(cipherData, 16, cipherBytes, 0, cipherData.length - 16);\r\n\r\n            // ==================== 步骤3：派生密钥和IV ====================\r\n            \r\n            // 使用EVP_BytesToKey算法生成密钥和初始化向量\r\n            byte[][] keyAndIV = EVP_BytesToKey(32, 16, secretKey.getBytes(StandardCharsets.UTF_8), saltBytes, 1);\r\n            byte[] key = keyAndIV[0];  // 32字节密钥（AES-256）\r\n            byte[] iv = keyAndIV[1];   // 16字节IV\r\n\r\n            // ==================== 步骤4：AES解密 ====================\r\n            \r\n            // 创建AES密钥规范\r\n            SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\r\n            // 创建IV参数规范\r\n            javax.crypto.spec.IvParameterSpec ivSpec = new javax.crypto.spec.IvParameterSpec(iv);\r\n\r\n            // 初始化解密器：AES/CBC/PKCS5Padding（与CryptoJS默认设置一致）\r\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\r\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\r\n\r\n            // 执行解密\r\n            byte[] decryptedBytes = cipher.doFinal(cipherBytes);\r\n            \r\n            // 转换为字符串并返回\r\n            return new String(decryptedBytes, StandardCharsets.UTF_8);\r\n            \r\n        } catch (Exception e) {\r\n            log.error(\"API密钥解密失败\", e);\r\n            throw new ServiceException(CONFIG_NOT_EXISTS, \"API密钥解密失败: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * EVP_BytesToKey算法实现 - 密钥派生函数\r\n     * \r\n     * 这是OpenSSL标准的密钥派生算法，用于从密码和盐值生成密钥和IV\r\n     * \r\n     * @param keyLen 密钥长度（字节）\r\n     * @param ivLen IV长度（字节）\r\n     * @param password 密码\r\n     * @param salt 盐值\r\n     * @param iterations 迭代次数\r\n     * @return [密钥, IV]\r\n     */\r\n    private static byte[][] EVP_BytesToKey(int keyLen, int ivLen, byte[] password, byte[] salt, int iterations) {\r\n        // ==================== 步骤1：初始化 ====================\r\n        \r\n        byte[] key = new byte[keyLen];\r\n        byte[] iv = new byte[ivLen];\r\n        byte[] concatenatedHashBytes = new byte[0];\r\n\r\n        // 初始化MD5消息摘要\r\n        MessageDigest md5;\r\n        try {\r\n            md5 = MessageDigest.getInstance(\"MD5\");\r\n        } catch (NoSuchAlgorithmException e) {\r\n            throw new RuntimeException(\"MD5算法不可用\", e);\r\n        }\r\n\r\n        // ==================== 步骤2：计算需要的哈希轮数 ====================\r\n        \r\n        int hashLen = 16; // MD5输出长度\r\n        int keyAndIvLen = keyLen + ivLen;\r\n        int numHashes = (keyAndIvLen + hashLen - 1) / hashLen; // 向上取整\r\n\r\n        // ==================== 步骤3：生成哈希链 ====================\r\n        \r\n        byte[] result = new byte[numHashes * hashLen];\r\n        int resultLen = 0;\r\n\r\n        for (int i = 1; i \u003c= numHashes; i++) {\r\n            // 第一轮：只使用密码和盐\r\n            // 后续轮：使用前一轮的结果 + 密码 + 盐\r\n            md5.reset();\r\n            if (i \u003e 1) {\r\n                md5.update(concatenatedHashBytes);\r\n            }\r\n            md5.update(password);\r\n            if (salt != null) {\r\n                md5.update(salt);\r\n            }\r\n            concatenatedHashBytes = md5.digest();\r\n\r\n            // 执行额外的迭代（通常为1，即不额外迭代）\r\n            for (int j = 1; j \u003c iterations; j++) {\r\n                md5.reset();\r\n                md5.update(concatenatedHashBytes);\r\n                concatenatedHashBytes = md5.digest();\r\n            }\r\n\r\n            // 将哈希结果拷贝到结果数组中\r\n            System.arraycopy(\r\n                concatenatedHashBytes, 0,\r\n                result, resultLen,\r\n                Math.min(concatenatedHashBytes.length, result.length - resultLen)\r\n            );\r\n            resultLen += concatenatedHashBytes.length;\r\n        }\r\n\r\n        // ==================== 步骤4：分离密钥和IV ====================\r\n        \r\n        // 从结果中提取密钥\r\n        System.arraycopy(result, 0, key, 0, keyLen);\r\n        // 从结果中提取IV\r\n        System.arraycopy(result, keyLen, iv, 0, ivLen);\r\n\r\n        return new byte[][]{key, iv};\r\n    }\r\n\r\n    /**\r\n     * HTTP POST request - HuTool-based wrapper\r\n     * \r\n     * @param url Request URL\r\n     * @param headers Request headers\r\n     * @param requestBody Request body\r\n     * @return Response string\r\n     */\r\n    public static String post(String url, Map\u003cString, String\u003e headers, String requestBody) {\r\n        try (HttpResponse response = HttpRequest.post(url)\r\n                .addHeaders(headers)\r\n                .body(requestBody)\r\n                .execute()) {\r\n            return response.body();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * HTTP GET request - HuTool-based wrapper\r\n     * \r\n     * @param url Request URL  \r\n     * @param headers Request headers\r\n     * @return Response string\r\n     */\r\n    public static String get(String url, Map\u003cString, String\u003e headers) {\r\n        try (HttpResponse response = HttpRequest.get(url)\r\n                .addHeaders(headers)\r\n                .execute()) {\r\n            return response.body();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### ConversationMessageServiceImpl: Complete Implementation of Message Service\r\n\r\n```java\r\npackage com.chat.allchatonthis.service.core.impl;\r\n\r\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\r\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\r\nimport com.chat.allchatonthis.common.exception.ServiceException;\r\nimport com.chat.allchatonthis.common.util.http.HttpUtils;\r\nimport com.chat.allchatonthis.common.util.json.JsonUtils;\r\nimport com.chat.allchatonthis.entity.dataobject.ConversationDO;\r\nimport com.chat.allchatonthis.entity.dataobject.ConversationMessageDO;\r\nimport com.chat.allchatonthis.entity.dataobject.UserConfigDO;\r\nimport com.chat.allchatonthis.mapper.ConversationMessageMapper;\r\nimport com.chat.allchatonthis.service.core.ConversationMessageService;\r\nimport com.chat.allchatonthis.service.core.ConversationService;\r\nimport com.chat.allchatonthis.service.core.UserConfigService;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.cache.annotation.CacheConfig;\r\nimport org.springframework.cache.annotation.CacheEvict;\r\nimport org.springframework.cache.annotation.Cacheable;\r\nimport org.springframework.cache.annotation.Caching;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.util.StringUtils;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport static com.chat.allchatonthis.common.enums.ErrorCodeConstants.*;\r\n\r\n/**\r\n * Conversation Message Service Implementation Class - Core business logic for message processing\r\n */\r\n@Service\r\n@AllArgsConstructor\r\n@Slf4j\r\n@CacheConfig(cacheNames = \"conversation_message\")\r\npublic class ConversationMessageServiceImpl extends ServiceImpl\u003cConversationMessageMapper, ConversationMessageDO\u003e \r\n        implements ConversationMessageService {\r\n\r\n    private final ConversationService conversationService;\r\n    private final UserConfigService userConfigService;\r\n    private final RedisTemplate\u003cString, Object\u003e redisTemplate;\r\n\r\n    /**\r\n     * Send message - Core business method of the system\r\n     * \r\n     * @param userMessage User message content\r\n     * @param configId Configuration ID\r\n     * @param conversationId Conversation ID\r\n     * @param userId User ID\r\n     * @param secretKey Decryption key\r\n     * @return Assistant reply message\r\n     */\r\n    @Override\r\n    @Transactional  // Ensure transaction consistency\r\n    @Caching(evict = {\r\n            @CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n    })\r\n    public ConversationMessageDO sendMessage(String userMessage, Long configId, Long conversationId, \r\n                                           Long userId, String secretKey) {\r\n        // ==================== Step 1: Permission verification ====================\r\n        \r\n        // Verify conversation ownership: ensure users can only operate their own conversations\r\n        ConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\n        if (conversation == null) {\r\n            throw new ServiceException(CONVERSATION_NOT_EXISTS.getCode(), CONVERSATION_NOT_EXISTS.getMsg());\r\n        }\r\n\r\n        // Verify configuration ownership: ensure users can only use their own configurations\r\n        UserConfigDO config = userConfigService.getConfig(configId, userId);\r\n        if (config == null) {\r\n            throw new ServiceException(CONFIGURATION_NOT_EXISTS.getCode(), CONFIGURATION_NOT_EXISTS.getMsg());\r\n        }\r\n\r\n        // Set temporary decryption key\r\n        if (StringUtils.hasText(secretKey)) {\r\n            config.setSecretKey(secretKey);\r\n        }\r\n\r\n        try {\r\n            // ==================== Step 2: Prepare message objects ====================\r\n            \r\n            // Create user message object (Note: only create here, don't save to database yet)\r\n            // This is a transactional design: ensure API call succeeds first, then save data\r\n            ConversationMessageDO userMessageDO = new ConversationMessageDO()\r\n                    .setConversationId(conversationId)\r\n                    .setConfigId(configId)\r\n                    .setRole(\"user\")\r\n                    .setContent(userMessage);\r\n\r\n            // ==================== Step 3: Get conversation history ====================\r\n            \r\n            // Get all historical messages of current conversation for building context\r\n            List\u003cConversationMessageDO\u003e previousMessages = list(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n                    .eq(ConversationMessageDO::getConversationId, conversationId)\r\n                    .orderByAsc(ConversationMessageDO::getCreateTime));\r\n\r\n            // ==================== Step 4: Call AI API ====================\r\n            \r\n            // Call AI API to get reply (this is the key step, may fail)\r\n            ConversationMessageDO assistantMessageDO = generateAssistantResponse(\r\n                userMessage, config, conversationId, configId, previousMessages\r\n            );\r\n\r\n            // ==================== Step 5: Save messages ====================\r\n            \r\n            // Only execute here if API call succeeds\r\n            // Batch save user message and assistant reply, ensure data consistency\r\n            save(userMessageDO);\r\n            save(assistantMessageDO);\r\n\r\n            // ==================== Step 6: Update conversation status ====================\r\n            \r\n            // Update conversation's last update time\r\n            conversation.setUpdateTime(assistantMessageDO.getUpdateTime());\r\n            conversationService.updateById(conversation);\r\n\r\n            // Mark configuration as available (health check)\r\n            markConfigurationAsAvailable(configId, userId);\r\n\r\n            return assistantMessageDO;\r\n            \r\n        } catch (Exception e) {\r\n            log.error(\"Message sending failed\", e);\r\n\r\n            // Unified exception handling: don't create error messages, throw exception directly\r\n            if (e instanceof ServiceException) {\r\n                throw e;\r\n            }\r\n            throw new ServiceException(MESSAGE_SEND_FAILED.getCode(), e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate assistant reply - Core logic for AI API calls\r\n     * \r\n     * @param userMessage User message\r\n     * @param config Configuration information\r\n     * @param conversationId Conversation ID\r\n     * @param configId Configuration ID\r\n     * @param conversationMessages Conversation history\r\n     * @return Assistant reply message\r\n     */\r\n    private ConversationMessageDO generateAssistantResponse(\r\n            String userMessage,\r\n            UserConfigDO config,\r\n            Long conversationId,\r\n            Long configId,\r\n            List\u003cConversationMessageDO\u003e conversationMessages) {\r\n\r\n        // ==================== Step 1: Prepare request data ====================\r\n        \r\n        // Use HttpUtils to prepare complete request data (including conversation history)\r\n        Map\u003cString, Object\u003e requestData = HttpUtils.prepareRequestData(config, userMessage, conversationMessages);\r\n        \r\n        // Extract request headers and request body\r\n        Map\u003cString, String\u003e headers = (Map\u003cString, String\u003e) requestData.get(\"headers\");\r\n        Map\u003cString, Object\u003e requestBody = (Map\u003cString, Object\u003e) requestData.get(\"requestBody\");\r\n\r\n        // ==================== Step 2: Send HTTP request ====================\r\n        \r\n        // Serialize request body to JSON string\r\n        String requestBodyStr = JsonUtils.toJsonString(requestBody);\r\n        \r\n        // Send POST request to AI API\r\n        String responseStr = HttpUtils.post(config.getApiUrl(), headers, requestBodyStr);\r\n\r\n        // Check if response is empty\r\n        if (responseStr == null) {\r\n            throw new ServiceException(API_CALL_FAILED.getCode(), \"API returned empty response\");\r\n        }\r\n\r\n        // ==================== Step 3: Parse response ====================\r\n        \r\n        // Parse response JSON\r\n        Map\u003cString, Object\u003e responseMap = JsonUtils.parseObject(responseStr, Map.class);\r\n\r\n        // Extract AI reply content\r\n        String content = null;\r\n        String thinking = null;\r\n\r\n        // Extract reply content according to configured path\r\n        if (StringUtils.hasText(config.getResponseTextPath())) {\r\n            content = JsonUtils.extractValueFromPath(responseMap, config.getResponseTextPath());\r\n        }\r\n\r\n        // Extract thinking process according to configured path (if supported)\r\n        if (StringUtils.hasText(config.getResponseThinkingTextPath())) {\r\n            thinking = JsonUtils.extractValueFromPath(responseMap, config.getResponseThinkingTextPath());\r\n        }\r\n\r\n        // Verify if content was successfully extracted\r\n        if (content == null) {\r\n            throw new ServiceException(API_CALL_FAILED.getCode(), \"Unable to extract content from response\");\r\n        }\r\n\r\n        // ==================== Step 4: Build reply message ====================\r\n        \r\n        // Create assistant reply message object\r\n        return new ConversationMessageDO()\r\n                .setConversationId(conversationId)\r\n                .setConfigId(configId)\r\n                .setRole(\"assistant\")\r\n                .setContent(content)\r\n                .setThinkingText(thinking);  // Thinking process (optional)\r\n    }\r\n\r\n    /**\r\n     * Mark configuration as available - Health check and monitoring\r\n     * \r\n     * @param configId Configuration ID\r\n     * @param userId User ID\r\n     * @return Whether successful\r\n     */\r\n    @Override\r\n    public boolean markConfigurationAsAvailable(Long configId, Long userId) {\r\n        // Get configuration information\r\n        UserConfigDO config = userConfigService.getConfig(configId, userId);\r\n        if (config == null) {\r\n            return false;\r\n        }\r\n\r\n        // Update configuration status: set as available and record last usage time\r\n        userConfigService.setAvailableAndUpdateLastUsedTime(configId, true);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get conversation message list - With caching\r\n     * \r\n     * @param conversationId Conversation ID\r\n     * @param userId User ID\r\n     * @return Message list\r\n     */\r\n    @Override\r\n    @Cacheable(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n    public List\u003cConversationMessageDO\u003e getMessages(Long conversationId, Long userId) {\r\n        // Verify conversation ownership\r\n        ConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\n        if (conversation == null) {\r\n            throw new ServiceException(CONVERSATION_NOT_EXISTS.getCode(), CONVERSATION_NOT_EXISTS.getMsg());\r\n        }\r\n\r\n        // Query messages, ordered by creation time ascending\r\n        return list(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n                .eq(ConversationMessageDO::getConversationId, conversationId)\r\n                .orderByAsc(ConversationMessageDO::getCreateTime)\r\n                .orderByAsc(ConversationMessageDO::getId)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get single message - With caching\r\n     * \r\n     * @param id Message ID\r\n     * @param userId User ID\r\n     * @return Message object\r\n     */\r\n    @Override\r\n    @Cacheable(key = \"'id:' + #id + ':user:' + #userId\")\r\n    public ConversationMessageDO getMessage(Long id, Long userId) {\r\n        ConversationMessageDO message = getById(id);\r\n        if (message == null) {\r\n            return null;\r\n        }\r\n\r\n        // Verify conversation ownership\r\n        ConversationDO conversation = conversationService.getConversation(message.getConversationId(), userId);\r\n        if (conversation == null) {\r\n            return null;\r\n        }\r\n\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Delete message - Clear cache\r\n     * \r\n     * @param id Message ID\r\n     * @param userId User ID\r\n     * @return Whether successful\r\n     */\r\n    @Override\r\n    @Transactional\r\n    @CacheEvict(key = \"'id:' + #id + ':user:' + #userId\")\r\n    public boolean deleteMessage(Long id, Long userId) {\r\n        ConversationMessageDO message = getMessage(id, userId);\r\n        if (message == null) {\r\n            return false;\r\n        }\r\n\r\n        // Manually clear related cache\r\n        Long conversationId = message.getConversationId();\r\n        String cacheKey = \"acot_conversation_message::conversation:\" + conversationId + \":user:\" + userId;\r\n        redisTemplate.delete(cacheKey);\r\n\r\n        return removeById(id);\r\n    }\r\n\r\n    /**\r\n     * Delete all messages of conversation - Batch delete\r\n     * \r\n     * @param conversationId Conversation ID\r\n     * @param userId User ID\r\n     * @return Whether successful\r\n     */\r\n    @Override\r\n    @Transactional\r\n    @CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n    public boolean deleteMessagesByConversationId(Long conversationId, Long userId) {\r\n        // Verify conversation ownership\r\n        ConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\n        if (conversation == null) {\r\n            return false;\r\n        }\r\n\r\n        // Batch delete messages\r\n        return remove(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n                .eq(ConversationMessageDO::getConversationId, conversationId));\r\n    }\r\n}\r\n```\r\n\r\n## Final Words\r\n\r\nMessage construction, extraction, and transmission are the most complex aspects of the ACOT project, while also being its core functionality. Through this platform, users can theoretically connect to any available large model API (or even APIs that aren't large models). By saving user-defined configuration files on the platform, this platform can become users' custom large model connector.\r\n\r\nWell, now it's time for my favorite wishing session! 💫\r\n\r\n*May the structures of various APIs converge like streams, and the broad river embrace forms from all corners of the world. May the algorithms that accommodate all things enable everything hidden to be discovered by people.* ✨\r\n\r\n```java\r\n// Wish (Code Version)\r\nwhile (bugs.exist()) {\r\n    debug();\r\n    if (fixed) {\r\n        celebrate(); 🎉\r\n    }\r\n}\r\n```\r\n"])</script><script>self.__next_f.push([1,"f:T6f42,"])</script><script>self.__next_f.push([1,"\r\n# All-Chat-on-This Endpoint Monitoring and Exposure Implementation: From AOP Aspects to Prometheus Monitoring Ecosystem\r\n\r\n\"Let me see what users are doing\" (Let me access!)\r\n\r\nACOT's monitoring system design is relatively simple, currently only monitoring interface call counts and online users, but we can see the complete monitoring ecosystem process from data collection to visualization display through this simple application.\r\n\r\n## Monitoring Architecture: Four-Tier Separation Design\r\n\r\n### Layered Architecture Overview: Data Flow Lifecycle\r\n\r\nACOT's monitoring system adopts a typical **four-tier separation architecture**, where each layer has its unique responsibilities and technology selection:\r\n\r\n```mermaid\r\ngraph TB\r\n    A[Data Collection Layer] --\u003e B[Metric Storage Layer]\r\n    B --\u003e C[Data Exposure Layer]\r\n    C --\u003e D[Monitoring Visualization Layer]\r\n    \r\n    A1[AOP Aspect Interception] --\u003e A\r\n    A2[Spring Security Events] --\u003e A\r\n    A3[HTTP Session Monitoring] --\u003e A\r\n    \r\n    B1[Micrometer Core] --\u003e B\r\n    B2[Counter] --\u003e B\r\n    B3[Gauge] --\u003e B\r\n    \r\n    C1[Spring Boot Actuator] --\u003e C\r\n    C2[Actuator Prometheus] --\u003e C\r\n    C3[Actuator Metrics] --\u003e C\r\n    \r\n    D1[Prometheus Time Series Database] --\u003e D\r\n    D2[Grafana Visualization] --\u003e D\r\n    D3[Alert System] --\u003e D\r\n```\r\n\r\n**Why Layered Architecture?**\r\n\r\nThis layered design follows the principle of **separation of concerns**:\r\n\r\n$$Monitoring System = Data Collection \\oplus Metric Storage \\oplus Data Exposure \\oplus Visualization Display$$\r\n\r\nEach layer's technology selection can evolve independently, such as:\r\n- Data Collection Layer: Can switch from AOP to Filter or Interceptor\r\n- Metric Storage Layer: Can switch from Micrometer to other metric libraries\r\n- Data Exposure Layer: Can support multiple formats (Prometheus, JSON, XML, etc.)\r\n- Visualization Layer: Can switch from Grafana to other monitoring platforms\r\n\r\n## Core Principles of Endpoint Monitoring: AOP\r\n\r\n### AOP Aspect-Oriented Programming: The Mysterious Enhancer\r\n\r\n**What is AOP?**\r\n\r\nAOP (Aspect-Oriented Programming) is programming that adds \"enhancements\" to methods without modifying original code.\r\n\r\n```java\r\n// Original business method\r\npublic String getUserInfo(Long userId) {\r\n    return userService.getUser(userId);\r\n}\r\n\r\n// Actual execution flow after AOP magic\r\npublic String getUserInfo(Long userId) {\r\n    // ↓ AOP Before Advice: Record call statistics\r\n    endpointMetrics.incrementEndpointCount(\"UserController\", \"getUserInfo\");\r\n    \r\n    // ↓ Original business logic\r\n    String result = userService.getUser(userId);\r\n    \r\n    // ↓ AOP After Advice: Record response time, exception handling, etc.\r\n    return result;\r\n}\r\n```\r\n\r\n### EndpointMetricsAspect: Aspect Interception\r\n\r\n```java\r\n@Aspect\r\n@Component\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class EndpointMetricsAspect {\r\n\r\n    private final EndpointMetrics endpointMetrics;\r\n\r\n    /**\r\n     * Pointcut definition: Only intercept classes annotated with @RestController\r\n     * \r\n     * Difference between @within and @target:\r\n     * - @within: Class-level matching, determined at compile time\r\n     * - @target: Object-level matching, determined at runtime\r\n     * \r\n     * Reason for choosing @within: Better performance,切入点 can be determined at compile time\r\n     */\r\n    @Pointcut(\"@within(org.springframework.web.bind.annotation.RestController)\")\r\n    public void controllerPointcut() {\r\n        // Pointcut definition method, no implementation needed\r\n    }\r\n\r\n    /**\r\n     * Before Advice: Count calls before method execution\r\n     * \r\n     * Why choose @Before instead of @Around?\r\n     * - @Before: Lightweight, only needs to record calls\r\n     * - @Around: Heavyweight, needs to control method execution flow\r\n     */\r\n    @Before(\"controllerPointcut()\")\r\n    public void beforeControllerMethod(JoinPoint joinPoint) {\r\n        try {\r\n            // Step 1: Get method signature information\r\n            MethodSignature signature = (MethodSignature) joinPoint.getSignature();\r\n            Method method = signature.getMethod();\r\n            Class\u003c?\u003e controllerClass = method.getDeclaringClass();\r\n            \r\n            // Step 2: Extract class name and method name\r\n            String controllerName = controllerClass.getSimpleName();  // UserController\r\n            String methodName = method.getName();                     // getUserInfo\r\n\r\n            // Step 3: Verify if it's an HTTP endpoint (avoid intercepting internal methods)\r\n            if (isHttpEndpoint(method)) {\r\n                // Step 4: Record endpoint call statistics\r\n                endpointMetrics.incrementEndpointCount(controllerName, methodName);\r\n                log.debug(\"Endpoint call: {}.{}\", controllerName, methodName);\r\n            }\r\n        } catch (Exception e) {\r\n            // Key design: Exception isolation, monitoring failures should not affect business\r\n            log.error(\"Endpoint metrics recording failed\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * HTTP endpoint identification algorithm: Supports all Spring Web annotations\r\n     * \r\n     * Why do we need this check?\r\n     * - @RestController classes may have non-HTTP methods (like private helper methods)\r\n     * - Only real HTTP endpoints need to be counted\r\n     */\r\n    private boolean isHttpEndpoint(Method method) {\r\n        return method.isAnnotationPresent(RequestMapping.class) ||      // General mapping\r\n                method.isAnnotationPresent(GetMapping.class) ||         // GET request\r\n                method.isAnnotationPresent(PostMapping.class) ||        // POST request\r\n                method.isAnnotationPresent(PutMapping.class) ||         // PUT request\r\n                method.isAnnotationPresent(DeleteMapping.class) ||      // DELETE request\r\n                method.isAnnotationPresent(PatchMapping.class);         // PATCH request\r\n    }\r\n}\r\n```\r\n\r\n**JoinPoint Information Extraction Chain:**\r\n\r\n```java\r\n// Complete chain of JoinPoint information extraction\r\nJoinPoint joinPoint = // Injected by AOP framework\r\n    ↓\r\nMethodSignature signature = (MethodSignature) joinPoint.getSignature();\r\n    ↓\r\nMethod method = signature.getMethod();  // Get Method object\r\n    ↓\r\nClass\u003c?\u003e clazz = method.getDeclaringClass();  // Get declaring class\r\n    ↓\r\nString className = clazz.getSimpleName();     // UserController\r\nString methodName = method.getName();         // getUserInfo\r\n```\r\n\r\n### Thread-Safe Counter Design: EndpointMetrics Concurrency\r\n\r\nHow to ensure counter accuracy in high-concurrency environments? Let's see the implementation——\r\n\r\n```java\r\n@Component\r\npublic class EndpointMetrics {\r\n    \r\n    // Core component: Micrometer's meter registry\r\n    private final MeterRegistry meterRegistry;\r\n    \r\n    // Thread-safe counter cache: Avoid repeated Counter creation\r\n    private final Map\u003cString, Counter\u003e endpointCounters = new ConcurrentHashMap\u003c\u003e();\r\n    \r\n    // Atomic operation for online user counter\r\n    private final AtomicInteger onlineUsers = new AtomicInteger(0);\r\n\r\n    /**\r\n     * Constructor: Register Gauge metric for online users\r\n     * \r\n     * Difference between Gauge and Counter:\r\n     * - Gauge: Instant value metric, such as current online users, memory usage\r\n     * - Counter: Cumulative metric, such as API call count, error count\r\n     */\r\n    public EndpointMetrics(MeterRegistry meterRegistry) {\r\n        this.meterRegistry = meterRegistry;\r\n        \r\n        // Register Gauge: Reflect real-time online users\r\n        Gauge.builder(\"acot.online.users\", onlineUsers::get)  // Reference atomic class's get method\r\n                .description(\"Current number of online users\")\r\n                .register(meterRegistry);\r\n    }\r\n\r\n    /**\r\n     * Increment endpoint call count: Core thread-safe algorithm\r\n     * \r\n     * @param controllerName Controller name\r\n     * @param methodName Method name\r\n     */\r\n    public void incrementEndpointCount(String controllerName, String methodName) {\r\n        // Construct endpoint identifier\r\n        String endpoint = controllerName + \".\" + methodName;\r\n        \r\n        // Key algorithm: Atomic guarantee of computeIfAbsent\r\n        Counter counter = endpointCounters.computeIfAbsent(endpoint, k -\u003e\r\n                Counter.builder(\"acot.endpoint.calls\")\r\n                        // Multi-dimensional tags: Support complex Prometheus queries\r\n                        .tags(Arrays.asList(\r\n                                Tag.of(\"controller\", controllerName),  // Group by controller\r\n                                Tag.of(\"method\", methodName)))         // Group by method\r\n                        .description(\"Endpoint call count statistics\")\r\n                        .register(meterRegistry));  // Register with Micrometer\r\n        \r\n        // Atomic increment operation\r\n        counter.increment();\r\n    }\r\n\r\n    /**\r\n     * User login: Atomically increment online user count\r\n     */\r\n    public void userLoggedIn() {\r\n        onlineUsers.incrementAndGet();  // Atomic operation: current + 1\r\n    }\r\n\r\n    /**\r\n     * User logout: Atomically decrement with boundary check\r\n     */\r\n    public void userLoggedOut() {\r\n        // Atomic operation to prevent negative values: max(0, current - 1)\r\n        onlineUsers.updateAndGet(current -\u003e Math.max(0, current - 1));\r\n    }\r\n}\r\n```\r\n\r\n**Why choose ConcurrentHashMap + computeIfAbsent?**\r\n\r\nThe advantages of this combination are:\r\n\r\nIncorrect approach:\r\n```java\r\n// ❌ Error implementation with race condition\r\nif (!endpointCounters.containsKey(endpoint)) {\r\n    // Problem: Two threads might execute here simultaneously\r\n    endpointCounters.put(endpoint, createNewCounter(endpoint));\r\n}\r\nCounter counter = endpointCounters.get(endpoint);\r\n```\r\n\r\nCorrect approach:\r\n```java\r\n// ✅ Atomic operation, thread-safe\r\nCounter counter = endpointCounters.computeIfAbsent(endpoint, k -\u003e createNewCounter(k));\r\n```\r\n\r\n**Time complexity analysis of computeIfAbsent:**\r\n\r\nIn ideal conditions:\r\n- First access: $O(1)$ creation + $O(1)$ insertion = $O(1)$\r\n- Subsequent accesses: $O(1)$ lookup\r\n\r\n### Dual Guarantee Mechanism for Online User Statistics\r\n\r\nACOT implements a \"double insurance\" user statistics system:\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant User as User\r\n    participant Security as Spring Security\r\n    participant Session as HTTP Session\r\n    participant Listener1 as UserActivityMetricsConfig\r\n    participant Listener2 as SessionEventListener\r\n    participant Metrics as EndpointMetrics\r\n\r\n    User-\u003e\u003eSecurity: Login\r\n    Security-\u003e\u003eListener1: AuthenticationSuccessEvent\r\n    Listener1-\u003e\u003eMetrics: userLoggedIn() [+1]\r\n    \r\n    User-\u003e\u003eSecurity: Normal logout\r\n    Security-\u003e\u003eListener1: LogoutSuccessEvent\r\n    Listener1-\u003e\u003eMetrics: userLoggedOut() [-1]\r\n    \r\n    Note over Session: Session timeout or abnormal disconnection\r\n    Session-\u003e\u003eListener2: sessionDestroyed\r\n    Listener2-\u003e\u003eMetrics: userLoggedOut() [-1]\r\n```\r\n\r\n### UserActivityMetricsConfig: Spring Security Event Handling\r\n\r\n```java\r\n@Configuration\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class UserActivityMetricsConfig {\r\n\r\n    private final EndpointMetrics endpointMetrics;\r\n\r\n    /**\r\n     * Login success event listener\r\n     * \r\n     * Advantages of Spring event mechanism:\r\n     * - Loose coupling: No direct dependency between listener and event publisher\r\n     * - Asynchronous support: Can be configured for asynchronous processing\r\n     * - Multiple listeners: Multiple listeners for the same event\r\n     */\r\n    @EventListener\r\n    public void handleAuthenticationSuccess(AuthenticationSuccessEvent event) {\r\n        Authentication authentication = event.getAuthentication();\r\n        String username = authentication.getName();\r\n        \r\n        log.debug(\"User login: {}\", username);\r\n        \r\n        // Increment online user count\r\n        endpointMetrics.userLoggedIn();\r\n    }\r\n\r\n    /**\r\n     * Logout success event listener\r\n     * \r\n     * Note: authentication might be null in some logout scenarios\r\n     * For example: Active logout after session timeout\r\n     */\r\n    @EventListener\r\n    public void handleLogout(LogoutSuccessEvent event) {\r\n        Authentication authentication = event.getAuthentication();\r\n        \r\n        if (authentication != null) {\r\n            String username = authentication.getName();\r\n            log.debug(\"User logout: {}\", username);\r\n        }\r\n        \r\n        // Decrement online user count (regardless of whether authentication is null)\r\n        endpointMetrics.userLoggedOut();\r\n    }\r\n\r\n    /**\r\n     * Custom authentication success handler: Avoid duplicate statistics\r\n     * \r\n     * Why do we need this Bean?\r\n     * - Form-based login might be needed in some cases\r\n     * - This handler only handles logging, does not repeat metric statistics\r\n     */\r\n    @Bean\r\n    public AuthenticationSuccessHandler loggingAuthenticationSuccessHandler() {\r\n        return (request, response, authentication) -\u003e {\r\n            String username = authentication.getName();\r\n            log.debug(\"Form login success: {}\", username);\r\n            // Note: Do not call endpointMetrics.userLoggedIn() here\r\n            // Because @EventListener already handles statistics\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Custom logout success handler: Avoid duplicate statistics\r\n     */\r\n    @Bean\r\n    public LogoutSuccessHandler loggingLogoutSuccessHandler() {\r\n        return (request, response, authentication) -\u003e {\r\n            if (authentication != null) {\r\n                String username = authentication.getName();\r\n                log.debug(\"Form logout success: {}\", username);\r\n            }\r\n            // Note: Do not call endpointMetrics.userLoggedOut() here\r\n            // Because @EventListener already handles statistics\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n### SessionEventListener: Fallback Mechanism for Session Lifecycle\r\n\r\n```java\r\n@Component\r\n@Slf4j\r\n@RequiredArgsConstructor\r\npublic class SessionEventListener implements HttpSessionListener {\r\n\r\n    private final EndpointMetrics endpointMetrics;\r\n\r\n    /**\r\n     * Session destruction listener: Handle users who \"silently leave\"\r\n     * \r\n     * Trigger scenarios for session destruction:\r\n     * 1. Session timeout (most common)\r\n     * 2. User actively closes browser\r\n     * 3. Calling session.invalidate()\r\n     * 4. Application server shutdown\r\n     */\r\n    @Override\r\n    public void sessionDestroyed(HttpSessionEvent se) {\r\n        String sessionId = se.getSession().getId();\r\n        log.debug(\"Session destroyed: {}\", sessionId);\r\n        \r\n        // Fallback mechanism: Ensure accurate user count statistics\r\n        endpointMetrics.userLoggedOut();\r\n    }\r\n\r\n    // Note: sessionCreated method is not implemented here\r\n    // Because session creation does not equal user login\r\n    // Anonymous users also create sessions\r\n}\r\n```\r\n\r\n**Why do we need SessionEventListener?**\r\n\r\nSpring Security event listening has a blind spot: Users who \"silently leave\".\r\n\r\n| Leaving Method | Spring Security Event | Session Event | Statistics Accuracy |\r\n|----------|-------------------|-------------|------------|\r\n| Normal logout | ✅ LogoutSuccessEvent | ✅ sessionDestroyed | ✅ Double guarantee |\r\n| Close browser | ❌ No event | ✅ sessionDestroyed (delayed) | ✅ Fallback mechanism |\r\n| Network disconnected | ❌ No event | ✅ sessionDestroyed (delayed) | ✅ Fallback mechanism |\r\n| Session timeout | ❌ No event | ✅ sessionDestroyed | ✅ Fallback mechanism |\r\n\r\n## Prometheus: Time Series Database\r\n\r\n### Why Choose Prometheus?\r\n\r\nPrometheus is more than just a monitoring system; it's like a \"time magician\" that can record the ever-changing system state into queryable, analyzable time series data.\r\n\r\n**Core advantages of Prometheus:**\r\n\r\n1. **Elegance of Pull mode:**\r\n   ```mermaid\r\ngraph LR\r\n       A[Prometheus Server] --\u003e|Pull every 15s| B[ACOT App 1:8080/actuator/prometheus]\r\n       A --\u003e|Pull every 15s| C[ACOT App 2:8081/actuator/prometheus]\r\n       A --\u003e|Pull every 15s| D[Other services:9090/metrics]\r\n   ```\r\n\r\n2. **Multi-dimensional label system:**\r\n   ```promql\r\n   # Query call count for specific controller\r\n   acot_endpoint_calls_total{controller=\"UserController\"}\r\n   \r\n   # Query call count for specific method\r\n   acot_endpoint_calls_total{method=\"getUserInfo\"}\r\n   \r\n   # Query combination of specific controller + method\r\n   acot_endpoint_calls_total{controller=\"UserController\", method=\"getUserInfo\"}\r\n   ```\r\n\r\n3. **Powerful query language PromQL:**\r\n   \r\n   ```promql\r\n   # Query average online users in the past 5 minutes\r\n   avg_over_time(acot_online_users[5m])\r\n   \r\n   # Query API call growth rate\r\n   rate(acot_endpoint_calls_total[5m])\r\n   \r\n   # Query busiest endpoints\r\n   topk(10, rate(acot_endpoint_calls_total[1h]))\r\n   ```\r\n\r\n### Time Series Data Model: Fundamentals of Timestamp Design\r\n\r\nPrometheus's data model can be expressed with a mathematical formula:\r\n\r\n$$Metric = MetricName\\{label_1=value_1, label_2=value_2, ...\\} \\rightarrow (timestamp, value)$$\r\n\r\nFor example:\r\n```\r\nacot_endpoint_calls_total{controller=\"UserController\", method=\"getUserInfo\"} 42 @1234567890\r\n```\r\n\r\n**Selection strategy for data types:**\r\n\r\n| Metric Type | Applicable Scenario | Application in ACOT | Mathematical Property |\r\n|----------|----------|--------------|----------|\r\n| Counter | Monotonically increasing | API call count | $f(t_2) \\geq f(t_1)$ when $t_2 \u003e t_1$ |\r\n| Gauge | Instant value | Online users | $f(t)$ can change arbitrarily |\r\n| Histogram | Distribution statistics | Response time distribution | $\\sum_{i=1}^{n} bucket_i = total$ |\r\n| Summary | Quantile statistics | Response time percentiles | $P_{50}, P_{90}, P_{99}$ |\r\n\r\n### Integration of Spring Boot and Prometheus\r\n\r\n**Maven dependency configuration:**\r\n\r\n```xml\r\n\u003c!-- Spring Boot Actuator: Production-level application monitoring --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\n    \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n\r\n\u003c!-- Micrometer Prometheus: Prometheus exporter for metrics --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\r\n    \u003cartifactId\u003emicrometer-registry-prometheus\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n\r\n\u003c!-- Spring AOP: Aspect-oriented programming support --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\n    \u003cartifactId\u003espring-boot-starter-aop\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n```\r\n\r\n**application.yaml configuration:**\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        # Security consideration: Only expose necessary endpoints\r\n        include: \"health,info,metrics,prometheus,env,threaddump,loggers\"\r\n        base-path: /actuator\r\n      cors:\r\n        # Development environment configuration, need restrictions in production\r\n        allowed-origins: \"*\"\r\n        allowed-methods: GET,POST,PUT,DELETE,OPTIONS,HEAD\r\n        allowed-headers: \"*\"\r\n  \r\n  endpoint:\r\n    prometheus:\r\n      # Recommended to set to \"when_authorized\" in production\r\n      access: unrestricted\r\n    metrics:\r\n      access: unrestricted\r\n  \r\n  metrics:\r\n    distribution:\r\n      percentiles-histogram:\r\n        # Enable histogram statistics for HTTP request response time\r\n        http.server.requests: true\r\n    tags:\r\n      # Add application identification tag to all metrics\r\n      application: ${spring.application.name}\r\n    \r\n  prometheus:\r\n    metrics:\r\n      export:\r\n        enabled: true\r\n        # Push interval can be configured, not needed for pull mode by default\r\n        # step: 15s\r\n  \r\n  health:\r\n    diskspace:\r\n      enabled: true\r\n    db:\r\n      enabled: true\r\n\r\n# Enable debug logs to view metric registration process\r\nlogging:\r\n  level:\r\n    com.chat.allchatonthis.config.metrics: debug\r\n```\r\n\r\n**Prometheus configuration example:**\r\n\r\n```yaml\r\n# prometheus.yml\r\nglobal:\r\n  scrape_interval: 15s\r\n  evaluation_interval: 15s\r\n\r\nscrape_configs:\r\n  - job_name: 'acot-backend'\r\n    metrics_path: '/actuator/prometheus'\r\n    static_configs:\r\n      - targets: ['localhost:8080']\r\n    scrape_interval: 10s\r\n    scrape_timeout: 5s\r\n```\r\n\r\n## Grafana: Data Visualization\r\n\r\n### Core Value of Grafana\r\n\r\nIf Prometheus is the \"data collector\", then Grafana is the \"data artist\". It can transform cold numbers into intuitive charts, making monitoring data \"speak\".\r\n\r\n**Construction ideas for ACOT monitoring dashboard:**\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"ACOT Grafana Dashboard\"\r\n        A[System Overview Panel] --\u003e A1[Real-time Online Users Curve]\r\n        A --\u003e A2[Total API Calls]\r\n        A --\u003e A3[System Health Status]\r\n        \r\n        B[API Call Statistics Panel] --\u003e B1[Popular API Ranking]\r\n        B --\u003e B2[API Call Trend Chart]\r\n        B --\u003e B3[Error Rate Statistics]\r\n        \r\n        C[User Activity Panel] --\u003e C1[User Login/Logout Trend]\r\n        C --\u003e C2[User Active Period Analysis]\r\n        C --\u003e C3[Session Duration Distribution]\r\n        \r\n        D[Performance Metrics Panel] --\u003e D1[Response Time Distribution]\r\n        D --\u003e D2[JVM Memory Usage]\r\n        D --\u003e D3[Database Connection Pool Status]\r\n        \r\n        E[Alert Status Panel]\r\n    end\r\n```\r\n\r\n**Key PromQL query statements:**\r\n\r\n```promql\r\n# 1. Current online users\r\nacot_online_users\r\n\r\n# 2. API call rate (per second)\r\nrate(acot_endpoint_calls_total[5m])\r\n\r\n# 3. Most popular API endpoints (Top 10)\r\ntopk(10, increase(acot_endpoint_calls_total[1h]))\r\n\r\n# 4. User login rate\r\nrate(acot_online_users[5m]) \u003e 0\r\n\r\n# 5. System average response time\r\nrate(http_server_requests_seconds_sum[5m]) / rate(http_server_requests_seconds_count[5m])\r\n\r\n# 6. Error rate statistics\r\nrate(http_server_requests_seconds_count{status=~\"4..|5..\"}[5m]) / \r\nrate(http_server_requests_seconds_count[5m]) * 100\r\n```\r\n\r\n## In-depth Code Analysis: Line-by-Line Dissection of Monitoring Implementation Details\r\n\r\n### MetricsController: HTTP Exposure Interface for Monitoring Data\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/metrics\")\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class MetricsController {\r\n\r\n    private final MeterRegistry meterRegistry;\r\n\r\n    /**\r\n     * Get current online users\r\n     * \r\n     * Implementation principle:\r\n     * 1. Find Gauge named \"acot.online.users\" through MeterRegistry\r\n     * 2. Call gauge().value() to get current instant...\r\n     * 3. Convert to integer and return\r\n     */\r\n    @GetMapping(\"/online-users\")\r\n    public CommonResult\u003cInteger\u003e getOnlineUsers() {\r\n        // Lookup chain for MeterRegistry.get() method:\r\n        // 1. Find registered Meter by name\r\n        // 2. Return first matching Meter\r\n        // 3. Throw MeterNotFoundException if not found\r\n        Integer onlineUsers = (int) meterRegistry.get(\"acot.online.users\").gauge().value();\r\n        \r\n        return CommonResult.success(onlineUsers);\r\n    }\r\n\r\n    /**\r\n     * Get endpoint call statistics\r\n     * \r\n     * This method demonstrates the power of Micrometer Search API\r\n     */\r\n    @GetMapping(\"/endpoints\")\r\n    public CommonResult\u003cMap\u003cString, Object\u003e\u003e getEndpointStats() {\r\n        Map\u003cString, Object\u003e stats = new HashMap\u003c\u003e();\r\n        \r\n        // Streaming query with Micrometer Search API\r\n        Search.in(meterRegistry)\r\n            .name(\"acot.endpoint.calls\")  // Step 1: Filter by name\r\n            .counters()                   // Step 2: Keep only Counter type\r\n            .forEach(counter -\u003e {         // Step 3: Iterate all matching Counters\r\n                // Extract Counter's tag information\r\n                Iterable\u003cTag\u003e tags = counter.getId().getTags();\r\n                \r\n                String controller = \"\";\r\n                String method = \"\";\r\n                \r\n                // Iterate tags to extract controller and method information\r\n                for (Tag tag : tags) {\r\n                    if (\"controller\".equals(tag.getKey())) {\r\n                        controller = tag.getValue();\r\n                    } else if (\"method\".equals(tag.getKey())) {\r\n                        method = tag.getValue();\r\n                    }\r\n                }\r\n                \r\n                // Construct endpoint identifier and record count value\r\n                String endpoint = controller + \".\" + method;\r\n                stats.put(endpoint, (int) counter.count());\r\n            });\r\n        \r\n        return CommonResult.success(stats);\r\n    }\r\n\r\n    /**\r\n     * Get monitoring data summary\r\n     * \r\n     * This method demonstrates how to aggregate multiple metrics\r\n     */\r\n    @GetMapping(\"/summary\")\r\n    public CommonResult\u003cMap\u003cString, Object\u003e\u003e getMetricsSummary() {\r\n        Map\u003cString, Object\u003e summary = new HashMap\u003c\u003e();\r\n        \r\n        // Get online users\r\n        Integer onlineUsers = (int) meterRegistry.get(\"acot.online.users\").gauge().value();\r\n        summary.put(\"onlineUsers\", onlineUsers);\r\n        \r\n        // Calculate total API calls (sum of all endpoint counters)\r\n        double totalApiCalls = Search.in(meterRegistry)\r\n            .name(\"acot.endpoint.calls\")\r\n            .counters()\r\n            .stream()\r\n            .mapToDouble(counter -\u003e counter.count())  // Extract each counter's value\r\n            .sum();                                   // Sum them up\r\n        summary.put(\"totalApiCalls\", (int) totalApiCalls);\r\n        \r\n        return CommonResult.success(summary);\r\n    }\r\n}\r\n```\r\n\r\n**Internal working mechanism of MeterRegistry:**\r\n\r\n```java\r\n// Simplified lookup algorithm for MeterRegistry\r\npublic Meter get(String name) {\r\n    for (Meter meter : this.meters) {\r\n        if (meter.getId().getName().equals(name)) {\r\n            return meter;\r\n        }\r\n    }\r\n    throw new MeterNotFoundException(\"Meter not found: \" + name);\r\n}\r\n```\r\n\r\n### Complete Metric Data Flow Analysis\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as Client\r\n    participant Controller as RestController\r\n    participant Aspect as EndpointMetricsAspect\r\n    participant Metrics as EndpointMetrics\r\n    participant Registry as MeterRegistry\r\n    participant Prometheus as Prometheus endpoint\r\n\r\n    Client-\u003e\u003eController: HTTP request\r\n    Controller-\u003e\u003eAspect: Method call (AOP interception)\r\n    Aspect-\u003e\u003eMetrics: incrementEndpointCount()\r\n    Metrics-\u003e\u003eRegistry: counter.increment()\r\n    Controller-\u003e\u003eClient: Return response\r\n    \r\n    Note over Registry: Metric data continues to accumulate\r\n    \r\n    Prometheus-\u003e\u003eController: GET /actuator/prometheus\r\n    Controller-\u003e\u003eRegistry: Get all metrics\r\n    Registry-\u003e\u003ePrometheus: Return Prometheus format data\r\n```\r\n\r\n### In-depth Analysis of Configuration Files\r\n\r\n**Why do we need these configurations?**\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        # Why only expose these endpoints?\r\n        include: \"health,info,metrics,prometheus,env,threaddump,loggers\"\r\n        # Security considerations:\r\n        # - health: Health check needed for load balancing\r\n        # - metrics: Internal monitoring queries\r\n        # - prometheus: External monitoring system pull\r\n        # - Other sensitive endpoints not exposed to avoid information leakage\r\n```\r\n\r\n**Security configuration for production environment:**\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"health,prometheus\"  # Minimal exposure principle\r\n        base-path: /internal/actuator  # Internal path for gateway routing control\r\n  endpoint:\r\n    prometheus:\r\n      access: when_authorized  # Requires authentication\r\n    health:\r\n      show-details: when_authorized  # Detailed information requires authentication\r\n  server:\r\n    port: 9090  # Independent management port for firewall policies\r\n```\r\n\r\n## Final Thoughts\r\n\r\nCompared to using monitoring systems to focus on system health, I actually prefer using monitoring systems for user behavior analysis. Admittedly, security is more important than personalization, but isn't the purpose of security to enable more possibilities afterward?\r\n\r\nACOT's monitoring system design is relatively simple, but it demonstrates a system's long-term sustainable development capability - a keen sense of user needs. After all, a system that can solve user needs is a good system.\r\n\r\n*May future systems be like intelligent spirits, listening attentively to visitors, becoming sharp tools in their hands, serving as operators of the future, making human wisdom shine in the universe.* ✨\r\n\r\n```java\r\n// Wish (monitoring version)\r\nwhile (system.isRunning()) {\r\n    monitor.collect();\r\n    if (anomaly.detected()) {\r\n        alert.send(); 🚨\r\n        engineer.fix();\r\n    }\r\n    dashboard.update(); 📊\r\n}\r\n```\r\n"])</script><script>self.__next_f.push([1,"10:T32b9,"])</script><script>self.__next_f.push([1,"\r\n# Specialization Time Half Calculator - Algorithm Analysis\r\n\r\n## Preface\r\n\r\nThe Specialization Time Half Calculator is a tool specifically designed for Arknights players to calculate the optimal timing for switching to half-time operators like Aylinar or Logos, allowing them to precisely trigger the specialization time reduction effect. This article will provide a detailed breakdown of its core algorithm implementation logic.\r\n\r\nThis algorithm looks quite complex, but the core idea is actually simple: **figure out when to switch to half-time operators so that the remaining time can be exactly halved**.\r\n\r\n## Core Algorithm Analysis\r\n\r\n### Data Structure Design\r\n\r\nFirst, let's look at the main data used by this calculator:\r\n\r\n```javascript\r\nconst halfOperatorParams = reactive({\r\n  efficiency: null,        // Efficiency provided by current specialization assistant operator\r\n  isFit: false,           // Whether it enjoys class specialization efficiency bonus\r\n  halfOperatorAddition: 0.3, // Half-time operator specialization efficiency bonus (default 30%)\r\n  hasAscalon: false,      // Whether Ascalon/Zhuohang is stationed in Control Center\r\n  remainder: null,        // Currently displayed remaining time\r\n  leadTime: 5,           // Default 5-minute advance reminder\r\n})\r\n```\r\n\r\n### Algorithm Core Logic\r\n\r\n`calculateTime()` function analysis:\r\n\r\n```javascript\r\nfunction calculateTime() {\r\n  // Step 1: Calculate extra efficiency\r\n  extraEfficiency = 0.05 + (halfOperatorParams.hasAscalon ? 0.05 : 0)\r\n```\r\n\r\nCode explanation:\r\n- Training Room base efficiency is 5% (0.05)\r\n- If Control Center has Ascalon or Zhuohang, add another 5%\r\n- So `extraEfficiency` is either 0.05 or 0.1\r\n\r\n```javascript\r\n  // Step 2: Calculate current total efficiency\r\n  nowEfficiency.value = 1 + halfOperatorParams.efficiency + extraEfficiency\r\n```\r\n\r\nFormula understanding:\r\n- Base efficiency is 1 (which is 100%)\r\n- Add the specialization assistant operator's efficiency (e.g., 0.6 means 60%)\r\n- Add the extra efficiency calculated above\r\n- For example: 1 + 0.6 + 0.05 = 1.65 (which is 165% efficiency)\r\n\r\n```javascript\r\n  // Step 3: Calculate half-time operator efficiency\r\n  halfOperatorEfficiency.value = halfOperatorParams.isFit ? \r\n    1 + halfOperatorParams.halfOperatorAddition + extraEfficiency : \r\n    1 + extraEfficiency;\r\n```\r\n\r\nThere's a judgment here:\r\n- If the half-time operator has class bonus (like Aylinar's bonus for Guard/Sniper), add `halfOperatorAddition`\r\n- If no class bonus, only add the base extra efficiency\r\n- For example, Aylinar for Guard class: 1 + 0.3 + 0.05 = 1.35 (135% efficiency)\r\n\r\n### The Essence of Time Calculation\r\n\r\nNext is the core part of the algorithm:\r\n\r\n```javascript\r\n  if (halfOperatorParams.efficiency != null \u0026\u0026 halfOperatorParams.remainder != null) {\r\n    // Step 4: Convert display time to total seconds\r\n    remainSeconds = convertToSeconds(halfOperatorParams.remainder)\r\n```\r\n\r\nThis function converts user input time (like \"04:30:15\") to seconds for easier calculation.\r\n\r\n```javascript\r\n    // Step 5: Calculate actual remaining time under zero efficiency\r\n    zeroEffRemainSeconds.value = remainSeconds * nowEfficiency.value\r\n```\r\n\r\nThis step is crucial! Why multiply by current efficiency?\r\n\r\nHere's an example:\r\n- Display remaining time 1 hour (3600 seconds)\r\n- Current efficiency 165% (1.65)\r\n- Under zero efficiency actually needs: 3600 × 1.65 = 5940 seconds\r\n\r\nThis is done to unify the calculation baseline.\r\n\r\n```javascript\r\n    // Step 6: Calculate time needed by half-time operator\r\n    zeroEffNeedTime = halfOperatorEfficiency.value * 5 * 60 * 60\r\n```\r\n\r\nThe logic here is:\r\n- Half-time operator's halving effect requires remaining time ≥ 5 hours to trigger\r\n- 5 hours = 5 × 60 × 60 = 18000 seconds\r\n- But considering the half-time operator's efficiency, the actual zero-efficiency time needed is: 18000 × half-time operator efficiency\r\n\r\n```javascript\r\n    // Step 7: Calculate time difference\r\n    timeDifference = zeroEffRemainSeconds.value - zeroEffNeedTime\r\n    timeDifference /= nowEfficiency.value\r\n```\r\n\r\nThis is the algorithm's core:\r\n- First calculate the time difference under zero efficiency\r\n- Then divide by current efficiency to get the difference value under actual display time\r\n- This difference is \"how long until we need to switch to half-time operator\"\r\n\r\n### Status Judgment Logic\r\n\r\nFinally, there's status judgment:\r\n\r\n```javascript\r\n    // Step 8: Calculate ample time\r\n    ampleTime = timeDifference - halfOperatorParams.leadTime * 60\r\n    \r\n    if (ampleTime \u003e 0) {\r\n      // Case 1: Still have ample time\r\n      state.value = \"success\"\r\n      // Calculate reminder time...\r\n    } else if (timeDifference \u003e 0) {\r\n      // Case 2: Already very urgent\r\n      state.value = \"warning\"\r\n    } else {\r\n      // Case 3: Too late\r\n      state.value = \"danger\"\r\n    }\r\n```\r\n\r\nThree states are designed here:\r\n1. **Success** (Green): Still have time, can set alarm\r\n2. **Warning** (Yellow): Switch operators immediately!\r\n3. **Danger** (Red): Can no longer trigger halving effect\r\n\r\n## UI Data Display Logic\r\n\r\n### Efficiency Display\r\n\r\n```javascript\r\n// Display efficiency in percentage form\r\n{{ ((nowEfficiency - 1) * 100).toFixed(0) }}%\r\n{{ ((halfOperatorEfficiency - 1) * 100).toFixed(0) }}%\r\n```\r\n\r\nThis converts efficiency to percentage display, e.g., 1.65 displays as 65%.\r\n\r\n### Remaining Time Formatting\r\n\r\n```javascript\r\nconst formattedRemainingTime = computed(() =\u003e {\r\n  if (!zeroEffRemainSeconds.value) return '00:00:00'\r\n  const hours = Math.floor(zeroEffRemainSeconds.value / 3600)\r\n  const minutes = Math.floor((zeroEffRemainSeconds.value % 3600) / 60).toString().padStart(2, '0')\r\n  const seconds = Math.floor(zeroEffRemainSeconds.value % 60).toString().padStart(2, '0')\r\n  return `${hours}:${minutes}:${seconds}`\r\n})\r\n```\r\n\r\nThis function converts seconds to nice time format, like \"5:30:45\".\r\n\r\n### Reminder Time Calculation\r\n\r\n```javascript\r\nremindTime = secondsToTimeString(getSecondsSinceMidnight() + ampleTime \u003e 86400 ?\r\n  Math.floor(getSecondsSinceMidnight() + ampleTime - 86400) :\r\n  Math.floor(getSecondsSinceMidnight() + ampleTime))\r\n```\r\n\r\nThis part handles cross-day situations:\r\n- If reminder time exceeds 24:00 of current day, calculate as next day's time\r\n- For example, if it's 23:30 now and needs 2-hour reminder, that would be 01:30 tomorrow\r\n\r\n## Practical Application Scenario\r\n\r\nSuppose you now have a Guard operator in specialization, displaying 6 hours remaining time:\r\n\r\n1. **Input Data**:\r\n- Remaining time: 06:00:00\r\n- Current efficiency: 60% (0.6)\r\n- Has Ascalon/Zhuohang: Yes\r\n- Aylinar has Guard bonus: Yes\r\n\r\n2. **Calculation Process**:\r\n- Current total efficiency: 1 + 0.6 + 0.1 = 1.7 (170%)\r\n- Aylinar efficiency: 1 + 0.3 + 0.1 = 1.4 (140%)\r\n- Actual remaining under zero efficiency: 6×3600×1.7 = 36720 seconds\r\n- Time Aylinar needs: 5×3600×1.4 = 25200 seconds\r\n- Time difference: (36720 - 25200) / 1.7 ≈ 6776 seconds ≈ 1 hour 52 minutes (rounded down)\r\n\r\n3. **Result**: Switch to Aylinar in about 1 hour 52 minutes to precisely trigger halving effect! (Of course, don't cut it that close in actual use)\r\n\r\n## Complete Algorithm Code Analysis\r\n\r\nBelow is the complete `calculateTime()` function:\r\n\r\n```javascript\r\nfunction calculateTime() {\r\n  // ==================== Phase 1: Calculate Base Efficiency ====================\r\n  \r\n  // Calculate extra efficiency bonus\r\n  // Training Room base efficiency fixed at 5%, if Control Center has Ascalon/Zhuohang add another 5%\r\n  extraEfficiency = 0.05 + (halfOperatorParams.hasAscalon ? 0.05 : 0)\r\n  \r\n  // Calculate current total efficiency (efficiency before switching to half-time operator)\r\n  // Formula: Base 100% + specialization assistant operator efficiency + extra efficiency\r\n  nowEfficiency.value = 1 + halfOperatorParams.efficiency + extraEfficiency\r\n  \r\n  // Calculate half-time operator total efficiency (efficiency after switching to half-time operator)\r\n  // If half-time operator has class bonus, add corresponding bonus value, otherwise only add base extra efficiency\r\n  halfOperatorEfficiency.value = halfOperatorParams.isFit ? \r\n    1 + halfOperatorParams.halfOperatorAddition + extraEfficiency : \r\n    1 + extraEfficiency;\r\n\r\n  // ==================== Phase 2: Check Input Data Completeness ====================\r\n  \r\n  // Only calculate when both efficiency and remaining time have values\r\n  if (halfOperatorParams.efficiency != null \u0026\u0026 halfOperatorParams.remainder != null) {\r\n    \r\n    // ==================== Phase 3: Time Conversion Core Logic ====================\r\n    \r\n    // Convert user input time format (like \"04:30:15\") to total seconds\r\n    remainSeconds = convertToSeconds(halfOperatorParams.remainder)\r\n    \r\n    // 【Core Algorithm 1】Calculate actual remaining time under zero efficiency\r\n    // Why multiply by current efficiency? To convert \"display time with efficiency bonus\" to \"real time under zero efficiency\"\r\n    // Example: Display 1 hour, current 170% efficiency, then under zero efficiency actually needs 1×1.7=1.7 hours\r\n    zeroEffRemainSeconds.value = remainSeconds * nowEfficiency.value\r\n    \r\n    // 【Core Algorithm 2】Calculate time needed by half-time operator under zero efficiency\r\n    // Halving effect trigger condition: remaining time ≥ 5 hours\r\n    // But this 5 hours is under half-time operator efficiency, so under zero efficiency needs: 5 hours × half-time operator efficiency\r\n    zeroEffNeedTime = halfOperatorEfficiency.value * 5 * 60 * 60\r\n    \r\n    // 【Core Algorithm 3】Calculate time difference under zero efficiency\r\n    // This difference represents: current remaining time - minimum time needed by half-time operator\r\n    // Positive means there's surplus, negative means insufficient\r\n    timeDifference = zeroEffRemainSeconds.value - zeroEffNeedTime\r\n    \r\n    // 【Core Algorithm 4】Convert zero efficiency time difference back to current efficiency time difference\r\n    // Because we need to tell user \"X minutes left to switch operators\", this X is time under current efficiency\r\n    timeDifference /= nowEfficiency.value\r\n    \r\n    // ==================== Phase 4: Status Judgment and User Reminders ====================\r\n    \r\n    // Calculate ample time: time difference minus user-set advance reminder time\r\n    // For example, time difference has 10 minutes left, user sets 5-minute advance reminder, then ample time is 5 minutes\r\n    ampleTime = timeDifference - halfOperatorParams.leadTime * 60\r\n    \r\n    if (ampleTime \u003e 0) {\r\n      // 【Status 1: Success】Still have sufficient ample time\r\n      state.value = \"success\"\r\n      \r\n      // Calculate specific reminder time point\r\n      // Get current time seconds since midnight, add ample time, that's the reminder time point\r\n      // If exceeds 24 hours (86400 seconds), subtract 86400, representing next day's time\r\n      remindTime = secondsToTimeString(\r\n        getSecondsSinceMidnight() + ampleTime \u003e 86400 ?\r\n          Math.floor(getSecondsSinceMidnight() + ampleTime - 86400) :\r\n          Math.floor(getSecondsSinceMidnight() + ampleTime)\r\n      )\r\n      \r\n      // Generate reminder text\r\n      remindText.value = `减半干员的专精减半效果将在${Math.floor(timeDifference / 60)}分钟后迎来临界触发点，可以制定${remindTime}时间点的闹钟(〃'▽'〃)`\r\n      \r\n    } else if (timeDifference \u003e 0) {\r\n      // 【Status 2: Warning】Insufficient ample time, but can still trigger halving effect\r\n      state.value = \"warning\"\r\n      remindText.value = \"立，刻，换，减，半，干，员！！！(╬◣д◢)\"\r\n      \r\n    } else {\r\n      // 【Status 3: Danger】Already missed optimal timing, cannot trigger halving effect\r\n      state.value = \"danger\"\r\n      remindText.value = \"已经...已经触发不了了...o(╥﹏╥)o\"\r\n    }\r\n    \r\n  } else {\r\n    // ==================== Default State When Data Incomplete ====================\r\n    state.value = \"info\"\r\n    remindText.value = \"得先输入数据才会有结果哦(￣▽￣)\"\r\n  }\r\n}\r\n```\r\n\r\n### Mathematical Principles of the Algorithm\r\n\r\nThe core mathematical idea of this algorithm is **time equivalent conversion**:\r\n\r\n1. **Unified Baseline**: All time calculations are converted to \"zero efficiency baseline\" for comparison\r\n2. **Efficiency Conversion Formulas**:\r\n- Display time → Zero efficiency time: `Display time × Current efficiency`\r\n- Zero efficiency time → Display time: `Zero efficiency time ÷ Current efficiency`\r\n\r\n3. **Critical Point Judgment**:\r\n```\r\nZero efficiency remaining time ≥ Zero efficiency time needed by half-time operator\r\ni.e.: remainSeconds × nowEfficiency ≥ 5 hours × halfOperatorEfficiency\r\n   ```\r\n\r\n4. **Time Difference Calculation**:\r\n```\r\nActually available time = (Remaining time - Minimum needed time) ÷ Current efficiency\r\n   ```\r\n\r\nThe advantage of this design is the ability to precisely handle time conversions under different efficiencies, ensuring calculation result accuracy."])</script><script>self.__next_f.push([1,"11:T19c4,"])</script><script>self.__next_f.push([1,"\r\n`MutationObserver` is a native browser API for monitoring changes to the DOM tree. It can asynchronously observe changes to specified elements and their children, making it the recommended approach for handling DOM changes in modern web development.\r\n\r\n\r\n### **Basic Purpose**\r\n`MutationObserver` is used to monitor the following types of DOM changes:\r\n- Addition or removal of child nodes\r\n- Attribute changes on elements\r\n- Text content changes\r\n- Changes to element subtrees\r\n\r\n```javascript\r\nconst observer = new MutationObserver((mutations) =\u003e {\r\n  mutations.forEach((mutation) =\u003e {\r\n    console.log('DOM changed:', mutation);\r\n  });\r\n});\r\n```\r\n\r\n\r\n### **Basic Usage**\r\nCreating a MutationObserver requires three steps:\r\n\r\n```javascript\r\n// 1. Create observer instance\r\nconst observer = new MutationObserver((mutations, observer) =\u003e {\r\n  // Handle changes\r\n  mutations.forEach((mutation) =\u003e {\r\n    console.log('Change type:', mutation.type);\r\n    console.log('Target element:', mutation.target);\r\n  });\r\n});\r\n\r\n// 2. Configure observation options\r\nconst config = {\r\n  childList: true,        // Observe child node changes\r\n  attributes: true,       // Observe attribute changes\r\n  attributeOldValue: true,// Record old attribute values\r\n  characterData: true,    // Observe text content changes\r\n  subtree: true          // Observe entire subtree\r\n};\r\n\r\n// 3. Start observing\r\nconst targetNode = document.getElementById('myDiv');\r\nobserver.observe(targetNode, config);\r\n```\r\n\r\n\r\n### **Configuration Options Explained**\r\n```javascript\r\nconst config = {\r\n  childList: true,          // Monitor addition/removal of child nodes\r\n  attributes: true,         // Monitor attribute changes\r\n  attributeOldValue: true,  // Record attribute values before changes\r\n  attributeFilter: ['class', 'style'], // Only monitor specified attributes\r\n  characterData: true,      // Monitor text node content changes\r\n  characterDataOldValue: true, // Record text values before changes\r\n  subtree: true            // Monitor changes in entire subtree\r\n};\r\n```\r\n\r\n\r\n### **Practical Examples**\r\n\r\n#### **Monitoring Class Name Changes**\r\n```javascript\r\nconst observer = new MutationObserver((mutations) =\u003e {\r\n  mutations.forEach((mutation) =\u003e {\r\n    if (mutation.type === 'attributes' \u0026\u0026 mutation.attributeName === 'class') {\r\n      console.log('Class changed from', mutation.oldValue, 'to', mutation.target.className);\r\n    }\r\n  });\r\n});\r\n\r\nobserver.observe(document.body, {\r\n  attributes: true,\r\n  attributeOldValue: true,\r\n  attributeFilter: ['class']\r\n});\r\n```\r\n\r\n#### **Monitoring Child Element Addition**\r\n```javascript\r\nconst listObserver = new MutationObserver((mutations) =\u003e {\r\n  mutations.forEach((mutation) =\u003e {\r\n    if (mutation.type === 'childList') {\r\n      mutation.addedNodes.forEach((node) =\u003e {\r\n        if (node.nodeType === Node.ELEMENT_NODE) {\r\n          console.log('New element added:', node);\r\n        }\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nconst todoList = document.getElementById('todoList');\r\nlistObserver.observe(todoList, { childList: true });\r\n```\r\n\r\n\r\n### **Comparison with Traditional Event Listening**\r\n```javascript\r\n// Traditional approach: Using DOMNodeInserted (deprecated)\r\nelement.addEventListener('DOMNodeInserted', handler, false);\r\n\r\n// Modern approach: Using MutationObserver\r\nconst observer = new MutationObserver(handler);\r\nobserver.observe(element, { childList: true, subtree: true });\r\n```\r\n\r\n\r\n### **Performance Advantages**\r\n1. **Asynchronous execution**: Won't block the main thread\r\n2. **Batch processing**: Multiple changes are combined into a single callback\r\n3. **Precise control**: Can selectively monitor specific types of changes\r\n\r\n\r\n### **Real-world Application Scenarios**\r\n- **Infinite scroll lists**: Monitor container height changes\r\n- **Dynamic content loading**: Monitor insertion of new content\r\n- **Theme switching**: Monitor class or data attribute changes\r\n- **Form validation**: Monitor input content changes\r\n- **Component library development**: Monitor DOM structure changes\r\n\r\n\r\n### **Usage in React**\r\n```jsx\r\nimport React, { useEffect, useRef } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const containerRef = useRef(null);\r\n\r\n  useEffect(() =\u003e {\r\n    const observer = new MutationObserver((mutations) =\u003e {\r\n      mutations.forEach((mutation) =\u003e {\r\n        if (mutation.type === 'childList') {\r\n          console.log('Child elements changed');\r\n        }\r\n      });\r\n    });\r\n\r\n    if (containerRef.current) {\r\n      observer.observe(containerRef.current, {\r\n        childList: true,\r\n        subtree: true\r\n      });\r\n    }\r\n\r\n    // Cleanup function\r\n    return () =\u003e {\r\n      observer.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  return \u003cdiv ref={containerRef}\u003eMonitored container\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Important Considerations**\r\n1. **Proper disconnection**: Use `observer.disconnect()` to avoid memory leaks\r\n2. **Avoid infinite loops**: Modifying DOM in callbacks may trigger new changes\r\n3. **Performance considerations**: Avoid monitoring overly large DOM trees\r\n4. **Browser compatibility**: Supported in all modern browsers, IE11+\r\n\r\n\r\n### **Complete Example**\r\n```javascript\r\nclass DOMWatcher {\r\n  constructor(target, options = {}) {\r\n    this.target = target;\r\n    this.options = {\r\n      childList: true,\r\n      attributes: true,\r\n      subtree: true,\r\n      ...options\r\n    };\r\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\r\n  }\r\n\r\n  handleMutations(mutations) {\r\n    mutations.forEach((mutation) =\u003e {\r\n      switch (mutation.type) {\r\n        case 'childList':\r\n          this.handleChildListChange(mutation);\r\n          break;\r\n        case 'attributes':\r\n          this.handleAttributeChange(mutation);\r\n          break;\r\n        case 'characterData':\r\n          this.handleTextChange(mutation);\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  handleChildListChange(mutation) {\r\n    console.log('Child elements changed:', mutation.addedNodes, mutation.removedNodes);\r\n  }\r\n\r\n  handleAttributeChange(mutation) {\r\n    console.log('Attribute changed:', mutation.attributeName, mutation.oldValue);\r\n  }\r\n\r\n  handleTextChange(mutation) {\r\n    console.log('Text changed:', mutation.oldValue, mutation.target.textContent);\r\n  }\r\n\r\n  start() {\r\n    this.observer.observe(this.target, this.options);\r\n  }\r\n\r\n  stop() {\r\n    this.observer.disconnect();\r\n  }\r\n}\r\n\r\n// Usage example\r\nconst watcher = new DOMWatcher(document.body);\r\nwatcher.start();\r\n```\r\n\r\nMutationObserver is the standard solution for monitoring DOM changes in modern web development, providing powerful functionality and excellent performance.\r\n"])</script><script>self.__next_f.push([1,"12:T2e94,"])</script><script>self.__next_f.push([1,"\r\n`requestAnimationFrame` is a native browser API for creating smooth animation effects. It calls a specified callback function before the next repaint, ensuring animations stay synchronized with the browser's refresh rate.\r\n\r\n\r\n### **Basic Purpose**\r\nThe main purposes of `requestAnimationFrame` are:\r\n- Execute animation functions before the browser's next repaint\r\n- Synchronize with display refresh rate (typically 60fps)\r\n- Automatically pause when page is not visible, saving performance\r\n- Provide smoother animation experience\r\n\r\n```javascript\r\nfunction animate() {\r\n  // Animation logic\r\n  console.log('Executing animation frame');\r\n  \r\n  // Request next frame\r\n  requestAnimationFrame(animate);\r\n}\r\n\r\n// Start animation\r\nrequestAnimationFrame(animate);\r\n```\r\n\r\n\r\n### **Basic Usage**\r\n```javascript\r\nfunction animate(timestamp) {\r\n  // timestamp: current timestamp (in milliseconds)\r\n  console.log('Current time:', timestamp);\r\n  \r\n  // Execute animation logic\r\n  element.style.left = Math.sin(timestamp / 1000) * 100 + 'px';\r\n  \r\n  // Request next frame\r\n  requestAnimationFrame(animate);\r\n}\r\n\r\n// Start animation\r\nconst animationId = requestAnimationFrame(animate);\r\n\r\n// Cancel animation\r\ncancelAnimationFrame(animationId);\r\n```\r\n\r\n### Working Principle and Common Issues\r\n\r\n#### Why is requestAnimationFrame typically called recursively?\r\n\r\n`requestAnimationFrame` uses recursive calls because it is fundamentally one-time: each call executes the callback function only once before the next repaint. To create continuous animation effects, you need to request the next frame at the end of each callback, forming a recursive calling pattern. This ensures animation frames are precisely synchronized with the browser's repaint rhythm.\r\n\r\n#### Won't continuous recursive calls to requestAnimationFrame cause stack overflow?\r\n\r\nNo, it won't cause stack overflow. Because the callback function of `requestAnimationFrame` is scheduled by the browser's event loop mechanism when the current execution stack is empty, following an asynchronous execution model. After each call, the callback function is triggered before the browser's next repaint, and by that time, the previous function call stack has already completed execution and been released, so the call stack won't grow indefinitely.\r\n\r\n#### What is the browser's repaint task queue?\r\n\r\nThe browser's repaint task queue is a task queue for managing visual update operations. When DOM or CSS changes require screen updates, these update operations are added to the repaint queue. The browser periodically (usually synchronized with the display refresh rate) takes tasks from the queue for execution to ensure smooth visual updates.\r\n\r\n#### How does requestAnimationFrame ensure synchronization with the browser refresh rate?\r\n\r\nBrowsers regularly trigger repaints at their own refresh rate (typically 60Hz, i.e., 60 times per second) to update the page display. The callback function of `requestAnimationFrame` is added to the browser's **repaint task queue** and executed before the next repaint, thus naturally aligning with the repaint frequency.\r\n\r\nAdditionally, browsers may adjust the refresh rate based on device performance or page status (e.g., when switching to the background, it may drop to 30Hz). `requestAnimationFrame` automatically adapts to these changes, and the callback trigger frequency synchronizes with the browser's actual repaint frequency without manual intervention.\r\n\r\n### **Comparison with Traditional Solutions**\r\n\r\n#### **Problems with setTimeout/setInterval**\r\n```javascript\r\n// Traditional approach: Using setTimeout (not recommended)\r\nfunction animateWithTimeout() {\r\n  element.style.left = parseInt(element.style.left || 0) + 1 + 'px';\r\n  setTimeout(animateWithTimeout, 16); // ~60fps\r\n}\r\n\r\n// Problems:\r\n// 1. Not synchronized with browser refresh rate\r\n// 2. Still executes when page is not visible\r\n// 3. May cause frame drops or stuttering\r\n```\r\n\r\n#### **Advantages of requestAnimationFrame**\r\n```javascript\r\n// Modern approach: Using requestAnimationFrame (recommended)\r\nfunction animateWithRAF(timestamp) {\r\n  element.style.left = parseInt(element.style.left || 0) + 1 + 'px';\r\n  requestAnimationFrame(animateWithRAF);\r\n}\r\n\r\n// Advantages:\r\n// 1. Synchronized with browser refresh rate\r\n// 2. Automatically pauses when page is not visible\r\n// 3. Better performance and battery life\r\n```\r\n\r\n\r\n### **Practical Examples**\r\n\r\n#### **Simple Movement Animation**\r\n```javascript\r\nclass Animator {\r\n  constructor(element) {\r\n    this.element = element;\r\n    this.isRunning = false;\r\n    this.animationId = null;\r\n  }\r\n\r\n  start() {\r\n    if (this.isRunning) return;\r\n    \r\n    this.isRunning = true;\r\n    this.animate();\r\n  }\r\n\r\n  stop() {\r\n    this.isRunning = false;\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n    }\r\n  }\r\n\r\n  animate = (timestamp) =\u003e {\r\n    if (!this.isRunning) return;\r\n\r\n    // Animation logic\r\n    const x = Math.sin(timestamp / 1000) * 200;\r\n    this.element.style.transform = `translateX(${x}px)`;\r\n\r\n    // Request next frame\r\n    this.animationId = requestAnimationFrame(this.animate);\r\n  }\r\n}\r\n\r\n// Usage example\r\nconst element = document.getElementById('myElement');\r\nconst animator = new Animator(element);\r\nanimator.start();\r\n```\r\n\r\n#### **Time-Controlled Animation**\r\n```javascript\r\nclass TimedAnimation {\r\n  constructor(element, duration = 2000) {\r\n    this.element = element;\r\n    this.duration = duration;\r\n    this.startTime = null;\r\n  }\r\n\r\n  start() {\r\n    this.startTime = null;\r\n    this.animate();\r\n  }\r\n\r\n  animate = (timestamp) =\u003e {\r\n    if (!this.startTime) {\r\n      this.startTime = timestamp;\r\n    }\r\n\r\n    const elapsed = timestamp - this.startTime;\r\n    const progress = Math.min(elapsed / this.duration, 1);\r\n\r\n    // Use easing function\r\n    const easeProgress = this.easeInOutQuad(progress);\r\n    \r\n    // Apply animation\r\n    this.element.style.transform = `translateX(${easeProgress * 300}px)`;\r\n\r\n    // Continue animation or end\r\n    if (progress \u003c 1) {\r\n      requestAnimationFrame(this.animate);\r\n    } else {\r\n      console.log('Animation completed');\r\n    }\r\n  }\r\n\r\n  easeInOutQuad(t) {\r\n    return t \u003c 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Performance Optimization Tips**\r\n\r\n#### **Avoid Forced Reflow**\r\n```javascript\r\n// Bad practice: Multiple read/write operations causing reflow\r\nfunction badAnimate() {\r\n  element1.style.left = element1.offsetLeft + 1 + 'px'; // Read triggers reflow\r\n  element2.style.left = element2.offsetLeft + 1 + 'px'; // Another reflow\r\n}\r\n\r\n// Good practice: Batch style operations\r\nfunction goodAnimate() {\r\n  // Read all needed values first\r\n  const left1 = element1.offsetLeft;\r\n  const left2 = element2.offsetLeft;\r\n  \r\n  // Then batch write operations\r\n  element1.style.left = left1 + 1 + 'px';\r\n  element2.style.left = left2 + 1 + 'px';\r\n}\r\n```\r\n\r\n#### **Use CSS Transforms Instead of Position Changes**\r\n```javascript\r\n// Poor performance: Changing left/top\r\nfunction slowAnimate(timestamp) {\r\n  element.style.left = Math.sin(timestamp / 1000) * 100 + 'px';\r\n}\r\n\r\n// Better performance: Using transform\r\nfunction fastAnimate(timestamp) {\r\n  const x = Math.sin(timestamp / 1000) * 100;\r\n  element.style.transform = `translateX(${x}px)`;\r\n}\r\n```\r\n\r\n\r\n### **Usage in React**\r\n```jsx\r\nimport React, { useEffect, useRef, useState } from 'react';\r\n\r\nfunction AnimatedComponent() {\r\n  const elementRef = useRef(null);\r\n  const animationRef = useRef(null);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n\r\n  const animate = (timestamp) =\u003e {\r\n    if (!elementRef.current || !isAnimating) return;\r\n\r\n    const x = Math.sin(timestamp / 1000) * 100;\r\n    elementRef.current.style.transform = `translateX(${x}px)`;\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n  };\r\n\r\n  const startAnimation = () =\u003e {\r\n    setIsAnimating(true);\r\n  };\r\n\r\n  const stopAnimation = () =\u003e {\r\n    setIsAnimating(false);\r\n    if (animationRef.current) {\r\n      cancelAnimationFrame(animationRef.current);\r\n    }\r\n  };\r\n\r\n  useEffect(() =\u003e {\r\n    if (isAnimating) {\r\n      animationRef.current = requestAnimationFrame(animate);\r\n    }\r\n\r\n    return () =\u003e {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n      }\r\n    };\r\n  }, [isAnimating]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv ref={elementRef} style={{ width: 50, height: 50, backgroundColor: 'blue' }}\u003e\r\n        Animated Element\r\n      \u003c/div\u003e\r\n      \u003cbutton onClick={isAnimating ? stopAnimation : startAnimation}\u003e\r\n        {isAnimating ? 'Stop' : 'Start'} Animation\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Custom Animation Hook**\r\n```jsx\r\nimport { useEffect, useRef, useCallback } from 'react';\r\n\r\nfunction useAnimationFrame(callback, isRunning = true) {\r\n  const requestRef = useRef();\r\n\r\n  const animate = useCallback((timestamp) =\u003e {\r\n    callback(timestamp);\r\n    if (isRunning) {\r\n      requestRef.current = requestAnimationFrame(animate);\r\n    }\r\n  }, [callback, isRunning]);\r\n\r\n  useEffect(() =\u003e {\r\n    if (isRunning) {\r\n      requestRef.current = requestAnimationFrame(animate);\r\n    } else {\r\n      if (requestRef.current) {\r\n        cancelAnimationFrame(requestRef.current);\r\n      }\r\n    }\r\n\r\n    return () =\u003e {\r\n      if (requestRef.current) {\r\n        cancelAnimationFrame(requestRef.current);\r\n      }\r\n    };\r\n  }, [animate, isRunning]);\r\n}\r\n\r\n// Usage example\r\nfunction MyAnimatedComponent() {\r\n  const [position, setPosition] = useState(0);\r\n\r\n  useAnimationFrame((timestamp) =\u003e {\r\n    setPosition(Math.sin(timestamp / 1000) * 100);\r\n  });\r\n\r\n  return (\r\n    \u003cdiv style={{ transform: `translateX(${position}px)` }}\u003e\r\n      Animated Content\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Real-world Application Scenarios**\r\n- **Smooth scrolling**: Scroll to specific positions on pages\r\n- **Particle systems**: Create particle animation effects\r\n- **Data visualization**: Chart animations and transitions\r\n- **Game development**: Game loops and character animations\r\n- **UI animations**: Button clicks, page transition animations\r\n- **Performance monitoring**: FPS calculation and performance analysis\r\n\r\n\r\n### **Important Considerations**\r\n1. **Memory management**: Always use `cancelAnimationFrame` to clean up animations\r\n2. **Conditional checks**: Check if animation should continue in callbacks\r\n3. **Performance considerations**: Avoid complex calculations in animations\r\n4. **Browser compatibility**: Supported in all modern browsers, polyfill available if needed\r\n\r\n\r\n### **Complete Animation Manager Example**\r\n```javascript\r\nclass AnimationManager {\r\n  constructor() {\r\n    this.animations = new Map();\r\n    this.isRunning = false;\r\n    this.animationId = null;\r\n  }\r\n\r\n  add(key, animationFn) {\r\n    this.animations.set(key, {\r\n      fn: animationFn,\r\n      active: true\r\n    });\r\n    \r\n    if (!this.isRunning) {\r\n      this.start();\r\n    }\r\n  }\r\n\r\n  remove(key) {\r\n    this.animations.delete(key);\r\n    \r\n    if (this.animations.size === 0) {\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  start() {\r\n    if (this.isRunning) return;\r\n    \r\n    this.isRunning = true;\r\n    this.tick();\r\n  }\r\n\r\n  stop() {\r\n    this.isRunning = false;\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n    }\r\n  }\r\n\r\n  tick = (timestamp) =\u003e {\r\n    if (!this.isRunning) return;\r\n\r\n    // Execute all active animations\r\n    for (const [key, animation] of this.animations) {\r\n      if (animation.active) {\r\n        animation.fn(timestamp);\r\n      }\r\n    }\r\n\r\n    // Request next frame\r\n    this.animationId = requestAnimationFrame(this.tick);\r\n  }\r\n}\r\n\r\n// Global animation manager\r\nconst animationManager = new AnimationManager();\r\n\r\n// Usage example\r\nanimationManager.add('myAnimation', (timestamp) =\u003e {\r\n  // Animation logic\r\n});\r\n```\r\n\r\n`requestAnimationFrame` is the core API for modern web animations, providing smooth and efficient animation solutions.\r\n"])</script><script>self.__next_f.push([1,"13:T4087,"])</script><script>self.__next_f.push([1,"\r\n`AnimatePresence` is a core component provided by Framer Motion for handling component exit animations. It detects the removal of direct child components in the React component tree, allowing components to execute complete exit animations before unmounting.\r\n\r\n\r\n### **Basic Purpose**\r\n`AnimatePresence` is primarily used in the following scenarios:\r\n- **Component exit animations**: Execute animations before component unmounting\r\n- **Conditional rendering animations**: Handle component show/hide based on state\r\n- **List item animations**: Transition effects when list items are added/removed\r\n- **Route transition animations**: Animation effects for page or view switching\r\n\r\n```jsx\r\nimport { AnimatePresence, motion } from \"framer-motion\";\r\n\r\nfunction App() {\r\n  const [show, setShow] = useState(true);\r\n\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {show \u0026\u0026 (\r\n        \u003cmotion.div\r\n          key=\"modal\"\r\n          initial={{ opacity: 0 }}\r\n          animate={{ opacity: 1 }}\r\n          exit={{ opacity: 0 }}\r\n        \u003e\r\n          Content\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Basic Usage**\r\n\r\n#### **Conditional Rendering Animation**\r\n```jsx\r\nimport { AnimatePresence, motion } from \"framer-motion\";\r\n\r\nfunction Modal({ isOpen, onClose }) {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {isOpen \u0026\u0026 (\r\n        \u003cmotion.div\r\n          key=\"modal\"\r\n          initial={{ opacity: 0, scale: 0.8 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          exit={{ opacity: 0, scale: 0.8 }}\r\n          className=\"modal-overlay\"\r\n        \u003e\r\n          \u003cmotion.div\r\n            initial={{ y: -50 }}\r\n            animate={{ y: 0 }}\r\n            exit={{ y: -50 }}\r\n            className=\"modal-content\"\r\n          \u003e\r\n            \u003ch2\u003eModal Title\u003c/h2\u003e\r\n            \u003cp\u003eModal content\u003c/p\u003e\r\n            \u003cbutton onClick={onClose}\u003eClose\u003c/button\u003e\r\n          \u003c/motion.div\u003e\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **List Animations**\r\n```jsx\r\nfunction TodoList() {\r\n  const [todos, setTodos] = useState([\r\n    { id: 1, text: \"Learn React\" },\r\n    { id: 2, text: \"Learn Framer Motion\" }\r\n  ]);\r\n\r\n  const removeTodo = (id) =\u003e {\r\n    setTodos(prev =\u003e prev.filter(todo =\u003e todo.id !== id));\r\n  };\r\n\r\n  return (\r\n    \u003cul\u003e\r\n      \u003cAnimatePresence\u003e\r\n        {todos.map(todo =\u003e (\r\n          \u003cmotion.li\r\n            key={todo.id} // Critical: Each child element must have a unique key\r\n            initial={{ opacity: 0, x: -100 }}\r\n            animate={{ opacity: 1, x: 0 }}\r\n            exit={{ opacity: 0, x: 100 }}\r\n            layout // Automatically handle layout animations\r\n          \u003e\r\n            {todo.text}\r\n            \u003cbutton onClick={() =\u003e removeTodo(todo.id)}\u003eDelete\u003c/button\u003e\r\n          \u003c/motion.li\u003e\r\n        ))}\r\n      \u003c/AnimatePresence\u003e\r\n    \u003c/ul\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Using Variants**\r\n```jsx\r\nconst modalVariants = {\r\n  hidden: { \r\n    opacity: 0, \r\n    scale: 0.8,\r\n    transition: { \r\n      when: \"afterChildren\" // Execute child animations first\r\n    }\r\n  },\r\n  visible: { \r\n    opacity: 1, \r\n    scale: 1,\r\n    transition: { \r\n      when: \"beforeChildren\", // Execute parent animation first\r\n      staggerChildren: 0.1 // Stagger child animations\r\n    }\r\n  }\r\n};\r\n\r\nconst itemVariants = {\r\n  hidden: { opacity: 0, y: 20 },\r\n  visible: { opacity: 1, y: 0 }\r\n};\r\n\r\nfunction AnimatedModal({ isOpen }) {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {isOpen \u0026\u0026 (\r\n        \u003cmotion.div\r\n          variants={modalVariants}\r\n          initial=\"hidden\"\r\n          animate=\"visible\"\r\n          exit=\"hidden\"\r\n          className=\"modal\"\r\n        \u003e\r\n          \u003cmotion.h2 variants={itemVariants}\u003eTitle\u003c/motion.h2\u003e\r\n          \u003cmotion.p variants={itemVariants}\u003eContent\u003c/motion.p\u003e\r\n          \u003cmotion.button variants={itemVariants}\u003eButton\u003c/motion.button\u003e\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Importance of the key Attribute**\r\n\r\n#### **Triggering Animations by Changing key**\r\n```jsx\r\nfunction Slideshow() {\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  const images = [\r\n    { id: 1, src: \"image1.jpg\", alt: \"Image 1\" },\r\n    { id: 2, src: \"image2.jpg\", alt: \"Image 2\" },\r\n    { id: 3, src: \"image3.jpg\", alt: \"Image 3\" }\r\n  ];\r\n\r\n  const currentImage = images[currentIndex];\r\n\r\n  return (\r\n    \u003cdiv className=\"slideshow\"\u003e\r\n      \u003cAnimatePresence mode=\"wait\"\u003e\r\n        \u003cmotion.img\r\n          key={currentImage.id} // Changing key triggers component remounting\r\n          src={currentImage.src}\r\n          alt={currentImage.alt}\r\n          initial={{ x: 300, opacity: 0 }}\r\n          animate={{ x: 0, opacity: 1 }}\r\n          exit={{ x: -300, opacity: 0 }}\r\n          transition={{ duration: 0.5 }}\r\n        /\u003e\r\n      \u003c/AnimatePresence\u003e\r\n      \r\n      \u003cbutton onClick={() =\u003e setCurrentIndex(prev =\u003e (prev + 1) % images.length)}\u003e\r\n        Next\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **mode Attribute Explained**\r\n\r\n#### **sync Mode (Default)**\r\n```jsx\r\n// Components enter and exit simultaneously\r\n\u003cAnimatePresence mode=\"sync\"\u003e\r\n  {show \u0026\u0026 \u003cComponent key=\"item\" /\u003e}\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n#### **wait Mode**\r\n```jsx\r\n// Wait for exit animation to complete before starting enter animation\r\n\u003cAnimatePresence mode=\"wait\"\u003e\r\n  \u003cComponent key={activeTab} /\u003e\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n#### **popLayout Mode**\r\n```jsx\r\n// Exiting elements \"pop out\" of layout, other elements adjust position immediately\r\n\u003cAnimatePresence mode=\"popLayout\"\u003e\r\n  {items.map(item =\u003e (\r\n    \u003cmotion.div key={item.id} layout\u003e\r\n      {item.content}\r\n    \u003c/motion.div\u003e\r\n  ))}\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n\r\n### **Advanced Features**\r\n\r\n#### **Accessing Component Presence State**\r\n```jsx\r\nimport { useIsPresent } from \"framer-motion\";\r\n\r\nfunction Component() {\r\n  const isPresent = useIsPresent();\r\n\r\n  return (\r\n    \u003cmotion.div\r\n      style={{ \r\n        backgroundColor: isPresent ? \"green\" : \"red\" \r\n      }}\r\n    \u003e\r\n      {isPresent ? \"Component exists\" : \"Component exiting\"}\r\n    \u003c/motion.div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Passing Custom Data**\r\n```jsx\r\nfunction Slideshow() {\r\n  const [direction, setDirection] = useState(1); // 1: forward, -1: backward\r\n\r\n  const slideVariants = {\r\n    enter: (direction) =\u003e ({\r\n      x: direction \u003e 0 ? 1000 : -1000,\r\n      opacity: 0\r\n    }),\r\n    center: {\r\n      zIndex: 1,\r\n      x: 0,\r\n      opacity: 1\r\n    },\r\n    exit: (direction) =\u003e ({\r\n      zIndex: 0,\r\n      x: direction \u003c 0 ? 1000 : -1000,\r\n      opacity: 0\r\n    })\r\n  };\r\n\r\n  return (\r\n    \u003cAnimatePresence custom={direction}\u003e\r\n      \u003cmotion.div\r\n        key={currentSlide}\r\n        custom={direction}\r\n        variants={slideVariants}\r\n        initial=\"enter\"\r\n        animate=\"center\"\r\n        exit=\"exit\"\r\n        transition={{ duration: 0.5 }}\r\n      \u003e\r\n        Slide content\r\n      \u003c/motion.div\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Manual Removal Control**\r\n```jsx\r\nimport { usePresence } from \"framer-motion\";\r\n\r\nfunction Component() {\r\n  const [isPresent, safeToRemove] = usePresence();\r\n\r\n  useEffect(() =\u003e {\r\n    if (!isPresent) {\r\n      // Execute custom cleanup logic\r\n      setTimeout(() =\u003e {\r\n        console.log(\"Executing cleanup\");\r\n        safeToRemove(); // Tell AnimatePresence it's safe to remove component\r\n      }, 1000);\r\n    }\r\n  }, [isPresent, safeToRemove]);\r\n\r\n  return \u003cdiv\u003eComponent with custom exit logic\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Real-World Application Scenarios**\r\n\r\n#### **Route Transition Animation**\r\n```jsx\r\nimport { useLocation } from \"react-router-dom\";\r\n\r\nfunction AnimatedRoutes() {\r\n  const location = useLocation();\r\n\r\n  return (\r\n    \u003cAnimatePresence mode=\"wait\"\u003e\r\n      \u003cmotion.div\r\n        key={location.pathname}\r\n        initial={{ opacity: 0, x: 100 }}\r\n        animate={{ opacity: 1, x: 0 }}\r\n        exit={{ opacity: 0, x: -100 }}\r\n        transition={{ duration: 0.3 }}\r\n      \u003e\r\n        \u003cRoutes location={location}\u003e\r\n          \u003cRoute path=\"/\" component={Home} /\u003e\r\n          \u003cRoute path=\"/about\" component={About} /\u003e\r\n          \u003cRoute path=\"/contact\" component={Contact} /\u003e\r\n        \u003c/Routes\u003e\r\n      \u003c/motion.div\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Notification System**\r\n```jsx\r\nfunction NotificationCenter() {\r\n  const [notifications, setNotifications] = useState([]);\r\n\r\n  const removeNotification = (id) =\u003e {\r\n    setNotifications(prev =\u003e prev.filter(n =\u003e n.id !== id));\r\n  };\r\n\r\n  return (\r\n    \u003cdiv className=\"notification-center\"\u003e\r\n      \u003cAnimatePresence\u003e\r\n        {notifications.map(notification =\u003e (\r\n          \u003cmotion.div\r\n            key={notification.id}\r\n            initial={{ opacity: 0, y: -50, scale: 0.3 }}\r\n            animate={{ opacity: 1, y: 0, scale: 1 }}\r\n            exit={{ \r\n              opacity: 0, \r\n              scale: 0.5, \r\n              transition: { duration: 0.2 } \r\n            }}\r\n            layout\r\n            className=\"notification\"\r\n          \u003e\r\n            \u003cp\u003e{notification.message}\u003c/p\u003e\r\n            \u003cbutton onClick={() =\u003e removeNotification(notification.id)}\u003e\r\n              ×\r\n            \u003c/button\u003e\r\n          \u003c/motion.div\u003e\r\n        ))}\r\n      \u003c/AnimatePresence\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Search Results Animation**\r\n```jsx\r\nfunction SearchResults({ results, query }) {\r\n  return (\r\n    \u003cdiv className=\"search-results\"\u003e\r\n      \u003cAnimatePresence\u003e\r\n        {results.map((result, index) =\u003e (\r\n          \u003cmotion.div\r\n            key={result.id}\r\n            initial={{ opacity: 0, y: 20 }}\r\n            animate={{ opacity: 1, y: 0 }}\r\n            exit={{ opacity: 0, y: -20 }}\r\n            transition={{ delay: index * 0.05 }}\r\n            layout\r\n            className=\"search-result-item\"\r\n          \u003e\r\n            \u003ch3\u003e{result.title}\u003c/h3\u003e\r\n            \u003cp\u003e{result.description}\u003c/p\u003e\r\n          \u003c/motion.div\u003e\r\n        ))}\r\n      \u003c/AnimatePresence\u003e\r\n      \r\n      {results.length === 0 \u0026\u0026 query \u0026\u0026 (\r\n        \u003cmotion.div\r\n          initial={{ opacity: 0 }}\r\n          animate={{ opacity: 1 }}\r\n          className=\"no-results\"\r\n        \u003e\r\n          No relevant results found\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Performance Optimization**\r\n\r\n#### **Avoiding Unnecessary Re-renders**\r\n```jsx\r\n// Problem: Creating new variants object on every render\r\nfunction BadComponent() {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      \u003cmotion.div\r\n        variants={{\r\n          initial: { opacity: 0 },\r\n          animate: { opacity: 1 },\r\n          exit: { opacity: 0 }\r\n        }}\r\n      /\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n\r\n// Solution: Extract variants outside the component\r\nconst variants = {\r\n  initial: { opacity: 0 },\r\n  animate: { opacity: 1 },\r\n  exit: { opacity: 0 }\r\n};\r\n\r\nfunction GoodComponent() {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      \u003cmotion.div variants={variants} /\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Optimizing List Animations with layout Attribute**\r\n```jsx\r\nfunction OptimizedList({ items }) {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {items.map(item =\u003e (\r\n        \u003cmotion.div\r\n          key={item.id}\r\n          layout // Automatically handle position change animations\r\n          initial={{ opacity: 0, scale: 0.8 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          exit={{ opacity: 0, scale: 0.8 }}\r\n          transition={{ \r\n            layout: { duration: 0.3 }, // Layout animation configuration\r\n            opacity: { duration: 0.2 }  // Opacity animation configuration\r\n          }}\r\n        \u003e\r\n          {item.content}\r\n        \u003c/motion.div\u003e\r\n      ))}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n\r\n1. **Always provide unique keys for direct child components**\r\n   ```jsx\r\n   // ✅ Correct\r\n   \u003cAnimatePresence\u003e\r\n     {items.map(item =\u003e (\r\n       \u003cmotion.div key={item.id}\u003e\r\n         {item.content}\r\n       \u003c/motion.div\u003e\r\n     ))}\r\n   \u003c/AnimatePresence\u003e\r\n\r\n   // ❌ Wrong: Using index as key\r\n   \u003cAnimatePresence\u003e\r\n     {items.map((item, index) =\u003e (\r\n       \u003cmotion.div key={index}\u003e\r\n         {item.content}\r\n       \u003c/motion.div\u003e\r\n     ))}\r\n   \u003c/AnimatePresence\u003e\r\n   ```\r\n\r\n2. **Ensure AnimatePresence is outside conditional rendering**\r\n   ```jsx\r\n   // ✅ Correct\r\n   \u003cAnimatePresence\u003e\r\n     {isVisible \u0026\u0026 \u003cComponent /\u003e}\r\n   \u003c/AnimatePresence\u003e\r\n\r\n   // ❌ Wrong: AnimatePresence is conditionally rendered\r\n   {isVisible \u0026\u0026 (\r\n     \u003cAnimatePresence\u003e\r\n       \u003cComponent /\u003e\r\n     \u003c/AnimatePresence\u003e\r\n   )}\r\n   ```\r\n\r\n3. **Use mode attribute appropriately**\r\n   - `sync`: Suitable for most scenarios\r\n   - `wait`: Suitable for page transitions, single element replacement\r\n   - `popLayout`: Suitable for layout adjustments when list items are deleted\r\n\r\n4. **Performance considerations**\r\n   - Extract variants objects outside components\r\n   - Use `layout` attribute to handle position changes\r\n   - Avoid complex calculations during animations\r\n\r\n\r\n### **Common Issues and Solutions**\r\n\r\n#### **Exit animations not working**\r\n```jsx\r\n// Problem: Non-unique key or missing key\r\n\u003cAnimatePresence\u003e\r\n  {show \u0026\u0026 \u003cmotion.div\u003eContent\u003c/motion.div\u003e} {/* Missing key */}\r\n\u003c/AnimatePresence\u003e\r\n\r\n// Solution: Add unique key\r\n\u003cAnimatePresence\u003e\r\n  {show \u0026\u0026 \u003cmotion.div key=\"unique-id\"\u003eContent\u003c/motion.div\u003e}\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n#### **Layout animation conflicts with popLayout**\r\n```jsx\r\n// Solution: Set relative positioning for parent container\r\n\u003cmotion.ul style={{ position: \"relative\" }} layout\u003e\r\n  \u003cAnimatePresence mode=\"popLayout\"\u003e\r\n    {items.map(item =\u003e (\r\n      \u003cmotion.li key={item.id} layout /\u003e\r\n    ))}\r\n  \u003c/AnimatePresence\u003e\r\n\u003c/motion.ul\u003e\r\n```\r\n\r\n#### **Using with LayoutGroup**\r\n```jsx\r\nimport { LayoutGroup } from \"framer-motion\";\r\n\r\n\u003cLayoutGroup\u003e\r\n  \u003cmotion.ul layout\u003e\r\n    \u003cAnimatePresence\u003e\r\n      {items.map(item =\u003e (\r\n        \u003cmotion.li key={item.id} layout /\u003e\r\n      ))}\r\n    \u003c/AnimatePresence\u003e\r\n  \u003c/motion.ul\u003e\r\n\u003c/LayoutGroup\u003e\r\n```\r\n\r\n\r\n### **Complete Example**\r\n```jsx\r\nimport React, { useState } from 'react';\r\nimport { AnimatePresence, motion } from 'framer-motion';\r\n\r\nconst cardVariants = {\r\n  initial: { \r\n    opacity: 0, \r\n    scale: 0.8, \r\n    rotate: -10 \r\n  },\r\n  animate: { \r\n    opacity: 1, \r\n    scale: 1, \r\n    rotate: 0,\r\n    transition: {\r\n      duration: 0.3,\r\n      ease: \"easeOut\"\r\n    }\r\n  },\r\n  exit: { \r\n    opacity: 0, \r\n    scale: 0.8, \r\n    rotate: 10,\r\n    transition: {\r\n      duration: 0.2,\r\n      ease: \"easeIn\"\r\n    }\r\n  }\r\n};\r\n\r\nfunction CardManager() {\r\n  const [cards, setCards] = useState([\r\n    { id: 1, title: \"Card 1\", content: \"This is the first card\" },\r\n    { id: 2, title: \"Card 2\", content: \"This is the second card\" },\r\n    { id: 3, title: \"Card 3\", content: \"This is the third card\" }\r\n  ]);\r\n\r\n  const addCard = () =\u003e {\r\n    const newCard = {\r\n      id: Date.now(),\r\n      title: `Card ${cards.length + 1}`,\r\n      content: `This is the ${cards.length + 1}th card`\r\n    };\r\n    setCards(prev =\u003e [...prev, newCard]);\r\n  };\r\n\r\n  const removeCard = (id) =\u003e {\r\n    setCards(prev =\u003e prev.filter(card =\u003e card.id !== id));\r\n  };\r\n\r\n  return (\r\n    \u003cdiv className=\"card-manager\"\u003e\r\n      \u003cbutton onClick={addCard} className=\"add-button\"\u003e\r\n        Add Card\r\n      \u003c/button\u003e\r\n      \r\n      \u003cdiv className=\"cards-container\"\u003e\r\n        \u003cAnimatePresence\u003e\r\n          {cards.map(card =\u003e (\r\n            \u003cmotion.div\r\n              key={card.id}\r\n              variants={cardVariants}\r\n              initial=\"initial\"\r\n              animate=\"animate\"\r\n              exit=\"exit\"\r\n              layout\r\n              className=\"card\"\r\n            \u003e\r\n              \u003ch3\u003e{card.title}\u003c/h3\u003e\r\n              \u003cp\u003e{card.content}\u003c/p\u003e\r\n              \u003cbutton \r\n                onClick={() =\u003e removeCard(card.id)}\r\n                className=\"remove-button\"\r\n              \u003e\r\n                Delete\r\n              \u003c/button\u003e\r\n            \u003c/motion.div\u003e\r\n          ))}\r\n        \u003c/AnimatePresence\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nexport default CardManager;\r\n```\r\n\r\n\r\n### **Important Notes**\r\n\r\n- **Importance of keys**: Direct child components must have unique and stable keys\r\n- **Component hierarchy**: AnimatePresence only detects changes in direct child components\r\n- **Performance impact**: Complex exit animations may affect performance, especially on mobile devices\r\n- **Browser compatibility**: Requires modern browser support, older browsers may need polyfills\r\n- **Memory management**: Ensure proper cleanup of components and event listeners after animations complete\r\n\r\n`AnimatePresence` is a powerful tool for creating smooth user interfaces. When used properly, it can greatly enhance the interactive experience and visual effects of applications.\r\n"])</script><script>self.__next_f.push([1,"14:T4276,"])</script><script>self.__next_f.push([1,"\n`React.createContext` is the core function of React's Context API, used to create a Context object that solves the problem of cross-level data passing between components, avoiding \"props drilling.\"\n\n\n### **Basic Purpose**\nContext provides a way to share data throughout the component tree without manually passing props through every level:\n\n- **Solve props drilling problem**: Avoid passing props through multiple nested component levels\n- **Global state management**: Share global data like themes, user information, language settings throughout the component tree\n- **Cross-component communication**: Allow components at any level to access shared data\n\n```jsx\nimport React, { createContext } from 'react';\n\n// Create Context\nconst ThemeContext = createContext();\n```\n\n\n### **Basic Syntax**\n```jsx\nconst MyContext = createContext(defaultValue);\n```\n\n- **defaultValue**: The default value used when there's no matching Provider in the component tree\n\n\n### **Complete Usage Flow**\n\n#### **1. Create Context and Custom Hook**\n```jsx\nimport React, { createContext, useContext, useState, useMemo } from 'react';\n\n// Create theme Context (keep private, don't export)\nconst ThemeContext = createContext();\n\n// Custom Hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  \n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  \n  return context;\n}\n```\n\n#### **2. Create Provider Component**\n```jsx\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () =\u003e {\n    setTheme(prev =\u003e prev === 'light' ? 'dark' : 'light');\n  };\n\n  // Use useMemo for performance optimization\n  const value = useMemo(() =\u003e ({\n    theme,\n    toggleTheme\n  }), [theme]);\n\n  return (\n    \u003cThemeContext.Provider value={value}\u003e\n      {children}\n    \u003c/ThemeContext.Provider\u003e\n  );\n}\n```\n\n#### **3. Use Custom Hook to Access Data**\n```jsx\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    \u003cheader style={{ \n      background: theme === 'light' ? '#fff' : '#333',\n      color: theme === 'light' ? '#333' : '#fff'\n    }}\u003e\n      \u003ch1\u003eMy App\u003c/h1\u003e\n      \u003cbutton onClick={toggleTheme}\u003e\n        Switch to {theme === 'light' ? 'dark' : 'light'} theme\n      \u003c/button\u003e\n    \u003c/header\u003e\n  );\n}\n```\n\n#### **4. Complete Application Example**\n```jsx\nfunction App() {\n  return (\n    \u003cThemeProvider\u003e\n      \u003cdiv\u003e\n        \u003cHeader /\u003e\n        \u003cContent /\u003e\n      \u003c/div\u003e\n    \u003c/ThemeProvider\u003e\n  );\n}\n\nfunction Content() {\n  const { theme } = useTheme();\n  \n  return (\n    \u003cmain style={{\n      background: theme === 'light' ? '#f5f5f5' : '#222',\n      color: theme === 'light' ? '#333' : '#fff',\n      padding: '20px'\n    }}\u003e\n      \u003cp\u003eThis is the main content area\u003c/p\u003e\n      \u003cSidebar /\u003e\n    \u003c/main\u003e\n  );\n}\n\nfunction Sidebar() {\n  const { theme } = useTheme();\n  \n  return (\n    \u003caside style={{\n      background: theme === 'light' ? '#e0e0e0' : '#444',\n      padding: '10px'\n    }}\u003e\n      \u003cp\u003eSidebar content\u003c/p\u003e\n    \u003c/aside\u003e\n  );\n}\n```\n\n\n### **Using Multiple Contexts**\n```jsx\n// User info Context\nconst UserContext = createContext();\n\n// Language Context  \nconst LanguageContext = createContext();\n\n// Combine multiple Providers\nfunction AppProviders({ children }) {\n  const [user, setUser] = useState(null);\n  const [language, setLanguage] = useState('en');\n\n  return (\n    \u003cUserContext.Provider value={{ user, setUser }}\u003e\n      \u003cLanguageContext.Provider value={{ language, setLanguage }}\u003e\n        \u003cThemeContext.Provider value={{ theme: 'light' }}\u003e\n          {children}\n        \u003c/ThemeContext.Provider\u003e\n      \u003c/LanguageContext.Provider\u003e\n    \u003c/UserContext.Provider\u003e\n  );\n}\n\n// Using multiple Contexts\nfunction UserProfile() {\n  const { user } = useContext(UserContext);\n  const { language } = useContext(LanguageContext);\n  const { theme } = useTheme(); // ThemeContext already has custom Hook\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eUser: {user?.name}\u003c/p\u003e\n      \u003cp\u003eLanguage: {language}\u003c/p\u003e\n      \u003cp\u003eTheme: {theme}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **Create Custom Hooks for Other Contexts**\n```jsx\n// Create custom Hook for user Context\nfunction useUser() {\n  const context = useContext(UserContext);\n  \n  if (!context) {\n    throw new Error('useUser must be used within UserProvider');\n  }\n  \n  return context;\n}\n\n// Create custom Hook for language Context\nfunction useLanguage() {\n  const context = useContext(LanguageContext);\n  \n  if (!context) {\n    throw new Error('useLanguage must be used within LanguageProvider');\n  }\n  \n  return context;\n}\n\n// Using multiple custom Hooks\nfunction MyComponent() {\n  const { theme, toggleTheme } = useTheme();\n  const { user, setUser } = useUser();\n  const { language, setLanguage } = useLanguage();\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCurrent theme: {theme}\u003c/p\u003e\n      \u003cp\u003eCurrent user: {user?.name || 'Not logged in'}\u003c/p\u003e\n      \u003cp\u003eCurrent language: {language}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **Complex State Management Example**\n```jsx\n// Shopping cart Context\nconst CartContext = createContext();\n\nfunction CartProvider({ children }) {\n  const [items, setItems] = useState([]);\n\n  const addItem = (product) =\u003e {\n    setItems(prev =\u003e {\n      const existingItem = prev.find(item =\u003e item.id === product.id);\n      if (existingItem) {\n        return prev.map(item =\u003e\n          item.id === product.id\n            ? { ...item, quantity: item.quantity + 1 }\n            : item\n        );\n      }\n      return [...prev, { ...product, quantity: 1 }];\n    });\n  };\n\n  const removeItem = (productId) =\u003e {\n    setItems(prev =\u003e prev.filter(item =\u003e item.id !== productId));\n  };\n\n  const updateQuantity = (productId, quantity) =\u003e {\n    if (quantity \u003c= 0) {\n      removeItem(productId);\n      return;\n    }\n    \n    setItems(prev =\u003e\n      prev.map(item =\u003e\n        item.id === productId\n          ? { ...item, quantity }\n          : item\n      )\n    );\n  };\n\n  const getTotalPrice = () =\u003e {\n    return items.reduce((total, item) =\u003e total + item.price * item.quantity, 0);\n  };\n\n  const getTotalItems = () =\u003e {\n    return items.reduce((total, item) =\u003e total + item.quantity, 0);\n  };\n\n  const clearCart = () =\u003e {\n    setItems([]);\n  };\n\n  const value = {\n    items,\n    addItem,\n    removeItem,\n    updateQuantity,\n    getTotalPrice,\n    getTotalItems,\n    clearCart\n  };\n\n  return (\n    \u003cCartContext.Provider value={value}\u003e\n      {children}\n    \u003c/CartContext.Provider\u003e\n  );\n}\n\n// Shopping cart Hook\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCart must be used within CartProvider');\n  }\n  return context;\n}\n\n// Product component\nfunction ProductCard({ product }) {\n  const { addItem } = useCart();\n\n  return (\n    \u003cdiv className=\"product-card\"\u003e\n      \u003ch3\u003e{product.name}\u003c/h3\u003e\n      \u003cp\u003ePrice: ${product.price}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e addItem(product)}\u003e\n        Add to Cart\n      \u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\n// Cart component\nfunction Cart() {\n  const { items, updateQuantity, removeItem, getTotalPrice, clearCart } = useCart();\n\n  return (\n    \u003cdiv className=\"cart\"\u003e\n      \u003ch2\u003eShopping Cart\u003c/h2\u003e\n      {items.length === 0 ? (\n        \u003cp\u003eCart is empty\u003c/p\u003e\n      ) : (\n        \u003c\u003e\n          {items.map(item =\u003e (\n            \u003cdiv key={item.id} className=\"cart-item\"\u003e\n              \u003cspan\u003e{item.name}\u003c/span\u003e\n              \u003cspan\u003e${item.price}\u003c/span\u003e\n              \u003cinput\n                type=\"number\"\n                value={item.quantity}\n                onChange={(e) =\u003e updateQuantity(item.id, parseInt(e.target.value))}\n                min=\"1\"\n              /\u003e\n              \u003cbutton onClick={() =\u003e removeItem(item.id)}\u003eRemove\u003c/button\u003e\n            \u003c/div\u003e\n          ))}\n          \u003cdiv className=\"cart-total\"\u003e\n            \u003cp\u003eTotal: ${getTotalPrice()}\u003c/p\u003e\n            \u003cbutton onClick={clearCart}\u003eClear Cart\u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **Using with useReducer**\n```jsx\nimport React, { createContext, useContext, useReducer } from 'react';\n\n// Define actions\nconst ACTIONS = {\n  SET_LOADING: 'SET_LOADING',\n  SET_USER: 'SET_USER',\n  SET_ERROR: 'SET_ERROR',\n  LOGOUT: 'LOGOUT'\n};\n\n// Define reducer\nfunction authReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.SET_LOADING:\n      return { ...state, loading: action.payload };\n    case ACTIONS.SET_USER:\n      return { ...state, user: action.payload, loading: false, error: null };\n    case ACTIONS.SET_ERROR:\n      return { ...state, error: action.payload, loading: false };\n    case ACTIONS.LOGOUT:\n      return { user: null, loading: false, error: null };\n    default:\n      return state;\n  }\n}\n\n// Initial state\nconst initialState = {\n  user: null,\n  loading: false,\n  error: null\n};\n\n// Create Context\nconst AuthContext = createContext();\n\n// AuthProvider component\nfunction AuthProvider({ children }) {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  const login = async (email, password) =\u003e {\n    dispatch({ type: ACTIONS.SET_LOADING, payload: true });\n    \n    try {\n      // Simulate API call\n      const response = await fetch('/api/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email, password })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Login failed');\n      }\n      \n      const user = await response.json();\n      dispatch({ type: ACTIONS.SET_USER, payload: user });\n    } catch (error) {\n      dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\n    }\n  };\n\n  const logout = () =\u003e {\n    dispatch({ type: ACTIONS.LOGOUT });\n  };\n\n  const value = {\n    ...state,\n    login,\n    logout\n  };\n\n  return (\n    \u003cAuthContext.Provider value={value}\u003e\n      {children}\n    \u003c/AuthContext.Provider\u003e\n  );\n}\n\n// Custom Hook\nfunction useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within AuthProvider');\n  }\n  return context;\n}\n\n// Login component\nfunction LoginForm() {\n  const { login, loading, error } = useAuth();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleSubmit = (e) =\u003e {\n    e.preventDefault();\n    login(email, password);\n  };\n\n  return (\n    \u003cform onSubmit={handleSubmit}\u003e\n      \u003cdiv\u003e\n        \u003cinput\n          type=\"email\"\n          placeholder=\"Email\"\n          value={email}\n          onChange={(e) =\u003e setEmail(e.target.value)}\n        /\u003e\n      \u003c/div\u003e\n      \u003cdiv\u003e\n        \u003cinput\n          type=\"password\"\n          placeholder=\"Password\"\n          value={password}\n          onChange={(e) =\u003e setPassword(e.target.value)}\n        /\u003e\n      \u003c/div\u003e\n      {error \u0026\u0026 \u003cp style={{ color: 'red' }}\u003e{error}\u003c/p\u003e}\n      \u003cbutton type=\"submit\" disabled={loading}\u003e\n        {loading ? 'Logging in...' : 'Login'}\n      \u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n\n### **Performance Optimization**\n\n#### **Avoid Unnecessary Re-renders**\n```jsx\n// Problem: value object is recreated every time\nfunction BadProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  return (\n    \u003cUserContext.Provider value={{ user, setUser }}\u003e\n      {children}\n    \u003c/UserContext.Provider\u003e\n  );\n}\n\n// Solution: Use useMemo to cache value\nfunction GoodProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  const value = useMemo(() =\u003e ({\n    user,\n    setUser\n  }), [user]);\n  \n  return (\n    \u003cUserContext.Provider value={value}\u003e\n      {children}\n    \u003c/UserContext.Provider\u003e\n  );\n}\n```\n\n#### **Split Context**\n```jsx\n// Split frequently changing and infrequently changing data\nconst UserDataContext = createContext(); // User info (changes infrequently)\nconst UserActionsContext = createContext(); // User actions (never changes)\n\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  // Action functions don't change\n  const actions = useMemo(() =\u003e ({\n    login: (userData) =\u003e setUser(userData),\n    logout: () =\u003e setUser(null),\n    updateProfile: (updates) =\u003e setUser(prev =\u003e ({ ...prev, ...updates }))\n  }), []);\n\n  return (\n    \u003cUserActionsContext.Provider value={actions}\u003e\n      \u003cUserDataContext.Provider value={user}\u003e\n        {children}\n      \u003c/UserDataContext.Provider\u003e\n    \u003c/UserActionsContext.Provider\u003e\n  );\n}\n\n// Separately access data and actions\nfunction useUserData() {\n  return useContext(UserDataContext);\n}\n\nfunction useUserActions() {\n  return useContext(UserActionsContext);\n}\n```\n\n\n### **Usage in Class Components**\n\n#### **Consumer Component**\n```jsx\n// Note: Consumer still needs to directly use Context\n// Because class components can't use Hooks, need to export Context\nexport const ThemeContext = createContext(); // Need to export for Consumer\n\nfunction MyClassComponent() {\n  return (\n    \u003cThemeContext.Consumer\u003e\n      {({ theme, toggleTheme }) =\u003e (\n        \u003cdiv style={{ background: theme === 'light' ? '#fff' : '#333' }}\u003e\n          \u003cbutton onClick={toggleTheme}\u003eToggle Theme\u003c/button\u003e\n        \u003c/div\u003e\n      )}\n    \u003c/ThemeContext.Consumer\u003e\n  );\n}\n```\n\n#### **contextType**\n```jsx\nclass MyClassComponent extends React.Component {\n  static contextType = ThemeContext; // Need to directly reference Context\n\n  render() {\n    const { theme, toggleTheme } = this.context;\n    \n    return (\n      \u003cdiv style={{ background: theme === 'light' ? '#fff' : '#333' }}\u003e\n        \u003cbutton onClick={toggleTheme}\u003eToggle Theme\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\n// Recommended: Convert class component to function component, use custom Hook\nfunction MyFunctionComponent() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    \u003cdiv style={{ background: theme === 'light' ? '#fff' : '#333' }}\u003e\n      \u003cbutton onClick={toggleTheme}\u003eToggle Theme\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **Complete Custom Hook Best Practices Example**\n```jsx\n// contexts/ThemeContext.js\nimport React, { createContext, useContext, useState, useMemo } from 'react';\n\n// Context remains private\nconst ThemeContext = createContext();\n\n// Provider component\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () =\u003e {\n    setTheme(prev =\u003e prev === 'light' ? 'dark' : 'light');\n  };\n\n  // Performance optimization: cache Context value\n  const value = useMemo(() =\u003e ({\n    theme,\n    toggleTheme\n  }), [theme]);\n\n  return (\n    \u003cThemeContext.Provider value={value}\u003e\n      {children}\n    \u003c/ThemeContext.Provider\u003e\n  );\n}\n\n// Custom Hook (includes error checking)\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  \n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  \n  return context;\n}\n\n// Optional: provide types for TypeScript\nexport type Theme = 'light' | 'dark';\nexport interface ThemeContextType {\n  theme: Theme;\n  toggleTheme: () =\u003e void;\n}\n```\n\n```jsx\n// components/App.js\nimport React from 'react';\nimport { ThemeProvider } from '../contexts/ThemeContext';\nimport Header from './Header';\nimport Content from './Content';\n\nfunction App() {\n  return (\n    \u003cThemeProvider\u003e\n      \u003cHeader /\u003e\n      \u003cContent /\u003e\n    \u003c/ThemeProvider\u003e\n  );\n}\n\nexport default App;\n```\n\n```jsx\n// components/Header.js\nimport React from 'react';\nimport { useTheme } from '../contexts/ThemeContext';\n\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    \u003cheader style={{\n      background: theme === 'light' ? '#fff' : '#333',\n      color: theme === 'light' ? '#333' : '#fff'\n    }}\u003e\n      \u003ch1\u003eMy App\u003c/h1\u003e\n      \u003cbutton onClick={toggleTheme}\u003e\n        Toggle Theme\n      \u003c/button\u003e\n    \u003c/header\u003e\n  );\n}\n\nexport default Header;\n```\n\n\n### **Best Practices**\n\n1. **Use custom Hooks instead of directly using Context**\n   - Provides better encapsulation and error checking\n   - Keeps Context private, doesn't expose implementation details\n\n2. **Use Context appropriately**\n   - Only use when truly needing to pass data across multiple component levels\n   - Avoid putting all state into Context\n\n3. **Create dedicated Provider components**\n   - Encapsulate Context creation and state management logic\n   - Provide clear API\n\n4. **Performance optimization**\n   - Use useMemo to cache Context value\n   - Split frequently changing and infrequently changing data\n\n5. **Error handling**\n   - Check if Context exists in custom Hooks\n   - Provide meaningful error messages\n\n6. **File organization**\n   - Put each Context in a separate file\n   - Export Provider and custom Hook, not Context itself\n\n\n### **Important Considerations**\n\n- **Performance impact**: Context value changes will cause all consuming components to re-render\n- **Don't overuse**: Simple props passing might be more appropriate than Context\n- **Default value limitations**: defaultValue only takes effect when there's no Provider\n- **Nested Providers**: Multiple Providers of the same Context form nesting relationships\n- **Testing complexity**: Context may increase component testing complexity\n\n`React.createContext` is a powerful tool for managing cross-component state, but should be used in appropriate scenarios to avoid over-engineering that increases application complexity.\n"])</script><script>self.__next_f.push([1,"15:T14c2,"])</script><script>self.__next_f.push([1,"\r\n`React.memo` is a higher-order component provided by React for optimizing the performance of function components by preventing unnecessary re-renders.\r\n\r\n\r\n### **Basic Purpose**\r\n`React.memo` performs a **shallow comparison** of the component's **previous and current props**. If the props haven't changed, React will reuse the previous render result and skip the component re-render, thus improving performance.\r\n\r\n```jsx\r\nconst MyComponent = React.memo(function MyComponent(props) {\r\n  // Component logic\r\n});\r\n```\r\n\r\n\r\n### **Shallow Comparison**\r\nShallow comparison only checks if object or array references are the same, not their internal properties. For example:\r\n\r\n```jsx\r\n// Example 1: Props reference unchanged, won't re-render\r\n\u003cMyComponent data={someData} /\u003e // First render\r\n\u003cMyComponent data={someData} /\u003e // Second render, data reference is same, skip render\r\n\r\n// Example 2: Props reference changed, will re-render\r\n\u003cMyComponent data={[1, 2, 3]} /\u003e // First render\r\n\u003cMyComponent data={[1, 2, 3]} /\u003e // Second render, data is new array, trigger render\r\n```\r\n\r\n\r\n### **Custom Comparison Function**\r\nYou can pass a custom comparison function as the second parameter to control whether to skip rendering:\r\n\r\n```jsx\r\nconst MyComponent = React.memo(\r\n  function MyComponent(props) {\r\n    // Component logic\r\n  },\r\n  (prevProps, nextProps) =\u003e {\r\n    // Return true to skip render; return false to trigger render\r\n    return prevProps.someProp === nextProps.someProp;\r\n  }\r\n);\r\n```\r\n\r\n\r\n### **Difference from `shouldComponentUpdate`**\r\n- `React.memo` is for **function components** and only compares props.\r\n- `shouldComponentUpdate` is for **class components** and can compare both props and state.\r\n\r\n\r\n### **Difference from `useMemo`**\r\nAlthough both are used for performance optimization, `React.memo` and `useMemo` have completely different scopes and usage scenarios:\r\n\r\n| Feature | React.memo | useMemo |\r\n|---------|------------|---------|\r\n| **Purpose** | Optimize component rendering | Optimize calculation results |\r\n| **Target** | Entire component | Calculated values/objects |\r\n| **Comparison Content** | Props | Dependency array |\r\n| **Return Value** | Component | Calculation result |\r\n| **Usage Location** | Outside component definition | Inside component |\r\n\r\n```jsx\r\n// React.memo: Prevent component re-rendering\r\nconst ExpensiveComponent = React.memo(({ data }) =\u003e {\r\n  return \u003cdiv\u003e{data.map(item =\u003e \u003cspan key={item.id}\u003e{item.name}\u003c/span\u003e)}\u003c/div\u003e;\r\n});\r\n\r\nfunction ParentComponent() {\r\n  const [count, setCount] = useState(0);\r\n  const [items] = useState([{ id: 1, name: 'Item 1' }]);\r\n\r\n  // useMemo: Cache calculation results\r\n  const processedItems = useMemo(() =\u003e {\r\n    return items.map(item =\u003e ({ ...item, processed: true }));\r\n  }, [items]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eCount: {count}\u003c/button\u003e\r\n      {/* React.memo prevents unnecessary re-renders when count changes */}\r\n      \u003cExpensiveComponent data={processedItems} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n**Combined usage example**:\r\n```jsx\r\n// Using useMemo to provide stable prop references\r\nconst ParentComponent = () =\u003e {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  // useMemo ensures stable config object reference\r\n  const config = useMemo(() =\u003e ({\r\n    theme: 'dark',\r\n    pageSize: 10\r\n  }), []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eCount: {count}\u003c/button\u003e\r\n      {/* React.memo prevents unnecessary re-renders */}\r\n      \u003cMemoizedChild config={config} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\nconst MemoizedChild = React.memo(({ config }) =\u003e {\r\n  return \u003cdiv\u003eConfig theme: {config.theme}\u003c/div\u003e;\r\n});\r\n```\r\n\r\n\r\n### **Important Considerations**\r\n1. **Use only for pure components**: Ensure the component returns the same result for the same props.\r\n2. **Avoid inline functions/objects**:\r\n```jsx\r\n// Creates new onClick function every render, making memo ineffective\r\n\u003cMyComponent onClick={() =\u003e console.log('Click')} /\u003e\r\n\r\n// Better: Extract function outside component or use useCallback\r\nconst handleClick = useCallback(() =\u003e console.log('Click'), []);\r\n\u003cMyComponent onClick={handleClick} /\u003e\r\n   ```\r\n3. **Doesn't compare state changes**: `React.memo` only focuses on props, internal state changes will still trigger re-renders.\r\n\r\n\r\n### **Use Cases**\r\n- Components that render frequently but props change infrequently.\r\n- Large component trees where render performance optimization is needed.\r\n- Static display components (like list items, cards).\r\n\r\n\r\n### **Example Code**\r\nHere's a simple example using `React.memo`:\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\n// Component wrapped with React.memo\r\nconst UserCard = React.memo(({ name, age }) =\u003e {\r\n  console.log('UserCard rendering');\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003e{name}\u003c/h3\u003e\r\n      \u003cp\u003eAge: {age}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// Parent component\r\nfunction App() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e\r\n        Count: {count}\r\n      \u003c/button\u003e\r\n      {/* Even when count changes, UserCard won't re-render */}\r\n      \u003cUserCard name=\"John\" age={25} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\nIn this example, clicking the button updates `count`, but `UserCard` won't re-render because its props haven't changed.\r\n"])</script><script>self.__next_f.push([1,"16:T2d44,"])</script><script>self.__next_f.push([1,"\r\n`useCallback` is a performance optimization Hook provided by React, used to cache function definitions and prevent unnecessary re-renders of child components due to function reference changes. It returns a memoized callback function that only updates when dependencies change.\r\n\r\n\r\n### **Basic Purpose**\r\nThe main purposes of `useCallback` are:\r\n- Cache function definitions to avoid creating new function instances on every render\r\n- Work with `React.memo` to optimize child component performance\r\n- Return the same function reference when dependencies don't change\r\n\r\n```jsx\r\nimport React, { useCallback, useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  // Use useCallback to cache function\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log('Button clicked');\r\n  }, []); // Empty dependency array, function never updates\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={handleClick}\u003eClick\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Basic Syntax**\r\n```jsx\r\nconst memoizedCallback = useCallback(\r\n  () =\u003e {\r\n    // Function body\r\n    doSomething(a, b);\r\n  },\r\n  [a, b] // Dependency array\r\n);\r\n```\r\n\r\n- **First parameter**: The function to cache\r\n- **Second parameter**: Dependency array, function will be recreated when values in array change\r\n\r\n\r\n### **Comparison with Regular Functions**\r\n\r\n#### **Without useCallback (Problem Example)**\r\n```jsx\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n\r\n  // New function created on every render\r\n  const handleNameChange = (newName) =\u003e {\r\n    setName(newName);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n      {/* Even if name doesn't change, Child will re-render */}\r\n      \u003cChild onNameChange={handleNameChange} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst Child = React.memo(({ onNameChange }) =\u003e {\r\n  console.log('Child component re-rendered');\r\n  return \u003cbutton onClick={() =\u003e onNameChange('Jane')}\u003eChange Name\u003c/button\u003e;\r\n});\r\n```\r\n\r\n#### **With useCallback (Optimized)**\r\n```jsx\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('John');\r\n\r\n  // Use useCallback to cache function\r\n  const handleNameChange = useCallback((newName) =\u003e {\r\n    setName(newName);\r\n  }, []); // name update passed through parameter, no dependency needed\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n      {/* When count changes, Child won't re-render */}\r\n      \u003cChild onNameChange={handleNameChange} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Using Dependency Arrays**\r\n\r\n#### **Empty Dependency Array**\r\n```jsx\r\n// Function never gets recreated\r\nconst handleClick = useCallback(() =\u003e {\r\n  console.log('This function never changes');\r\n}, []);\r\n```\r\n\r\n#### **With Dependencies**\r\n```jsx\r\nfunction SearchComponent() {\r\n  const [query, setQuery] = useState('');\r\n  const [filter, setFilter] = useState('all');\r\n\r\n  // Function recreated when query or filter changes\r\n  const handleSearch = useCallback(() =\u003e {\r\n    console.log(`Search: ${query}, Filter: ${filter}`);\r\n  }, [query, filter]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput value={query} onChange={(e) =\u003e setQuery(e.target.value)} /\u003e\r\n      \u003cSearchButton onSearch={handleSearch} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Real-world Application Scenarios**\r\n\r\n#### **Optimizing List Rendering**\r\n```jsx\r\nfunction TodoList() {\r\n  const [todos, setTodos] = useState([]);\r\n\r\n  // Delete item function\r\n  const handleDelete = useCallback((id) =\u003e {\r\n    setTodos(prev =\u003e prev.filter(todo =\u003e todo.id !== id));\r\n  }, []); // Using functional update, no need to depend on todos\r\n\r\n  // Toggle completion status\r\n  const handleToggle = useCallback((id) =\u003e {\r\n    setTodos(prev =\u003e \r\n      prev.map(todo =\u003e \r\n        todo.id === id ? { ...todo, done: !todo.done } : todo\r\n      )\r\n    );\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {todos.map(todo =\u003e (\r\n        \u003cTodoItem\r\n          key={todo.id}\r\n          todo={todo}\r\n          onDelete={handleDelete}\r\n          onToggle={handleToggle}\r\n        /\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst TodoItem = React.memo(({ todo, onDelete, onToggle }) =\u003e {\r\n  console.log(`TodoItem ${todo.id} rendered`);\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cspan\u003e{todo.text}\u003c/span\u003e\r\n      \u003cbutton onClick={() =\u003e onToggle(todo.id)}\u003e\r\n        {todo.done ? 'Undo' : 'Done'}\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e onDelete(todo.id)}\u003eDelete\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n#### **Form Handling Optimization**\r\n```jsx\r\nfunction UserForm() {\r\n  const [formData, setFormData] = useState({\r\n    name: '',\r\n    email: '',\r\n    age: ''\r\n  });\r\n\r\n  // Generic field update function\r\n  const handleFieldChange = useCallback((field) =\u003e {\r\n    return (value) =\u003e {\r\n      setFormData(prev =\u003e ({\r\n        ...prev,\r\n        [field]: value\r\n      }));\r\n    };\r\n  }, []);\r\n\r\n  // Submit function\r\n  const handleSubmit = useCallback(() =\u003e {\r\n    console.log('Submit form:', formData);\r\n  }, [formData]);\r\n\r\n  return (\r\n    \u003cform\u003e\r\n      \u003cFormField\r\n        label=\"Name\"\r\n        value={formData.name}\r\n        onChange={handleFieldChange('name')}\r\n      /\u003e\r\n      \u003cFormField\r\n        label=\"Email\"\r\n        value={formData.email}\r\n        onChange={handleFieldChange('email')}\r\n      /\u003e\r\n      \u003cbutton type=\"button\" onClick={handleSubmit}\u003e\r\n        Submit\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n\r\nconst FormField = React.memo(({ label, value, onChange }) =\u003e {\r\n  console.log(`FormField ${label} rendered`);\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003clabel\u003e{label}\u003c/label\u003e\r\n      \u003cinput\r\n        value={value}\r\n        onChange={(e) =\u003e onChange(e.target.value)}\r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n\r\n### **Working with Other Hooks**\r\n\r\n#### **Difference between useMemo and useCallback**\r\n```jsx\r\nfunction MyComponent({ items }) {\r\n  // useMemo caches computed result\r\n  const expensiveValue = useMemo(() =\u003e {\r\n    return items.reduce((sum, item) =\u003e sum + item.value, 0);\r\n  }, [items]);\r\n\r\n  // useCallback caches function definition\r\n  const handleSort = useCallback(() =\u003e {\r\n    return items.sort((a, b) =\u003e a.value - b.value);\r\n  }, [items]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eTotal: {expensiveValue}\u003c/p\u003e\r\n      \u003cbutton onClick={handleSort}\u003eSort\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Combined with useEffect**\r\n```jsx\r\nfunction DataFetcher({ userId }) {\r\n  const [data, setData] = useState(null);\r\n\r\n  // Cache data fetching function\r\n  const fetchData = useCallback(async () =\u003e {\r\n    try {\r\n      const response = await fetch(`/api/users/${userId}`);\r\n      const userData = await response.json();\r\n      setData(userData);\r\n    } catch (error) {\r\n      console.error('Failed to fetch data:', error);\r\n    }\r\n  }, [userId]);\r\n\r\n  useEffect(() =\u003e {\r\n    fetchData();\r\n  }, [fetchData]); // fetchData as dependency\r\n\r\n  return \u003cdiv\u003e{data ? data.name : 'Loading...'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Common Pitfalls and Solutions**\r\n\r\n#### **Forgetting to Add Dependencies**\r\n```jsx\r\nfunction BadExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // Wrong: missing count dependency\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log(count); // This will always log the initial value 0\r\n  }, []); // Should be [count]\r\n\r\n  return \u003cbutton onClick={handleClick}\u003eClick\u003c/button\u003e;\r\n}\r\n\r\nfunction GoodExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // Correct: includes all dependencies\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log(count);\r\n  }, [count]);\r\n\r\n  return \u003cbutton onClick={handleClick}\u003eClick\u003c/button\u003e;\r\n}\r\n```\r\n\r\n#### **Avoiding Over-optimization**\r\n```jsx\r\n// Unnecessary optimization\r\nfunction OverOptimized() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // This component is simple, doesn't need useCallback\r\n  const handleClick = useCallback(() =\u003e {\r\n    setCount(prev =\u003e prev + 1);\r\n  }, []);\r\n\r\n  return \u003cbutton onClick={handleClick}\u003e{count}\u003c/button\u003e;\r\n}\r\n\r\n// Simple and direct approach\r\nfunction Simple() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    \u003cbutton onClick={() =\u003e setCount(prev =\u003e prev + 1)}\u003e\r\n      {count}\r\n    \u003c/button\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Performance Testing Example**\r\n```jsx\r\nimport React, { useCallback, useState, useRef } from 'react';\r\n\r\nfunction PerformanceTest() {\r\n  const [count, setCount] = useState(0);\r\n  const renderCountRef = useRef(0);\r\n\r\n  // Version with useCallback\r\n  const optimizedHandler = useCallback(() =\u003e {\r\n    console.log('Optimized version called');\r\n  }, []);\r\n\r\n  // Version without useCallback\r\n  const unoptimizedHandler = () =\u003e {\r\n    console.log('Unoptimized version called');\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eParent renders: {++renderCountRef.current}\u003c/p\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement Count\u003c/button\u003e\r\n      \r\n      \u003cOptimizedChild handler={optimizedHandler} /\u003e\r\n      \u003cUnoptimizedChild handler={unoptimizedHandler} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst OptimizedChild = React.memo(({ handler }) =\u003e {\r\n  const renderCount = useRef(0);\r\n  console.log('OptimizedChild renders:', ++renderCount.current);\r\n  \r\n  return \u003cbutton onClick={handler}\u003eOptimized Version\u003c/button\u003e;\r\n});\r\n\r\nconst UnoptimizedChild = React.memo(({ handler }) =\u003e {\r\n  const renderCount = useRef(0);\r\n  console.log('UnoptimizedChild renders:', ++renderCount.current);\r\n  \r\n  return \u003cbutton onClick={handler}\u003eUnoptimized Version\u003c/button\u003e;\r\n});\r\n```\r\n\r\n\r\n### **Usage in Custom Hooks**\r\n```jsx\r\nfunction useAPI(url) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const fetchData = useCallback(async () =\u003e {\r\n    setLoading(true);\r\n    try {\r\n      const response = await fetch(url);\r\n      const result = await response.json();\r\n      setData(result);\r\n    } catch (error) {\r\n      console.error('API call failed:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [url]);\r\n\r\n  const refresh = useCallback(() =\u003e {\r\n    fetchData();\r\n  }, [fetchData]);\r\n\r\n  useEffect(() =\u003e {\r\n    fetchData();\r\n  }, [fetchData]);\r\n\r\n  return { data, loading, refresh };\r\n}\r\n\r\n// Using custom Hook\r\nfunction UserProfile({ userId }) {\r\n  const { data, loading, refresh } = useAPI(`/api/users/${userId}`);\r\n\r\n  if (loading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch1\u003e{data?.name}\u003c/h1\u003e\r\n      \u003cbutton onClick={refresh}\u003eRefresh\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n1. **Work with React.memo**: The main value of useCallback is preventing unnecessary child component re-renders\r\n2. **Correct dependency setup**: Include all variables used in the callback function\r\n3. **Avoid over-optimization**: Not every function needs to be wrapped with useCallback\r\n4. **Use functional updates**: Reduce state dependencies to improve function stability\r\n5. **Consider alternatives**: Sometimes restructuring components is better than using useCallback\r\n\r\n\r\n### **Important Considerations**\r\n- **Memory overhead**: Caching functions consumes additional memory\r\n- **Dependency tracking**: Ensure ESLint rule `exhaustive-deps` is enabled\r\n- **Shallow comparison**: Dependency array uses shallow comparison, be careful with objects and arrays\r\n- **Debugging difficulty**: Overuse can make code harder to understand and debug\r\n\r\n`useCallback` is an important tool for React performance optimization, but should be used in appropriate scenarios to avoid over-optimization that increases code complexity.\r\n"])</script><script>self.__next_f.push([1,"17:T3479,"])</script><script>self.__next_f.push([1,"\r\n`useEffect` is one of React's most important Hooks, used to handle side effects. It combines the functionality of `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` from class components, enabling function components to perform data fetching, subscriptions setup, DOM operations, and other side effects.\r\n\r\n\r\n### **Basic Purpose**\r\nThe main purposes of `useEffect` are:\r\n- Execute side effects (data fetching, subscriptions, DOM operations, etc.)\r\n- Execute code after component renders\r\n- Handle component lifecycle events\r\n- Clean up resources to prevent memory leaks\r\n\r\n```jsx\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // Basic useEffect\r\n  useEffect(() =\u003e {\r\n    document.title = `Count: ${count}`;\r\n  });\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCurrent count: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Basic Syntax**\r\n```jsx\r\nuseEffect(() =\u003e {\r\n  // Side effect code\r\n  \r\n  return () =\u003e {\r\n    // Cleanup code (optional)\r\n  };\r\n}, [dependencies]); // Dependency array (optional)\r\n```\r\n\r\n- **First parameter**: Side effect function\r\n- **Second parameter**: Dependency array (optional)\r\n- **Return value**: Cleanup function (optional)\r\n\r\n\r\n### **Different Usage Patterns**\r\n\r\n#### **Execute After Every Render**\r\n```jsx\r\nfunction Component() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // No dependency array, executes after every render\r\n  useEffect(() =\u003e {\r\n    console.log('Component rendered');\r\n  });\r\n\r\n  return \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e{count}\u003c/button\u003e;\r\n}\r\n```\r\n\r\n#### **Execute Only on Mount**\r\n```jsx\r\nfunction Component() {\r\n  const [data, setData] = useState(null);\r\n\r\n  // Empty dependency array, executes only once on component mount\r\n  useEffect(() =\u003e {\r\n    console.log('Component mounted');\r\n    \r\n    // Fetch data\r\n    fetch('/api/data')\r\n      .then(response =\u003e response.json())\r\n      .then(data =\u003e setData(data));\r\n  }, []); // Empty dependency array\r\n\r\n  return \u003cdiv\u003e{data ? JSON.stringify(data) : 'Loading...'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **Execute When Specific Values Change**\r\n```jsx\r\nfunction Component({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n\r\n  // Executes when userId changes\r\n  useEffect(() =\u003e {\r\n    console.log('userId changed:', userId);\r\n    \r\n    fetch(`/api/users/${userId}`)\r\n      .then(response =\u003e response.json())\r\n      .then(userData =\u003e setUser(userData));\r\n  }, [userId]); // Depends on userId\r\n\r\n  return \u003cdiv\u003e{user ? user.name : 'Loading...'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Cleanup Side Effects**\r\n\r\n#### **Cleanup Timers**\r\n```jsx\r\nfunction Timer() {\r\n  const [seconds, setSeconds] = useState(0);\r\n\r\n  useEffect(() =\u003e {\r\n    const interval = setInterval(() =\u003e {\r\n      setSeconds(prev =\u003e prev + 1);\r\n    }, 1000);\r\n\r\n    // Cleanup function: clear timer when component unmounts\r\n    return () =\u003e {\r\n      clearInterval(interval);\r\n    };\r\n  }, []); // Empty dependency, set up only once\r\n\r\n  return \u003cdiv\u003eRunning for {seconds} seconds\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **Cleanup Event Listeners**\r\n```jsx\r\nfunction WindowSize() {\r\n  const [windowSize, setWindowSize] = useState({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight\r\n  });\r\n\r\n  useEffect(() =\u003e {\r\n    const handleResize = () =\u003e {\r\n      setWindowSize({\r\n        width: window.innerWidth,\r\n        height: window.innerHeight\r\n      });\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n\r\n    // Cleanup event listener\r\n    return () =\u003e {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, []);\r\n\r\n  return \u003cdiv\u003eWindow size: {windowSize.width} x {windowSize.height}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **Cancel Network Requests**\r\n```jsx\r\nfunction DataFetcher({ url }) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  useEffect(() =\u003e {\r\n    const abortController = new AbortController();\r\n\r\n    const fetchData = async () =\u003e {\r\n      try {\r\n        setLoading(true);\r\n        const response = await fetch(url, {\r\n          signal: abortController.signal\r\n        });\r\n        const result = await response.json();\r\n        setData(result);\r\n      } catch (error) {\r\n        if (error.name !== 'AbortError') {\r\n          console.error('Failed to fetch data:', error);\r\n        }\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n\r\n    // Cleanup: cancel request\r\n    return () =\u003e {\r\n      abortController.abort();\r\n    };\r\n  }, [url]);\r\n\r\n  if (loading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\r\n  return \u003cdiv\u003e{JSON.stringify(data)}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Common Application Scenarios**\r\n\r\n#### **Data Fetching**\r\n```jsx\r\nfunction UserList() {\r\n  const [users, setUsers] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() =\u003e {\r\n    const fetchUsers = async () =\u003e {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n        const response = await fetch('/api/users');\r\n        \r\n        if (!response.ok) {\r\n          throw new Error('Failed to fetch user list');\r\n        }\r\n        \r\n        const userData = await response.json();\r\n        setUsers(userData);\r\n      } catch (err) {\r\n        setError(err.message);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchUsers();\r\n  }, []);\r\n\r\n  if (loading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\r\n  if (error) return \u003cdiv\u003eError: {error}\u003c/div\u003e;\r\n\r\n  return (\r\n    \u003cul\u003e\r\n      {users.map(user =\u003e (\r\n        \u003cli key={user.id}\u003e{user.name}\u003c/li\u003e\r\n      ))}\r\n    \u003c/ul\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Subscribe to External Data Sources**\r\n```jsx\r\nfunction ChatRoom({ roomId }) {\r\n  const [messages, setMessages] = useState([]);\r\n\r\n  useEffect(() =\u003e {\r\n    const socket = new WebSocket(`ws://localhost:8080/chat/${roomId}`);\r\n\r\n    socket.onmessage = (event) =\u003e {\r\n      const message = JSON.parse(event.data);\r\n      setMessages(prev =\u003e [...prev, message]);\r\n    };\r\n\r\n    socket.onerror = (error) =\u003e {\r\n      console.error('WebSocket error:', error);\r\n    };\r\n\r\n    // Cleanup: close connection\r\n    return () =\u003e {\r\n      socket.close();\r\n    };\r\n  }, [roomId]); // Reconnect when roomId changes\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003eChat Room {roomId}\u003c/h3\u003e\r\n      {messages.map((msg, index) =\u003e (\r\n        \u003cp key={index}\u003e{msg.text}\u003c/p\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **DOM Operations**\r\n```jsx\r\nfunction FocusInput() {\r\n  const [inputValue, setInputValue] = useState('');\r\n  const inputRef = useRef(null);\r\n\r\n  // Focus input after component mounts\r\n  useEffect(() =\u003e {\r\n    if (inputRef.current) {\r\n      inputRef.current.focus();\r\n    }\r\n  }, []);\r\n\r\n  // Update document title when input value changes\r\n  useEffect(() =\u003e {\r\n    document.title = inputValue || 'Please enter content';\r\n  }, [inputValue]);\r\n\r\n  return (\r\n    \u003cinput\r\n      ref={inputRef}\r\n      value={inputValue}\r\n      onChange={(e) =\u003e setInputValue(e.target.value)}\r\n      placeholder=\"Enter content\"\r\n    /\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Using Multiple useEffects**\r\n```jsx\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  const [posts, setPosts] = useState([]);\r\n  const [onlineStatus, setOnlineStatus] = useState(false);\r\n\r\n  // Effect 1: Fetch user info\r\n  useEffect(() =\u003e {\r\n    fetch(`/api/users/${userId}`)\r\n      .then(response =\u003e response.json())\r\n      .then(userData =\u003e setUser(userData));\r\n  }, [userId]);\r\n\r\n  // Effect 2: Fetch user posts\r\n  useEffect(() =\u003e {\r\n    fetch(`/api/users/${userId}/posts`)\r\n      .then(response =\u003e response.json())\r\n      .then(postsData =\u003e setPosts(postsData));\r\n  }, [userId]);\r\n\r\n  // Effect 3: Subscribe to online status\r\n  useEffect(() =\u003e {\r\n    const subscription = subscribeToUserOnlineStatus(\r\n      userId,\r\n      setOnlineStatus\r\n    );\r\n\r\n    return () =\u003e {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [userId]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {user \u0026\u0026 (\r\n        \u003c\u003e\r\n          \u003ch1\u003e{user.name} {onlineStatus ? '🟢' : '🔴'}\u003c/h1\u003e\r\n          \u003cp\u003ePost count: {posts.length}\u003c/p\u003e\r\n        \u003c/\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Conditional Effect Execution**\r\n```jsx\r\nfunction ConditionalEffect({ shouldFetch, url }) {\r\n  const [data, setData] = useState(null);\r\n\r\n  useEffect(() =\u003e {\r\n    // Only execute when shouldFetch is true\r\n    if (!shouldFetch) return;\r\n\r\n    fetch(url)\r\n      .then(response =\u003e response.json())\r\n      .then(result =\u003e setData(result));\r\n  }, [shouldFetch, url]);\r\n\r\n  return \u003cdiv\u003e{data ? JSON.stringify(data) : 'No data'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **useEffect in Custom Hooks**\r\n```jsx\r\n// Custom Hook: fetch data\r\nfunction useApi(url) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() =\u003e {\r\n    let cancelled = false;\r\n\r\n    const fetchData = async () =\u003e {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n        const response = await fetch(url);\r\n        const result = await response.json();\r\n        \r\n        if (!cancelled) {\r\n          setData(result);\r\n        }\r\n      } catch (err) {\r\n        if (!cancelled) {\r\n          setError(err.message);\r\n        }\r\n      } finally {\r\n        if (!cancelled) {\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n\r\n    return () =\u003e {\r\n      cancelled = true;\r\n    };\r\n  }, [url]);\r\n\r\n  return { data, loading, error };\r\n}\r\n\r\n// Using custom Hook\r\nfunction UserComponent({ userId }) {\r\n  const { data: user, loading, error } = useApi(`/api/users/${userId}`);\r\n\r\n  if (loading) return \u003cdiv\u003eLoading...\u003c/div\u003e;\r\n  if (error) return \u003cdiv\u003eError: {error}\u003c/div\u003e;\r\n  if (!user) return \u003cdiv\u003eUser not found\u003c/div\u003e;\r\n\r\n  return \u003ch1\u003e{user.name}\u003c/h1\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Common Pitfalls and Solutions**\r\n\r\n#### **Infinite Loops**\r\n```jsx\r\n// Wrong: causes infinite loop\r\nfunction BadExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() =\u003e {\r\n    setCount(count + 1); // Increments count on every render\r\n  }); // No dependency array\r\n\r\n  return \u003cdiv\u003e{count}\u003c/div\u003e;\r\n}\r\n\r\n// Correct: add appropriate dependency array\r\nfunction GoodExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() =\u003e {\r\n    const timer = setTimeout(() =\u003e {\r\n      setCount(count + 1);\r\n    }, 1000);\r\n\r\n    return () =\u003e clearTimeout(timer);\r\n  }, [count]); // Depends on count\r\n\r\n  return \u003cdiv\u003e{count}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **Missing Dependencies**\r\n```jsx\r\nfunction SearchComponent() {\r\n  const [query, setQuery] = useState('');\r\n  const [results, setResults] = useState([]);\r\n\r\n  // Wrong: missing query dependency\r\n  useEffect(() =\u003e {\r\n    if (query) {\r\n      fetch(`/api/search?q=${query}`)\r\n        .then(response =\u003e response.json())\r\n        .then(data =\u003e setResults(data));\r\n    }\r\n  }, []); // Should include [query]\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        value={query} \r\n        onChange={(e) =\u003e setQuery(e.target.value)} \r\n      /\u003e\r\n      {/* results won't update */}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Performance Optimization Tips**\r\n\r\n#### **Debounced Search**\r\n```jsx\r\nfunction SearchWithDebounce() {\r\n  const [query, setQuery] = useState('');\r\n  const [results, setResults] = useState([]);\r\n\r\n  useEffect(() =\u003e {\r\n    if (!query) {\r\n      setResults([]);\r\n      return;\r\n    }\r\n\r\n    const timeoutId = setTimeout(() =\u003e {\r\n      fetch(`/api/search?q=${query}`)\r\n        .then(response =\u003e response.json())\r\n        .then(data =\u003e setResults(data));\r\n    }, 500); // 500ms debounce\r\n\r\n    return () =\u003e clearTimeout(timeoutId);\r\n  }, [query]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        value={query}\r\n        onChange={(e) =\u003e setQuery(e.target.value)}\r\n        placeholder=\"Search...\"\r\n      /\u003e\r\n      \u003cul\u003e\r\n        {results.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e{item.title}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Reduce Effect Execution**\r\n```jsx\r\nfunction OptimizedComponent({ user }) {\r\n  const [profile, setProfile] = useState(null);\r\n\r\n  // Use useMemo to avoid unnecessary dependency changes\r\n  const userId = useMemo(() =\u003e user?.id, [user?.id]);\r\n\r\n  useEffect(() =\u003e {\r\n    if (!userId) return;\r\n\r\n    fetch(`/api/profiles/${userId}`)\r\n      .then(response =\u003e response.json())\r\n      .then(data =\u003e setProfile(data));\r\n  }, [userId]); // Only executes when userId actually changes\r\n\r\n  return \u003cdiv\u003e{profile?.bio}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n1. **Use dependency arrays properly**: Include all variables used in the effect\r\n2. **Separate concerns**: Use different useEffects for different side effects\r\n3. **Clean up promptly**: Return cleanup functions to prevent memory leaks\r\n4. **Avoid over-triggering**: Use appropriate dependencies to reduce unnecessary executions\r\n5. **Error handling**: Handle errors properly in async operations\r\n\r\n\r\n### **Important Considerations**\r\n- **Dependency checking**: Use ESLint plugin `exhaustive-deps` to check dependencies\r\n- **Async operations**: Effect functions themselves cannot be async, define async functions inside\r\n- **Cleanup timing**: Cleanup functions execute before component unmounts or dependencies change\r\n- **Execution timing**: Effects execute asynchronously after DOM updates\r\n\r\n`useEffect` is a powerful tool for handling side effects, and proper usage enables function components to have complete lifecycle capabilities.\r\n"])</script><script>self.__next_f.push([1,"18:T4e65,"])</script><script>self.__next_f.push([1,"\r\n`useMemo` is a performance optimization Hook provided by React, used to cache computed results and avoid repeating expensive calculations on every render. It returns a memoized value that only recalculates when dependencies change.\r\n\r\n\r\n### **Basic Purpose**\r\nThe main purposes of `useMemo` are:\r\n- Cache computation results to avoid repeated expensive calculations\r\n- Optimize component performance by reducing unnecessary re-renders\r\n- Return the same reference value when dependencies don't change\r\n- Work with `React.memo` to optimize child component prop passing\r\n\r\n```jsx\r\nimport React, { useMemo, useState } from 'react';\r\n\r\nfunction MyComponent({ items }) {\r\n  const [filter, setFilter] = useState('');\r\n\r\n  // Use useMemo to cache filter results\r\n  const filteredItems = useMemo(() =\u003e {\r\n    console.log('Executing filter calculation');\r\n    return items.filter(item =\u003e \r\n      item.name.toLowerCase().includes(filter.toLowerCase())\r\n    );\r\n  }, [items, filter]); // Depends on items and filter\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        value={filter}\r\n        onChange={(e) =\u003e setFilter(e.target.value)}\r\n        placeholder=\"Search...\"\r\n      /\u003e\r\n      \u003cul\u003e\r\n        {filteredItems.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e{item.name}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Basic Syntax**\r\n```jsx\r\nconst memoizedValue = useMemo(() =\u003e {\r\n  // Computation logic\r\n  return expensiveCalculation(a, b);\r\n}, [a, b]); // Dependency array\r\n```\r\n\r\n- **First parameter**: Computation function that returns the value to cache\r\n- **Second parameter**: Dependency array, recalculates when values in array change\r\n\r\n\r\n### **Comparison with Regular Computation**\r\n\r\n#### **Without useMemo (Problem Example)**\r\n```jsx\r\nfunction ExpensiveComponent({ data, threshold }) {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // This expensive calculation runs on every render\r\n  const expensiveValue = data\r\n    .filter(item =\u003e item.value \u003e threshold)\r\n    .reduce((sum, item) =\u003e sum + item.value, 0);\r\n\r\n  console.log('Calculation executed'); // Logs on every render\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eExpensive calculation result: {expensiveValue}\u003c/p\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement Count\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **With useMemo (Optimized)**\r\n```jsx\r\nfunction OptimizedComponent({ data, threshold }) {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // Only recalculates when data or threshold changes\r\n  const expensiveValue = useMemo(() =\u003e {\r\n    console.log('Calculation executed'); // Only logs when dependencies change\r\n    return data\r\n      .filter(item =\u003e item.value \u003e threshold)\r\n      .reduce((sum, item) =\u003e sum + item.value, 0);\r\n  }, [data, threshold]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eExpensive calculation result: {expensiveValue}\u003c/p\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement Count\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Real-world Application Scenarios**\r\n\r\n#### **Complex Data Processing**\r\n```jsx\r\nfunction DataAnalytics({ salesData, dateRange, category }) {\r\n  // Data filtering and aggregation\r\n  const processedData = useMemo(() =\u003e {\r\n    console.log('Processing data...');\r\n    \r\n    return salesData\r\n      .filter(sale =\u003e {\r\n        const saleDate = new Date(sale.date);\r\n        return saleDate \u003e= dateRange.start \u0026\u0026 \r\n               saleDate \u003c= dateRange.end \u0026\u0026\r\n               sale.category === category;\r\n      })\r\n      .reduce((acc, sale) =\u003e {\r\n        const month = sale.date.substr(0, 7);\r\n        acc[month] = (acc[month] || 0) + sale.amount;\r\n        return acc;\r\n      }, {});\r\n  }, [salesData, dateRange, category]);\r\n\r\n  // Calculate statistics\r\n  const statistics = useMemo(() =\u003e {\r\n    const values = Object.values(processedData);\r\n    return {\r\n      total: values.reduce((sum, val) =\u003e sum + val, 0),\r\n      average: values.length ? values.reduce((sum, val) =\u003e sum + val, 0) / values.length : 0,\r\n      max: Math.max(...values),\r\n      min: Math.min(...values)\r\n    };\r\n  }, [processedData]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003eSales Analysis\u003c/h3\u003e\r\n      \u003cp\u003eTotal: {statistics.total}\u003c/p\u003e\r\n      \u003cp\u003eAverage: {statistics.average.toFixed(2)}\u003c/p\u003e\r\n      \u003cp\u003eMax: {statistics.max}\u003c/p\u003e\r\n      \u003cp\u003eMin: {statistics.min}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Search and Sorting**\r\n```jsx\r\nfunction ProductList({ products, searchTerm, sortBy, sortOrder }) {\r\n  // Search filtering\r\n  const filteredProducts = useMemo(() =\u003e {\r\n    if (!searchTerm) return products;\r\n    \r\n    return products.filter(product =\u003e\r\n      product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n      product.description.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }, [products, searchTerm]);\r\n\r\n  // Sorting\r\n  const sortedProducts = useMemo(() =\u003e {\r\n    const sorted = [...filteredProducts].sort((a, b) =\u003e {\r\n      let aValue = a[sortBy];\r\n      let bValue = b[sortBy];\r\n\r\n      if (typeof aValue === 'string') {\r\n        aValue = aValue.toLowerCase();\r\n        bValue = bValue.toLowerCase();\r\n      }\r\n\r\n      if (aValue \u003c bValue) return sortOrder === 'asc' ? -1 : 1;\r\n      if (aValue \u003e bValue) return sortOrder === 'asc' ? 1 : -1;\r\n      return 0;\r\n    });\r\n\r\n    return sorted;\r\n  }, [filteredProducts, sortBy, sortOrder]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eFound {sortedProducts.length} products\u003c/p\u003e\r\n      {sortedProducts.map(product =\u003e (\r\n        \u003cdiv key={product.id}\u003e\r\n          \u003ch4\u003e{product.name}\u003c/h4\u003e\r\n          \u003cp\u003e{product.description}\u003c/p\u003e\r\n          \u003cp\u003ePrice: ${product.price}\u003c/p\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Avoiding Child Component Re-renders**\r\n```jsx\r\nfunction ParentComponent() {\r\n  const [count, setCount] = useState(0);\r\n  const [users, setUsers] = useState([]);\r\n\r\n  // Without useMemo: creates new config object every render\r\n  const badConfig = {\r\n    pageSize: 10,\r\n    sortBy: 'name'\r\n  };\r\n\r\n  // Using useMemo: config object reference remains stable\r\n  const config = useMemo(() =\u003e ({\r\n    pageSize: 10,\r\n    sortBy: 'name'\r\n  }), []); // Empty dependency, config never changes\r\n\r\n  // User list computation logic\r\n  const processedUsers = useMemo(() =\u003e {\r\n    return users.map(user =\u003e ({\r\n      ...user,\r\n      displayName: `${user.firstName} ${user.lastName}`,\r\n      isActive: user.lastLogin \u003e Date.now() - 30 * 24 * 60 * 60 * 1000\r\n    }));\r\n  }, [users]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n      \r\n      {/* Using badConfig would cause UserList to re-render every time */}\r\n      \u003cUserList users={processedUsers} config={config} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst UserList = React.memo(({ users, config }) =\u003e {\r\n  console.log('UserList rendered');\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      {users.slice(0, config.pageSize).map(user =\u003e (\r\n        \u003cdiv key={user.id}\u003e\r\n          {user.displayName} {user.isActive ? '🟢' : '🔴'}\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n\r\n### **Comparison with useCallback**\r\n\r\n#### **useMemo vs useCallback**\r\n```jsx\r\nfunction ComparisonExample({ items }) {\r\n  // useMemo: caches computed result (value)\r\n  const expensiveValue = useMemo(() =\u003e {\r\n    return items.reduce((sum, item) =\u003e sum + item.value, 0);\r\n  }, [items]);\r\n\r\n  // useCallback: caches function definition\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log('Button clicked');\r\n  }, []);\r\n\r\n  // Equivalent writing\r\n  const memoizedCallback = useMemo(() =\u003e {\r\n    return () =\u003e console.log('Button clicked');\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eTotal: {expensiveValue}\u003c/p\u003e\r\n      \u003cbutton onClick={handleClick}\u003eClick\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Difference from `React.memo`**\r\nWhile both `useMemo` and `React.memo` are performance optimization tools, they solve different problems and are used in completely different ways:\r\n\r\n| Feature | useMemo | React.memo |\r\n|---------|---------|------------|\r\n| **Optimization Target** | Calculation process | Component rendering |\r\n| **Scope** | Values inside components | Entire component |\r\n| **Usage Location** | Inside components (Hook) | Outside component definition (HOC) |\r\n| **Trigger Condition** | Dependency array changes | Props changes |\r\n| **Return Type** | Any value | React component |\r\n\r\n```jsx\r\n// React.memo: Component-level optimization\r\nconst ProductCard = React.memo(({ product, onAddToCart }) =\u003e {\r\n  console.log('ProductCard rendered');\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003e{product.name}\u003c/h3\u003e\r\n      \u003cp\u003ePrice: ¥{product.price}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e onAddToCart(product.id)}\u003e\r\n        Add to Cart\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// useMemo: Value-level optimization\r\nfunction ProductList({ products, category, searchTerm }) {\r\n  console.log('ProductList rendered');\r\n\r\n  // useMemo caches filtering results\r\n  const filteredProducts = useMemo(() =\u003e {\r\n    console.log('Executing filtering calculation');\r\n    return products\r\n      .filter(p =\u003e p.category === category)\r\n      .filter(p =\u003e p.name.includes(searchTerm));\r\n  }, [products, category, searchTerm]);\r\n\r\n  // useMemo caches callback function for use with React.memo\r\n  const handleAddToCart = useMemo(() =\u003e {\r\n    return (productId) =\u003e {\r\n      console.log('Added to cart:', productId);\r\n    };\r\n  }, []); // Or use useCallback\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eFound {filteredProducts.length} products\u003c/p\u003e\r\n      {filteredProducts.map(product =\u003e (\r\n        \u003cProductCard\r\n          key={product.id}\r\n          product={product}\r\n          onAddToCart={handleAddToCart}\r\n        /\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n**Best Practices for Combined Usage**:```jsx\r\nfunction ShoppingApp() {\r\n  const [cart, setCart] = useState([]);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [products] = useState([\r\n    { id: 1, name: 'iPhone', category: 'electronics', price: 999 },\r\n    { id: 2, name: 'T-Shirt', category: 'clothing', price: 29 }\r\n  ]);\r\n\r\n  // useMemo: Cache search results\r\n  const searchResults = useMemo(() =\u003e {\r\n    if (!searchTerm) return products;\r\n    return products.filter(p =\u003e \r\n      p.name.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }, [products, searchTerm]);\r\n\r\n  // useMemo: Cache cart statistics\r\n  const cartStats = useMemo(() =\u003e {\r\n    return {\r\n      itemCount: cart.length,\r\n      total: cart.reduce((sum, item) =\u003e sum + item.price, 0)\r\n    };\r\n  }, [cart]);\r\n\r\n  // useCallback: Stable event handler\r\n  const addToCart = useCallback((productId) =\u003e {\r\n    const product = products.find(p =\u003e p.id === productId);\r\n    setCart(prev =\u003e [...prev, product]);\r\n  }, [products]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        value={searchTerm}\r\n        onChange={(e) =\u003e setSearchTerm(e.target.value)}\r\n        placeholder=\"Search products...\"\r\n      /\u003e\r\n      \r\n      {/* CartSummary optimized with React.memo */}\r\n      \u003cCartSummary stats={cartStats} /\u003e\r\n      \r\n      {/* ProductGrid optimized with React.memo */}\r\n      \u003cProductGrid \r\n        products={searchResults} \r\n        onAddToCart={addToCart} \r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\n// React.memo optimized components\r\nconst CartSummary = React.memo(({ stats }) =\u003e {\r\n  console.log('CartSummary rendered');\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eShopping Cart: {stats.itemCount} items\u003c/p\u003e\r\n      \u003cp\u003eTotal: ¥{stats.total}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\nconst ProductGrid = React.memo(({ products, onAddToCart }) =\u003e {\r\n  console.log('ProductGrid rendered');\r\n  return (\r\n    \u003cdiv\u003e\r\n      {products.map(product =\u003e (\r\n        \u003cProductItem\r\n          key={product.id}\r\n          product={product}\r\n          onAddToCart={onAddToCart}\r\n        /\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\nconst ProductItem = React.memo(({ product, onAddToCart }) =\u003e {\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch4\u003e{product.name}\u003c/h4\u003e\r\n      \u003cp\u003e¥{product.price}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e onAddToCart(product.id)}\u003e\r\n        Add to Cart\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n**When to use which**：\r\n- **Use `useMemo`**：\r\n  - Expensive calculations need caching\r\n  - Need to provide stable props reference\r\n  - Avoid creating new object/array every render\r\n\r\n- **Use `React.memo`**：\r\n  - Component often receives the same props\r\n  - Component rendering cost is high\r\n  - Parent component frequently re-renders but child component props changes less often\r\n\r\n- **Combine usage**：\r\n  - Use `useMemo` to create stable props\r\n  - Use `React.memo` to prevent child component unnecessary re-renders\r\n\r\n\r\n### **Conditional Computation**\r\n```jsx\r\nfunction ConditionalMemo({ data, shouldProcess, processingType }) {\r\n  const processedData = useMemo(() =\u003e {\r\n    // Only process when needed\r\n    if (!shouldProcess) return data;\r\n\r\n    console.log('Executing data processing...');\r\n    \r\n    switch (processingType) {\r\n      case 'sort':\r\n        return [...data].sort((a, b) =\u003e a.value - b.value);\r\n      case 'filter':\r\n        return data.filter(item =\u003e item.active);\r\n      case 'transform':\r\n        return data.map(item =\u003e ({ ...item, processed: true }));\r\n      default:\r\n        return data;\r\n    }\r\n  }, [data, shouldProcess, processingType]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eData items count: {processedData.length}\u003c/p\u003e\r\n      {processedData.map(item =\u003e (\r\n        \u003cdiv key={item.id}\u003e{item.name}\u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Memoizing Complex Objects**\r\n```jsx\r\nfunction FormValidator({ formData, validationRules }) {\r\n  // Validation results computation\r\n  const validationResults = useMemo(() =\u003e {\r\n    const results = {};\r\n    \r\n    Object.keys(validationRules).forEach(field =\u003e {\r\n      const value = formData[field];\r\n      const rules = validationRules[field];\r\n      \r\n      results[field] = {\r\n        isValid: true,\r\n        errors: []\r\n      };\r\n\r\n      rules.forEach(rule =\u003e {\r\n        if (!rule.validator(value)) {\r\n          results[field].isValid = false;\r\n          results[field].errors.push(rule.message);\r\n        }\r\n      });\r\n    });\r\n\r\n    return results;\r\n  }, [formData, validationRules]);\r\n\r\n  // Overall form status\r\n  const formStatus = useMemo(() =\u003e {\r\n    const allFields = Object.values(validationResults);\r\n    const hasErrors = allFields.some(field =\u003e !field.isValid);\r\n    const totalErrors = allFields.reduce((sum, field) =\u003e sum + field.errors.length, 0);\r\n\r\n    return {\r\n      isValid: !hasErrors,\r\n      errorCount: totalErrors,\r\n      canSubmit: !hasErrors \u0026\u0026 Object.keys(formData).length \u003e 0\r\n    };\r\n  }, [validationResults, formData]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eForm status: {formStatus.isValid ? 'Valid' : 'Invalid'}\u003c/p\u003e\r\n      \u003cp\u003eError count: {formStatus.errorCount}\u003c/p\u003e\r\n      \u003cbutton disabled={!formStatus.canSubmit}\u003e\r\n        Submit Form\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Common Pitfalls and Solutions**\r\n\r\n#### **Incorrect Dependency Array**\r\n```jsx\r\nfunction BadExample({ items, filter }) {\r\n  const [multiplier, setMultiplier] = useState(1);\r\n\r\n  // Wrong: missing multiplier dependency\r\n  const processedItems = useMemo(() =\u003e {\r\n    return items\r\n      .filter(item =\u003e item.category === filter)\r\n      .map(item =\u003e ({ ...item, value: item.value * multiplier }));\r\n  }, [items, filter]); // Should include [items, filter, multiplier]\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        type=\"number\" \r\n        value={multiplier}\r\n        onChange={(e) =\u003e setMultiplier(Number(e.target.value))}\r\n      /\u003e\r\n      {/* processedItems won't update when multiplier changes */}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Over-optimization**\r\n```jsx\r\n// Unnecessary optimization\r\nfunction OverOptimized() {\r\n  const [name, setName] = useState('');\r\n\r\n  // Simple string operations don't need useMemo\r\n  const uppercaseName = useMemo(() =\u003e {\r\n    return name.toUpperCase();\r\n  }, [name]);\r\n\r\n  return \u003cdiv\u003e{uppercaseName}\u003c/div\u003e;\r\n}\r\n\r\n// Simple and direct approach\r\nfunction Simple() {\r\n  const [name, setName] = useState('');\r\n\r\n  return \u003cdiv\u003e{name.toUpperCase()}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **Reference Type Pitfalls**\r\n```jsx\r\nfunction ReferenceTypeExample({ config }) {\r\n  // Wrong: config is an object, might be considered new every time\r\n  const processedConfig = useMemo(() =\u003e {\r\n    return {\r\n      ...config,\r\n      processed: true\r\n    };\r\n  }, [config]); // config object reference might change every time\r\n\r\n  // Correct: use specific object properties as dependencies\r\n  const processedConfigCorrect = useMemo(() =\u003e {\r\n    return {\r\n      ...config,\r\n      processed: true\r\n    };\r\n  }, [config.apiUrl, config.timeout, config.retries]); // Specific properties\r\n\r\n  return \u003cdiv\u003eConfig processed\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **Performance Testing Example**\r\n```jsx\r\nfunction PerformanceTest({ data }) {\r\n  const [rerenderCount, setRerenderCount] = useState(0);\r\n\r\n  // Expensive calculation (simulated)\r\n  const expensiveCalculation = (items) =\u003e {\r\n    console.log('Executing expensive calculation...');\r\n    let result = 0;\r\n    for (let i = 0; i \u003c 1000000; i++) {\r\n      result += Math.random();\r\n    }\r\n    return items.length + result;\r\n  };\r\n\r\n  // Version without caching\r\n  const unoptimizedValue = expensiveCalculation(data);\r\n\r\n  // Version with caching\r\n  const optimizedValue = useMemo(() =\u003e {\r\n    return expensiveCalculation(data);\r\n  }, [data]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eRe-render count: {rerenderCount}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setRerenderCount(prev =\u003e prev + 1)}\u003e\r\n        Trigger Re-render\r\n      \u003c/button\u003e\r\n      \u003cp\u003eUnoptimized value: {unoptimizedValue.toFixed(2)}\u003c/p\u003e\r\n      \u003cp\u003eOptimized value: {optimizedValue.toFixed(2)}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Usage in Custom Hooks**\r\n```jsx\r\nfunction useFilteredData(data, filters) {\r\n  const filteredData = useMemo(() =\u003e {\r\n    let result = data;\r\n\r\n    if (filters.search) {\r\n      result = result.filter(item =\u003e\r\n        item.name.toLowerCase().includes(filters.search.toLowerCase())\r\n      );\r\n    }\r\n\r\n    if (filters.category) {\r\n      result = result.filter(item =\u003e item.category === filters.category);\r\n    }\r\n\r\n    if (filters.priceRange) {\r\n      result = result.filter(item =\u003e\r\n        item.price \u003e= filters.priceRange.min \u0026\u0026\r\n        item.price \u003c= filters.priceRange.max\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }, [data, filters.search, filters.category, filters.priceRange]);\r\n\r\n  const statistics = useMemo(() =\u003e {\r\n    return {\r\n      count: filteredData.length,\r\n      averagePrice: filteredData.length\r\n        ? filteredData.reduce((sum, item) =\u003e sum + item.price, 0) / filteredData.length\r\n        : 0\r\n    };\r\n  }, [filteredData]);\r\n\r\n  return { filteredData, statistics };\r\n}\r\n\r\n// Using custom Hook\r\nfunction ProductCatalog({ products }) {\r\n  const [filters, setFilters] = useState({\r\n    search: '',\r\n    category: '',\r\n    priceRange: { min: 0, max: 1000 }\r\n  });\r\n\r\n  const { filteredData, statistics } = useFilteredData(products, filters);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eFound {statistics.count} products\u003c/p\u003e\r\n      \u003cp\u003eAverage price: ${statistics.averagePrice.toFixed(2)}\u003c/p\u003e\r\n      {/* Render product list */}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n1. **Identify expensive calculations**: Only use useMemo for truly expensive computations\r\n2. **Set dependencies correctly**: Include all variables used in the computation\r\n3. **Avoid over-optimization**: Simple calculations don't need memoization\r\n4. **Stable references**: Provide stable prop references for child components\r\n5. **Measure performance**: Use developer tools to verify optimization effectiveness\r\n\r\n\r\n### **Important Considerations**\r\n- **Memory overhead**: Cached values consume additional memory\r\n- **Computation cost**: Memoization itself has costs, ensure benefits outweigh costs\r\n- **Dependency comparison**: Uses shallow comparison, be careful with objects and arrays\r\n- **Debugging difficulty**: Overuse can make code harder to understand\r\n\r\n`useMemo` is an important tool for optimizing React application performance, but should be used in appropriate scenarios to avoid over-optimization that increases code complexity.\r\n"])</script><script>self.__next_f.push([1,"19:T6f5c,"])</script><script>self.__next_f.push([1,"\r\n`useReducer` is a state management Hook provided by React, suitable for managing complex state logic. It works similarly to Redux, using a reducer function to handle state updates, and is particularly suitable for handling multiple related state values or complex state transition logic.\r\n\r\n\r\n### **Basic Purpose**\r\nThe main purposes of `useReducer` are:\r\n- Manage complex component state logic\r\n- Handle multiple related state values\r\n- Provide predictable state update methods\r\n- Replace complex useState scenarios\r\n- Work with useContext for global state management\r\n\r\n```jsx\r\nimport React, { useReducer } from 'react';\r\n\r\n// Define reducer function\r\nfunction counterReducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + 1 };\r\n    case 'decrement':\r\n      return { count: state.count - 1 };\r\n    case 'reset':\r\n      return { count: 0 };\r\n    default:\r\n      throw new Error(`Unknown action type: ${action.type}`);\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {state.count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+1\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-1\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'reset' })}\u003eReset\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Basic Syntax**\r\n```jsx\r\nconst [state, dispatch] = useReducer(reducer, initialState, init);\r\n```\r\n\r\n- **reducer**: reducer function `(state, action) =\u003e newState`\r\n- **initialState**: initial state value\r\n- **init**: optional initialization function for lazy initialization\r\n- **return value**: `[state, dispatch]` array\r\n\r\n\r\n### **Comparison with useState**\r\n\r\n#### **Using useState (Simple State)**\r\n```jsx\r\nfunction SimpleCounter() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count - 1)}\u003eDecrement\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(0)}\u003eReset\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Using useReducer (Complex State)**\r\n```jsx\r\nfunction ComplexCounter() {\r\n  const initialState = {\r\n    count: 0,\r\n    step: 1,\r\n    history: []\r\n  };\r\n\r\n  function reducer(state, action) {\r\n    switch (action.type) {\r\n      case 'increment':\r\n        return {\r\n          ...state,\r\n          count: state.count + state.step,\r\n          history: [...state.history, { action: 'increment', value: state.step }]\r\n        };\r\n      case 'decrement':\r\n        return {\r\n          ...state,\r\n          count: state.count - state.step,\r\n          history: [...state.history, { action: 'decrement', value: state.step }]\r\n        };\r\n      case 'setStep':\r\n        return {\r\n          ...state,\r\n          step: action.payload\r\n        };\r\n      case 'reset':\r\n        return {\r\n          ...initialState\r\n        };\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {state.count}\u003c/p\u003e\r\n      \u003cp\u003eStep: {state.step}\u003c/p\u003e\r\n      \u003cinput\r\n        type=\"number\"\r\n        value={state.step}\r\n        onChange={(e) =\u003e dispatch({ \r\n          type: 'setStep', \r\n          payload: parseInt(e.target.value) || 1 \r\n        })}\r\n      /\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e\r\n        Increment {state.step}\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e\r\n        Decrement {state.step}\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'reset' })}\u003eReset\u003c/button\u003e\r\n      \r\n      \u003ch3\u003eAction History:\u003c/h3\u003e\r\n      \u003cul\u003e\r\n        {state.history.map((item, index) =\u003e (\r\n          \u003cli key={index}\u003e\r\n            {item.action} {item.value}\r\n          \u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Form State Management**\r\n\r\n#### **Complex Form Handling**\r\n```jsx\r\nfunction FormWithReducer() {\r\n  const initialState = {\r\n    values: {\r\n      name: '',\r\n      email: '',\r\n      age: '',\r\n      preferences: []\r\n    },\r\n    errors: {},\r\n    isSubmitting: false,\r\n    isValid: false\r\n  };\r\n\r\n  function formReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'SET_FIELD':\r\n        return {\r\n          ...state,\r\n          values: {\r\n            ...state.values,\r\n            [action.field]: action.value\r\n          }\r\n        };\r\n      \r\n      case 'SET_ERROR':\r\n        return {\r\n          ...state,\r\n          errors: {\r\n            ...state.errors,\r\n            [action.field]: action.error\r\n          }\r\n        };\r\n      \r\n      case 'CLEAR_ERROR':\r\n        const newErrors = { ...state.errors };\r\n        delete newErrors[action.field];\r\n        return {\r\n          ...state,\r\n          errors: newErrors\r\n        };\r\n      \r\n      case 'ADD_PREFERENCE':\r\n        return {\r\n          ...state,\r\n          values: {\r\n            ...state.values,\r\n            preferences: [...state.values.preferences, action.preference]\r\n          }\r\n        };\r\n      \r\n      case 'REMOVE_PREFERENCE':\r\n        return {\r\n          ...state,\r\n          values: {\r\n            ...state.values,\r\n            preferences: state.values.preferences.filter(p =\u003e p !== action.preference)\r\n          }\r\n        };\r\n      \r\n      case 'SET_SUBMITTING':\r\n        return {\r\n          ...state,\r\n          isSubmitting: action.isSubmitting\r\n        };\r\n      \r\n      case 'RESET_FORM':\r\n        return initialState;\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(formReducer, initialState);\r\n\r\n  const handleFieldChange = (field, value) =\u003e {\r\n    dispatch({ type: 'SET_FIELD', field, value });\r\n    \r\n    // Real-time validation\r\n    if (field === 'email' \u0026\u0026 value \u0026\u0026 !value.includes('@')) {\r\n      dispatch({ type: 'SET_ERROR', field, error: 'Please enter a valid email address' });\r\n    } else {\r\n      dispatch({ type: 'CLEAR_ERROR', field });\r\n    }\r\n  };\r\n\r\n  const handleSubmit = async (e) =\u003e {\r\n    e.preventDefault();\r\n    dispatch({ type: 'SET_SUBMITTING', isSubmitting: true });\r\n    \r\n    try {\r\n      // Simulate API call\r\n      await new Promise(resolve =\u003e setTimeout(resolve, 2000));\r\n      console.log('Form submitted successfully:', state.values);\r\n      dispatch({ type: 'RESET_FORM' });\r\n    } catch (error) {\r\n      console.error('Submission failed:', error);\r\n    } finally {\r\n      dispatch({ type: 'SET_SUBMITTING', isSubmitting: false });\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cform onSubmit={handleSubmit}\u003e\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003eName:\u003c/label\u003e\r\n        \u003cinput\r\n          value={state.values.name}\r\n          onChange={(e) =\u003e handleFieldChange('name', e.target.value)}\r\n        /\u003e\r\n        {state.errors.name \u0026\u0026 \u003cspan style={{color: 'red'}}\u003e{state.errors.name}\u003c/span\u003e}\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003eEmail:\u003c/label\u003e\r\n        \u003cinput\r\n          value={state.values.email}\r\n          onChange={(e) =\u003e handleFieldChange('email', e.target.value)}\r\n        /\u003e\r\n        {state.errors.email \u0026\u0026 \u003cspan style={{color: 'red'}}\u003e{state.errors.email}\u003c/span\u003e}\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003eAge:\u003c/label\u003e\r\n        \u003cinput\r\n          type=\"number\"\r\n          value={state.values.age}\r\n          onChange={(e) =\u003e handleFieldChange('age', e.target.value)}\r\n        /\u003e\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003ePreferences:\u003c/label\u003e\r\n        {['Technology', 'Design', 'Management'].map(pref =\u003e (\r\n          \u003clabel key={pref}\u003e\r\n            \u003cinput\r\n              type=\"checkbox\"\r\n              checked={state.values.preferences.includes(pref)}\r\n              onChange={(e) =\u003e {\r\n                if (e.target.checked) {\r\n                  dispatch({ type: 'ADD_PREFERENCE', preference: pref });\r\n                } else {\r\n                  dispatch({ type: 'REMOVE_PREFERENCE', preference: pref });\r\n                }\r\n              }}\r\n            /\u003e\r\n            {pref}\r\n          \u003c/label\u003e\r\n        ))}\r\n      \u003c/div\u003e\r\n\r\n      \u003cbutton type=\"submit\" disabled={state.isSubmitting}\u003e\r\n        {state.isSubmitting ? 'Submitting...' : 'Submit'}\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Shopping Cart State Management**\r\n\r\n#### **E-commerce Shopping Cart Example**\r\n```jsx\r\nfunction ShoppingCart() {\r\n  const initialState = {\r\n    items: [],\r\n    total: 0,\r\n    discount: 0,\r\n    couponCode: '',\r\n    isLoading: false\r\n  };\r\n\r\n  function cartReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'ADD_ITEM':\r\n        const existingItem = state.items.find(item =\u003e item.id === action.item.id);\r\n        let newItems;\r\n        \r\n        if (existingItem) {\r\n          newItems = state.items.map(item =\u003e\r\n            item.id === action.item.id\r\n              ? { ...item, quantity: item.quantity + 1 }\r\n              : item\r\n          );\r\n        } else {\r\n          newItems = [...state.items, { ...action.item, quantity: 1 }];\r\n        }\r\n\r\n        return {\r\n          ...state,\r\n          items: newItems,\r\n          total: calculateTotal(newItems, state.discount)\r\n        };\r\n\r\n      case 'REMOVE_ITEM':\r\n        const filteredItems = state.items.filter(item =\u003e item.id !== action.itemId);\r\n        return {\r\n          ...state,\r\n          items: filteredItems,\r\n          total: calculateTotal(filteredItems, state.discount)\r\n        };\r\n\r\n      case 'UPDATE_QUANTITY':\r\n        const updatedItems = state.items.map(item =\u003e\r\n          item.id === action.itemId\r\n            ? { ...item, quantity: Math.max(0, action.quantity) }\r\n            : item\r\n        ).filter(item =\u003e item.quantity \u003e 0);\r\n\r\n        return {\r\n          ...state,\r\n          items: updatedItems,\r\n          total: calculateTotal(updatedItems, state.discount)\r\n        };\r\n\r\n      case 'APPLY_COUPON':\r\n        const discount = calculateDiscount(action.couponCode, state.items);\r\n        return {\r\n          ...state,\r\n          couponCode: action.couponCode,\r\n          discount,\r\n          total: calculateTotal(state.items, discount)\r\n        };\r\n\r\n      case 'CLEAR_CART':\r\n        return initialState;\r\n\r\n      case 'SET_LOADING':\r\n        return {\r\n          ...state,\r\n          isLoading: action.isLoading\r\n        };\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  // Helper functions\r\n  const calculateTotal = (items, discount = 0) =\u003e {\r\n    const subtotal = items.reduce((sum, item) =\u003e sum + item.price * item.quantity, 0);\r\n    return subtotal - discount;\r\n  };\r\n\r\n  const calculateDiscount = (couponCode, items) =\u003e {\r\n    const subtotal = items.reduce((sum, item) =\u003e sum + item.price * item.quantity, 0);\r\n    switch (couponCode) {\r\n      case 'SAVE10':\r\n        return subtotal * 0.1;\r\n      case 'SAVE20':\r\n        return subtotal * 0.2;\r\n      default:\r\n        return 0;\r\n    }\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(cartReducer, initialState);\r\n\r\n  // Product data\r\n  const products = [\r\n    { id: 1, name: 'iPhone 15', price: 5999 },\r\n    { id: 2, name: 'MacBook Pro', price: 15999 },\r\n    { id: 3, name: 'AirPods', price: 1299 }\r\n  ];\r\n\r\n  const addToCart = (product) =\u003e {\r\n    dispatch({ type: 'ADD_ITEM', item: product });\r\n  };\r\n\r\n  const removeFromCart = (itemId) =\u003e {\r\n    dispatch({ type: 'REMOVE_ITEM', itemId });\r\n  };\r\n\r\n  const updateQuantity = (itemId, quantity) =\u003e {\r\n    dispatch({ type: 'UPDATE_QUANTITY', itemId, quantity });\r\n  };\r\n\r\n  const applyCoupon = (couponCode) =\u003e {\r\n    dispatch({ type: 'APPLY_COUPON', couponCode });\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch2\u003eProduct List\u003c/h2\u003e\r\n      {products.map(product =\u003e (\r\n        \u003cdiv key={product.id} style={{ border: '1px solid #ccc', margin: '10px', padding: '10px' }}\u003e\r\n          \u003ch3\u003e{product.name}\u003c/h3\u003e\r\n          \u003cp\u003ePrice: ${product.price}\u003c/p\u003e\r\n          \u003cbutton onClick={() =\u003e addToCart(product)}\u003eAdd to Cart\u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n\r\n      \u003ch2\u003eShopping Cart\u003c/h2\u003e\r\n      {state.items.length === 0 ? (\r\n        \u003cp\u003eCart is empty\u003c/p\u003e\r\n      ) : (\r\n        \u003c\u003e\r\n          {state.items.map(item =\u003e (\r\n            \u003cdiv key={item.id} style={{ border: '1px solid #eee', margin: '5px', padding: '10px' }}\u003e\r\n              \u003ch4\u003e{item.name}\u003c/h4\u003e\r\n              \u003cp\u003eUnit Price: ${item.price}\u003c/p\u003e\r\n              \u003cdiv\u003e\r\n                Quantity: \r\n                \u003cbutton onClick={() =\u003e updateQuantity(item.id, item.quantity - 1)}\u003e-\u003c/button\u003e\r\n                \u003cspan style={{ margin: '0 10px' }}\u003e{item.quantity}\u003c/span\u003e\r\n                \u003cbutton onClick={() =\u003e updateQuantity(item.id, item.quantity + 1)}\u003e+\u003c/button\u003e\r\n              \u003c/div\u003e\r\n              \u003cp\u003eSubtotal: ${item.price * item.quantity}\u003c/p\u003e\r\n              \u003cbutton onClick={() =\u003e removeFromCart(item.id)}\u003eRemove\u003c/button\u003e\r\n            \u003c/div\u003e\r\n          ))}\r\n\r\n          \u003cdiv\u003e\r\n            \u003cinput\r\n              placeholder=\"Enter coupon code\"\r\n              onChange={(e) =\u003e applyCoupon(e.target.value)}\r\n            /\u003e\r\n            \u003cp\u003eDiscount: ${state.discount}\u003c/p\u003e\r\n            \u003ch3\u003eTotal: ${state.total}\u003c/h3\u003e\r\n            \u003cbutton onClick={() =\u003e dispatch({ type: 'CLEAR_CART' })}\u003eClear Cart\u003c/button\u003e\r\n          \u003c/div\u003e\r\n        \u003c/\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Working with useContext**\r\n\r\n#### **Global State Management**\r\n```jsx\r\n// Create Context\r\nconst AppContext = React.createContext();\r\n\r\n// Initial state\r\nconst initialState = {\r\n  user: null,\r\n  theme: 'light',\r\n  notifications: [],\r\n  isLoading: false\r\n};\r\n\r\n// Reducer function\r\nfunction appReducer(state, action) {\r\n  switch (action.type) {\r\n    case 'SET_USER':\r\n      return {\r\n        ...state,\r\n        user: action.user\r\n      };\r\n    \r\n    case 'LOGOUT':\r\n      return {\r\n        ...state,\r\n        user: null\r\n      };\r\n    \r\n    case 'TOGGLE_THEME':\r\n      return {\r\n        ...state,\r\n        theme: state.theme === 'light' ? 'dark' : 'light'\r\n      };\r\n    \r\n    case 'ADD_NOTIFICATION':\r\n      return {\r\n        ...state,\r\n        notifications: [...state.notifications, {\r\n          id: Date.now(),\r\n          message: action.message,\r\n          type: action.notificationType || 'info'\r\n        }]\r\n      };\r\n    \r\n    case 'REMOVE_NOTIFICATION':\r\n      return {\r\n        ...state,\r\n        notifications: state.notifications.filter(n =\u003e n.id !== action.id)\r\n      };\r\n    \r\n    case 'SET_LOADING':\r\n      return {\r\n        ...state,\r\n        isLoading: action.isLoading\r\n      };\r\n    \r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Provider component\r\nfunction AppProvider({ children }) {\r\n  const [state, dispatch] = useReducer(appReducer, initialState);\r\n\r\n  const actions = {\r\n    login: (user) =\u003e {\r\n      dispatch({ type: 'SET_USER', user });\r\n      dispatch({ type: 'ADD_NOTIFICATION', message: 'Login successful', notificationType: 'success' });\r\n    },\r\n    \r\n    logout: () =\u003e {\r\n      dispatch({ type: 'LOGOUT' });\r\n      dispatch({ type: 'ADD_NOTIFICATION', message: 'Logged out', notificationType: 'info' });\r\n    },\r\n    \r\n    toggleTheme: () =\u003e {\r\n      dispatch({ type: 'TOGGLE_THEME' });\r\n    },\r\n    \r\n    addNotification: (message, type) =\u003e {\r\n      dispatch({ type: 'ADD_NOTIFICATION', message, notificationType: type });\r\n    },\r\n    \r\n    removeNotification: (id) =\u003e {\r\n      dispatch({ type: 'REMOVE_NOTIFICATION', id });\r\n    },\r\n    \r\n    setLoading: (isLoading) =\u003e {\r\n      dispatch({ type: 'SET_LOADING', isLoading });\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cAppContext.Provider value={{ state, actions }}\u003e\r\n      {children}\r\n    \u003c/AppContext.Provider\u003e\r\n  );\r\n}\r\n\r\n// Custom Hook\r\nfunction useAppContext() {\r\n  const context = useContext(AppContext);\r\n  if (!context) {\r\n    throw new Error('useAppContext must be used within AppProvider');\r\n  }\r\n  return context;\r\n}\r\n\r\n// Example usage components\r\nfunction Header() {\r\n  const { state, actions } = useAppContext();\r\n\r\n  return (\r\n    \u003cheader style={{ \r\n      background: state.theme === 'light' ? '#fff' : '#333',\r\n      color: state.theme === 'light' ? '#333' : '#fff',\r\n      padding: '1rem'\r\n    }}\u003e\r\n      \u003ch1\u003eMy App\u003c/h1\u003e\r\n      \u003cdiv\u003e\r\n        {state.user ? (\r\n          \u003cdiv\u003e\r\n            \u003cspan\u003eWelcome, {state.user.name}\u003c/span\u003e\r\n            \u003cbutton onClick={actions.logout}\u003eLogout\u003c/button\u003e\r\n          \u003c/div\u003e\r\n        ) : (\r\n          \u003cbutton onClick={() =\u003e actions.login({ name: 'User', id: 1 })}\u003e\r\n            Login\r\n          \u003c/button\u003e\r\n        )}\r\n        \u003cbutton onClick={actions.toggleTheme}\u003e\r\n          Switch to {state.theme === 'light' ? 'dark' : 'light'} theme\r\n        \u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/header\u003e\r\n  );\r\n}\r\n\r\nfunction NotificationList() {\r\n  const { state, actions } = useAppContext();\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {state.notifications.map(notification =\u003e (\r\n        \u003cdiv \r\n          key={notification.id}\r\n          style={{\r\n            padding: '10px',\r\n            margin: '5px',\r\n            background: notification.type === 'success' ? 'green' : \r\n                       notification.type === 'error' ? 'red' : 'blue',\r\n            color: 'white'\r\n          }}\r\n        \u003e\r\n          {notification.message}\r\n          \u003cbutton onClick={() =\u003e actions.removeNotification(notification.id)}\u003e\r\n            ×\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\n// Main app\r\nfunction App() {\r\n  return (\r\n    \u003cAppProvider\u003e\r\n      \u003cHeader /\u003e\r\n      \u003cNotificationList /\u003e\r\n    \u003c/AppProvider\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Async Operations Handling**\r\n\r\n#### **Data Fetching State Management**\r\n```jsx\r\nfunction DataFetcher() {\r\n  const initialState = {\r\n    data: null,\r\n    loading: false,\r\n    error: null,\r\n    lastFetch: null\r\n  };\r\n\r\n  function dataReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'FETCH_START':\r\n        return {\r\n          ...state,\r\n          loading: true,\r\n          error: null\r\n        };\r\n      \r\n      case 'FETCH_SUCCESS':\r\n        return {\r\n          ...state,\r\n          loading: false,\r\n          data: action.data,\r\n          lastFetch: new Date(),\r\n          error: null\r\n        };\r\n      \r\n      case 'FETCH_ERROR':\r\n        return {\r\n          ...state,\r\n          loading: false,\r\n          error: action.error,\r\n          data: null\r\n        };\r\n      \r\n      case 'CLEAR_DATA':\r\n        return initialState;\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(dataReducer, initialState);\r\n\r\n  const fetchData = async (url) =\u003e {\r\n    dispatch({ type: 'FETCH_START' });\r\n    \r\n    try {\r\n      const response = await fetch(url);\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      const data = await response.json();\r\n      dispatch({ type: 'FETCH_SUCCESS', data });\r\n    } catch (error) {\r\n      dispatch({ type: 'FETCH_ERROR', error: error.message });\r\n    }\r\n  };\r\n\r\n  const clearData = () =\u003e {\r\n    dispatch({ type: 'CLEAR_DATA' });\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e fetchData('/api/users')}\u003eFetch User Data\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e fetchData('/api/posts')}\u003eFetch Post Data\u003c/button\u003e\r\n      \u003cbutton onClick={clearData}\u003eClear Data\u003c/button\u003e\r\n\r\n      {state.loading \u0026\u0026 \u003cp\u003eLoading...\u003c/p\u003e}\r\n      {state.error \u0026\u0026 \u003cp style={{color: 'red'}}\u003eError: {state.error}\u003c/p\u003e}\r\n      {state.data \u0026\u0026 (\r\n        \u003cdiv\u003e\r\n          \u003cp\u003eData fetched at: {state.lastFetch?.toLocaleString()}\u003c/p\u003e\r\n          \u003cpre\u003e{JSON.stringify(state.data, null, 2)}\u003c/pre\u003e\r\n        \u003c/div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Game State Management**\r\n\r\n#### **Tic-Tac-Toe Game Example**\r\n```jsx\r\nfunction TicTacToe() {\r\n  const initialState = {\r\n    board: Array(9).fill(null),\r\n    isXNext: true,\r\n    winner: null,\r\n    gameOver: false,\r\n    moves: 0\r\n  };\r\n\r\n  function gameReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'MAKE_MOVE':\r\n        if (state.board[action.index] || state.winner) {\r\n          return state;\r\n        }\r\n\r\n        const newBoard = [...state.board];\r\n        newBoard[action.index] = state.isXNext ? 'X' : 'O';\r\n        \r\n        const winner = calculateWinner(newBoard);\r\n        const gameOver = winner || newBoard.every(cell =\u003e cell !== null);\r\n\r\n        return {\r\n          ...state,\r\n          board: newBoard,\r\n          isXNext: !state.isXNext,\r\n          winner,\r\n          gameOver,\r\n          moves: state.moves + 1\r\n        };\r\n\r\n      case 'RESET_GAME':\r\n        return initialState;\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const calculateWinner = (board) =\u003e {\r\n    const lines = [\r\n      [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows\r\n      [0, 3, 6], [1, 4, 7], [2, 5, 8], // Columns\r\n      [0, 4, 8], [2, 4, 6] // Diagonals\r\n    ];\r\n\r\n    for (let line of lines) {\r\n      const [a, b, c] = line;\r\n      if (board[a] \u0026\u0026 board[a] === board[b] \u0026\u0026 board[a] === board[c]) {\r\n        return board[a];\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(gameReducer, initialState);\r\n\r\n  const makeMove = (index) =\u003e {\r\n    dispatch({ type: 'MAKE_MOVE', index });\r\n  };\r\n\r\n  const resetGame = () =\u003e {\r\n    dispatch({ type: 'RESET_GAME' });\r\n  };\r\n\r\n  const renderSquare = (index) =\u003e (\r\n    \u003cbutton\r\n      style={{\r\n        width: '60px',\r\n        height: '60px',\r\n        fontSize: '20px',\r\n        fontWeight: 'bold'\r\n      }}\r\n      onClick={() =\u003e makeMove(index)}\r\n    \u003e\r\n      {state.board[index]}\r\n    \u003c/button\u003e\r\n  );\r\n\r\n  let status;\r\n  if (state.winner) {\r\n    status = `Winner: ${state.winner}`;\r\n  } else if (state.gameOver) {\r\n    status = 'Draw!';\r\n  } else {\r\n    status = `Next player: ${state.isXNext ? 'X' : 'O'}`;\r\n  }\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003e{status}\u003c/div\u003e\r\n      \u003cp\u003eMoves: {state.moves}\u003c/p\u003e\r\n      \u003cdiv\u003e\r\n        \u003cdiv\u003e\r\n          {renderSquare(0)}\r\n          {renderSquare(1)}\r\n          {renderSquare(2)}\r\n        \u003c/div\u003e\r\n        \u003cdiv\u003e\r\n          {renderSquare(3)}\r\n          {renderSquare(4)}\r\n          {renderSquare(5)}\r\n        \u003c/div\u003e\r\n        \u003cdiv\u003e\r\n          {renderSquare(6)}\r\n          {renderSquare(7)}\r\n          {renderSquare(8)}\r\n        \u003c/div\u003e\r\n      \u003c/div\u003e\r\n      \u003cbutton onClick={resetGame}\u003eReset Game\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Custom Hook Encapsulation**\r\n\r\n#### **Generic State Management Hook**\r\n```jsx\r\nfunction useStateWithReducer(initialState) {\r\n  function stateReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'SET':\r\n        return { ...state, ...action.payload };\r\n      case 'RESET':\r\n        return initialState;\r\n      case 'UPDATE_FIELD':\r\n        return { ...state, [action.field]: action.value };\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(stateReducer, initialState);\r\n\r\n  const setState = (payload) =\u003e {\r\n    dispatch({ type: 'SET', payload });\r\n  };\r\n\r\n  const resetState = () =\u003e {\r\n    dispatch({ type: 'RESET' });\r\n  };\r\n\r\n  const updateField = (field, value) =\u003e {\r\n    dispatch({ type: 'UPDATE_FIELD', field, value });\r\n  };\r\n\r\n  return [state, { setState, resetState, updateField }];\r\n}\r\n\r\n// Usage example\r\nfunction UserProfile() {\r\n  const [userState, userActions] = useStateWithReducer({\r\n    name: '',\r\n    email: '',\r\n    age: '',\r\n    isEditing: false\r\n  });\r\n\r\n  const handleSave = () =\u003e {\r\n    console.log('Save user info:', userState);\r\n    userActions.updateField('isEditing', false);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {userState.isEditing ? (\r\n        \u003cdiv\u003e\r\n          \u003cinput\r\n            value={userState.name}\r\n            onChange={(e) =\u003e userActions.updateField('name', e.target.value)}\r\n            placeholder=\"Name\"\r\n          /\u003e\r\n          \u003cinput\r\n            value={userState.email}\r\n            onChange={(e) =\u003e userActions.updateField('email', e.target.value)}\r\n            placeholder=\"Email\"\r\n          /\u003e\r\n          \u003cinput\r\n            value={userState.age}\r\n            onChange={(e) =\u003e userActions.updateField('age', e.target.value)}\r\n            placeholder=\"Age\"\r\n          /\u003e\r\n          \u003cbutton onClick={handleSave}\u003eSave\u003c/button\u003e\r\n          \u003cbutton onClick={() =\u003e userActions.updateField('isEditing', false)}\u003e\r\n            Cancel\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ) : (\r\n        \u003cdiv\u003e\r\n          \u003cp\u003eName: {userState.name}\u003c/p\u003e\r\n          \u003cp\u003eEmail: {userState.email}\u003c/p\u003e\r\n          \u003cp\u003eAge: {userState.age}\u003c/p\u003e\r\n          \u003cbutton onClick={() =\u003e userActions.updateField('isEditing', true)}\u003e\r\n            Edit\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Common Pitfalls and Solutions**\r\n\r\n#### **Improper State Updates**\r\n```jsx\r\nfunction BadExample() {\r\n  function badReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'ADD_ITEM':\r\n        // Wrong: directly modifying original state object\r\n        state.items.push(action.item);\r\n        return state;\r\n      \r\n      case 'UPDATE_USER':\r\n        // Wrong: directly modifying nested object\r\n        state.user.name = action.name;\r\n        return state;\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n}\r\n\r\nfunction GoodExample() {\r\n  function goodReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'ADD_ITEM':\r\n        // Correct: create new state object\r\n        return {\r\n          ...state,\r\n          items: [...state.items, action.item]\r\n        };\r\n      \r\n      case 'UPDATE_USER':\r\n        // Correct: use spread operator to create new object\r\n        return {\r\n          ...state,\r\n          user: {\r\n            ...state.user,\r\n            name: action.name\r\n          }\r\n        };\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **Deep State Updates**\r\n```jsx\r\nfunction DeepUpdateExample() {\r\n  const initialState = {\r\n    user: {\r\n      profile: {\r\n        personal: {\r\n          name: '',\r\n          age: 0\r\n        },\r\n        contact: {\r\n          email: '',\r\n          phone: ''\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  function deepUpdateReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'UPDATE_PERSONAL_INFO':\r\n        return {\r\n          ...state,\r\n          user: {\r\n            ...state.user,\r\n            profile: {\r\n              ...state.user.profile,\r\n              personal: {\r\n                ...state.user.profile.personal,\r\n                [action.field]: action.value\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n      case 'UPDATE_CONTACT_INFO':\r\n        return {\r\n          ...state,\r\n          user: {\r\n            ...state.user,\r\n            profile: {\r\n              ...state.user.profile,\r\n              contact: {\r\n                ...state.user.profile.contact,\r\n                [action.field]: action.value\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(deepUpdateReducer, initialState);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        placeholder=\"Name\"\r\n        onChange={(e) =\u003e dispatch({\r\n          type: 'UPDATE_PERSONAL_INFO',\r\n          field: 'name',\r\n          value: e.target.value\r\n        })}\r\n      /\u003e\r\n      \u003cinput\r\n        placeholder=\"Email\"\r\n        onChange={(e) =\u003e dispatch({\r\n          type: 'UPDATE_CONTACT_INFO',\r\n          field: 'email',\r\n          value: e.target.value\r\n        })}\r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n1. **Pure functions**: Reducer must be pure functions with no side effects\r\n2. **Immutable updates**: Always return new state objects, don't modify original state\r\n3. **Action types**: Use constants to define action types to avoid typos\r\n4. **State structure**: Keep state structure flat to avoid deep nesting\r\n5. **Default case**: Handle default case in reducer, usually return original state\r\n6. **Error handling**: Throw errors or warn for unknown action types\r\n\r\n\r\n### **When to Use useReducer**\r\n- **Complex state logic**: Multiple related state values need to be updated together\r\n- **Complex state transitions**: Next state value depends on previous value\r\n- **Shared state across components**: Combined with useContext for global state management\r\n- **Predictable state updates**: Need clear state change history and debugging\r\n\r\n\r\n### **Important Considerations**\r\n- **Performance considerations**: Every dispatch triggers re-render\r\n- **Initialization cost**: useReducer initialization is slightly heavier than useState\r\n- **Learning curve**: Has some learning cost compared to useState\r\n- **Debugging complexity**: State change logic is centralized in reducer, requires good debugging tools\r\n\r\n`useReducer` is a powerful tool for managing complex state, especially suitable for scenarios with multiple sub-values or complex state transition logic.\r\n"])</script><script>self.__next_f.push([1,"1a:T531e,"])</script><script>self.__next_f.push([1,"\r\n`useRef` is a versatile Hook provided by React, primarily used to directly access DOM elements and store mutable values that persist across renders. Unlike state, updating ref values doesn't trigger component re-renders.\r\n\r\n\r\n### **Basic Purpose**\r\nThe main purposes of `useRef` are:\r\n- Get direct references to DOM elements for operations like focus, scrolling, etc.\r\n- Store mutable values that persist across renders without triggering re-renders\r\n- Cache previous values (such as previous props or state)\r\n- Store timers, subscription objects, and other instances\r\n- Create uncontrolled components\r\n\r\n```jsx\r\nimport React, { useRef, useEffect } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const inputRef = useRef(null);\r\n\r\n  useEffect(() =\u003e {\r\n    // Focus the input on component mount\r\n    inputRef.current.focus();\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput ref={inputRef} placeholder=\"This input will be focused\" /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Basic Syntax**\r\n```jsx\r\nconst refContainer = useRef(initialValue);\r\n```\r\n\r\n- **initialValue**: Initial value (usually `null` for DOM refs)\r\n- **Return value**: A ref object with a `current` property\r\n- **refContainer.current**: Contains the actual ref value\r\n\r\n\r\n### **DOM Element References**\r\n\r\n#### **Basic DOM Operations**\r\n```jsx\r\nfunction DOMOperations() {\r\n  const inputRef = useRef(null);\r\n  const divRef = useRef(null);\r\n\r\n  const focusInput = () =\u003e {\r\n    inputRef.current.focus();\r\n  };\r\n\r\n  const scrollToDiv = () =\u003e {\r\n    divRef.current.scrollIntoView({ behavior: 'smooth' });\r\n  };\r\n\r\n  const changeStyles = () =\u003e {\r\n    divRef.current.style.backgroundColor = 'lightblue';\r\n    divRef.current.style.color = 'darkblue';\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput ref={inputRef} placeholder=\"Click button to focus\" /\u003e\r\n      \u003cbutton onClick={focusInput}\u003eFocus Input\u003c/button\u003e\r\n      \r\n      \u003cdiv style={{ height: '200vh' }}\u003eSpacer content\u003c/div\u003e\r\n      \r\n      \u003cdiv ref={divRef} style={{ padding: '20px', border: '1px solid #ccc' }}\u003e\r\n        Target div for scrolling and styling\r\n      \u003c/div\u003e\r\n      \r\n      \u003cbutton onClick={scrollToDiv}\u003eScroll to Div\u003c/button\u003e\r\n      \u003cbutton onClick={changeStyles}\u003eChange Styles\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Form Input Management**\r\n```jsx\r\nfunction FormInputs() {\r\n  const nameRef = useRef(null);\r\n  const emailRef = useRef(null);\r\n  const passwordRef = useRef(null);\r\n\r\n  const handleSubmit = (e) =\u003e {\r\n    e.preventDefault();\r\n    \r\n    const formData = {\r\n      name: nameRef.current.value,\r\n      email: emailRef.current.value,\r\n      password: passwordRef.current.value\r\n    };\r\n    \r\n    console.log('Form data:', formData);\r\n  };\r\n\r\n  const clearForm = () =\u003e {\r\n    nameRef.current.value = '';\r\n    emailRef.current.value = '';\r\n    passwordRef.current.value = '';\r\n    nameRef.current.focus();\r\n  };\r\n\r\n  const validateEmail = () =\u003e {\r\n    const email = emailRef.current.value;\r\n    const isValid = email.includes('@');\r\n    \r\n    emailRef.current.style.borderColor = isValid ? 'green' : 'red';\r\n  };\r\n\r\n  return (\r\n    \u003cform onSubmit={handleSubmit}\u003e\r\n      \u003cdiv\u003e\r\n        \u003cinput\r\n          ref={nameRef}\r\n          placeholder=\"Name\"\r\n          required\r\n        /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003cinput\r\n          ref={emailRef}\r\n          type=\"email\"\r\n          placeholder=\"Email\"\r\n          onBlur={validateEmail}\r\n          required\r\n        /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003cinput\r\n          ref={passwordRef}\r\n          type=\"password\"\r\n          placeholder=\"Password\"\r\n          required\r\n        /\u003e\r\n      \u003c/div\u003e\r\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\r\n      \u003cbutton type=\"button\" onClick={clearForm}\u003eClear\u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Canvas and Media Element Control**\r\n\r\n#### **Canvas Drawing**\r\n```jsx\r\nfunction CanvasDrawing() {\r\n  const canvasRef = useRef(null);\r\n  const isDrawing = useRef(false);\r\n\r\n  useEffect(() =\u003e {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    // Set canvas size\r\n    canvas.width = 400;\r\n    canvas.height = 300;\r\n    \r\n    // Set drawing styles\r\n    ctx.strokeStyle = '#000';\r\n    ctx.lineWidth = 2;\r\n    ctx.lineCap = 'round';\r\n  }, []);\r\n\r\n  const startDrawing = (e) =\u003e {\r\n    isDrawing.current = true;\r\n    const canvas = canvasRef.current;\r\n    const rect = canvas.getBoundingClientRect();\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    ctx.beginPath();\r\n    ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);\r\n  };\r\n\r\n  const draw = (e) =\u003e {\r\n    if (!isDrawing.current) return;\r\n    \r\n    const canvas = canvasRef.current;\r\n    const rect = canvas.getBoundingClientRect();\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);\r\n    ctx.stroke();\r\n  };\r\n\r\n  const stopDrawing = () =\u003e {\r\n    isDrawing.current = false;\r\n  };\r\n\r\n  const clearCanvas = () =\u003e {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ccanvas\r\n        ref={canvasRef}\r\n        onMouseDown={startDrawing}\r\n        onMouseMove={draw}\r\n        onMouseUp={stopDrawing}\r\n        onMouseLeave={stopDrawing}\r\n        style={{ border: '1px solid #ccc', cursor: 'crosshair' }}\r\n      /\u003e\r\n      \u003cbr /\u003e\r\n      \u003cbutton onClick={clearCanvas}\u003eClear Canvas\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Video Player Control**\r\n```jsx\r\nfunction VideoPlayer({ src }) {\r\n  const videoRef = useRef(null);\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [currentTime, setCurrentTime] = useState(0);\r\n  const [duration, setDuration] = useState(0);\r\n\r\n  const togglePlay = () =\u003e {\r\n    const video = videoRef.current;\r\n    if (isPlaying) {\r\n      video.pause();\r\n    } else {\r\n      video.play();\r\n    }\r\n    setIsPlaying(!isPlaying);\r\n  };\r\n\r\n  const handleTimeUpdate = () =\u003e {\r\n    const video = videoRef.current;\r\n    setCurrentTime(video.currentTime);\r\n  };\r\n\r\n  const handleLoadedMetadata = () =\u003e {\r\n    const video = videoRef.current;\r\n    setDuration(video.duration);\r\n  };\r\n\r\n  const seekTo = (time) =\u003e {\r\n    const video = videoRef.current;\r\n    video.currentTime = time;\r\n    setCurrentTime(time);\r\n  };\r\n\r\n  const changePlaybackSpeed = (speed) =\u003e {\r\n    const video = videoRef.current;\r\n    video.playbackRate = speed;\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cvideo\r\n        ref={videoRef}\r\n        src={src}\r\n        onTimeUpdate={handleTimeUpdate}\r\n        onLoadedMetadata={handleLoadedMetadata}\r\n        width=\"400\"\r\n        height=\"300\"\r\n      /\u003e\r\n      \r\n      \u003cdiv\u003e\r\n        \u003cbutton onClick={togglePlay}\u003e\r\n          {isPlaying ? 'Pause' : 'Play'}\r\n        \u003c/button\u003e\r\n        \u003cbutton onClick={() =\u003e seekTo(0)}\u003eRestart\u003c/button\u003e\r\n        \u003cbutton onClick={() =\u003e changePlaybackSpeed(0.5)}\u003e0.5x\u003c/button\u003e\r\n        \u003cbutton onClick={() =\u003e changePlaybackSpeed(1)}\u003e1x\u003c/button\u003e\r\n        \u003cbutton onClick={() =\u003e changePlaybackSpeed(2)}\u003e2x\u003c/button\u003e\r\n      \u003c/div\u003e\r\n      \r\n      \u003cdiv\u003e\r\n        \u003cinput\r\n          type=\"range\"\r\n          min=\"0\"\r\n          max={duration}\r\n          value={currentTime}\r\n          onChange={(e) =\u003e seekTo(parseFloat(e.target.value))}\r\n        /\u003e\r\n        \u003cspan\u003e{Math.floor(currentTime)}s / {Math.floor(duration)}s\u003c/span\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Storing Mutable Values**\r\n\r\n#### **Value Persistence Without Re-renders**\r\n```jsx\r\nfunction MutableValues() {\r\n  const [count, setCount] = useState(0);\r\n  const renderCount = useRef(0);\r\n  const previousCount = useRef(null);\r\n\r\n  // Update render count on each render\r\n  renderCount.current += 1;\r\n\r\n  // Store previous count value\r\n  useEffect(() =\u003e {\r\n    previousCount.current = count;\r\n  });\r\n\r\n  const incrementCount = () =\u003e {\r\n    setCount(prev =\u003e prev + 1);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCurrent count: {count}\u003c/p\u003e\r\n      \u003cp\u003ePrevious count: {previousCount.current}\u003c/p\u003e\r\n      \u003cp\u003eRender count: {renderCount.current}\u003c/p\u003e\r\n      \u003cbutton onClick={incrementCount}\u003eIncrement\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Timer and Interval Management**\r\n```jsx\r\nfunction TimerComponent() {\r\n  const [seconds, setSeconds] = useState(0);\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const intervalRef = useRef(null);\r\n\r\n  const startTimer = () =\u003e {\r\n    if (!isRunning) {\r\n      setIsRunning(true);\r\n      intervalRef.current = setInterval(() =\u003e {\r\n        setSeconds(prev =\u003e prev + 1);\r\n      }, 1000);\r\n    }\r\n  };\r\n\r\n  const pauseTimer = () =\u003e {\r\n    setIsRunning(false);\r\n    if (intervalRef.current) {\r\n      clearInterval(intervalRef.current);\r\n      intervalRef.current = null;\r\n    }\r\n  };\r\n\r\n  const resetTimer = () =\u003e {\r\n    setSeconds(0);\r\n    setIsRunning(false);\r\n    if (intervalRef.current) {\r\n      clearInterval(intervalRef.current);\r\n      intervalRef.current = null;\r\n    }\r\n  };\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() =\u003e {\r\n    return () =\u003e {\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch2\u003eTimer: {seconds}s\u003c/h2\u003e\r\n      \u003cbutton onClick={startTimer} disabled={isRunning}\u003e\r\n        Start\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={pauseTimer} disabled={!isRunning}\u003e\r\n        Pause\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={resetTimer}\u003eReset\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Component Instance References**\r\n\r\n#### **Child Component Method Calls**\r\n```jsx\r\n// Child component with exposed methods\r\nconst ChildComponent = forwardRef((props, ref) =\u003e {\r\n  const [message, setMessage] = useState('');\r\n\r\n  // Expose methods to parent\r\n  useImperativeHandle(ref, () =\u003e ({\r\n    showMessage: (msg) =\u003e {\r\n      setMessage(msg);\r\n    },\r\n    clearMessage: () =\u003e {\r\n      setMessage('');\r\n    },\r\n    focus: () =\u003e {\r\n      // Additional operations can be performed here\r\n      console.log('Child component focused');\r\n    }\r\n  }));\r\n\r\n  return (\r\n    \u003cdiv style={{ border: '1px solid #ccc', padding: '10px' }}\u003e\r\n      \u003cp\u003eChild Component\u003c/p\u003e\r\n      {message \u0026\u0026 \u003cp style={{ color: 'blue' }}\u003eMessage: {message}\u003c/p\u003e}\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// Parent component\r\nfunction ParentComponent() {\r\n  const childRef = useRef(null);\r\n\r\n  const handleShowMessage = () =\u003e {\r\n    childRef.current.showMessage('Hello from parent!');\r\n  };\r\n\r\n  const handleClearMessage = () =\u003e {\r\n    childRef.current.clearMessage();\r\n  };\r\n\r\n  const handleFocusChild = () =\u003e {\r\n    childRef.current.focus();\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003eParent Component\u003c/h3\u003e\r\n      \u003cChildComponent ref={childRef} /\u003e\r\n      \u003cdiv\u003e\r\n        \u003cbutton onClick={handleShowMessage}\u003eShow Message\u003c/button\u003e\r\n        \u003cbutton onClick={handleClearMessage}\u003eClear Message\u003c/button\u003e\r\n        \u003cbutton onClick={handleFocusChild}\u003eFocus Child\u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Custom Hooks with useRef**\r\n\r\n#### **Previous Value Hook**\r\n```jsx\r\nfunction usePrevious(value) {\r\n  const ref = useRef();\r\n  \r\n  useEffect(() =\u003e {\r\n    ref.current = value;\r\n  });\r\n  \r\n  return ref.current;\r\n}\r\n\r\n// Usage example\r\nfunction CounterWithPrevious() {\r\n  const [count, setCount] = useState(0);\r\n  const previousCount = usePrevious(count);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCurrent: {count}\u003c/p\u003e\r\n      \u003cp\u003ePrevious: {previousCount}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Debounced Input Hook**\r\n```jsx\r\nfunction useDebounce(value, delay) {\r\n  const [debouncedValue, setDebouncedValue] = useState(value);\r\n  const timerRef = useRef(null);\r\n\r\n  useEffect(() =\u003e {\r\n    // Clear previous timer\r\n    if (timerRef.current) {\r\n      clearTimeout(timerRef.current);\r\n    }\r\n\r\n    // Set new timer\r\n    timerRef.current = setTimeout(() =\u003e {\r\n      setDebouncedValue(value);\r\n    }, delay);\r\n\r\n    // Cleanup\r\n    return () =\u003e {\r\n      if (timerRef.current) {\r\n        clearTimeout(timerRef.current);\r\n      }\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return debouncedValue;\r\n}\r\n\r\n// Usage example\r\nfunction SearchWithDebounce() {\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const debouncedSearchTerm = useDebounce(searchTerm, 500);\r\n\r\n  useEffect(() =\u003e {\r\n    if (debouncedSearchTerm) {\r\n      console.log('Searching for:', debouncedSearchTerm);\r\n      // Perform search operation\r\n    }\r\n  }, [debouncedSearchTerm]);\r\n\r\n  return (\r\n    \u003cinput\r\n      value={searchTerm}\r\n      onChange={(e) =\u003e setSearchTerm(e.target.value)}\r\n      placeholder=\"Search...\"\r\n    /\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Element Size Tracking Hook**\r\n```jsx\r\nfunction useElementSize() {\r\n  const ref = useRef(null);\r\n  const [size, setSize] = useState({ width: 0, height: 0 });\r\n\r\n  useEffect(() =\u003e {\r\n    const element = ref.current;\r\n    if (!element) return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) =\u003e {\r\n      const entry = entries[0];\r\n      setSize({\r\n        width: entry.contentRect.width,\r\n        height: entry.contentRect.height\r\n      });\r\n    });\r\n\r\n    resizeObserver.observe(element);\r\n\r\n    return () =\u003e {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  return [ref, size];\r\n}\r\n\r\n// Usage example\r\nfunction ResizableBox() {\r\n  const [ref, size] = useElementSize();\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\r\n        ref={ref}\r\n        style={{\r\n          resize: 'both',\r\n          overflow: 'auto',\r\n          width: '200px',\r\n          height: '100px',\r\n          border: '1px solid #ccc',\r\n          padding: '10px'\r\n        }}\r\n      \u003e\r\n        Resize me!\r\n      \u003c/div\u003e\r\n      \u003cp\u003eWidth: {size.width}px, Height: {size.height}px\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Performance Optimization**\r\n\r\n#### **Avoiding Unnecessary Re-renders**\r\n```jsx\r\nfunction ExpensiveComponent({ data }) {\r\n  const expensiveValue = useRef(null);\r\n  const previousData = useRef(null);\r\n\r\n  // Only recalculate when data actually changes\r\n  if (data !== previousData.current) {\r\n    expensiveValue.current = data.reduce((sum, item) =\u003e {\r\n      // Simulate expensive calculation\r\n      for (let i = 0; i \u003c 1000000; i++) {\r\n        sum += Math.random();\r\n      }\r\n      return sum + item.value;\r\n    }, 0);\r\n    previousData.current = data;\r\n  }\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eExpensive calculation result: {expensiveValue.current}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Callback Ref for Dynamic Updates**\r\n```jsx\r\nfunction DynamicList({ items }) {\r\n  const itemRefs = useRef([]);\r\n\r\n  // Callback ref function\r\n  const setItemRef = (element, index) =\u003e {\r\n    itemRefs.current[index] = element;\r\n  };\r\n\r\n  const scrollToItem = (index) =\u003e {\r\n    const element = itemRefs.current[index];\r\n    if (element) {\r\n      element.scrollIntoView({ behavior: 'smooth', block: 'center' });\r\n    }\r\n  };\r\n\r\n  const highlightItem = (index) =\u003e {\r\n    const element = itemRefs.current[index];\r\n    if (element) {\r\n      element.style.backgroundColor = 'yellow';\r\n      setTimeout(() =\u003e {\r\n        element.style.backgroundColor = '';\r\n      }, 1000);\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv style={{ marginBottom: '10px' }}\u003e\r\n        {items.map((_, index) =\u003e (\r\n          \u003cbutton\r\n            key={index}\r\n            onClick={() =\u003e scrollToItem(index)}\r\n            style={{ marginRight: '5px' }}\r\n          \u003e\r\n            Scroll to {index}\r\n          \u003c/button\u003e\r\n        ))}\r\n      \u003c/div\u003e\r\n      \r\n      \u003cdiv style={{ height: '200px', overflow: 'auto', border: '1px solid #ccc' }}\u003e\r\n        {items.map((item, index) =\u003e (\r\n          \u003cdiv\r\n            key={item.id}\r\n            ref={(el) =\u003e setItemRef(el, index)}\r\n            style={{ padding: '20px', borderBottom: '1px solid #eee' }}\r\n            onClick={() =\u003e highlightItem(index)}\r\n          \u003e\r\n            Item {index}: {item.name}\r\n          \u003c/div\u003e\r\n        ))}\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Advanced Usage Patterns**\r\n\r\n#### **Multi-Element References**\r\n```jsx\r\nfunction MultiElementRefs() {\r\n  const inputRefs = useRef([]);\r\n  const [focusedIndex, setFocusedIndex] = useState(0);\r\n\r\n  const addInputRef = (element, index) =\u003e {\r\n    inputRefs.current[index] = element;\r\n  };\r\n\r\n  const focusInput = (index) =\u003e {\r\n    const input = inputRefs.current[index];\r\n    if (input) {\r\n      input.focus();\r\n      setFocusedIndex(index);\r\n    }\r\n  };\r\n\r\n  const handleKeyDown = (e, index) =\u003e {\r\n    if (e.key === 'Enter') {\r\n      const nextIndex = (index + 1) % 3;\r\n      focusInput(nextIndex);\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003eMulti-Input Focus Management\u003c/h3\u003e\r\n      {[0, 1, 2].map((index) =\u003e (\r\n        \u003cdiv key={index}\u003e\r\n          \u003cinput\r\n            ref={(el) =\u003e addInputRef(el, index)}\r\n            placeholder={`Input ${index + 1}`}\r\n            onKeyDown={(e) =\u003e handleKeyDown(e, index)}\r\n            style={{\r\n              margin: '5px',\r\n              border: focusedIndex === index ? '2px solid blue' : '1px solid #ccc'\r\n            }}\r\n          /\u003e\r\n          \u003cbutton onClick={() =\u003e focusInput(index)}\u003e\r\n            Focus Input {index + 1}\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Ref Forwarding with Conditional Logic**\r\n```jsx\r\nconst SmartInput = forwardRef(({ label, type = 'text', ...props }, ref) =\u003e {\r\n  const internalRef = useRef(null);\r\n  const [isFocused, setIsFocused] = useState(false);\r\n\r\n  // Use provided ref or internal ref\r\n  const inputRef = ref || internalRef;\r\n\r\n  const handleFocus = () =\u003e {\r\n    setIsFocused(true);\r\n  };\r\n\r\n  const handleBlur = () =\u003e {\r\n    setIsFocused(false);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv style={{ margin: '10px 0' }}\u003e\r\n      \u003clabel style={{ \r\n        display: 'block', \r\n        color: isFocused ? 'blue' : 'black',\r\n        fontWeight: isFocused ? 'bold' : 'normal'\r\n      }}\u003e\r\n        {label}\r\n      \u003c/label\u003e\r\n      \u003cinput\r\n        ref={inputRef}\r\n        type={type}\r\n        onFocus={handleFocus}\r\n        onBlur={handleBlur}\r\n        style={{\r\n          border: isFocused ? '2px solid blue' : '1px solid #ccc',\r\n          borderRadius: '4px',\r\n          padding: '8px'\r\n        }}\r\n        {...props}\r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// Usage\r\nfunction SmartForm() {\r\n  const nameRef = useRef(null);\r\n  const emailRef = useRef(null);\r\n\r\n  const handleSubmit = (e) =\u003e {\r\n    e.preventDefault();\r\n    console.log('Name:', nameRef.current.value);\r\n    console.log('Email:', emailRef.current.value);\r\n  };\r\n\r\n  return (\r\n    \u003cform onSubmit={handleSubmit}\u003e\r\n      \u003cSmartInput ref={nameRef} label=\"Name\" placeholder=\"Enter your name\" /\u003e\r\n      \u003cSmartInput ref={emailRef} label=\"Email\" type=\"email\" placeholder=\"Enter your email\" /\u003e\r\n      \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e\r\n      \u003cbutton type=\"button\" onClick={() =\u003e nameRef.current.focus()}\u003e\r\n        Focus Name\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Common Pitfalls and Solutions**\r\n\r\n#### **Stale Closure Issues**\r\n```jsx\r\nfunction StaleClosureExample() {\r\n  const [count, setCount] = useState(0);\r\n  const latestCount = useRef(count);\r\n\r\n  // Update ref on each render\r\n  latestCount.current = count;\r\n\r\n  useEffect(() =\u003e {\r\n    const timer = setInterval(() =\u003e {\r\n      // Wrong: uses stale closure\r\n      console.log('Stale count:', count);\r\n      \r\n      // Correct: uses latest value\r\n      console.log('Latest count:', latestCount.current);\r\n    }, 1000);\r\n\r\n    return () =\u003e clearInterval(timer);\r\n  }, []); // Empty dependency array\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eCount: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Conditional Ref Assignment**\r\n```jsx\r\nfunction ConditionalRef({ showInput }) {\r\n  const inputRef = useRef(null);\r\n\r\n  const focusInput = () =\u003e {\r\n    // Check if ref exists before using\r\n    if (inputRef.current) {\r\n      inputRef.current.focus();\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {showInput \u0026\u0026 (\r\n        \u003cinput ref={inputRef} placeholder=\"Conditional input\" /\u003e\r\n      )}\r\n      \u003cbutton onClick={focusInput}\u003eFocus Input\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n1. **Initialize with null**: For DOM refs, always initialize with `null`\r\n2. **Check existence**: Always check if `ref.current` exists before using it\r\n3. **Cleanup**: Clear timers and subscriptions stored in refs\r\n4. **Avoid overuse**: Don't use refs for everything; prefer state for reactive values\r\n5. **Forward refs properly**: Use `forwardRef` when creating reusable components\r\n6. **Type safety**: In TypeScript, properly type your refs\r\n\r\n\r\n### **When to Use useRef**\r\n- **DOM manipulation**: When you need direct access to DOM elements\r\n- **Instance variables**: Values that need to persist but shouldn't trigger re-renders\r\n- **Previous values**: Storing previous props or state values\r\n- **Timers and subscriptions**: Storing timer IDs and subscription objects\r\n- **Performance optimization**: Avoiding expensive calculations or operations\r\n\r\n\r\n### **Important Considerations**\r\n- **No re-renders**: Changing `ref.current` doesn't trigger component re-renders\r\n- **Mutable object**: The ref object itself is mutable across renders\r\n- **Latest values**: Refs always contain the latest value (no stale closures)\r\n- **Cleanup responsibility**: Remember to cleanup timers and subscriptions stored in refs\r\n\r\n`useRef` is a powerful tool for direct DOM access and storing persistent values that don't require reactive updates.\r\n"])</script><script>self.__next_f.push([1,"1b:T4e8d,"])</script><script>self.__next_f.push([1,"\r\nTailwind CSS provides a powerful theme system that allows developers to create consistent and flexible design systems. Through theme configuration, you can customize colors, spacing, fonts, and other design tokens to build unique brand styles.\r\n\r\n\r\n### **Basic Purpose**\r\nTailwind CSS theme system mainly accomplishes:\r\n- Define consistent design tokens (colors, spacing, fonts, etc.)\r\n- Support dark/light mode switching\r\n- Create custom design systems\r\n- Provide responsive design support\r\n- Maintain design consistency across the entire project\r\n\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    colors: {\r\n      primary: '#3b82f6',\r\n      secondary: '#6b7280',\r\n      danger: '#ef4444',\r\n    },\r\n    spacing: {\r\n      '72': '18rem',\r\n      '84': '21rem',\r\n      '96': '24rem',\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Basic Configuration Structure**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  content: ['./src/**/*.{html,js,jsx,ts,tsx}'],\r\n  darkMode: 'class', // or 'media'\r\n  theme: {\r\n    extend: {\r\n      // Extend default theme\r\n      colors: {\r\n        // Custom colors\r\n      },\r\n      fontFamily: {\r\n        // Custom fonts\r\n      },\r\n      spacing: {\r\n        // Custom spacing\r\n      }\r\n    },\r\n    // Override default theme\r\n    screens: {\r\n      // Custom breakpoints\r\n    }\r\n  },\r\n  plugins: []\r\n}\r\n```\r\n\r\n\r\n### **Color System Configuration**\r\n\r\n#### **Basic Color Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        // Brand colors\r\n        brand: {\r\n          50: '#eff6ff',\r\n          100: '#dbeafe',\r\n          200: '#bfdbfe',\r\n          300: '#93c5fd',\r\n          400: '#60a5fa',\r\n          500: '#3b82f6', // Main brand color\r\n          600: '#2563eb',\r\n          700: '#1d4ed8',\r\n          800: '#1e40af',\r\n          900: '#1e3a8a',\r\n        },\r\n        \r\n        // Functional colors\r\n        success: '#10b981',\r\n        warning: '#f59e0b',\r\n        error: '#ef4444',\r\n        info: '#3b82f6',\r\n        \r\n        // Neutral colors\r\n        neutral: {\r\n          light: '#f8fafc',\r\n          DEFAULT: '#64748b',\r\n          dark: '#1e293b',\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **CSS Variables for Dynamic Colors**\r\n```css\r\n/* styles/globals.css */\r\n:root {\r\n  --color-primary: 59 130 246;\r\n  --color-secondary: 107 114 128;\r\n  --color-success: 16 185 129;\r\n  --color-warning: 245 158 11;\r\n  --color-error: 239 68 68;\r\n}\r\n\r\n[data-theme=\"dark\"] {\r\n  --color-primary: 96 165 250;\r\n  --color-secondary: 156 163 175;\r\n}\r\n```\r\n\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        primary: 'rgb(var(--color-primary) / \u003calpha-value\u003e)',\r\n        secondary: 'rgb(var(--color-secondary) / \u003calpha-value\u003e)',\r\n        success: 'rgb(var(--color-success) / \u003calpha-value\u003e)',\r\n        warning: 'rgb(var(--color-warning) / \u003calpha-value\u003e)',\r\n        error: 'rgb(var(--color-error) / \u003calpha-value\u003e)',\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Dark Mode Configuration**\r\n\r\n#### **Class-based Dark Mode**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  darkMode: 'class',\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        // Light mode colors\r\n        background: '#ffffff',\r\n        foreground: '#000000',\r\n        \r\n        // Dark mode will use dark: prefix\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```jsx\r\n// React component example\r\nfunction ThemeToggle() {\r\n  const [isDark, setIsDark] = useState(false);\r\n\r\n  const toggleTheme = () =\u003e {\r\n    setIsDark(!isDark);\r\n    document.documentElement.classList.toggle('dark');\r\n  };\r\n\r\n  return (\r\n    \u003cdiv className=\"bg-background text-foreground dark:bg-gray-900 dark:text-white\"\u003e\r\n      \u003cbutton\r\n        onClick={toggleTheme}\r\n        className=\"px-4 py-2 bg-primary text-white rounded-lg dark:bg-primary-dark\"\r\n      \u003e\r\n        {isDark ? 'Light Mode' : 'Dark Mode'}\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **Media Query-based Dark Mode**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  darkMode: 'media', // Automatically follows system preference\r\n  // Configuration remains the same\r\n}\r\n```\r\n\r\n```css\r\n/* Automatically applies based on system preference */\r\n.card {\r\n  @apply bg-white dark:bg-gray-800;\r\n  @apply text-gray-900 dark:text-gray-100;\r\n}\r\n```\r\n\r\n\r\n### **Typography System**\r\n\r\n#### **Custom Font Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      fontFamily: {\r\n        // Custom font families\r\n        'sans': ['Inter', 'system-ui', 'sans-serif'],\r\n        'serif': ['Merriweather', 'Georgia', 'serif'],\r\n        'mono': ['Fira Code', 'Monaco', 'monospace'],\r\n        \r\n        // Brand fonts\r\n        'brand': ['Poppins', 'sans-serif'],\r\n        'heading': ['Playfair Display', 'serif'],\r\n      },\r\n      \r\n      fontSize: {\r\n        // Custom font sizes\r\n        'xs': ['0.75rem', { lineHeight: '1rem' }],\r\n        'sm': ['0.875rem', { lineHeight: '1.25rem' }],\r\n        'base': ['1rem', { lineHeight: '1.5rem' }],\r\n        'lg': ['1.125rem', { lineHeight: '1.75rem' }],\r\n        'xl': ['1.25rem', { lineHeight: '1.75rem' }],\r\n        \r\n        // Display sizes\r\n        'display-sm': ['2.5rem', { lineHeight: '3rem', fontWeight: '700' }],\r\n        'display-md': ['3rem', { lineHeight: '3.5rem', fontWeight: '700' }],\r\n        'display-lg': ['4rem', { lineHeight: '4.5rem', fontWeight: '800' }],\r\n      },\r\n      \r\n      fontWeight: {\r\n        'light': 300,\r\n        'normal': 400,\r\n        'medium': 500,\r\n        'semibold': 600,\r\n        'bold': 700,\r\n        'extrabold': 800,\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **Typography Component Classes**\r\n```css\r\n/* styles/components.css */\r\n@layer components {\r\n  .heading-1 {\r\n    @apply text-display-lg font-heading font-extrabold text-gray-900 dark:text-white;\r\n  }\r\n  \r\n  .heading-2 {\r\n    @apply text-display-md font-heading font-bold text-gray-800 dark:text-gray-100;\r\n  }\r\n  \r\n  .body-large {\r\n    @apply text-lg font-sans text-gray-700 dark:text-gray-300 leading-relaxed;\r\n  }\r\n  \r\n  .body-small {\r\n    @apply text-sm font-sans text-gray-600 dark:text-gray-400;\r\n  }\r\n  \r\n  .caption {\r\n    @apply text-xs font-medium text-gray-500 dark:text-gray-500 uppercase tracking-wide;\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Spacing and Layout System**\r\n\r\n#### **Custom Spacing Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      spacing: {\r\n        // Custom spacing values\r\n        '18': '4.5rem',\r\n        '72': '18rem',\r\n        '84': '21rem',\r\n        '96': '24rem',\r\n        \r\n        // Design system spacing\r\n        'xs': '0.5rem',    // 8px\r\n        'sm': '1rem',      // 16px\r\n        'md': '1.5rem',    // 24px\r\n        'lg': '2rem',      // 32px\r\n        'xl': '3rem',      // 48px\r\n        '2xl': '4rem',     // 64px\r\n        '3xl': '6rem',     // 96px\r\n      },\r\n      \r\n      maxWidth: {\r\n        'container': '1200px',\r\n        'content': '800px',\r\n        'sidebar': '300px',\r\n      },\r\n      \r\n      minHeight: {\r\n        'screen-75': '75vh',\r\n        'screen-50': '50vh',\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **Container Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    container: {\r\n      center: true,\r\n      padding: {\r\n        DEFAULT: '1rem',\r\n        sm: '2rem',\r\n        lg: '4rem',\r\n        xl: '5rem',\r\n        '2xl': '6rem',\r\n      },\r\n      screens: {\r\n        sm: '640px',\r\n        md: '768px',\r\n        lg: '1024px',\r\n        xl: '1280px',\r\n        '2xl': '1400px',\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Responsive Design Configuration**\r\n\r\n#### **Custom Breakpoints**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    screens: {\r\n      'xs': '475px',\r\n      'sm': '640px',\r\n      'md': '768px',\r\n      'lg': '1024px',\r\n      'xl': '1280px',\r\n      '2xl': '1536px',\r\n      \r\n      // Custom breakpoints\r\n      'tablet': '768px',\r\n      'laptop': '1024px',\r\n      'desktop': '1280px',\r\n      \r\n      // Maximum width breakpoints\r\n      'max-sm': {'max': '639px'},\r\n      'max-md': {'max': '767px'},\r\n      'max-lg': {'max': '1023px'},\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **Responsive Typography**\r\n```css\r\n/* Responsive text classes */\r\n@layer components {\r\n  .responsive-heading {\r\n    @apply text-2xl md:text-4xl lg:text-6xl;\r\n    @apply font-bold leading-tight;\r\n  }\r\n  \r\n  .responsive-body {\r\n    @apply text-sm md:text-base lg:text-lg;\r\n    @apply leading-relaxed;\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Component Patterns**\r\n\r\n#### **Button System**\r\n```css\r\n/* styles/components.css */\r\n@layer components {\r\n  .btn {\r\n    @apply inline-flex items-center justify-center;\r\n    @apply px-4 py-2 rounded-lg font-medium;\r\n    @apply transition-all duration-200;\r\n    @apply focus:outline-none focus:ring-2 focus:ring-offset-2;\r\n  }\r\n  \r\n  .btn-primary {\r\n    @apply btn;\r\n    @apply bg-primary text-white;\r\n    @apply hover:bg-primary-600 focus:ring-primary-500;\r\n    @apply dark:bg-primary-400 dark:hover:bg-primary-500;\r\n  }\r\n  \r\n  .btn-secondary {\r\n    @apply btn;\r\n    @apply bg-gray-200 text-gray-900;\r\n    @apply hover:bg-gray-300 focus:ring-gray-500;\r\n    @apply dark:bg-gray-700 dark:text-gray-100 dark:hover:bg-gray-600;\r\n  }\r\n  \r\n  .btn-outline {\r\n    @apply btn;\r\n    @apply border-2 border-primary text-primary bg-transparent;\r\n    @apply hover:bg-primary hover:text-white;\r\n    @apply focus:ring-primary-500;\r\n  }\r\n  \r\n  .btn-lg {\r\n    @apply px-6 py-3 text-lg;\r\n  }\r\n  \r\n  .btn-sm {\r\n    @apply px-3 py-1 text-sm;\r\n  }\r\n}\r\n```\r\n\r\n#### **Card Components**\r\n```css\r\n@layer components {\r\n  .card {\r\n    @apply bg-white rounded-lg shadow-md;\r\n    @apply dark:bg-gray-800 dark:shadow-lg;\r\n    @apply border border-gray-200 dark:border-gray-700;\r\n  }\r\n  \r\n  .card-header {\r\n    @apply px-6 py-4 border-b border-gray-200 dark:border-gray-700;\r\n  }\r\n  \r\n  .card-body {\r\n    @apply px-6 py-4;\r\n  }\r\n  \r\n  .card-footer {\r\n    @apply px-6 py-4 border-t border-gray-200 dark:border-gray-700;\r\n    @apply bg-gray-50 dark:bg-gray-750 rounded-b-lg;\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Advanced Theme Configuration**\r\n\r\n#### **Animation and Transition System**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      animation: {\r\n        // Custom animations\r\n        'fade-in': 'fadeIn 0.5s ease-in-out',\r\n        'slide-up': 'slideUp 0.3s ease-out',\r\n        'bounce-subtle': 'bounceSubtle 2s infinite',\r\n        'pulse-slow': 'pulse 3s infinite',\r\n      },\r\n      \r\n      keyframes: {\r\n        fadeIn: {\r\n          '0%': { opacity: '0' },\r\n          '100%': { opacity: '1' },\r\n        },\r\n        slideUp: {\r\n          '0%': { transform: 'translateY(20px)', opacity: '0' },\r\n          '100%': { transform: 'translateY(0)', opacity: '1' },\r\n        },\r\n        bounceSubtle: {\r\n          '0%, 100%': { transform: 'translateY(0)' },\r\n          '50%': { transform: 'translateY(-5px)' },\r\n        },\r\n      },\r\n      \r\n      transitionDuration: {\r\n        '400': '400ms',\r\n        '600': '600ms',\r\n        '800': '800ms',\r\n        '1200': '1200ms',\r\n      },\r\n      \r\n      transitionTimingFunction: {\r\n        'in-expo': 'cubic-bezier(0.95, 0.05, 0.795, 0.035)',\r\n        'out-expo': 'cubic-bezier(0.19, 1, 0.22, 1)',\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **Shadow and Border System**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      boxShadow: {\r\n        // Custom shadows\r\n        'subtle': '0 1px 3px rgba(0, 0, 0, 0.05)',\r\n        'card': '0 4px 6px -1px rgba(0, 0, 0, 0.1)',\r\n        'large': '0 10px 25px -3px rgba(0, 0, 0, 0.1)',\r\n        'inner-subtle': 'inset 0 1px 2px rgba(0, 0, 0, 0.05)',\r\n        \r\n        // Colored shadows\r\n        'primary': '0 4px 14px 0 rgba(59, 130, 246, 0.25)',\r\n        'success': '0 4px 14px 0 rgba(16, 185, 129, 0.25)',\r\n        'warning': '0 4px 14px 0 rgba(245, 158, 11, 0.25)',\r\n        'danger': '0 4px 14px 0 rgba(239, 68, 68, 0.25)',\r\n      },\r\n      \r\n      borderRadius: {\r\n        'xl': '1rem',\r\n        '2xl': '1.5rem',\r\n        '3xl': '2rem',\r\n      },\r\n      \r\n      borderWidth: {\r\n        '3': '3px',\r\n        '5': '5px',\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Theme Switching Implementation**\r\n\r\n#### **React Theme Provider**\r\n```jsx\r\n// contexts/ThemeContext.js\r\nimport React, { createContext, useContext, useEffect, useState } from 'react';\r\n\r\nconst ThemeContext = createContext();\r\n\r\nexport function ThemeProvider({ children }) {\r\n  const [theme, setTheme] = useState('light');\r\n\r\n  useEffect(() =\u003e {\r\n    // Get theme from localStorage or system preference\r\n    const savedTheme = localStorage.getItem('theme');\r\n    const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\r\n    const initialTheme = savedTheme || systemTheme;\r\n    \r\n    setTheme(initialTheme);\r\n    document.documentElement.classList.toggle('dark', initialTheme === 'dark');\r\n  }, []);\r\n\r\n  const toggleTheme = () =\u003e {\r\n    const newTheme = theme === 'light' ? 'dark' : 'light';\r\n    setTheme(newTheme);\r\n    localStorage.setItem('theme', newTheme);\r\n    document.documentElement.classList.toggle('dark', newTheme === 'dark');\r\n  };\r\n\r\n  const setLightTheme = () =\u003e {\r\n    setTheme('light');\r\n    localStorage.setItem('theme', 'light');\r\n    document.documentElement.classList.remove('dark');\r\n  };\r\n\r\n  const setDarkTheme = () =\u003e {\r\n    setTheme('dark');\r\n    localStorage.setItem('theme', 'dark');\r\n    document.documentElement.classList.add('dark');\r\n  };\r\n\r\n  return (\r\n    \u003cThemeContext.Provider value={{\r\n      theme,\r\n      toggleTheme,\r\n      setLightTheme,\r\n      setDarkTheme,\r\n      isDark: theme === 'dark'\r\n    }}\u003e\r\n      {children}\r\n    \u003c/ThemeContext.Provider\u003e\r\n  );\r\n}\r\n\r\nexport const useTheme = () =\u003e {\r\n  const context = useContext(ThemeContext);\r\n  if (!context) {\r\n    throw new Error('useTheme must be used within ThemeProvider');\r\n  }\r\n  return context;\r\n};\r\n```\r\n\r\n#### **Theme Toggle Component**\r\n```jsx\r\n// components/ThemeToggle.jsx\r\nimport React from 'react';\r\nimport { useTheme } from '../contexts/ThemeContext';\r\n\r\nfunction ThemeToggle() {\r\n  const { theme, toggleTheme, isDark } = useTheme();\r\n\r\n  return (\r\n    \u003cbutton\r\n      onClick={toggleTheme}\r\n      className={`\r\n        relative inline-flex items-center h-6 rounded-full w-11 \r\n        transition-colors duration-200 ease-in-out\r\n        ${isDark ? 'bg-blue-600' : 'bg-gray-300'}\r\n        focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500\r\n      `}\r\n      aria-label=\"Toggle theme\"\r\n    \u003e\r\n      \u003cspan\r\n        className={`\r\n          inline-block w-4 h-4 transform transition-transform duration-200 ease-in-out\r\n          bg-white rounded-full shadow-lg\r\n          ${isDark ? 'translate-x-6' : 'translate-x-1'}\r\n        `}\r\n      /\u003e\r\n      \r\n      {/* Icons */}\r\n      \u003cspan className=\"absolute left-1 top-1\"\u003e\r\n        {isDark ? '🌙' : '☀️'}\r\n      \u003c/span\u003e\r\n    \u003c/button\u003e\r\n  );\r\n}\r\n\r\nexport default ThemeToggle;\r\n```\r\n\r\n\r\n### **Multi-theme Support**\r\n\r\n#### **Multiple Theme Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        // Theme-specific colors using CSS variables\r\n        primary: 'var(--color-primary)',\r\n        secondary: 'var(--color-secondary)',\r\n        accent: 'var(--color-accent)',\r\n        background: 'var(--color-background)',\r\n        surface: 'var(--color-surface)',\r\n        text: 'var(--color-text)',\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n```css\r\n/* styles/themes.css */\r\n:root {\r\n  /* Default light theme */\r\n  --color-primary: #3b82f6;\r\n  --color-secondary: #6b7280;\r\n  --color-accent: #10b981;\r\n  --color-background: #ffffff;\r\n  --color-surface: #f8fafc;\r\n  --color-text: #1f2937;\r\n}\r\n\r\n[data-theme=\"dark\"] {\r\n  --color-primary: #60a5fa;\r\n  --color-secondary: #9ca3af;\r\n  --color-accent: #34d399;\r\n  --color-background: #111827;\r\n  --color-surface: #1f2937;\r\n  --color-text: #f9fafb;\r\n}\r\n\r\n[data-theme=\"blue\"] {\r\n  --color-primary: #1e40af;\r\n  --color-secondary: #3730a3;\r\n  --color-accent: #0ea5e9;\r\n  --color-background: #eff6ff;\r\n  --color-surface: #dbeafe;\r\n  --color-text: #1e3a8a;\r\n}\r\n\r\n[data-theme=\"green\"] {\r\n  --color-primary: #059669;\r\n  --color-secondary: #047857;\r\n  --color-accent: #10b981;\r\n  --color-background: #ecfdf5;\r\n  --color-surface: #d1fae5;\r\n  --color-text: #064e3b;\r\n}\r\n```\r\n\r\n\r\n### **Performance Optimization**\r\n\r\n#### **Purge CSS Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  content: [\r\n    './src/**/*.{js,jsx,ts,tsx}',\r\n    './public/index.html',\r\n    './components/**/*.{js,jsx,ts,tsx}',\r\n  ],\r\n  \r\n  // Safe list for dynamic classes\r\n  safelist: [\r\n    'bg-red-500',\r\n    'text-blue-600',\r\n    {\r\n      pattern: /bg-(red|green|blue)-(100|200|300|400|500|600|700|800|900)/,\r\n      variants: ['hover', 'focus', 'dark'],\r\n    },\r\n  ],\r\n  \r\n  theme: {\r\n    // Theme configuration\r\n  }\r\n}\r\n```\r\n\r\n#### **JIT Mode Configuration**\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  mode: 'jit', // Just-in-Time mode\r\n  purge: {\r\n    content: ['./src/**/*.{html,js,jsx,ts,tsx}'],\r\n    options: {\r\n      safelist: ['dark'], // Preserve dark mode class\r\n    }\r\n  },\r\n  \r\n  theme: {\r\n    extend: {\r\n      // Your theme extensions\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Best Practices**\r\n\r\n#### **Design Token Organization**\r\n```javascript\r\n// config/design-tokens.js\r\nconst colors = {\r\n  brand: {\r\n    primary: '#3b82f6',\r\n    secondary: '#6b7280',\r\n    accent: '#10b981',\r\n  },\r\n  semantic: {\r\n    success: '#10b981',\r\n    warning: '#f59e0b',\r\n    error: '#ef4444',\r\n    info: '#3b82f6',\r\n  },\r\n  neutral: {\r\n    50: '#f8fafc',\r\n    100: '#f1f5f9',\r\n    // ... more neutral colors\r\n    900: '#0f172a',\r\n  }\r\n};\r\n\r\nconst spacing = {\r\n  xs: '0.5rem',\r\n  sm: '1rem',\r\n  md: '1.5rem',\r\n  lg: '2rem',\r\n  xl: '3rem',\r\n  '2xl': '4rem',\r\n};\r\n\r\nconst typography = {\r\n  fontFamily: {\r\n    sans: ['Inter', 'system-ui', 'sans-serif'],\r\n    serif: ['Merriweather', 'Georgia', 'serif'],\r\n    mono: ['Fira Code', 'monospace'],\r\n  },\r\n  fontSize: {\r\n    'xs': ['0.75rem', '1rem'],\r\n    'sm': ['0.875rem', '1.25rem'],\r\n    'base': ['1rem', '1.5rem'],\r\n    'lg': ['1.125rem', '1.75rem'],\r\n    'xl': ['1.25rem', '1.75rem'],\r\n  }\r\n};\r\n\r\nmodule.exports = { colors, spacing, typography };\r\n```\r\n\r\n```javascript\r\n// tailwind.config.js\r\nconst { colors, spacing, typography } = require('./config/design-tokens');\r\n\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      colors,\r\n      spacing,\r\n      ...typography,\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **Common Pitfalls and Solutions**\r\n\r\n#### **CSS Variable Fallbacks**\r\n```css\r\n/* Provide fallbacks for CSS variables */\r\n.element {\r\n  background-color: #3b82f6; /* Fallback */\r\n  background-color: var(--color-primary, #3b82f6);\r\n}\r\n```\r\n\r\n#### **Dark Mode Flashing**\r\n```html\r\n\u003c!-- Prevent flash of unstyled content --\u003e\r\n\u003cscript\u003e\r\n  (function() {\r\n    const theme = localStorage.getItem('theme') || \r\n      (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');\r\n    \r\n    if (theme === 'dark') {\r\n      document.documentElement.classList.add('dark');\r\n    }\r\n  })();\r\n\u003c/script\u003e\r\n```\r\n\r\n#### **Dynamic Class Generation**\r\n```jsx\r\n// Wrong: Dynamic classes might be purged\r\nconst getButtonColor = (color) =\u003e `bg-${color}-500`;\r\n\r\n// Right: Use safelist or complete class names\r\nconst getButtonColor = (color) =\u003e {\r\n  const colors = {\r\n    blue: 'bg-blue-500',\r\n    red: 'bg-red-500',\r\n    green: 'bg-green-500',\r\n  };\r\n  return colors[color] || 'bg-gray-500';\r\n};\r\n```\r\n\r\n\r\n### **Important Considerations**\r\n- **Performance**: Use JIT mode and proper purging to minimize CSS bundle size\r\n- **Accessibility**: Ensure sufficient color contrast in all themes\r\n- **System preferences**: Respect user's system color scheme preferences\r\n- **Progressive enhancement**: Provide fallbacks for CSS variables\r\n- **Consistency**: Use design tokens consistently across the entire project\r\n\r\nTailwind CSS theme system provides powerful tools for creating consistent, maintainable, and flexible design systems that can adapt to various requirements and user preferences.\r\n"])</script><script>self.__next_f.push([1,"1c:T50d9,"])</script><script>self.__next_f.push([1,"\r\n# Binary Rain Curtain: A Glimpse into the Machine Computing World\r\n\r\nSomehow thinking of \"The Matrix\" when creating the background led to this.\r\n\r\nThis article will dissect every line of code from character grid to radial masking, completely deconstructing this visual effect that gives the mouse cursor \"illumination magic.\"\r\n\r\n## Canvas Initialization: Building the Digital Stage\r\n\r\nThe importance of Canvas in frontend graphics cannot be overstated—it serves as the canvas that carries the entire background.\r\n\r\n### Precise Adaptation of Responsive Canvas\r\n\r\n```12:25:src/components/ui/background/BinaryRainBackground.tsx\r\nconst resizeCanvas = useCallback(() =\u003e {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n\r\n    // Generate particles grid\r\n    const binaryChars = ['0', '1'];\r\n    const gridSize = 20;\r\n    particlesRef.current = [];\r\n}, []);\r\n```\r\n\r\n**getBoundingClientRect Precise Positioning**:\r\n\r\nThis seemingly simple method is actually a precision instrument in the Web API, returning not just the element's position, but a complete report containing all spatial information:\r\n- **Absolute Position**: Precise coordinates relative to the viewport\r\n- **Actual Dimensions**: Real size after CSS transformations\r\n- **Boundary Information**: Including all layout-affecting factors like border, padding, etc.\r\n\r\n**Why set canvas.width directly instead of CSS styles?**\r\n\r\n```typescript\r\ncanvas.width = rect.width;   // Set the actual resolution of the canvas\r\n// Instead of:\r\n// canvas.style.width = rect.width + 'px';  // Just visual scaling\r\n```\r\n\r\nThis is a classic trap in Canvas development! CSS dimensions are just visual scaling, while canvas.width sets the actual pixel resolution. If you only set CSS dimensions, you'll get a blurry mess like looking at pixel games through a magnifying glass.\r\n\r\n### Grid Generation: 20-Pixel Mathematical Art\r\n\r\n```26:39:src/components/ui/background/BinaryRainBackground.tsx\r\n// Generate particles grid\r\nconst binaryChars = ['0', '1'];\r\nconst gridSize = 20;\r\nparticlesRef.current = [];\r\n\r\nfor (let y = 0; y \u003c canvas.height; y += gridSize) {\r\n    for (let x = 0; x \u003c canvas.width; x += gridSize) {\r\n        particlesRef.current.push({\r\n            x,\r\n            y,\r\n            char: binaryChars[Math.floor(Math.random() * 2)]\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**Why choose a 20-pixel grid?** ~~(Mainly because other pixel values don't look as good visually)~~\r\n\r\n- **Too small (like 10px)**: Character density too high, GPU cries, frame rate dives 💔\r\n- **Too large (like 40px)**: Characters sparse, looks like scattered stars rather than matrix rain\r\n- **20px just right**: Ensures sufficient visual density without obvious lag\r\n\r\n**Mathematical estimation of character count**:\r\n\r\nFor a full-screen 1920×1080 display:\r\n$$Character\\ Count = \\frac{1920}{20} \\times \\frac{1080}{20} = 96 \\times 54 = 5184\\ characters$$\r\n\r\nEach character object contains 3 properties (x, y, char), occupying about 24 bytes in JavaScript, with total memory usage around 124KB—completely within controllable range!\r\n\r\n### Minimalist Design of Character Objects\r\n\r\n```typescript\r\ninterface ParticleData {\r\n    x: number;\r\n    y: number;\r\n    char: string;\r\n}\r\n```\r\n\r\nThis interface design embodies the \"Less is More\" philosophy:\r\n- **x, y**: Absolute position of the character in the grid\r\n- **char**: Currently displayed character ('0' or '1')\r\n- **No color**: Uniformly uses theme color, reducing memory usage\r\n- **No velocity**: Fixed position, no need for velocity property\r\n- **No lifecycle**: Characters are eternal, only content changes\r\n\r\n### Continuous Injection of Randomness\r\n\r\n```93:96:src/components/ui/background/BinaryRainBackground.tsx\r\nconst updateCharacters = useCallback(() =\u003e {\r\n    particlesRef.current.forEach(p =\u003e {\r\n        p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n    });\r\n}, []);\r\n```\r\n\r\nAttempts to reset the display character of each character object every second.\r\n\r\n## Animation Rendering: Visual Feast of Light and Shadow\r\n\r\nThe core of Canvas animation lies in the rendering loop, and our binary rain curtain uses some clever tricks to create unique visual effects.\r\n\r\n## Mouse Tracking and Radial Masking\r\n\r\n\"Mouse Spotlight and Character Matrix\"\r\n\r\n### Coordinate Transformation\r\n\r\n```45:51:src/components/ui/background/BinaryRainBackground.tsx\r\n// Mouse move event: update mouse coordinates\r\nthis.canvas.addEventListener('mousemove', (e) =\u003e {\r\n    const rect = this.canvas.getBoundingClientRect();\r\n    // Convert screen coordinates to Canvas coordinates\r\n    this.mouseX = e.clientX - rect.left;\r\n    this.mouseY = e.clientY - rect.top;\r\n});\r\n```\r\n\r\n**Mathematical transformation of coordinate systems**:\r\n\r\nMultiple coordinate systems exist in browsers:\r\n- **Screen coordinate system**: `e.clientX, e.clientY` (relative to viewport)\r\n- **Page coordinate system**: `e.pageX, e.pageY` (relative to entire page)\r\n- **Canvas coordinate system**: `mouseX, mouseY` (relative to canvas)\r\n\r\nTransformation formula:\r\n$$Canvas_{x} = Screen_{x} - Canvas_{offsetX}$$\r\n$$Canvas_{y} = Screen_{y} - Canvas_{offsetY}$$\r\n\r\nWhere `rect.left` and `rect.top` are the Canvas offsets relative to the viewport.\r\n\r\n### Radial Gradient\r\n\r\n```78:85:src/components/ui/background/BinaryRainBackground.tsx\r\n// Create mask\r\nctx.globalCompositeOperation = 'destination-in';\r\nconst gradient = ctx.createRadialGradient(\r\n    mousePosRef.current.x, mousePosRef.current.y, 0,\r\n    mousePosRef.current.x, mousePosRef.current.y, 200\r\n);\r\ngradient.addColorStop(0, 'rgba(255, 255, 255, 1)');\r\ngradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\r\n```\r\n\r\n**Geometric principles of radial gradient**:\r\n\r\n`createRadialGradient` creates a gradient from inner circle to outer circle:\r\n- **Inner circle**: Radius 0, position (mouseX, mouseY), completely opaque\r\n- **Outer circle**: Radius 200, position (mouseX, mouseY), completely transparent\r\n\r\nMathematical expression:\r\n$$Opacity(r) = \\begin{cases}\r\n1 \u0026 \\text{if } r = 0 \\\\\r\n1 - \\frac{r}{200} \u0026 \\text{if } 0 \u003c r \u003c 200 \\\\\r\n0 \u0026 \\text{if } r \\geq 200\r\n\\end{cases}$$\r\n\r\nWhere $r = \\sqrt{(x-mouseX)^2 + (y-mouseY)^2}$ is the distance from pixel to mouse.\r\n\r\n### destination-in Blending Mode\r\n\r\n```typescript\r\nctx.globalCompositeOperation = 'destination-in';\r\n```\r\n\r\n**Working principle**:\r\n1. **destination**: Content already drawn on canvas (our characters)\r\n2. **source**: Newly drawn content (radial gradient mask)\r\n3. **destination-in**: Only keeps the part of destination that overlaps with source and where source is opaque\r\n\r\n**Specific explanation of destination-in blending mode algorithm:**\r\n\r\n```typescript\r\n// Pseudocode\r\nfor (each pixel(x, y)) {\r\n    const characterOpacity = destination[x][y].alpha;    // Original opacity of character\r\n    const gradientOpacity = source[x][y].alpha;         // Opacity of radial gradient\r\n    \r\n    // destination-in blending formula\r\n    finalOpacity = characterOpacity * gradientOpacity;\r\n    \r\n    // If gradient is transparent at this position (alpha=0), character becomes transparent\r\n    // If gradient is opaque at this position (alpha=1), character remains as is\r\n}\r\n```\r\n\r\n**Visual effect**:\r\n\r\n- Gradient center (opaque): Characters fully visible\r\n- Gradient edge (transparent): Characters completely hidden\r\n- Gradient middle (semi-transparent): Characters partially visible\r\n\r\n## Character Updates: Double-Barrel Approach\r\n\r\nBinary rain curtain uses a dual timeline system, separately handling update and rendering responsibilities.\r\n\r\n### Division of Labor between Timer and Animation Frames\r\n\r\n```98:102:src/components/ui/background/BinaryRainBackground.tsx\r\n// Character update interval\r\nintervalIdRef.current = setInterval(updateCharacters, 1000);\r\n```\r\n\r\n```107:115:src/components/ui/background/BinaryRainBackground.tsx\r\nconst animate = useCallback(() =\u003e {\r\n    // ... rendering logic\r\n    animationIdRef.current = requestAnimationFrame(animate);\r\n}, [color]);\r\n```\r\n\r\n**Why use two timing systems?**\r\n\r\nThis is a classic separation strategy for performance optimization:\r\n\r\n**setInterval (1000ms) - Content Updates**:\r\n- Updates character content\r\n- Relatively low frequency\r\n- No need to sync with screen refresh\r\n\r\n**requestAnimationFrame (~16.67ms) - Visual Rendering**:\r\n- Draws current frame\r\n- Syncs with screen refresh rate\r\n- Automatically pauses when page is not visible\r\n\r\n### Memory-Friendly Character Updates\r\n\r\n```93:96:src/components/ui/background/BinaryRainBackground.tsx\r\nconst updateCharacters = useCallback(() =\u003e {\r\n    particlesRef.current.forEach(p =\u003e {\r\n        p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n    });\r\n}, []);\r\n```\r\n\r\n**Why not recreate objects?**\r\n\r\nWrong approach:\r\n```typescript\r\n// ❌ Creates lots of garbage objects\r\nparticlesRef.current = particlesRef.current.map(p =\u003e ({\r\n    ...p,\r\n    char: ['0', '1'][Math.floor(Math.random() * 2)]\r\n}));\r\n```\r\n\r\nCorrect approach:\r\n```typescript\r\n// ✅ Directly modify properties, zero garbage generation\r\nparticlesRef.current.forEach(p =\u003e {\r\n    p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n});\r\n```\r\n\r\nAdvantages of this approach:\r\n- **Zero memory allocation**: No new objects created\r\n- **Garbage collection friendly**: Reduces GC pressure\r\n- **Stable performance**: Avoids frame rate fluctuations\r\n\r\n## Performance Optimization\r\n\r\nThe usual three optimization strategies, but let's write them anyway.\r\n\r\n### useCallback Caching\r\n\r\n```12:40:src/components/ui/background/BinaryRainBackground.tsx\r\nconst resizeCanvas = useCallback(() =\u003e {\r\n    // ... size adjustment logic\r\n}, []);\r\n\r\nconst updateMousePos = useCallback((e: MouseEvent) =\u003e {\r\n    // ... mouse position update\r\n}, []);\r\n\r\nconst animate = useCallback(() =\u003e {\r\n    // ... animation loop\r\n}, [color]);\r\n\r\nconst updateCharacters = useCallback(() =\u003e {\r\n    // ... character update\r\n}, []);\r\n```\r\n\r\n**Problems without useCallback**:\r\n```typescript\r\n// ❌ Creates new functions on every render\r\nuseEffect(() =\u003e {\r\n    const animate = () =\u003e { /* ... */ };  // New function reference\r\n    requestAnimationFrame(animate);\r\n}, [color]);  // Creates animate repeatedly when color changes\r\n```\r\n\r\n**Advantages of using useCallback**:\r\n```typescript\r\n// ✅ Stable function reference, avoids repeated creation\r\nconst animate = useCallback(() =\u003e { /* ... */ }, [color]);\r\nuseEffect(() =\u003e {\r\n    requestAnimationFrame(animate);  // Uses cached function\r\n}, [animate]);\r\n```\r\n\r\n### Event Listener Lifecycle Management\r\n\r\n```104:112:src/components/ui/background/BinaryRainBackground.tsx\r\n// Set up event listeners\r\nwindow.addEventListener('resize', resizeCanvas);\r\ndocument.addEventListener('mousemove', updateMousePos);\r\n\r\n// Cleanup\r\nreturn () =\u003e {\r\n    window.removeEventListener('resize', resizeCanvas);\r\n    document.removeEventListener('mousemove', updateMousePos);\r\n};\r\n```\r\n\r\n**Why is cleanup so important?**\r\n\r\nEvent listeners are a common source of memory leaks:\r\n\r\n**Memory leak scenarios**:\r\n1. Component unmounts but event listeners still exist\r\n2. Listeners reference destroyed DOM elements\r\n3. Closures hold large memory references\r\n\r\n**Protection mechanism of cleanup functions**:\r\n- Ensures immediate cleanup when component unmounts\r\n- Avoids \"zombie listeners\" continuing to run\r\n- Releases memory references in closures\r\n\r\n### GPU Acceleration Tricks for Canvas Rendering\r\n\r\n```60:76:src/components/ui/background/BinaryRainBackground.tsx\r\n// Clear canvas\r\nctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n// Draw background\r\nctx.fillStyle = 'rgba(10, 10, 10, 0.1)';\r\nctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n// Text styling\r\nctx.fillStyle = color;\r\nctx.font = '14px monospace';\r\nctx.textAlign = 'left';\r\nctx.textBaseline = 'top';\r\n\r\n// Draw characters\r\nparticlesRef.current.forEach(p =\u003e {\r\n    ctx.fillText(p.char, p.x, p.y);\r\n});\r\n```\r\n\r\n**Batch setting of rendering states**:\r\n\r\nInefficient approach before optimization:\r\n```typescript\r\n// ❌ Set styles for each character\r\nparticlesRef.current.forEach(p =\u003e {\r\n    ctx.fillStyle = color;          // Repeated setting\r\n    ctx.font = '14px monospace';    // Repeated setting\r\n    ctx.fillText(p.char, p.x, p.y);\r\n});\r\n```\r\n\r\nEfficient approach after optimization:\r\n```typescript\r\n// ✅ Batch set styles, then batch draw\r\nctx.fillStyle = color;\r\nctx.font = '14px monospace';\r\nparticlesRef.current.forEach(p =\u003e {\r\n    ctx.fillText(p.char, p.x, p.y);  // Focus only on drawing\r\n});\r\n```\r\n\r\n## Complete Source Code Analysis\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport {useEffect, useRef, memo, useCallback} from 'react';\r\n\r\n// ==================== Type Definitions ====================\r\ninterface BinaryRainBackgroundProps {\r\n    className?: string;    // Custom style class name\r\n    opacity?: number;      // Overall opacity [0-1]\r\n    color?: string;        // Character color (RGBA format)\r\n}\r\n\r\n// ==================== Main Component: Binary Rain Background ====================\r\nexport const BinaryRainBackground = memo(function BinaryRainBackground({\r\n                                         className = '',\r\n                                         opacity = 0.6,              // Default 60% opacity\r\n                                         color = 'rgba(0, 255, 255, 1)'  // Default cyan\r\n                                     }: BinaryRainBackgroundProps) {\r\n    \r\n    // ==================== Refs Management ====================\r\n    const canvasRef = useRef\u003cHTMLCanvasElement\u003e(null);                              // Canvas DOM reference\r\n    const animationIdRef = useRef\u003cnumber | null\u003e(null);                             // RAF animation ID\r\n    const particlesRef = useRef\u003cArray\u003c{ x: number; y: number; char: string }\u003e\u003e([]);  // Character grid array\r\n    const mousePosRef = useRef({x: 0, y: 0});                                       // Mouse position cache\r\n    const intervalIdRef = useRef\u003cNodeJS.Timeout | null\u003e(null);                      // Character update timer\r\n\r\n    // ==================== Canvas Size Management ====================\r\n    const resizeCanvas = useCallback(() =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        // Get actual display size of Canvas\r\n        const rect = canvas.getBoundingClientRect();\r\n        canvas.width = rect.width;   // Set actual resolution\r\n        canvas.height = rect.height; // Avoid blur issues\r\n\r\n        // Generate character grid: regular grid with 20px spacing\r\n        const binaryChars = ['0', '1'];\r\n        const gridSize = 20;  // Grid size\r\n        particlesRef.current = [];\r\n\r\n        // Double loop to generate grid points\r\n        for (let y = 0; y \u003c canvas.height; y += gridSize) {\r\n            for (let x = 0; x \u003c canvas.width; x += gridSize) {\r\n                particlesRef.current.push({\r\n                    x,\r\n                    y,\r\n                    char: binaryChars[Math.floor(Math.random() * 2)]  // Random 0 or 1\r\n                });\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    // ==================== Mouse Position Tracking ====================\r\n    const updateMousePos = useCallback((e: MouseEvent) =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        // Coordinate system conversion: Screen coordinates → Canvas coordinates\r\n        const rect = canvas.getBoundingClientRect();\r\n        mousePosRef.current.x = e.clientX - rect.left;\r\n        mousePosRef.current.y = e.clientY - rect.top;\r\n    }, []);\r\n\r\n    // ==================== Core Animation Loop ====================\r\n    const animate = useCallback(() =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        // Register next frame\r\n        animationIdRef.current = requestAnimationFrame(animate);\r\n\r\n        // Step 1: Clear canvas (prepare new frame)\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // Step 2: Set text styles (batch setting improves performance)\r\n        ctx.fillStyle = color;\r\n        ctx.font = '14px monospace';    // Monospace font ensures alignment\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'top';\r\n\r\n        // Step 3: Draw all characters\r\n        particlesRef.current.forEach(p =\u003e {\r\n            ctx.fillText(p.char, p.x, p.y);\r\n        });\r\n\r\n        // Step 4: Create radial mask\r\n        ctx.globalCompositeOperation = 'destination-in';  // Mask blending mode\r\n        \r\n        // Create radial gradient centered on mouse\r\n        const gradient = ctx.createRadialGradient(\r\n            mousePosRef.current.x, mousePosRef.current.y, 0,      // Inner circle: mouse position, radius 0\r\n            mousePosRef.current.x, mousePosRef.current.y, 200     // Outer circle: mouse position, radius 200px\r\n        );\r\n        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');      // Center: completely opaque\r\n        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');      // Edge: completely transparent\r\n        \r\n        // Apply gradient mask\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // Step 6: Reset blending mode\r\n        ctx.globalCompositeOperation = 'source-over';\r\n    }, [color]);\r\n\r\n    // ==================== Character Content Update ====================\r\n    const updateCharacters = useCallback(() =\u003e {\r\n        // Iterate through all characters, randomly update content\r\n        particlesRef.current.forEach(p =\u003e {\r\n            p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n        });\r\n    }, []);\r\n\r\n    // ==================== Component Lifecycle Management ====================\r\n    useEffect(() =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        // Start character update timer (1 second interval)\r\n        intervalIdRef.current = setInterval(updateCharacters, 1000);\r\n\r\n        // Register event listeners\r\n        window.addEventListener('resize', resizeCanvas);          // Window size change\r\n        document.addEventListener('mousemove', updateMousePos);   // Mouse movement\r\n\r\n        // Initial setup\r\n        resizeCanvas();  // Calculate initial grid\r\n        animate();       // Start animation loop\r\n\r\n        // Cleanup function: executed when component unmounts\r\n        return () =\u003e {\r\n            // Cleanup animation loop\r\n            if (animationIdRef.current) {\r\n                cancelAnimationFrame(animationIdRef.current);\r\n            }\r\n            // Cleanup timer\r\n            if (intervalIdRef.current) {\r\n                clearInterval(intervalIdRef.current);\r\n            }\r\n            // Cleanup event listeners\r\n            window.removeEventListener('resize', resizeCanvas);\r\n            document.removeEventListener('mousemove', updateMousePos);\r\n        };\r\n    }, [color, resizeCanvas, updateMousePos, animate, updateCharacters]);\r\n\r\n    // ==================== Component Rendering ====================\r\n    return (\r\n        \u003ccanvas\r\n            ref={canvasRef}\r\n            className={`absolute inset-0 w-full h-full pointer-events-none ${className}`}\r\n            style={{\r\n                opacity,      // Apply opacity\r\n                zIndex: 0     // Ensure background layer\r\n            }}\r\n        /\u003e\r\n    );\r\n}); \r\n```\r\n\r\n### Core Algorithm Flowchart\r\n\r\n```\r\nInitialize → Grid Generation → Animation Loop → Character Update → Cleanup Resources\r\n     ↓            ↓               ↓               ↓               ↓\r\n   Canvas       20px Grid      RAF Loop        1s Timer      useEffect Cleanup\r\n Size Adapt   Character Dist   Render Opt    Random Update   Memory Release\r\n     ↓            ↓               ↓               ↓               ↓\r\n  Responsive    Binary Chars    Mouse Track    Visual Refresh  Complete Lifecycle\r\n   Design      Random Dist     Radial Mask    Keep Vitality     Management\r\n```\r\n\r\n### Key Technical Points Summary\r\n\r\n**1. Mathematical Implementation of Radial Masking**\r\n\r\n- Real-time mouse position tracking, precise coordinate conversion\r\n- Radial gradient creates spotlight effect\r\n- destination-in blending mode implements masking\r\n\r\n**2. Dual Timeline Design**\r\n\r\n- requestAnimationFrame: 60fps visual rendering\r\n- setInterval: 1s character content update\r\n- Separation of concerns, each with its own responsibility\r\n\r\n## Final Words\r\n\r\nI seriously thought for a while and realized I don't really have much to write......\r\n\r\nNever mind, it's time for my favorite wishing session again! Mua!\r\n\r\n*May your code be like the digital rain in The Matrix, weaving the most beautiful digital poetry in users' sight.* ✨\r\n"])</script><script>self.__next_f.push([1,"1d:T4787,"])</script><script>self.__next_f.push([1,"\r\n# Custom Cursor Pattern\r\n\r\n## Basic Concepts\r\n\r\nCustom cursor patterns mainly involve three core states:\r\n- **Default State**: The base style when the mouse is hovering\r\n- **Hover State**: The style when the mouse is hovering over an interactive element\r\n- **Dragging State**: The style when a drag operation is in progress\r\n\r\n## Why Can We Override the Default Cursor\r\n\r\nYou might wonder why our custom pattern can \"override\" the browser's default cursor? In fact, this is achieved by hiding the system cursor and replacing it with a custom element:\r\n\r\n### Principle of Cursor Hiding and Replacement\r\n\r\nThe core implementation is divided into two steps: **Hide the system cursor** + **Custom cursor follows**\r\n\r\n```tsx\r\n// Step 1: Hide the system default cursor\r\n\u003cdiv className=\"cursor-none\"\u003e\r\n  {/* Container content */}\r\n\u003c/div\u003e\r\n\r\n// Step 2: Create a custom cursor that follows the mouse\r\n\u003cmotion.div\r\n  className=\"fixed pointer-events-none z-50\"\r\n  style={{\r\n    left: position.x - 32,  // Follows the mouse X coordinate in real time\r\n    top: position.y - 32,   // Follows the mouse Y coordinate in real time\r\n  }}\r\n\u003e\r\n```\r\n\r\n### Technical Implementation Mechanism\r\n\r\n1. **Cursor Hiding (cursor-none)**: Use CSS properties to completely hide the browser's default cursor\r\n2. **Fixed Position**: Make the custom pattern positioned relative to the viewport, unaffected by scrolling\r\n3. **High Z-index**: Ensure the custom pattern appears above all other elements\r\n4. **Pointer Events None**: Make sure the pattern does not interfere with normal mouse interactions\r\n5. **Real-time Position Update**: Listen to mouse move events and dynamically update the pattern's position\r\n\r\n### Key Code Explanation\r\n\r\n```tsx\r\n// Step 1: Container applies cursor-none to hide the system cursor\r\n\u003cdiv\r\n  className={`overflow-hidden ${\r\n    effectiveDisplayMode === 'tiled' ? 'cursor-none' : ''\r\n  }`}\r\n  onMouseMove={handleMouseMove}\r\n\u003e\r\n  {/* Page content */}\r\n\u003c/div\u003e\r\n\r\n// Step 2: Listen to mouse movement to get real-time coordinates\r\nuseEffect(() =\u003e {\r\n  const handleMouseMove = (e: MouseEvent) =\u003e {\r\n    setPosition({ x: e.clientX, y: e.clientY });\r\n  };\r\n  \r\n  document.addEventListener('mousemove', handleMouseMove);\r\n  return () =\u003e document.removeEventListener('mousemove', handleMouseMove);\r\n}, []);\r\n```\r\n\r\nIn this way, the system's default cursor is completely hidden, and the user can only see our custom animated pattern. At the same time, because `pointer-events-none` is used, the custom cursor does not interfere with normal click, hover, and other interaction operations.\r\n\r\n## Implementation Ideas\r\n\r\n### State Management\r\n\r\nFirst, we need to define the basic properties of the cursor indicator:\r\n\r\n```tsx\r\ninterface CursorPatternProps {\r\n  isDragging: boolean;     // Whether dragging is in progress\r\n  isHovering: boolean;     // Whether hovering is in progress\r\n  position: { x: number; y: number };  // Cursor position\r\n}\r\n```\r\n\r\n### Animation Framework Choice\r\n\r\nUse Framer Motion (or others, as you like) to implement animation effects:\r\n\r\n```tsx\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\n// Basic container animation\r\n\u003cmotion.div\r\n  initial={{ opacity: 0, scale: 0 }}\r\n  animate={{ \r\n    opacity: 1, \r\n    scale: isDragging ? 1 : 0.7,  // Enlarge when dragging\r\n  }}\r\n  exit={{ opacity: 0, scale: 0 }}\r\n  transition={{ duration: 0.2, ease: 'easeOut' }}\r\n\u003e\r\n```\r\n\r\n## Design Layered Structure\r\n\r\n### Outer Rotating Ring\r\n\r\nCreate a rotating dashed border to let users perceive the active state:\r\n\r\n```tsx\r\n\u003cmotion.div\r\n  className=\"absolute w-16 h-16 rounded-full border-2 border-dashed\"\r\n  style={{\r\n    borderColor: currentTheme.colors.primary,\r\n    filter: `drop-shadow(0 0 8px ${currentTheme.colors.primary}33)`,\r\n  }}\r\n  animate={{\r\n    rotate: isDragging ? [0, 360] : [0, 180, 0],  // Continuous rotation when dragging\r\n  }}\r\n  transition={{\r\n    duration: isDragging ? 3 : 4,\r\n    repeat: Infinity,\r\n    ease: 'linear',\r\n  }}\r\n/\u003e\r\n```\r\n\r\n### Inner Pulse Circle\r\n\r\nAdd a pulsing animated inner circle:\r\n\r\n```tsx\r\n\u003cmotion.div\r\n  className=\"absolute w-16 h-16 rounded-full border\"\r\n  animate={{\r\n    scale: isDragging ? [1, 1.2, 1] : [1, 1.1, 1],\r\n    opacity: isDragging ? [0.7, 1, 0.7] : [0.4, 0.7, 0.4],\r\n  }}\r\n  transition={{\r\n    duration: isDragging ? 2 : 3,\r\n    repeat: Infinity,\r\n    ease: 'easeInOut',\r\n  }}\r\n/\u003e\r\n```\r\n\r\n### Central Geometric Shape\r\n\r\nPlace a recognizable geometric shape in the center, such as a triangle and a diamond:\r\n\r\n```tsx\r\n{/* Triangle indicator */}\r\n\u003cmotion.div\r\n  className=\"absolute w-0 h-0\"\r\n  style={{\r\n    borderLeft: '6px solid transparent',\r\n    borderRight: '6px solid transparent',\r\n    borderBottom: `10px solid ${currentTheme.colors.primary}`,\r\n  }}\r\n  animate={{\r\n    y: isDragging ? [-2, 2, -2] : [-1, 1, -1],  // Slight up and down floating\r\n  }}\r\n/\u003e\r\n\r\n{/* Diamond decoration */}\r\n\u003cmotion.div\r\n  className=\"absolute w-3 h-3 rotate-45\"\r\n  style={{\r\n    backgroundColor: currentTheme.colors.accent,\r\n  }}\r\n  animate={{\r\n    scale: isDragging ? [0.8, 1.2, 0.8] : [0.9, 1.1, 0.9],\r\n    rotate: isDragging ? [45, 135, 45] : [45, 90, 45],\r\n  }}\r\n/\u003e\r\n```\r\n\r\n### Diffusion Waves\r\n\r\nAdd outward-spreading wave effects in the dragging state:\r\n\r\n```tsx\r\n{isDragging \u0026\u0026 [0, 1, 2].map((index) =\u003e (\r\n  \u003cmotion.div\r\n    key={`wave-${index}`}\r\n    className=\"absolute w-16 h-16 rounded-full border opacity-30\"\r\n    animate={{\r\n      scale: [1, 2.5],\r\n      opacity: [0.6, 0],\r\n    }}\r\n    transition={{\r\n      duration: 1.5,\r\n      repeat: Infinity,\r\n      ease: 'easeOut',\r\n      delay: index * 0.5,  // Staggered animation\r\n    }}\r\n  /\u003e\r\n))}\r\n```\r\n\r\n### Directional Arrows\r\n\r\nAdd arrows in four directions to indicate draggable directions:\r\n\r\n```tsx\r\n{[0, 90, 180, 270].map((rotation, index) =\u003e (\r\n  \u003cmotion.div\r\n    key={`arrow-${index}`}\r\n    style={{\r\n      transform: `rotate(${rotation}deg) translateY(-24px)`,\r\n    }}\r\n    animate={{\r\n      opacity: isDragging ? [0.3, 1, 0.3] : [0.2, 0.6, 0.2],\r\n      y: isDragging ? [-2, 2, -2] : [-1, 1, -1],\r\n    }}\r\n    transition={{\r\n      delay: index * 0.2,  // Appear in sequence\r\n    }}\r\n  \u003e\r\n    {/* SVG arrow icon */}\r\n  \u003c/motion.div\u003e\r\n))}\r\n```\r\n\r\n## Theme Integration\r\n\r\n### Dynamic Colors\r\n\r\nUse the theme system to achieve dynamic color switching:\r\n\r\n```tsx\r\nconst { currentTheme } = useThemeStore();\r\n\r\n// Use theme color\r\nstyle={{\r\n  currentTheme.colors.primary,\r\n  backgroundColor: currentTheme.colors.accent,\r\n  filter: `drop-shadow(0 0 8px ${currentTheme.colors.primary}33)`,\r\n}}\r\n```\r\n\r\n### Responsive Design\r\n\r\nConsider display requirements for different devices:\r\n\r\n```tsx\r\n// Adjust indicator size based on screen size\r\nconst indicatorSize = useMediaQuery('(max-width: 768px)') ? 48 : 64;\r\n```\r\n\r\n### Client-side Rendering\r\n\r\nIn server-side rendering projects, ensure the cursor pattern is only rendered on the client:\r\n\r\n```tsx\r\nconst [mounted, setMounted] = useState(false);\r\n\r\nuseEffect(() =\u003e {\r\n  setMounted(true);\r\n}, []);\r\n\r\nif (!mounted) return null;\r\n```\r\n\r\n## Position Calculation\r\n\r\n  ```tsx\r\n  style={{\r\n    position.x - 32,  // Half the container width\r\n    top: position.y - 32,   // Half the container height\r\n  }}\r\n  ```\r\n\r\n## Full Code Explanation\r\n\r\n```tsx\r\n'use client';\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { useThemeStore } from '@/lib/stores/themeStore';\r\n\r\n// Define component property interface\r\ninterface DragIndicatorProps {\r\n  isDragging: boolean;     // Whether in dragging state\r\n  isHovering: boolean;     // Whether in hovering state\r\n  position: { x: number; y: number };  // Current mouse position coordinates\r\n}\r\n\r\nexport function DragIndicator({ isDragging, isHovering, position }: DragIndicatorProps) {\r\n  const { currentTheme } = useThemeStore();  // Get current theme config\r\n  const [mounted, setMounted] = useState(false);  // Client mount state\r\n\r\n  // Ensure the component only renders on the client to avoid hydration errors in SSR\r\n  useEffect(() =\u003e {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  // Do not render anything when not mounted\r\n  if (!mounted) return null;\r\n\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {/* Only show the indicator when dragging or hovering */}\r\n      {(isDragging || isHovering) \u0026\u0026 (\r\n        \u003cmotion.div\r\n          className=\"fixed pointer-events-none z-50 flex items-center justify-center\"\r\n          style={{\r\n            // Calculate container position based on mouse position, subtract half the container size to center\r\n            left: position.x - 32,\r\n            top: position.y - 32,\r\n            width: '64px',    // Fixed container size\r\n            height: '64px',\r\n          }}\r\n          // Enter animation: start from transparent and scaled down\r\n          initial={{ opacity: 0, scale: 0 }}\r\n          // Animation state: fully visible when dragging, slightly smaller when hovering\r\n          animate={{ \r\n            opacity: 1, \r\n            scale: isDragging ? 1 : 0.7,\r\n          }}\r\n          // Exit animation: return to transparent and scaled down\r\n          exit={{ opacity: 0, scale: 0 }}\r\n          transition={{ duration: 0.2, ease: 'easeOut' }}\r\n        \u003e\r\n          \r\n          {/* Outer rotating ring - dashed border */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 rounded-full border-2 border-dashed\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n              borderColor: currentTheme.colors.primary,  // Use theme primary color\r\n              // Add glow effect, 33% opacity\r\n              filter: `drop-shadow(0 0 8px ${currentTheme.colors.primary}33)`,\r\n              opacity: isDragging ? 1 : 0.6,  // More obvious when dragging\r\n            }}\r\n            animate={{\r\n              // Continuous 360-degree rotation when dragging, 180-degree back and forth when hovering\r\n              rotate: isDragging ? [0, 360] : [0, 180, 0],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 3 : 4,  // Faster rotation when dragging\r\n              repeat: Infinity,\r\n              ease: 'linear',\r\n            }}\r\n          /\u003e\r\n\r\n          {/* Inner pulse circle - solid border */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 rounded-full border\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n              borderColor: currentTheme.colors.accent,  // Use theme accent color\r\n              // Add 15% opacity background color\r\n              backgroundColor: `${currentTheme.colors.primary}15`,\r\n            }}\r\n            animate={{\r\n              // Pulse effect: scale changes\r\n              scale: isDragging ? [1, 1.2, 1] : [1, 1.1, 1],\r\n              // Opacity changes\r\n              opacity: isDragging ? [0.7, 1, 0.7] : [0.4, 0.7, 0.4],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 2 : 3,  // Faster pulse when dragging\r\n              repeat: Infinity,\r\n              ease: 'easeInOut',\r\n            }}\r\n          /\u003e\r\n\r\n          {/* Central geometric shape container */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 flex items-center justify-center\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n            }}\r\n            animate={{\r\n              // Rotate in the opposite direction to the outer ring for visual contrast\r\n              rotate: isDragging ? [0, -360] : [0, -90, 0],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 4 : 6,  // Slightly slower than the outer ring\r\n              repeat: Infinity,\r\n              ease: 'linear',\r\n            }}\r\n          \u003e\r\n            {/* Triangle indicator */}\r\n            \u003cmotion.div\r\n              className=\"absolute w-0 h-0\"\r\n              style={{\r\n                // Use CSS border trick to draw a triangle\r\n                borderLeft: '6px solid transparent',\r\n                borderRight: '6px solid transparent',\r\n                borderBottom: `10px solid ${currentTheme.colors.primary}`,\r\n                // Add glow effect\r\n                filter: `drop-shadow(0 0 4px ${currentTheme.colors.primary}66)`,\r\n                opacity: isDragging ? 1 : 0.7,\r\n              }}\r\n              animate={{\r\n                // Slight up and down floating effect\r\n                y: isDragging ? [-2, 2, -2] : [-1, 1, -1],\r\n              }}\r\n              transition={{\r\n                duration: isDragging ? 1.5 : 2.5,\r\n                repeat: Infinity,\r\n                ease: 'easeInOut',\r\n              }}\r\n            /\u003e\r\n\r\n            {/* Diamond decoration */}\r\n            \u003cmotion.div\r\n              className=\"absolute w-3 h-3 rotate-45\"\r\n              style={{\r\n                backgroundColor: currentTheme.colors.accent,\r\n                filter: `drop-shadow(0 0 4px ${currentTheme.colors.accent}66)`,\r\n                opacity: isDragging ? 1 : 0.7,\r\n              }}\r\n              animate={{\r\n                // Combined scale and rotation animation\r\n                scale: isDragging ? [0.8, 1.2, 0.8] : [0.9, 1.1, 0.9],\r\n                rotate: isDragging ? [45, 135, 45] : [45, 90, 45],\r\n              }}\r\n              transition={{\r\n                duration: isDragging ? 2.5 : 3.5,\r\n                repeat: Infinity,\r\n                ease: 'easeInOut',\r\n              }}\r\n            /\u003e\r\n          \u003c/motion.div\u003e\r\n\r\n          {/* Diffusion waves - only show when dragging */}\r\n          {isDragging \u0026\u0026 [0, 1, 2].map((index) =\u003e (\r\n            \u003cmotion.div\r\n              key={`wave-${index}`}\r\n              className=\"absolute w-16 h-16 rounded-full border opacity-30\"\r\n              style={{\r\n                left: 0,\r\n                top: 0,\r\n                borderColor: currentTheme.colors.primary,\r\n              }}\r\n              animate={{\r\n                scale: [1, 2.5],    // Spread outward\r\n                opacity: [0.6, 0],  // Gradually disappear\r\n              }}\r\n              transition={{\r\n                duration: 1.5,\r\n                repeat: Infinity,\r\n                ease: 'easeOut',\r\n                delay: index * 0.5,  // Staggered animation to form wave effect\r\n              }}\r\n            /\u003e\r\n          ))}\r\n\r\n          {/* Directional arrow container */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 flex items-center justify-center\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n            }}\r\n            animate={{\r\n              // Overall slow rotation\r\n              rotate: isDragging ? [0, 360] : [0, 45, 0],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 6 : 8,\r\n              repeat: Infinity,\r\n              ease: 'linear',\r\n            }}\r\n          \u003e\r\n            {/* Four directional arrows */}\r\n            {[0, 90, 180, 270].map((rotation, index) =\u003e (\r\n              \u003cmotion.div\r\n                key={`arrow-${index}`}\r\n                className=\"absolute w-4 h-4\"\r\n                style={{\r\n                  // Distribute around the circle according to angle\r\n                  transform: `rotate(${rotation}deg) translateY(-24px)`,\r\n                  opacity: isDragging ? 1 : 0.5,\r\n                }}\r\n                animate={{\r\n                  // Periodic changes in opacity and position\r\n                  opacity: isDragging ? [0.3, 1, 0.3] : [0.2, 0.6, 0.2],\r\n                  y: isDragging ? [-2, 2, -2] : [-1, 1, -1],\r\n                }}\r\n                transition={{\r\n                  duration: isDragging ? 1.8 : 2.5,\r\n                  repeat: Infinity,\r\n                  ease: 'easeInOut',\r\n                  delay: index * 0.2,  // Animate in sequence for a flowing feel\r\n                }}\r\n              \u003e\r\n                {/* SVG arrow icon */}\r\n                \u003csvg\r\n                  width=\"16\"\r\n                  height=\"16\"\r\n                  viewBox=\"0 0 16 16\"\r\n                  fill=\"none\"\r\n                  xmlns=\"http://www.w3.org/2000/svg\"\r\n                \u003e\r\n                  \u003cpath\r\n                    d=\"M8 2L8 14M8 2L4 6M8 2L12 6\"  // Arrow path\r\n                    stroke={currentTheme.colors.accent}\r\n                    strokeWidth=\"2\"\r\n                    strokeLinecap=\"round\"\r\n                    strokeLinejoin=\"round\"\r\n                    filter={`drop-shadow(0 0 2px ${currentTheme.colors.accent}66)`}\r\n                  /\u003e\r\n                \u003c/svg\u003e\r\n              \u003c/motion.div\u003e\r\n            ))}\r\n          \u003c/motion.div\u003e\r\n\r\n          {/* Grabbing hand icon for hover state - only show when not dragging */}\r\n          {!isDragging \u0026\u0026 (\r\n            \u003cmotion.div\r\n              className=\"absolute w-16 h-16 flex items-center justify-center\"\r\n              style={{\r\n                left: 0,\r\n                top: 0,\r\n              }}\r\n              initial={{ opacity: 0 }}\r\n              animate={{ opacity: 1 }}\r\n              transition={{ duration: 0.3 }}\r\n            \u003e\r\n              \u003cmotion.div\r\n                className=\"w-6 h-6 flex items-center justify-center\"\r\n                animate={{\r\n                  scale: [1, 1.1, 1],  // Slight breathing effect\r\n                }}\r\n                transition={{\r\n                  duration: 2,\r\n                  repeat: Infinity,\r\n                  ease: 'easeInOut',\r\n                }}\r\n              \u003e\r\n                {/* Grabbing hand SVG icon */}\r\n                \u003csvg\r\n                  width=\"20\"\r\n                  height=\"20\"\r\n                  viewBox=\"0 0 24 24\"\r\n                  fill=\"none\"\r\n                  xmlns=\"http://www.w3.org/2000/svg\"\r\n                \u003e\r\n                  \u003cpath\r\n                    d=\"M8 11V7C8 5.34315 9.34315 4 11 4C12.6569 4 14 5.34315 14 7V11M8 11L8 15C8 17.2091 9.79086 19 12 19C14.2091 19 16 17.2091 16 15V11M8 11H16M14 7V11M11 7V11\"\r\n                    stroke={currentTheme.colors.primary}\r\n                    strokeWidth=\"2\"\r\n                    strokeLinecap=\"round\"\r\n                    strokeLinejoin=\"round\"\r\n                    filter={`drop-shadow(0 0 4px ${currentTheme.colors.primary}66)`}\r\n                  /\u003e\r\n                \u003c/svg\u003e\r\n              \u003c/motion.div\u003e\r\n            \u003c/motion.div\u003e\r\n          )}\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n*May you be like gold hidden deep, shining with your own dazzling brilliance when unearthed.* ✨\r\n"])</script><script>self.__next_f.push([1,"1e:Td7ac,"])</script><script>self.__next_f.push([1,"\r\n# Floating Navigation Ball: From Mathematical Principles to Interactive Implementation\r\n\r\nWhen writing the navigation bar menu, I was thinking, how can I express modernity and tech-savviness while breaking through traditional layout? How about creating a floating ball type navigation bar? ...So I did just that.\r\n\r\nImagine if your website navigation could be like an intelligent assistant, quietly staying in the corner when not needed, gracefully sliding to the center of the screen to unfold all functions when required, and obediently returning to its original position after use... Yeah, that sounds pretty nice.\r\n\r\nThis floating navigation ball integrates complex interaction logic: draggable, snappable to screen edges, expandable into a circular menu, plus smooth animation transitions. In this article, I'll start from the most basic coordinate calculations and gradually dive deep into every implementation detail, comprehensively analyzing this seemingly simple yet complex interactive system.\r\n\r\n## State Management\r\n\r\nAny complex interactive system requires carefully designed state management, and our floating navigation ball is no exception. Let's first quickly review the overall state members:\r\n\r\n### State Definition\r\n\r\nWhy do we need so many state variables? Because each state carries specific responsibilities, and together they constitute a complete interactive ecosystem.\r\n\r\n```typescript\r\nconst [mounted, setMounted] = useState(false);\r\nconst [isExpanded, setIsExpanded] = useState(false);\r\nconst [position, setPosition] = useState\u003cPosition\u003e({x: 50, y: 50});\r\nconst [originalPosition, setOriginalPosition] = useState\u003cPosition\u003e({x: 50, y: 50});\r\nconst [isDragging, setIsDragging] = useState(false);\r\nconst [dragOffset, setDragOffset] = useState\u003cPosition\u003e({x: 0, y: 0});\r\nconst [dragStartPosition, setDragStartPosition] = useState\u003cPosition\u003e({x: 0, y: 0});\r\nconst [showRipple, setShowRipple] = useState(false);\r\n```\r\n\r\n### Core State Breakdown\r\n\r\nLet me explain the purpose of each state one by one:\r\n\r\n**mounted**: This is a \"fuse\" state. In the world of server-side rendering, `window.innerWidth` is undefined during initial rendering, so we need to wait until the component is actually mounted in the browser before performing position calculations.\r\n\r\n**isExpanded**: The \"switch\" state of the navigation ball. `false` means it's a small ball, `true` means it expands into a circular menu. This state controls the entire UI morphology change.\r\n\r\n**position**: Current real-time position coordinates. This is the core of the entire drag system, all position changes are reflected here.\r\n\r\n**originalPosition**: \"The remembered home.\" When the navigation ball expands, it moves to the screen center, but we need to remember its original position so it can return there when collapsed.\r\n\r\n**isDragging**: A flag for drag state. `true` when the user presses the mouse to start dragging, `false` when releasing the mouse. This state affects mouse event listening and visual feedback.\r\n\r\n**dragOffset**: This is the most easily overlooked yet most important state. It records the offset of the mouse click position relative to the top-left corner of the navigation ball, ensuring the ball doesn't \"jump\" to the mouse position during dragging.\r\n\r\n**dragStartPosition**: The recorder of the drag starting point. We need it to calculate drag distance and distinguish between \"click\" and \"actual drag.\"\r\n\r\n**showRipple**: The switch for visual feedback. Shows ripple effects during dragging, letting users know \"I'm moving this thing.\"\r\n\r\n### State Machine Design\r\n\r\nThe relationships between these states form a complex state machine:\r\n\r\n```\r\nNormal State ←→ Drag State → Snap State\r\n    ↓                            ↑\r\nExpanded State ←-----------------┘\r\n```\r\n\r\nKey state transition logic:\r\n- **Normal→Drag**: `mouseDown` event triggers, simultaneously setting `isDragging=true` and recording initial offset\r\n- **Drag→Snap**: `mouseUp` event triggers, executing edge snapping algorithm\r\n- **Normal→Expanded**: Click event triggers (non-drag), moves to screen center\r\n- **Expanded→Normal**: Click again or click background, returns to original position\r\n\r\nThe elegance of this state machine lies in its ability to correctly handle edge cases, such as users quickly clicking during drag, or starting to drag in expanded state, etc.\r\n\r\n## Coordinate System and Position Recording\r\n\r\nIn the browser world, there are many coordinate systems to choose from, and our choice determines the complexity and performance of the entire system.\r\n\r\n### Coordinate System Choice\r\n\r\nI chose the absolute positioning (`position: fixed`) + `left/top` properties approach, rather than the more modern `transform` approach. Why?\r\n\r\n```typescript\r\n// The approach we use\r\nstyle={{\r\n    left: `${position.x}px`,\r\n    top: `${position.y}px`,\r\n}}\r\n\r\n// Instead of this\r\nstyle={{\r\n    transform: `translate(${position.x}px, ${position.y}px)`\r\n}}\r\n```\r\n\r\n~~(Mainly because I'm lazy)~~ The reason is simple: **computational simplicity**. When using `left/top`, coordinate values directly correspond to screen positions, and we can directly use `getBoundingClientRect()` to get element positions for calculations. When using `transform`, the actual rendered position and the position recorded in CSS might be inconsistent, adding computational complexity.\r\n\r\nAlthough `transform` performs better in some cases (GPU acceleration), for a single navigation ball, this performance difference is negligible. Sometimes, simplicity is beauty.\r\n\r\n### Position Initialization Strategy\r\n\r\n```typescript\r\nconst initialX = window.innerWidth - 80;\r\nconst initialY = 100;\r\n```\r\n\r\n`window.innerWidth - 80` ensures the ball is completely within the screen, 80px is the ball size plus some margin, ensuring the floating navigation ball has high initial visibility on various devices.\r\n\r\n### Mathematical Principles of dragOffset\r\n\r\nThis is the most error-prone part of the entire drag system. Let me illustrate with an example:\r\n\r\nSuppose the navigation ball's top-left corner position is `(100, 50)`, and the user clicks at the center of the ball `(132, 82)` to start dragging (the ball size is 64x64px).\r\n\r\n```typescript\r\nconst handleMouseDown = (e: React.MouseEvent) =\u003e {\r\n    const rect = ballRef.current?.getBoundingClientRect();\r\n    if (rect) {\r\n        setDragOffset({\r\n            x: e.clientX - rect.left,  // 132 - 100 = 32\r\n            y: e.clientY - rect.top    // 82 - 50 = 32\r\n        });\r\n    }\r\n};\r\n```\r\n\r\nNow, when the mouse moves to `(200, 150)`, the new ball position should be:\r\n\r\n```typescript\r\nconst newPos = {\r\n    x: e.clientX - dragOffset.x,  // 200 - 32 = 168\r\n    y: e.clientY - dragOffset.y   // 150 - 32 = 118\r\n};\r\n```\r\n\r\nThis way, the ball's center will follow the mouse without producing a \"jump\" effect. If we didn't have the final correction of -32 pixels, when dragging actually occurs, the cursor would point to the ball's top-left corner instead of the ball center, causing drag offset errors.\r\n\r\n## Drag System Implementation\r\n\r\nThe drag system is the core functionality of the entire navigation ball, requiring handling of complex event sequences and state changes.\r\n\r\n### Drag Lifecycle\r\n\r\nA complete drag operation includes three phases:\r\n\r\n1. **mouseDown**: Initialize drag state\r\n2. **mouseMove**: Continuously update position\r\n3. **mouseUp**: End drag and execute subsequent logic\r\n\r\nEach phase has its specific responsibilities and processing logic.\r\n\r\n### Debounced Animation Implementation\r\n\r\nTraditional drag implementations immediately update position on every `mouseMove`, but this causes performance issues and visual jitter. I adopted a debouncing strategy:\r\n\r\n```typescript\r\nconst handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    if (!isDragging) return;\r\n\r\n    // Calculate new position\r\n    const newPos = {\r\n        x: e.clientX - dragOffset.x,\r\n        y: e.clientY - dragOffset.y\r\n    };\r\n\r\n    // Store pending position\r\n    pendingPositionRef.current = newPos;\r\n\r\n    // Immediately show ripple effect\r\n    setShowRipple(true);\r\n\r\n    // Clear existing debounce timer\r\n    if (debounceTimerRef.current) {\r\n        clearTimeout(debounceTimerRef.current);\r\n    }\r\n\r\n    // Set new debounce timer\r\n    debounceTimerRef.current = setTimeout(() =\u003e {\r\n        setPosition(newPos);\r\n        setShowRipple(false);\r\n    }, 500);\r\n}, [isDragging, dragOffset]);\r\n```\r\n\r\n**Note:** I used `ref` instead of `state` to store the pending position, because `useState` updates are asynchronous. When I use asynchronous state updates, there are read value hazards, i.e., when I read the \"updated\" value, the asynchronous update hasn't completed yet, so I'm actually reading the pre-update value, causing abnormal results. `ref` updates are synchronous and don't have thread safety issues, meaning the value I read \"after update\" is indeed the post-update value.\r\n\r\n### Drag Distance Determination\r\n\r\nHow to distinguish between \"click\" and \"drag\"? This is a classic UI interaction problem. My solution is based on Euclidean distance:\r\n\r\n```typescript\r\n// Record drag start position\r\nsetDragStartPosition({x: e.clientX, y: e.clientY});\r\n\r\n// Calculate distance in mouseMove\r\nconst dragDistance = Math.sqrt(\r\n    Math.pow(e.clientX - dragStartPosition.x, 2) +\r\n    Math.pow(e.clientY - dragStartPosition.y, 2)\r\n);\r\n\r\nif (dragDistance \u003e 3) {\r\n    hasDraggedSignificantlyRef.current = true;\r\n}\r\n```\r\n\r\nOnly when the floating navigation ball moves more than 3 pixels is it considered \"dragging,\" otherwise it's considered a \"click.\" Generally, natural hand tremor is usually within 1-2 pixels, so 3 pixels can effectively filter out these unintentional micro-movements while not hindering genuine drag intentions.\r\n\r\n### Intelligent Handling of Drag End\r\n\r\n```typescript\r\nconst handleMouseUp = useCallback(() =\u003e {\r\n    if (!isDragging) return;\r\n\r\n    setIsDragging(false);\r\n    setShowRipple(false);\r\n\r\n    // Clear debounce timer\r\n    if (debounceTimerRef.current) {\r\n        clearTimeout(debounceTimerRef.current);\r\n    }\r\n\r\n    if (hasDraggedSignificantlyRef.current) {\r\n        // Significant drag - execute snapping\r\n        const snappedPos = snapToEdge(pendingPositionRef.current);\r\n        setPosition(snappedPos);\r\n        setOriginalPosition(snappedPos);\r\n    }\r\n\r\n    // Reset drag flag\r\n    setTimeout(() =\u003e {\r\n        hasDraggedSignificantlyRef.current = false;\r\n    }, 100);\r\n}, [isDragging]);\r\n```\r\n\r\nThere's a detail here: why delay resetting the drag flag by 100ms? Because `mouseUp` and `click` events have timing differences. If reset immediately, the click event might be incorrectly processed as a post-drag click. The 100ms delay ensures correct event processing order.\r\n\r\n## Edge Snapping Algorithm\r\n\r\nThe snapping effect is a user-friendly design that ensures when you \"let go\" of the navigation ball, it automatically stops at a fixed distance from the screen edge, solving the core pain point of visually obsessive users. ~~(Like me)~~\r\n\r\n### Core Logic of Snapping Algorithm\r\n\r\nThe mathematical principle of snapping is actually simple: calculate the distance from the current position to four boundaries, then move to the nearest boundary:\r\n\r\n```typescript\r\nconst snapToEdge = useCallback((currentPos: Position) =\u003e {\r\n    const windowWidth = window.innerWidth;\r\n    const windowHeight = window.innerHeight;\r\n    const ballSize = 70;  // Ball size\r\n    const margin = 20;    // Distance from edge\r\n    \r\n    // Calculate distances to four boundaries\r\n    const distanceToLeft = currentPos.x;\r\n    const distanceToRight = windowWidth - currentPos.x;\r\n    const distanceToTop = currentPos.y;\r\n    const distanceToBottom = windowHeight - currentPos.y;\r\n    \r\n    // Find minimum distance\r\n    const minDistance = Math.min(\r\n        distanceToLeft, \r\n        distanceToRight, \r\n        distanceToTop, \r\n        distanceToBottom\r\n    );\r\n    \r\n    let newPos = {...currentPos};\r\n    \r\n    // Decide snap direction based on minimum distance\r\n    if (minDistance === distanceToLeft) {\r\n        newPos.x = margin;\r\n    } else if (minDistance === distanceToRight) {\r\n        newPos.x = windowWidth - ballSize - margin;\r\n    } else if (minDistance === distanceToTop) {\r\n        newPos.y = margin;\r\n    } else {\r\n        newPos.y = windowHeight - ballSize - margin;\r\n    }\r\n    \r\n    return newPos;\r\n}, []);\r\n```\r\n\r\n### Mathematical Principles of Boundary Calculation\r\n\r\nDistance calculation explanation:\r\n\r\n- **distanceToLeft**: Directly equals `currentPos.x`, because the left boundary is x=0\r\n- **distanceToRight**: `windowWidth - currentPos.x`, because the right boundary is window width\r\n- **distanceToTop**: Directly equals `currentPos.y`, because the top boundary is y=0  \r\n- **distanceToBottom**: `windowHeight - currentPos.y`, because the bottom boundary is window height\r\n\r\n`Math.min()` finds the smallest of these four values, corresponding to the nearest boundary.\r\n\r\n### Boundary Constraint Implementation\r\n\r\nThis is a protective logic to prevent boundary overflow:\r\n\r\n```typescript\r\nnewPos.x = Math.max(margin, Math.min(windowWidth - ballSize - margin, newPos.x));\r\nnewPos.y = Math.max(margin, Math.min(windowHeight - ballSize - margin, newPos.y));\r\n```\r\n\r\n\"Double clamping\" strategy:\r\n- `Math.min()` ensures position doesn't exceed right and bottom boundaries\r\n- `Math.max()` ensures position doesn't go below left and top boundaries\r\n\r\nThis way, regardless of what position the algorithm calculates, the final coordinates will be strictly limited within the safe range.\r\n\r\nWhy do we need `ballSize`? Because CSS's `left` and `top` properties position the element's top-left corner, not the center point. If we don't consider the ball's size, part of the ball might run off-screen.\r\n\r\n## Expand/Collapse Animation System\r\n\r\nThe expansion and collapse of the navigation ball is an animated process with transition effects, involving position movement, state switching, and timing control.\r\n\r\n### Center Positioning Algorithm\r\n\r\nWhen the user clicks the navigation ball, it needs to move to the screen center for expansion:\r\n\r\n```typescript\r\nconst centerX = window.innerWidth / 2 - 35;\r\nconst centerY = window.innerHeight / 2 - 35;\r\nsetPosition({x: centerX, y: centerY});\r\n```\r\n\r\n**Why subtract 35**? Because the navigation ball is 70px in size. If we want the ball's **center** to align with the screen center, we need to offset left and up by half the ball's size (70/2 = 35px).\r\n\r\nThis is the difference between visual center and geometric center:\r\n- **Geometric center**: The center point of the element's bounding box\r\n- **Visual center**: The element center point perceived by the human eye\r\n\r\nFor circular elements, these two are consistent, so we can use geometric calculations.\r\n\r\n### Timing Control for State Switching\r\n\r\nExpand and collapse animations require precise timing control:\r\n\r\n```typescript\r\nconst handleBallClick = () =\u003e {\r\n    if (!hasDraggedSignificantlyRef.current) {\r\n        if (!isExpanded) {\r\n            // Expand: first save current position, then move to center\r\n            setOriginalPosition(position);\r\n            const centerX = window.innerWidth / 2 - 35;\r\n            const centerY = window.innerHeight / 2 - 35;\r\n            setPosition({x: centerX, y: centerY});\r\n            setIsExpanded(true);\r\n        } else {\r\n            // Collapse: first set state, delay 150ms before moving\r\n            setIsExpanded(false);\r\n            setTimeout(() =\u003e {\r\n                setPosition(originalPosition);\r\n            }, 150);\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nThere's a key design decision here: why delay 150ms when collapsing?\r\n\r\nBecause menu item disappearing animations need time. If we immediately move the ball position while setting `isExpanded=false`, users would see the ball start moving while menu items are still disappearing, creating a jarring visual effect.\r\n\r\nThe 150ms delay allows the menu item disappearing animation to complete before the ball starts moving back to its original position. This timing arrangement makes the entire animation feel more coherent and natural.\r\n\r\n### Saving Mechanism for originalPosition\r\n\r\nThe timing of saving `originalPosition` is crucial:\r\n\r\n```typescript\r\n// Save before expanding\r\nsetOriginalPosition(position);\r\n\r\n// Update after drag ends\r\nsetOriginalPosition(snappedPos);\r\n```\r\n\r\nThis ensures that regardless of whether the user dragged the ball before expanding, it returns to the correct position when collapsed. If the user drags the ball to a new position then expands, it should return to the post-drag position when collapsed, not the initial position.\r\n\r\n## Circular Menu Layout Algorithm\r\n\r\nWhen the navigation ball expands, menu items need to be evenly distributed around a circle. This is a typical polar coordinate layout problem.\r\n\r\n### Mathematical Foundation of Polar Coordinate Layout\r\n\r\nThe core of circular layout is the conversion from polar coordinates to Cartesian coordinates:\r\n\r\n```typescript\r\nconst getCircularPosition = (index: number, total: number, radius: number = 120) =\u003e {\r\n    const angle = (2 * Math.PI * index) / total - Math.PI / 2;\r\n    const centerX = window.innerWidth / 2;\r\n    const centerY = window.innerHeight / 2;\r\n    return {\r\n        x: centerX + Math.cos(angle) * radius - 60,\r\n        y: centerY + Math.sin(angle) * radius - 30,\r\n    };\r\n};\r\n```\r\n\r\nLet me explain this algorithm line by line:\r\n\r\n**Angle calculation**: `(2 * Math.PI * index) / total` divides the circumference (2π radians) equally into `total` parts, with each menu item occupying one part.\r\n\r\n**Starting angle adjustment**: `- Math.PI / 2` adjusts the starting angle from 3 o'clock direction (0 radians) to 12 o'clock direction (-π/2 radians). This way the first menu item appears at the top, conforming to visual habits.\r\n\r\n**Coordinate conversion**: `Math.cos(angle) * radius` and `Math.sin(angle) * radius` convert polar coordinates to Cartesian coordinates relative to the circle center.\r\n\r\n**Position offset**: `- 60` and `- 30` adjust the menu item positioning point. These values are calculated based on the actual size of menu items, ensuring the menu item center points are located on the circumference.\r\n\r\n### Angle Distribution Strategy\r\n\r\nAssuming we have 6 menu items, their angle distribution is like this:\r\n\r\n```\r\nItem 0: (2π × 0) / 6 - π/2 = -π/2   (12 o'clock direction)\r\nItem 1: (2π × 1) / 6 - π/2 = -π/6   (2 o'clock direction)\r\nItem 2: (2π × 2) / 6 - π/2 = π/6    (4 o'clock direction)\r\nItem 3: (2π × 3) / 6 - π/2 = π/2    (6 o'clock direction)\r\nItem 4: (2π × 4) / 6 - π/2 = 5π/6   (8 o'clock direction)\r\nItem 5: (2π × 5) / 6 - π/2 = 7π/6   (10 o'clock direction)\r\n```\r\n\r\nThis distribution ensures visual uniformity and symmetry of menu items.\r\n\r\n## Keyframe Animation System\r\n\r\nThe appearance and disappearance animations of menu items are key to ensuring smoothness.\r\n\r\n### CSS-in-JS Animation Implementation\r\n\r\nI use CSS-in-JS animation definition to maintain component encapsulation:\r\n\r\n```jsx\r\n\u003cstyle jsx\u003e{`\r\n    @keyframes menuItemAppear {\r\n        0% {\r\n            opacity: 0;\r\n            transform: scale(0) translate(-50%, -50%);\r\n        }\r\n        50% {\r\n            opacity: 0.7;\r\n            transform: scale(0.8) translate(-25%, -25%);\r\n        }\r\n        100% {\r\n            opacity: 1;\r\n            transform: scale(1) translate(0%, 0%);\r\n        }\r\n    }\r\n    \r\n    .menu-item {\r\n        animation: menuItemAppear 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;\r\n    }\r\n`}\u003c/style\u003e\r\n```\r\n\r\nThis animation contains three keyframes:\r\n- **0%**: Completely transparent, zero scale, large offset\r\n- **50%**: Semi-transparent, 80% scale, small offset  \r\n- **100%**: Completely opaque, normal scale, no offset\r\n\r\n**Why include translate offset**? Pure scale animations would make menu items \"burst\" from the center point. Adding translate offset creates a \"flying in from afar\" dynamic effect.\r\n\r\n### Layered Animation Delays\r\n\r\n```typescript\r\nstyle={{\r\n    animationDelay: `${index * 120}ms`\r\n}}\r\n```\r\n\r\nEach menu item's animation delays by 120ms, creating a \"wave-like\" appearance effect. Menu items don't appear simultaneously but appear sequentially in order, like dominoes.\r\n\r\n### Easing Function Choice\r\n\r\n`cubic-bezier(0.4, 0, 0.2, 1)` is the \"standard\" easing function from Material Design, with characteristics:\r\n- **Slow start**: Acceleration is slower at the beginning, conforming to physical intuition\r\n- **Fast end**: Quickly reaches target state at the end, avoiding sluggishness\r\n- **Smooth transition**: No abrupt speed changes throughout the process\r\n\r\n## Event Handling and Performance Optimization\r\n\r\nWhen handling complex interactions, proper event management and performance optimization are essential.\r\n\r\n### Event Listener Lifecycle Management\r\n\r\nDrag functionality requires listening to mouse events at the document level, but these listeners must be properly managed to avoid memory leaks:\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    if (isDragging) {\r\n        document.addEventListener('mousemove', handleMouseMove);\r\n        document.addEventListener('mouseup', handleMouseUp);\r\n        return () =\u003e {\r\n            document.removeEventListener('mousemove', handleMouseMove);\r\n            document.removeEventListener('mouseup', handleMouseUp);\r\n        };\r\n    } else {\r\n        // Ensure listeners are removed in non-drag state\r\n        document.removeEventListener('mousemove', handleMouseMove);\r\n        document.removeEventListener('mouseup', handleMouseUp);\r\n    }\r\n}, [isDragging, handleMouseMove, handleMouseUp]);\r\n```\r\n\r\nDesign features:\r\n1. **Conditional listening**: Only add listeners during drag state, reducing unnecessary event processing\r\n2. **Automatic cleanup**: useEffect's return function ensures cleanup when component unmounts\r\n3. **State synchronization**: When drag state changes, listeners update accordingly\r\n\r\n### Performance Optimization with useCallback\r\n\r\n```typescript\r\nconst handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    // Processing logic...\r\n}, [isDragging, dragOffset, dragStartPosition]);\r\n\r\nconst snapToEdge = useCallback((currentPos: Position) =\u003e {\r\n    // Snapping logic...\r\n}, []);\r\n```\r\n\r\n`useCallback` ensures these function references remain stable when dependencies don't change, avoiding unnecessary re-renders and frequent addition/removal of event listeners.\r\n\r\n### Event Bubbling Prevention Strategy\r\n\r\n```typescript\r\nconst handleMouseDown = (e: React.MouseEvent) =\u003e {\r\n    e.preventDefault();  // Prevent default behaviors like text selection\r\n    if (isExpanded) return;  // Disable drag in expanded state\r\n    \r\n    setIsDragging(true);\r\n    // ... other logic\r\n};\r\n```\r\n\r\n`e.preventDefault()` prevents some default browser behaviors that might interfere with dragging, such as text selection, image dragging, etc.\r\n\r\n## Reusable Design Pattern Summary\r\n\r\nThrough this in-depth analysis, we can extract several general design patterns that can be applied to other similar interactive systems.\r\n\r\n### Core Design Pattern Extraction\r\n\r\n**Drag System Pattern**:\r\n```typescript\r\n// 1. State initialization\r\nconst [isDragging, setIsDragging] = useState(false);\r\nconst [dragOffset, setDragOffset] = useState({x: 0, y: 0});\r\nconst [position, setPosition] = useState({x: 0, y: 0});\r\n\r\n// 2. Event handling\r\nconst handleMouseDown = (e) =\u003e {\r\n    const rect = elementRef.current?.getBoundingClientRect();\r\n    setDragOffset({\r\n        x: e.clientX - rect.left,\r\n        y: e.clientY - rect.top\r\n    });\r\n    setIsDragging(true);\r\n};\r\n\r\n// 3. Position update\r\nconst handleMouseMove = (e) =\u003e {\r\n    if (!isDragging) return;\r\n    setPosition({\r\n        x: e.clientX - dragOffset.x,\r\n        y: e.clientY - dragOffset.y\r\n    });\r\n};\r\n```\r\n\r\n**Circular Layout Pattern**:\r\n```typescript\r\nconst getCircularPosition = (index, total, radius, centerX, centerY) =\u003e {\r\n    const angle = (2 * Math.PI * index) / total - Math.PI / 2;\r\n    return {\r\n        x: centerX + Math.cos(angle) * radius,\r\n        y: centerY + Math.sin(angle) * radius\r\n    };\r\n};\r\n```\r\n\r\n**State Machine Pattern**:\r\n```typescript\r\n// Clear state definition\r\nconst states = {\r\n    IDLE: 'idle',\r\n    DRAGGING: 'dragging',\r\n    EXPANDED: 'expanded'\r\n};\r\n\r\n// State transition logic\r\nconst handleStateTransition = (currentState, action) =\u003e {\r\n    switch (currentState) {\r\n        case states.IDLE:\r\n            return action === 'drag' ? states.DRAGGING : \r\n                   action === 'click' ? states.EXPANDED : currentState;\r\n        // ... other state transitions\r\n    }\r\n};\r\n```\r\n\r\n**Debounced Animation Pattern**:\r\n```typescript\r\nconst [pendingValue, setPendingValue] = useState(null);\r\nconst timerRef = useRef(null);\r\n\r\nconst debouncedUpdate = (newValue) =\u003e {\r\n    setPendingValue(newValue);\r\n    \r\n    if (timerRef.current) clearTimeout(timerRef.current);\r\n    \r\n    timerRef.current = setTimeout(() =\u003e {\r\n        setActualValue(newValue);\r\n    }, delay);\r\n};\r\n```\r\n\r\n### Best Practice Distillation\r\n\r\n1. **Event listener cleanup**: Always clean up event listeners in useEffect's return function\r\n2. **Coordinate calculation boundary protection**: Use Math.min/max to ensure coordinates are within safe ranges\r\n3. **State synchronization**: Related state updates must stay synchronized, avoiding intermediate states\r\n4. **Animation timing**: Complex animations must consider timing relationships between parts\r\n5. **User feedback**: Even with delayed updates, provide immediate visual feedback\r\n\r\n## Complete Source Code Analysis\r\n\r\n```typescript\r\n'use client';\r\nimport React, {useCallback, useEffect, useRef, useState} from 'react';\r\nimport {usePathname, useRouter} from 'next/navigation';\r\nimport {useTheme} from './ThemeProvider';\r\nimport {useLocaleStore} from '@/lib/stores/localeStore';\r\nimport {LOCALES} from '@/lib/utils/locales';\r\n\r\n// ==================== Type Definitions ====================\r\ninterface Position {\r\n    x: number;  // X coordinate\r\n    y: number;  // Y coordinate\r\n}\r\n\r\nexport function Navigation() {\r\n    // ==================== State Management ====================\r\n    // Basic states\r\n    const [mounted, setMounted] = useState(false);                    // Component mount state\r\n    const [isExpanded, setIsExpanded] = useState(false);              // Menu expansion state\r\n    \r\n    // Position-related states\r\n    const [position, setPosition] = useState\u003cPosition\u003e({x: 50, y: 50});           // Current position\r\n    const [originalPosition, setOriginalPosition] = useState\u003cPosition\u003e({x: 50, y: 50}); // Original position record\r\n    \r\n    // Drag-related states\r\n    const [isDragging, setIsDragging] = useState(false);              // Drag state flag\r\n    const [dragOffset, setDragOffset] = useState\u003cPosition\u003e({x: 0, y: 0});         // Drag offset\r\n    const [dragStartPosition, setDragStartPosition] = useState\u003cPosition\u003e({x: 0, y: 0}); // Drag start position\r\n    const [showRipple, setShowRipple] = useState(false);              // Show ripple effect\r\n    \r\n    // References and timers\r\n    const debounceTimerRef = useRef\u003cNodeJS.Timeout | null\u003e(null);     // Debounce timer\r\n    const hasDraggedSignificantlyRef = useRef(false);                 // Has significant drag occurred\r\n    const pendingPositionRef = useRef\u003cPosition\u003e({x: 50, y: 50});      // Pending position update\r\n    const ballRef = useRef\u003cHTMLDivElement\u003e(null);                     // Navigation ball reference\r\n    \r\n    // Next.js and theme hooks\r\n    const router = useRouter();\r\n    const pathname = usePathname();\r\n    const {theme, toggleTheme} = useTheme();\r\n    const {locale, toggleLocale} = useLocaleStore();\r\n\r\n    // ==================== Initialization Effect ====================\r\n    /**\r\n     * Initialize position when component mounts\r\n     * Calculate initial position during client-side rendering, avoiding window undefined issue during SSR\r\n     */\r\n    useEffect(() =\u003e {\r\n        setMounted(true);\r\n        const initialX = window.innerWidth - 80;   // 80px from right edge\r\n        const initialY = 100;                      // 100px from top\r\n        setPosition({x: initialX, y: initialY});\r\n        setOriginalPosition({x: initialX, y: initialY});\r\n        pendingPositionRef.current = {x: initialX, y: initialY};\r\n    }, []);\r\n\r\n    /**\r\n     * Clean up debounce timer to prevent memory leaks\r\n     */\r\n    useEffect(() =\u003e {\r\n        return () =\u003e {\r\n            if (debounceTimerRef.current) {\r\n                clearTimeout(debounceTimerRef.current);\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    // ==================== Navigation Configuration ====================\r\n    /**\r\n     * Navigation menu configuration\r\n     * Define all navigable pages and their identifiers\r\n     */\r\n    const sections = [\r\n        {\r\n            id: 'personal' as const,\r\n            label: 'Personal',\r\n            description: 'About Me',\r\n            href: '/personal'\r\n        },\r\n        {\r\n            id: 'works' as const,\r\n            label: 'Works',\r\n            description: 'Portfolio',\r\n            href: '/works'\r\n        },\r\n        {\r\n            id: 'contributions' as const,\r\n            label: 'Contributions',\r\n            description: 'Open Source',\r\n            href: '/contributions'\r\n        },\r\n        {\r\n            id: 'documents' as const,\r\n            label: 'Documents',\r\n            description: 'Insights',\r\n            href: '/documents'\r\n        },\r\n    ];\r\n\r\n    /**\r\n     * Get active navigation item based on current path\r\n     * @returns Currently active navigation item ID or null\r\n     */\r\n    const getActiveSection = () =\u003e {\r\n        if (pathname === '/') return 'personal';\r\n        if (pathname === '/works') return 'works';\r\n        if (pathname === '/contributions') return 'contributions';\r\n        if (pathname === '/documents') return 'documents';\r\n        return null;\r\n    };\r\n\r\n    const activeSection = getActiveSection();\r\n\r\n    // ==================== Core Algorithm: Edge Snapping ====================\r\n    /**\r\n     * Edge snapping algorithm\r\n     * Calculate distance to four boundaries and move to nearest boundary\r\n     * @param currentPos Current position\r\n     * @returns Position after snapping\r\n     */\r\n    const snapToEdge = useCallback((currentPos: Position) =\u003e {\r\n        const windowWidth = window.innerWidth;\r\n        const windowHeight = window.innerHeight;\r\n        const ballSize = 70;    // Navigation ball size\r\n        const margin = 20;      // Distance from edge\r\n        let newPos = {...currentPos};\r\n\r\n        // Calculate distances to four boundaries\r\n        const distanceToLeft = currentPos.x;\r\n        const distanceToRight = windowWidth - currentPos.x;\r\n        const distanceToTop = currentPos.y;\r\n        const distanceToBottom = windowHeight - currentPos.y;\r\n        \r\n        // Find minimum distance\r\n        const minDistance = Math.min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom);\r\n\r\n        // Determine snap direction based on minimum distance\r\n        if (minDistance === distanceToLeft) {\r\n            newPos.x = margin;  // Snap to left\r\n        } else if (minDistance === distanceToRight) {\r\n            newPos.x = windowWidth - ballSize - margin;  // Snap to right\r\n        } else if (minDistance === distanceToTop) {\r\n            newPos.y = margin;  // Snap to top\r\n        } else {\r\n            newPos.y = windowHeight - ballSize - margin;  // Snap to bottom\r\n        }\r\n\r\n        // Boundary constraints: ensure position is within safe range\r\n        newPos.x = Math.max(margin, Math.min(windowWidth - ballSize - margin, newPos.x));\r\n        newPos.y = Math.max(margin, Math.min(windowHeight - ballSize - margin, newPos.y));\r\n        \r\n        return newPos;\r\n    }, []);\r\n\r\n    // ==================== Drag Event Handling ====================\r\n    /**\r\n     * Mouse down event handler\r\n     * Initialize drag state, record start position and offset\r\n     */\r\n    const handleMouseDown = (e: React.MouseEvent) =\u003e {\r\n        e.preventDefault();  // Prevent default behaviors (like text selection)\r\n        if (isExpanded) return;  // Disable drag in expanded state\r\n\r\n        setIsDragging(true);\r\n        hasDraggedSignificantlyRef.current = false;\r\n        setDragStartPosition({x: e.clientX, y: e.clientY});\r\n        \r\n        // Calculate mouse click position relative to navigation ball offset\r\n        const rect = ballRef.current?.getBoundingClientRect();\r\n        if (rect) {\r\n            setDragOffset({\r\n                x: e.clientX - rect.left,  // Mouse X - ball left = X offset\r\n                y: e.clientY - rect.top    // Mouse Y - ball top = Y offset\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Mouse move event handler (with debounce strategy)\r\n     * Update position in real-time, but use debouncing to avoid frequent rendering\r\n     */\r\n    const handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n        if (!isDragging) return;\r\n\r\n        // Calculate new position based on mouse position and initial offset\r\n        const newPos = {\r\n            x: e.clientX - dragOffset.x,\r\n            y: e.clientY - dragOffset.y\r\n        };\r\n\r\n        // Store pending position (for debounced update)\r\n        pendingPositionRef.current = newPos;\r\n\r\n        // Immediately show ripple effect for instant feedback\r\n        setShowRipple(true);\r\n\r\n        // Clear existing debounce timer\r\n        if (debounceTimerRef.current) {\r\n            clearTimeout(debounceTimerRef.current);\r\n        }\r\n\r\n        // Set new debounce timer (500ms delay)\r\n        debounceTimerRef.current = setTimeout(() =\u003e {\r\n            setPosition(newPos);\r\n            setShowRipple(false);\r\n        }, 500);\r\n\r\n        // Calculate drag distance to determine if it's significant drag\r\n        const dragDistance = Math.sqrt(\r\n            Math.pow(e.clientX - dragStartPosition.x, 2) +\r\n            Math.pow(e.clientY - dragStartPosition.y, 2)\r\n        );\r\n\r\n        // Over 3 pixels is considered significant drag\r\n        if (dragDistance \u003e 3) {\r\n            hasDraggedSignificantlyRef.current = true;\r\n        }\r\n    }, [isDragging, dragOffset, dragStartPosition]);\r\n\r\n    /**\r\n     * Mouse up event handler\r\n     * End drag and execute snapping logic\r\n     */\r\n    const handleMouseUp = useCallback(() =\u003e {\r\n        if (!isDragging) return;\r\n\r\n        setIsDragging(false);\r\n        setShowRipple(false);\r\n\r\n        // Clear debounce timer\r\n        if (debounceTimerRef.current) {\r\n            clearTimeout(debounceTimerRef.current);\r\n            debounceTimerRef.current = null;\r\n        }\r\n\r\n        // If significant drag occurred, execute edge snapping\r\n        if (hasDraggedSignificantlyRef.current) {\r\n            const snappedPos = snapToEdge(pendingPositionRef.current);\r\n            setPosition(snappedPos);\r\n            setOriginalPosition(snappedPos);  // Update original position record\r\n        }\r\n\r\n        // Delay reset of drag flag to avoid conflict with click events\r\n        setTimeout(() =\u003e {\r\n            hasDraggedSignificantlyRef.current = false;\r\n        }, 100);\r\n    }, [isDragging]);\r\n\r\n    // ==================== Global Event Listeners ====================\r\n    /**\r\n     * Manage global mouse event listeners\r\n     * Only add listeners during drag state for performance optimization\r\n     */\r\n    useEffect(() =\u003e {\r\n        if (isDragging) {\r\n            document.addEventListener('mousemove', handleMouseMove);\r\n            document.addEventListener('mouseup', handleMouseUp);\r\n            return () =\u003e {\r\n                document.removeEventListener('mousemove', handleMouseMove);\r\n                document.removeEventListener('mouseup', handleMouseUp);\r\n            };\r\n        } else {\r\n            // Ensure listeners are removed in non-drag state\r\n            document.removeEventListener('mousemove', handleMouseMove);\r\n            document.removeEventListener('mouseup', handleMouseUp);\r\n        }\r\n    }, [isDragging]);\r\n\r\n    // ==================== Interaction Event Handling ====================\r\n    /**\r\n     * Navigation ball click event handler\r\n     * Toggle expand/collapse state, handle position movement\r\n     */\r\n    const handleBallClick = () =\u003e {\r\n        // Only handle click when no significant drag occurred\r\n        if (!hasDraggedSignificantlyRef.current) {\r\n            if (!isExpanded) {\r\n                // Expand: save current position, move to screen center\r\n                setOriginalPosition(position);\r\n                const centerX = window.innerWidth / 2 - 35;   // Center X - ball radius\r\n                const centerY = window.innerHeight / 2 - 35;  // Center Y - ball radius\r\n                setPosition({x: centerX, y: centerY});\r\n                setIsExpanded(true);\r\n            } else {\r\n                // Collapse: delay 150ms before returning to original position\r\n                setIsExpanded(false);\r\n                setTimeout(() =\u003e {\r\n                    setPosition(originalPosition);\r\n                }, 150);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Menu item click event handler\r\n     * Execute action then collapse menu\r\n     */\r\n    const handleMenuItemClick = (action: () =\u003e void) =\u003e {\r\n        action();\r\n        setIsExpanded(false);\r\n        setTimeout(() =\u003e {\r\n            setPosition(originalPosition);\r\n        }, 150);\r\n    };\r\n\r\n    /**\r\n     * Page navigation handler\r\n     */\r\n    const navigateToPage = (href: string) =\u003e {\r\n        handleMenuItemClick(() =\u003e router.push(href));\r\n    };\r\n\r\n    /**\r\n     * Theme toggle handler\r\n     */\r\n    const handleThemeToggle = () =\u003e {\r\n        handleMenuItemClick(() =\u003e toggleTheme());\r\n    };\r\n\r\n    /**\r\n     * Locale toggle handler\r\n     * Support language switching redirect for document pages\r\n     */\r\n    const handleLocaleToggle = () =\u003e {\r\n        handleMenuItemClick(() =\u003e {\r\n            toggleLocale((newLocale) =\u003e {\r\n                // Check if on document page, redirect to same article in new language\r\n                if (pathname.startsWith('/documents/')) {\r\n                    const pathSegments = pathname.split('/').filter(Boolean);\r\n                    if (pathSegments.length \u003e= 4) {\r\n                        const [, currentLang, category, fileName] = pathSegments;\r\n                        const newPath = `/documents/${newLocale}/${category}/${fileName}`;\r\n                        router.push(newPath);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Backdrop click event handler\r\n     * Click background to collapse menu\r\n     */\r\n    const handleBackdropClick = () =\u003e {\r\n        setIsExpanded(false);\r\n        setTimeout(() =\u003e {\r\n            setPosition(originalPosition);\r\n        }, 150);\r\n    };\r\n\r\n    // ==================== Core Algorithm: Circular Layout ====================\r\n    /**\r\n     * Circular menu layout algorithm\r\n     * Use polar coordinates to calculate menu item positions\r\n     * @param index Menu item index\r\n     * @param total Total number of menu items\r\n     * @param radius Circle radius\r\n     * @returns Screen coordinates of menu item\r\n     */\r\n    const getCircularPosition = (index: number, total: number, radius: number = 120) =\u003e {\r\n        // Calculate angle: divide circumference equally, starting angle at -π/2 (12 o'clock)\r\n        const angle = (2 * Math.PI * index) / total - Math.PI / 2;\r\n        \r\n        // Screen center coordinates\r\n        const centerX = window.innerWidth / 2;\r\n        const centerY = window.innerHeight / 2;\r\n        \r\n        // Polar to Cartesian coordinate conversion\r\n        return {\r\n            x: centerX + Math.cos(angle) * radius - 60,  // -60 for menu item width adjustment\r\n            y: centerY + Math.sin(angle) * radius - 30,  // -30 for menu item height adjustment\r\n        };\r\n    };\r\n\r\n    // ==================== Style Utility Functions ====================\r\n    /**\r\n     * Get uniform button styles\r\n     */\r\n    const getUniformButtonStyles = () =\u003e {\r\n        return \"fixed z-50 rounded-xl shadow-lg hover:scale-110 transition-all duration-300 group opacity-0 menu-item backdrop-blur-md border bg-surface/60 border-surface/40 hover:bg-surface/80\";\r\n    };\r\n\r\n    /**\r\n     * Get theme button styles\r\n     */\r\n    const getThemeButtonStyles = () =\u003e {\r\n        return \"fixed z-50 w-16 h-12 rounded-xl shadow-lg hover:scale-110 transition-all duration-300 group opacity-0 menu-item backdrop-blur-md bg-transparent hover:bg-surface/20\";\r\n    };\r\n\r\n    // ==================== UI Components ====================\r\n    /**\r\n     * Active state indicator component\r\n     */\r\n    const ActiveIndicator = ({isActive}: { isActive: boolean }) =\u003e {\r\n        if (!isActive) return null;\r\n\r\n        return (\r\n            \u003cdiv className=\"absolute -top-1 -right-1 w-3 h-3 rounded-full shadow-lg\"\u003e\r\n                \u003cdiv className=\"w-full h-full rounded-full bg-primary\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n        );\r\n    };\r\n\r\n    // Theme icon components\r\n    const SunIcon = () =\u003e (\r\n        \u003cdiv className=\"w-5 h-5 text-accent transition-all duration-300\"\u003e\r\n            \u003csvg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\r\n                \u003cpath fillRule=\"evenodd\"\r\n                      d=\"M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z\"\r\n                      clipRule=\"evenodd\"/\u003e\r\n            \u003c/svg\u003e\r\n        \u003c/div\u003e\r\n    );\r\n\r\n    const MoonIcon = () =\u003e (\r\n        \u003cdiv className=\"w-5 h-5 text-accent transition-all duration-300\"\u003e\r\n            \u003csvg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\r\n                \u003cpath d=\"M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z\"/\u003e\r\n            \u003c/svg\u003e\r\n        \u003c/div\u003e\r\n    );\r\n\r\n    // Language toggle icon component\r\n    const LocaleIcon = () =\u003e (\r\n        \u003cdiv className=\"w-5 h-5 text-accent transition-all duration-300 flex items-center justify-center\"\u003e\r\n            \u003cspan className=\"text-sm font-bold\"\u003e\r\n                {LOCALES[locale].flag}\r\n            \u003c/span\u003e\r\n        \u003c/div\u003e\r\n    );\r\n\r\n    // ==================== Render Logic ====================\r\n    /**\r\n     * Loading state render\r\n     */\r\n    if (!mounted) {\r\n        return (\r\n            \u003cdiv className=\"fixed top-20 right-5 z-50\"\u003e\r\n                \u003cdiv\r\n                    className=\"w-16 h-16 rounded-full backdrop-blur-md border animate-pulse bg-surface/60 border-surface/40\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Build complete menu items array\r\n     */\r\n    const allMenuItems = [\r\n        ...sections.map(section =\u003e ({\r\n            type: 'section' as const,\r\n            section,\r\n            action: () =\u003e navigateToPage(section.id === 'personal' ? '/' : section.href),\r\n            isActive: activeSection === section.id\r\n        })),\r\n        {\r\n            type: 'theme' as const,\r\n            action: handleThemeToggle,\r\n            isActive: false\r\n        },\r\n        {\r\n            type: 'locale' as const,\r\n            action: handleLocaleToggle,\r\n            isActive: false\r\n        }\r\n    ];\r\n\r\n    return (\r\n        \u003c\u003e\r\n            {/* ==================== Main Navigation Ball ==================== */}\r\n            \u003cdiv\r\n                ref={ballRef}\r\n                className={`\r\n          fixed z-50 transition-all duration-500 cursor-pointer select-none\r\n          ${isDragging ? 'cursor-grabbing scale-110 duration-0' : 'cursor-grab hover:scale-105'}\r\n          ${isExpanded ? 'hover:scale-120' : ''}\r\n        `}\r\n                style={{\r\n                    left: `${position.x}px`,\r\n                    top: `${position.y}px`,\r\n                    transform: `${isDragging ? 'rotate(5deg)' : isExpanded ? 'rotate(0deg) scale(1.1)' : 'rotate(0deg)'}`\r\n                }}\r\n                onMouseDown={handleMouseDown}\r\n                onClick={handleBallClick}\r\n            \u003e\r\n                {/* Modern navigation ball */}\r\n                \u003cdiv className={`\r\n          relative w-16 h-16 rounded-full transition-all duration-500\r\n          ${isExpanded ? 'animate-pulse shadow-lg' : ''}\r\n        `}\u003e\r\n                    {/* Ball shadow */}\r\n                    \u003cdiv className=\"absolute inset-0 rounded-full bg-black/20 blur-lg translate-y-2\"\u003e\u003c/div\u003e\r\n                    \r\n                    {/* Ripple effect - shown during drag */}\r\n                    {showRipple \u0026\u0026 (\r\n                        \u003cdiv\r\n                            className=\"absolute rounded-full border-2 animate-ping pointer-events-none\"\r\n                            style={{\r\n                                borderColor: theme === 'dark' ? 'rgba(78, 205, 196, 0.6)' : 'rgba(0, 102, 204, 0.6)',\r\n                                width: '80px',\r\n                                height: '80px',\r\n                                top: '-8px',\r\n                                left: '-8px',\r\n                                animationDuration: '1s'\r\n                            }}\r\n                        \u003e\u003c/div\u003e\r\n                    )}\r\n\r\n                    {/* Main ball body */}\r\n                    \u003cdiv\r\n                        className=\"relative w-full h-full rounded-full shadow-xl transform-gpu backdrop-blur-md border transition-all duration-300 bg-surface/60 border-surface/40 hover:bg-surface/80\"\u003e\r\n                        {/* Highlight effect */}\r\n                        \u003cdiv className=\"absolute top-2 left-2 w-4 h-4 rounded-full bg-white/30 blur-sm\"\u003e\u003c/div\u003e\r\n                        \r\n                        {/* Menu symbol */}\r\n                        \u003cdiv className=\"absolute inset-0 flex items-center justify-center\"\u003e\r\n                            \u003cdiv className={`\r\n                w-6 h-6 rounded-full border transition-all duration-300 flex items-center justify-center border-foreground/40\r\n                ${isExpanded ? 'rotate-90 scale-110' : 'rotate-0'}\r\n              `}\u003e\r\n                                {\r\n                                    isExpanded ? (\r\n                                        \u003cdiv\r\n                                            className=\"relative transition-all duration-300 w-2 h-2 opacity-50 text-center flex items-center justify-center text-foreground\"\r\n                                            style={{transform: 'translateY(-1px)'}}\r\n                                        \u003e×\u003c/div\u003e\r\n                                    ) : (\r\n                                        \u003cdiv\r\n                                            className=\"transition-all duration-300 w-1 h-1 opacity-50 rounded-full bg-foreground\"\u003e\u003c/div\u003e\r\n                                    )\r\n                                }\r\n\r\n                            \u003c/div\u003e\r\n                        \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n\r\n            {/* ==================== Circular Menu ==================== */}\r\n            {isExpanded \u0026\u0026 (\r\n                \u003c\u003e\r\n                    {/* Background overlay */}\r\n                    \u003cdiv\r\n                        className=\"fixed inset-0 z-40 backdrop-blur-md transition-all duration-300 bg-background/20\"\r\n                        onClick={handleBackdropClick}\r\n                    \u003e\u003c/div\u003e\r\n\r\n                    {/* Circular layout menu items */}\r\n                    {allMenuItems.map((item, index) =\u003e {\r\n                        const circularPos = getCircularPosition(index, allMenuItems.length);\r\n\r\n                        if (item.type === 'section') {\r\n                            const section = item.section!;\r\n\r\n                            return (\r\n                                \u003cbutton\r\n                                    key={section.id}\r\n                                    onClick={item.action}\r\n                                    className={`${getUniformButtonStyles()} w-28 h-14 ${item.isActive ? 'ring-2 ring-blue-400/60 scale-105' : ''}`}\r\n                                    style={{\r\n                                        left: `${circularPos.x}px`,\r\n                                        top: `${circularPos.y}px`,\r\n                                        animationDelay: `${index * 120}ms`\r\n                                    }}\r\n                                \u003e\r\n                                    {/* Section content */}\r\n                                    \u003cdiv\r\n                                        className=\"absolute inset-0 flex flex-col items-center justify-center text-foreground\"\u003e\r\n                                        \u003cspan className=\"text-sm font-bold leading-tight text-center\"\u003e\r\n                                            {section.label}\r\n                                        \u003c/span\u003e\r\n                                        \u003cspan className=\"text-xs opacity-70 mt-0.5 font-medium\"\u003e\r\n                                            {section.description}\r\n                                        \u003c/span\u003e\r\n                                    \u003c/div\u003e\r\n\r\n                                    \u003cActiveIndicator isActive={item.isActive}/\u003e\r\n                                \u003c/button\u003e\r\n                            );\r\n                        } else if (item.type === 'theme') {\r\n                            return (\r\n                                \u003cbutton\r\n                                    key=\"theme\"\r\n                                    onClick={item.action}\r\n                                    className={getThemeButtonStyles()}\r\n                                    style={{\r\n                                        left: `${circularPos.x}px`,\r\n                                        top: `${circularPos.y}px`,\r\n                                        animationDelay: `${index * 120}ms`\r\n                                    }}\r\n                                \u003e\r\n                                    {/* Theme toggle icon */}\r\n                                    \u003cdiv className=\"flex items-center justify-center h-full\"\u003e\r\n                                        {theme === 'dark' ? \u003cSunIcon/\u003e : \u003cMoonIcon/\u003e}\r\n                                    \u003c/div\u003e\r\n                                \u003c/button\u003e\r\n                            );\r\n                        } else { // locale toggle\r\n                            return (\r\n                                \u003cbutton\r\n                                    key=\"locale\"\r\n                                    onClick={item.action}\r\n                                    className={getThemeButtonStyles()}\r\n                                    style={{\r\n                                        left: `${circularPos.x}px`,\r\n                                        top: `${circularPos.y}px`,\r\n                                        animationDelay: `${index * 120}ms`\r\n                                    }}\r\n                                \u003e\r\n                                    {/* Language toggle icon */}\r\n                                    \u003cdiv className=\"flex items-center justify-center h-full\"\u003e\r\n                                        \u003cLocaleIcon/\u003e\r\n                                    \u003c/div\u003e\r\n                                \u003c/button\u003e\r\n                            );\r\n                        }\r\n                    })}\r\n                \u003c/\u003e\r\n            )}\r\n\r\n            {/* ==================== CSS Animation Definitions ==================== */}\r\n            \u003cstyle jsx\u003e{`\r\n                @keyframes menuItemAppear {\r\n                    0% {\r\n                        opacity: 0;\r\n                        transform: scale(0) translate(-50%, -50%);\r\n                    }\r\n                    50% {\r\n                        opacity: 0.7;\r\n                        transform: scale(0.8) translate(-25%, -25%);\r\n                    }\r\n                    100% {\r\n                        opacity: 1;\r\n                        transform: scale(1) translate(0%, 0%);\r\n                    }\r\n                }\r\n\r\n                @keyframes menuItemDisappear {\r\n                    0% {\r\n                        opacity: 1;\r\n                        transform: scale(1) translate(0%, 0%);\r\n                    }\r\n                    50% {\r\n                        opacity: 0.3;\r\n                        transform: scale(0.6) translate(-25%, -25%);\r\n                    }\r\n                    100% {\r\n                        opacity: 0;\r\n                        transform: scale(0) translate(-50%, -50%);\r\n                    }\r\n                }\r\n\r\n                .menu-item {\r\n                    animation: menuItemAppear 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;\r\n                }\r\n            `}\u003c/style\u003e\r\n        \u003c/\u003e\r\n    );\r\n}\r\n```\r\n\r\n### Core Algorithm Flow Diagram\r\n\r\n```\r\nUser Interaction → Event Judgment → State Update → Position Calculation → Visual Feedback\r\n    ↓                ↓               ↓              ↓                  ↓\r\nMouse Down      Drag/Click      isDragging     dragOffset         Ripple Effect\r\n    ↓                ↓               ↓              ↓                  ↓\r\nMouse Move      Distance Calc   position Update  Debounced Update  Real-time Feedback\r\n    ↓                ↓               ↓              ↓                  ↓\r\nMouse Up        Snapping Algo   Boundary Constraint Menu Expand    Animation Transition\r\n```\r\n\r\n### Key Algorithm Analysis\r\n\r\n**1. Edge Snapping Core Algorithm**\r\n```typescript\r\n// Key: Calculate distance to four edges, move to nearest boundary\r\nconst distanceToLeft = currentPos.x;\r\nconst distanceToRight = windowWidth - currentPos.x;\r\nconst distanceToTop = currentPos.y;\r\nconst distanceToBottom = windowHeight - currentPos.y;\r\nconst minDistance = Math.min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom);\r\n\r\n// Determine snap direction based on minimum distance\r\nif (minDistance === distanceToLeft) {\r\n    newPos.x = margin;  // Snap to left\r\n}\r\n```\r\n\r\n**2. Circular Layout Mathematical Calculation**\r\n```typescript\r\n// Key: Polar coordinate conversion + angle division\r\nconst angle = (2 * Math.PI * index) / total - Math.PI / 2;  // Angle calculation\r\nconst x = centerX + Math.cos(angle) * radius;               // X coordinate conversion\r\nconst y = centerY + Math.sin(angle) * radius;               // Y coordinate conversion\r\n```\r\n\r\n**3. Debounced Drag Optimization**\r\n```typescript\r\n// Key: Immediate feedback + delayed update\r\npendingPositionRef.current = newPos;     // Store pending position\r\nsetShowRipple(true);                     // Show immediate feedback\r\nsetTimeout(() =\u003e {                       // Debounced update\r\n    setPosition(newPos);\r\n    setShowRipple(false);\r\n}, 500);\r\n```\r\n\r\n**4. Drag Distance Determination**\r\n```typescript\r\n// Key: Euclidean distance calculation\r\nconst dragDistance = Math.sqrt(\r\n    Math.pow(e.clientX - dragStartPosition.x, 2) +\r\n    Math.pow(e.clientY - dragStartPosition.y, 2)\r\n);\r\nif (dragDistance \u003e 3) {  // 3 pixel threshold filters hand tremor\r\n    hasDraggedSignificantlyRef.current = true;\r\n}\r\n```\r\n\r\n*May your navigation be as stable as the North Star, as dynamic as a meteor.* ✨\r\n"])</script><script>self.__next_f.push([1,"1f:Ta251,"])</script><script>self.__next_f.push([1,"\r\n# Foam Background: From Canvas Thinking to DOM Implementation of a Particle World\r\n\r\nPreface—This is part of the aesthetics plan.\r\n\r\nIn this article, I will start from the Canvas mindset and gradually demonstrate how to create smooth particle animation effects using DOM + CSS combinations, covering implementation details across all aspects including physics simulation, theme responsiveness, performance optimization, and more.\r\n\r\n## Translating Canvas Thinking into the DOM World\r\n\r\nBefore we begin, let's talk about why we're \"betraying\" Canvas and embracing the DOM.\r\n\r\n### Canvas vs DOM: A Philosophical Choice\r\n\r\nIn the Canvas world, particle system implementation is straightforward:\r\n\r\n```javascript\r\n// Canvas classic approach\r\nfunction drawParticle(ctx, particle) {\r\n    ctx.beginPath();\r\n    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\r\n    ctx.fillStyle = particle.color;\r\n    ctx.fill();\r\n}\r\n\r\nfunction animateFrame() {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    particles.forEach(particle =\u003e {\r\n        updateParticle(particle);\r\n        drawParticle(ctx, particle);\r\n    });\r\n    requestAnimationFrame(animateFrame);\r\n}\r\n```\r\n\r\nClean and simple, with decent performance. But I chose DOM for these reasons:\r\n\r\n1. This is point one\r\n2. This is point two\r\n3. This is point three\r\n4. This is point four\r\n5. This is...\r\n\r\nOkay, enough joking. Actually it's:\r\n\r\n1. **Better accessibility**: DOM elements natively support screen readers and other assistive technologies\r\n2. **Easier theme integration**: Seamless integration with CSS variables and theme systems\r\n3. **Simpler event handling**: Each particle is a real DOM element, making event handling more intuitive\r\n4. **GPU-accelerated transforms**: CSS transform properties automatically trigger GPU acceleration\r\n\r\nOf course, the trade-off is increased complexity and some performance compromises. ~~(Mainly because the AI initially gave me a DOM solution and I went deeper and deeper down this path)~~\r\n\r\n### The Art of Creating DOM Particles\r\n\r\nIn the DOM world, each particle is a real div element:\r\n\r\n```typescript\r\nconst el = document.createElement('div');\r\nel.style.position = 'absolute';\r\nel.style.borderRadius = '50%';\r\nel.style.backgroundColor = colors.particle;\r\nel.style.pointerEvents = 'none';\r\nel.style.willChange = 'transform, opacity';\r\n\r\ncontainer.appendChild(el);\r\n```\r\n\r\nProperty explanations:\r\n\r\n- **position: absolute**: Takes particles out of document flow for free positioning\r\n- **borderRadius: 50%**: Transforms square div into circle, mimicking foam shape\r\n- **pointerEvents: none**: Ensures particles don't interfere with user page interactions\r\n- **willChange**: Hints to browser that this element will change frequently, enabling optimizations\r\n\r\n### Coordinate System Mapping\r\n\r\nCanvas uses standard Cartesian coordinates, while DOM uses CSS coordinates. Fortunately, the mapping is straightforward:\r\n\r\n```typescript\r\n// Canvas: drawCircle(x, y, radius)\r\n// DOM: element.style.left = x + 'px'; element.style.top = y + 'px';\r\n\r\n// Our implementation\r\np.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\np.el.style.opacity = opacity.toString();\r\n```\r\n\r\nUsing `transform` instead of directly modifying `left/top` is important: **transform doesn't trigger reflow**, only repaint and compositing, which is much better for performance.\r\n\r\n## Particle Lifecycle \u0026 Data Architecture\r\n\r\nNow let's dive into the core of the particle system—data structure design.\r\n\r\n### Particle Interface Design\r\n\r\n```typescript\r\ninterface Particle {\r\n  el: HTMLDivElement;    // DOM element reference\r\n  x: number;             // X coordinate\r\n  y: number;             // Y coordinate  \r\n  vx: number;            // X velocity\r\n  vy: number;            // Y velocity\r\n  size: number;          // Particle size\r\n  depth: number;         // Depth layer (0-1)\r\n}\r\n```\r\n\r\nField explanations:\r\n\r\n- **el**: Directly stores DOM element reference, avoiding frequent DOM queries\r\n- **x, y**: Current precise position (can be decimal)\r\n- **vx, vy**: Velocity vector for physics simulation\r\n- **size**: Base particle size, combined with depth to calculate final display size\r\n- **depth**: Key to visual depth, controlling particle size, opacity, and movement speed\r\n\r\n### Particle Initialization Randomization Strategy\r\n\r\n```typescript\r\nconst initializeParticles = useCallback(() =\u003e {\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n    const colors = getThemeColors();\r\n\r\n    for (let i = 0; i \u003c NUM_PARTICLES; i++) {\r\n        const size = 2 + Math.random() * 4;      // Random size 2-6px\r\n        const depth = Math.random();             // Random depth 0-1\r\n        const x = Math.random() * width;         // Random X position\r\n        const y = Math.random() * height;        // Random Y position\r\n\r\n        const particle = {\r\n            el, x, y,\r\n            vx: 0, vy: 0,                        // Initial velocity is 0\r\n            size, depth\r\n        };\r\n        \r\n        particlesRef.current.push(particle);\r\n    }\r\n}, [getThemeColors]);\r\n```\r\n\r\n**Why initial velocity is 0**? Let particles start from rest, only moving when subject to external forces (animation effects), which feels more physically intuitive.\r\n\r\n### Animation Loop Time Precision Control\r\n\r\nThis is the heart of the entire system—the animation loop:\r\n\r\n```typescript\r\nconst animate = useCallback(() =\u003e {\r\n    const mouse = mouseRef.current;\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    for (let p of particlesRef.current) {\r\n        // Base drift (simulate fluid motion)\r\n        p.vx += 0.01 * p.depth;\r\n        p.vy += 0.005 * p.depth;\r\n\r\n        // Interactive force field calculation\r\n        if (mouse.down) {\r\n            const dx = p.x - mouse.x;\r\n            const dy = p.y - mouse.y;\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            if (dist \u003c 100) {\r\n                const baseForce = 100 / (dist + 10);\r\n                const force = baseForce * p.depth;\r\n\r\n                p.vx += force * (dx / dist);\r\n                p.vy += force * (dy / dist);\r\n            }\r\n        }\r\n\r\n        // Apply friction\r\n        p.vx *= 0.95;\r\n        p.vy *= 0.95;\r\n\r\n        // Update position\r\n        p.x += p.vx;\r\n        p.y += p.vy;\r\n\r\n        // Boundary wrapping\r\n        if (p.x \u003c -10) p.x = width + 10;\r\n        if (p.x \u003e width + 10) p.x = -10;\r\n        if (p.y \u003c -10) p.y = height + 10;\r\n        if (p.y \u003e height + 10) p.y = -10;\r\n\r\n        // Visual effect updates\r\n        const scale = 0.6 + 0.4 * p.depth;\r\n        const opacity = 0.4 + 0.6 * p.depth;\r\n\r\n        p.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\n        p.el.style.opacity = opacity.toString();\r\n    }\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n}, []);\r\n```\r\n\r\nValue explanations:\r\n\r\n1. **0.01 * p.depth**: Base drift force, giving particles slight natural movement\r\n2. **0.005 * p.depth**: Y-direction drift is smaller, simulating subtle gravity influence\r\n3. **100 / (dist + 10)**: Inverse square force field, closer distance = stronger force, +10 avoids division by zero\r\n4. **0.95**: Friction coefficient, gradually slowing particle movement, simulating air resistance\r\n5. **-10, +10**: Boundary buffer, letting particles enter from off-screen to avoid sudden appearance\r\n\r\n## The Physics World of Interaction Systems\r\n\r\nYou don't want the background UI to be just a dynamic wallpaper, right?—Woz Ki Shuo De\r\n\r\n### Complete Lifecycle Management of Mouse Events\r\n\r\n```typescript\r\nconst mouseRef = useRef\u003cMouseState\u003e({ x: 0, y: 0, down: false });\r\n\r\nconst updateMousePos = useCallback((e: MouseEvent | Touch) =\u003e {\r\n    mouseRef.current.x = e.clientX;\r\n    mouseRef.current.y = e.clientY;\r\n}, []);\r\n\r\nconst handleMouseDown = useCallback((e: MouseEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e);\r\n}, [updateMousePos]);\r\n\r\nconst handleMouseUp = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n}, []);\r\n\r\nconst handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e);\r\n}, [updateMousePos]);\r\n```\r\n\r\n**Why use ref instead of state**? Because in a 60fps animation loop, we need to read mouse position every frame. Using state would cause unnecessary re-renders. Ref provides an \"escape hatch from React's render cycle.\"\r\n\r\n### Mathematical Principles of Force Field Calculation\r\n\r\nThis is the core of physics simulation:\r\n\r\n```typescript\r\n// Calculate vector from particle to mouse\r\nconst dx = p.x - mouse.x;\r\nconst dy = p.y - mouse.y;\r\n\r\n// Calculate distance (Euclidean distance)\r\nconst dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n// Inverse square force field (like gravity)\r\nconst baseForce = 100 / (dist + 10);\r\n\r\n// Depth affects force magnitude\r\nconst force = baseForce * p.depth;\r\n\r\n// Calculate unit vector and apply force\r\np.vx += force * (dx / dist);\r\np.vy += force * (dy / dist);\r\n```\r\n\r\nThis formula simulates a \"repulsion field\":\r\n\r\n1. **Distance calculation**: Uses Pythagorean theorem to calculate actual distance\r\n2. **Force magnitude**: Uses inverse square law, closer distance = stronger force\r\n3. **Force direction**: `(dx/dist, dy/dist)` is the unit vector from mouse to particle\r\n4. **Depth weighting**: Particles closer to screen are more affected by force, adding depth perception\r\n\r\n### Multi-touch Support\r\n\r\n```typescript\r\nconst handleTouchStart = useCallback((e: TouchEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n\r\nconst handleTouchMove = useCallback((e: TouchEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n```\r\n\r\nMobile device support only takes the first touch point because multi-touch physics simulation would become extremely complex, and most users only use one finger anyway. ~~(Rationalization of laziness)~~\r\n\r\n### Friction Simulation\r\n\r\n```typescript\r\np.vx *= 0.95;\r\np.vy *= 0.95;\r\n```\r\n\r\n~~Random friction coefficient found online.~~\r\n\r\n## Color Mixing in Theme Systems\r\n\r\nThe foam background needs seamless integration with the website's theme system, involving fairly complex color mixing calculations.\r\n\r\n### HSL Color Space\r\n\r\nCompared to RGB, HSL is more suitable for generating similar colors:\r\n\r\n```typescript\r\nconst hexToHsl = useCallback((hex: string) =\u003e {\r\n    // Convert hex to RGB\r\n    const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n    const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n    const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n\r\n    // Find max and min values\r\n    const max = Math.max(r, g, b);\r\n    const min = Math.min(r, g, b);\r\n    let h = 0, s = 0, l = (max + min) / 2;\r\n\r\n    if (max !== min) {\r\n        const d = max - min;\r\n        s = l \u003e 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        \r\n        switch (max) {\r\n            case r: h = (g - b) / d + (g \u003c b ? 6 : 0); break;\r\n            case g: h = (b - r) / d + 2; break;\r\n            case b: h = (r - g) / d + 4; break;\r\n        }\r\n        h /= 6;\r\n    }\r\n\r\n    return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];\r\n}, []);\r\n```\r\n\r\nThis conversion algorithm looks complex but the principle is intuitive:\r\n1. **Normalize RGB to 0-1 range**\r\n2. **Calculate lightness (L)**: Average of max and min values\r\n3. **Calculate saturation (S)**: Based on lightness and color range\r\n4. **Calculate hue (H)**: Based on dominant color position\r\n\r\n### Dynamic Generation Strategy for Theme Response\r\n\r\n```typescript\r\nconst getThemeColors = useCallback(() =\u003e {\r\n    const [primaryH, primaryS] = hexToHsl(currentTheme.colors.primary);\r\n    const [accentH, accentS] = hexToHsl(currentTheme.colors.accent);\r\n    \r\n    const isDark = currentTheme.id === 'dark';\r\n    \r\n    if (isDark) {\r\n        // Dark theme: deeper, more saturated colors\r\n        return {\r\n            background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS + 10, 40)}%, 25%), hsl(${accentH}, ${Math.max(accentS + 5, 35)}%, 20%))`,\r\n            particle: `hsl(${primaryH}, ${Math.max(primaryS + 15, 50)}%, 45%)`\r\n        };\r\n    } else {\r\n        // Light theme: brighter colors\r\n        return {\r\n            background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS - 20, 20)}%, 60%), hsl(${accentH}, ${Math.max(accentS - 10, 30)}%, 50%))`,\r\n            particle: `hsl(${primaryH}, ${Math.max(primaryS - 10, 35)}%, 75%)`\r\n        };\r\n    }\r\n}, [currentTheme, hexToHsl]);\r\n```\r\n\r\nThis function considers multiple factors:\r\n\r\n- **Saturation adjustment**: Dark mode increases saturation, light mode decreases it, ensuring appropriate contrast\r\n- **Lightness control**: Dark mode uses lower lightness values (20-45%), light mode uses higher values (50-75%)\r\n- **Gradient design**: 135-degree diagonal gradient from primary to accent color, creating spatial depth\r\n- **Safety boundaries**: Uses `Math.max()` to ensure saturation and lightness don't go too low\r\n\r\n### Real-time Updates of Dynamic Colors\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    if (particlesRef.current.length \u003e 0) {\r\n        const colors = getThemeColors();\r\n        \r\n        // Update all particle colors\r\n        particlesRef.current.forEach(p =\u003e {\r\n            p.el.style.backgroundColor = colors.particle;\r\n        });\r\n        \r\n        // Update container background\r\n        if (containerRef.current) {\r\n            containerRef.current.style.background = colors.background;\r\n        }\r\n    }\r\n}, [currentTheme, getThemeColors]);\r\n```\r\n\r\nWhen themes switch, all particles synchronously update colors without recreating DOM elements, ensuring smooth transitions.\r\n\r\n### Depth Mathematical Model\r\n\r\n```typescript\r\nconst depth = Math.random(); // Random depth value 0-1\r\n\r\n// Depth-based scaling\r\nconst scale = 0.6 + 0.4 * depth;\r\n\r\n// Depth-based opacity\r\nconst opacity = 0.4 + 0.6 * depth;\r\n\r\n// Depth-based movement speed\r\np.vx += 0.01 * p.depth;\r\np.vy += 0.005 * p.depth;\r\n```\r\n\r\nLayered rendering:\r\n\r\n- **scale: 0.6-1.0**: Distant particles are small, near particles are large\r\n- **opacity: 0.4-1.0**: Distant particles are transparent, near particles are opaque\r\n- **speed: depth multiplier**: Near particles move faster, distant particles move slower\r\n\r\n### Parallax Motion Simulation\r\n\r\n```typescript\r\n// In interaction force calculation\r\nconst force = baseForce * p.depth;\r\n```\r\n\r\nUsing depth value as force multiplier means:\r\n- Near particles are more sensitive to interaction\r\n- Distant particles react more sluggishly\r\n- Overall presents parallax scrolling effect\r\n\r\nThis design makes users feel like they're interacting with a real 3D space rather than points on a plane. (Maybe?)\r\n\r\n## Particle Redistribution in Responsive Layout\r\n\r\nWhen window size changes, the particle system needs to flexibly adapt to new dimensions.\r\n\r\n### Window Size Change Monitoring Strategy\r\n\r\n```typescript\r\nconst handleResize = useCallback(() =\u003e {\r\n    // Reinitialize particle distribution\r\n    initializeParticles();\r\n}, [initializeParticles]);\r\n\r\nuseEffect(() =\u003e {\r\n    window.addEventListener('resize', handleResize);\r\n    \r\n    return () =\u003e window.removeEventListener('resize', handleResize);\r\n}, [handleResize]);\r\n```\r\n\r\n**Why choose reinitialization over repositioning**? Because repositioning existing particles would cause visual \"jumping,\" while reinitialization, though briefly rebuilding, creates more natural visual effects.\r\n\r\n### Memory Safety of Particle Cleanup\r\n\r\n```typescript\r\n// Clean existing particles\r\nparticlesRef.current.forEach(p =\u003e p.el.remove());\r\nparticlesRef.current = [];\r\n```\r\n\r\n**Why manual remove**? Because we use native DOM operations, React won't automatically clean these elements. Without manual removal, DOM would accumulate lots of invisible elements, causing memory leaks.\r\n\r\n### Necessity of Debouncing\r\n\r\nWhen users resize windows, resize events fire frantically. Without debouncing, every tiny window change would recreate 300 particles—after dragging back and forth dozens of times, you might hear the beautiful sound of GPU fans spinning.\r\n\r\n**Debounce implementation**:\r\n\r\n```typescript\r\n// Debounce utility function\r\nconst debounce = useCallback((func: Function, wait: number) =\u003e {\r\n    let timeout: NodeJS.Timeout;\r\n    return function executedFunction(...args: any[]) {\r\n        const later = () =\u003e {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}, []);\r\n\r\n// Create debounced resize handler\r\nconst debouncedHandleResize = useCallback(\r\n    debounce(handleResize, 1000), // 1 second debounce delay\r\n    [debounce, handleResize]\r\n);\r\n\r\n// Use debounced version in event listener\r\nuseEffect(() =\u003e {\r\n    window.addEventListener('resize', debouncedHandleResize);\r\n    \r\n    return () =\u003e {\r\n        window.removeEventListener('resize', debouncedHandleResize);\r\n    };\r\n}, [debouncedHandleResize]);\r\n```\r\n\r\n**How debouncing works**:\r\n\r\n1. User starts dragging window → First resize event arrives\r\n2. Debounce function sets 1000ms timer, preparing to execute rebuild\r\n3. User continues dragging → More resize events arrive\r\n4. Each new event cancels previous timer and restarts countdown\r\n5. User stops dragging for 1000ms → Timer triggers, executes particle rebuild\r\n\r\nThis optimizes what could be dozens of rebuild operations into just one rebuild after the user truly \"finishes adjusting.\"\r\n\r\n## Key Performance Optimization Strategies\r\n\r\nAnimating 300 DOM elements simultaneously is a severe test for browsers—every optimization detail is crucial.\r\n\r\n### Proper Use of willChange Property\r\n\r\n```typescript\r\nel.style.willChange = 'transform, opacity';\r\n```\r\n\r\nThis line tells the browser: \"This element's transform and opacity will change frequently, please prepare a GPU layer for it.\"\r\n\r\nBut! willChange is a double-edged sword:\r\n- **Benefits**: Enables GPU acceleration, smoother animations\r\n- **Drawbacks**: Consumes extra GPU memory, too much use can backfire\r\n\r\nSo we only use it on properties that truly need animation.\r\n\r\n### requestAnimationFrame Lifecycle Management\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    animate();\r\n    \r\n    return () =\u003e {\r\n        if (animationIdRef.current !== null) {\r\n            cancelAnimationFrame(animationIdRef.current);\r\n        }\r\n        \r\n        // Clean all particles\r\n        particlesRef.current.forEach(p =\u003e p.el.remove());\r\n    };\r\n}, [animate]);\r\n```\r\n\r\nThis cleanup function does two important things:\r\n1. **Cancel animation frames**: Prevents animation from continuing after component unmounts\r\n2. **Clean DOM elements**: Prevents memory leaks\r\n\r\n### z-index Strategy for Layer Management\r\n\r\n```typescript\r\nclassName=\"fixed inset-0 w-full h-full overflow-hidden pointer-events-none z-0\"\r\n```\r\n\r\n- **z-0**: Ensures background stays at bottom layer, never obscuring other content\r\n- **pointer-events-none**: Makes entire container non-responsive to mouse events, avoiding page interaction interference\r\n- **overflow-hidden**: Prevents particles from displaying outside container\r\n\r\n## Edge Cases in Event Handling\r\n\r\nReal-world user interactions are far more complex than ideal scenarios—we need to handle various edge cases.\r\n\r\n### Special Handling for Touch Devices\r\n\r\n```typescript\r\nconst handleTouchStart = useCallback((e: TouchEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n\r\nconst handleTouchMove = useCallback((e: TouchEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n\r\nconst handleTouchEnd = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n}, []);\r\n```\r\n\r\n**Why only take the first touch point**? Because multi-touch would make force field calculations extremely complex, and most users only use one finger to \"poke bubbles\" anyway.\r\n\r\n### Event Listener Scope Control\r\n\r\n```typescript\r\n// Global events\r\ndocument.addEventListener('mousedown', handleMouseDown);\r\ndocument.addEventListener('mouseup', handleMouseUp);\r\ndocument.addEventListener('mousemove', handleMouseMove);\r\n\r\n// Container local events\r\ncontainer.addEventListener('touchstart', handleTouchStart);\r\ncontainer.addEventListener('touchend', handleTouchEnd);\r\ncontainer.addEventListener('touchmove', handleTouchMove);\r\n```\r\n\r\n- **Mouse events bound to document**: Ensures interaction continues even when mouse moves outside container during dragging\r\n- **Touch events bound to container**: Touch event propagation mechanisms differ, binding to container is safer\r\n\r\n## Reusable Design Pattern Summary\r\n\r\nThrough this in-depth implementation analysis, we can extract several universal design patterns.\r\n\r\n### Universal Architecture for Particle Systems\r\n\r\n```typescript\r\n// 1. Data structure design\r\ninterface Particle {\r\n    el: HTMLElement;      // DOM reference\r\n    x: number; y: number; // Position\r\n    vx: number; vy: number; // Velocity\r\n    [key: string]: any;   // Other properties\r\n}\r\n\r\n// 2. Lifecycle management\r\nconst createParticle = () =\u003e { /* Creation logic */ };\r\nconst updateParticle = (particle: Particle) =\u003e { /* Update logic */ };\r\nconst destroyParticle = (particle: Particle) =\u003e { /* Destruction logic */ };\r\n\r\n// 3. Animation loop\r\nconst animate = () =\u003e {\r\n    particles.forEach(updateParticle);\r\n    requestAnimationFrame(animate);\r\n};\r\n```\r\n\r\n### Basic Patterns for Physics Simulation\r\n\r\n```typescript\r\n// Force field calculation pattern\r\nconst calculateForce = (particle: Particle, target: Position) =\u003e {\r\n    const dx = particle.x - target.x;\r\n    const dy = particle.y - target.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    const force = strength / (distance + epsilon);\r\n    \r\n    return {\r\n        fx: force * (dx / distance),\r\n        fy: force * (dy / distance)\r\n    };\r\n};\r\n\r\n// Boundary handling pattern\r\nconst handleBoundaries = (particle: Particle, bounds: Bounds) =\u003e {\r\n    if (particle.x \u003c bounds.left) particle.x = bounds.right;\r\n    if (particle.x \u003e bounds.right) particle.x = bounds.left;\r\n    if (particle.y \u003c bounds.top) particle.y = bounds.bottom;\r\n    if (particle.y \u003e bounds.bottom) particle.y = bounds.top;\r\n};\r\n```\r\n\r\n### Design Patterns for Theme Response\r\n\r\n```typescript\r\n// Color system pattern\r\nconst createThemeColors = (baseTheme: Theme) =\u003e {\r\n    const [h, s, l] = hexToHsl(baseTheme.primary);\r\n    \r\n    return {\r\n        background: `hsl(${h}, ${s}%, ${l}%)`,\r\n        particle: `hsl(${h}, ${Math.max(s - 20, 20)}%, ${l + 20}%)`,\r\n        // ... other colors\r\n    };\r\n};\r\n\r\n// Theme switching response pattern\r\nuseEffect(() =\u003e {\r\n    const colors = createThemeColors(currentTheme);\r\n    updateParticleColors(colors);\r\n}, [currentTheme]);\r\n```\r\n\r\n### Responsive Particle Layout Pattern\r\n\r\n```typescript\r\n// Responsive relayout pattern\r\nconst handleResize = useCallback(() =\u003e {\r\n    // Clean existing particles\r\n    particles.forEach(particle =\u003e particle.el.remove());\r\n    \r\n    // Reinitialize\r\n    initializeParticles();\r\n}, []);\r\n\r\nuseEffect(() =\u003e {\r\n    window.addEventListener('resize', handleResize);\r\n    return () =\u003e window.removeEventListener('resize', handleResize);\r\n}, []);\r\n```\r\n\r\n### Performance Optimization Best Practices\r\n\r\n1. **Use requestAnimationFrame instead of timers**\r\n2. **Use transform instead of directly modifying position properties**\r\n3. **Use willChange hints appropriately**\r\n4. **Clean up DOM elements and event listeners promptly**\r\n5. **Avoid frequent DOM queries, use reference caching**\r\n6. **Use debouncing and throttling when appropriate**\r\n\r\n## Implementation Review\r\n\r\nThrough this in-depth technical analysis, we've seen the complex world hidden behind a seemingly simple \"foam background.\" From Canvas thinking to DOM implementation, from physics simulation to visual effects, from performance optimization to edge case handling—every aspect requires careful design and meticulous debugging.\r\n\r\nChoosing DOM over Canvas might seem like \"using a cannon to shoot mosquitoes,\" but this choice brings better accessibility, easier theme integration, and more intuitive event handling. Sometimes, the seemingly \"dumb\" approach can open up new possibilities.\r\n\r\n## Complete Implementation Source Code\r\n\r\n```typescript\r\n'use client';\r\nimport React, { useEffect, useRef, useCallback } from 'react';\r\nimport { useThemeStore } from '@/lib/stores/themeStore';\r\n\r\n// ==================== Type Definitions ====================\r\n/**\r\n * Particle data structure\r\n * Each particle is an independent physical entity\r\n */\r\ninterface Particle {\r\n  el: HTMLDivElement;  // DOM element reference, avoiding frequent queries\r\n  x: number;           // Current X coordinate (precise to decimal)\r\n  y: number;           // Current Y coordinate (precise to decimal)\r\n  vx: number;          // X-direction velocity\r\n  vy: number;          // Y-direction velocity\r\n  size: number;        // Particle base size\r\n  depth: number;       // Depth layer (0-1), affecting size, opacity, speed\r\n}\r\n\r\n/**\r\n * Mouse/Touch state\r\n * Used for interactive force field calculations\r\n */\r\ninterface MouseState {\r\n  x: number;      // Mouse X coordinate\r\n  y: number;      // Mouse Y coordinate\r\n  down: boolean;  // Whether in pressed state\r\n}\r\n\r\nconst FoamBackground: React.FC = () =\u003e {\r\n  // ==================== Reference Definitions ====================\r\n  const containerRef = useRef\u003cHTMLDivElement\u003e(null);        // Container DOM reference\r\n  const particlesRef = useRef\u003cParticle[]\u003e([]);              // Particle array reference\r\n  const mouseRef = useRef\u003cMouseState\u003e({ x: 0, y: 0, down: false }); // Mouse state reference\r\n  const animationIdRef = useRef\u003cnumber | null\u003e(null);       // Animation ID reference for canceling animation\r\n  const { currentTheme } = useThemeStore();                 // Theme state\r\n\r\n  // ==================== Configuration Constants ====================\r\n  const NUM_PARTICLES = 300;  // Total particle count, balancing visual effect and performance\r\n\r\n  // ==================== Utility Functions ====================\r\n  /**\r\n   * Debounce utility function\r\n   * Used to optimize resize event handling, avoiding frequent particle rebuilds\r\n   * @param func Function to debounce\r\n   * @param wait Debounce delay time (milliseconds)\r\n   */\r\n  const debounce = useCallback((func: Function, wait: number) =\u003e {\r\n    let timeout: NodeJS.Timeout;\r\n    return function executedFunction(...args: any[]) {\r\n      const later = () =\u003e {\r\n        clearTimeout(timeout);\r\n        func(...args);\r\n      };\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(later, wait);\r\n    };\r\n  }, []);\r\n\r\n  /**\r\n   * Convert hexadecimal color to HSL color space\r\n   * HSL is more suitable for generating similar color variations\r\n   * @param hex Hexadecimal color value (e.g., \"#ff6600\")\r\n   * @returns [hue, saturation, lightness] array\r\n   */\r\n  const hexToHsl = useCallback((hex: string) =\u003e {\r\n    // Convert hex to RGB (0-1 range)\r\n    const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n    const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n    const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n\r\n    // Calculate max and min values\r\n    const max = Math.max(r, g, b);\r\n    const min = Math.min(r, g, b);\r\n    let h = 0, s = 0, l = (max + min) / 2;  // Lightness is average of max and min\r\n\r\n    if (max !== min) {\r\n      const d = max - min;\r\n      // Calculate saturation based on lightness\r\n      s = l \u003e 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      \r\n      // Calculate hue based on dominant color\r\n      switch (max) {\r\n        case r: h = (g - b) / d + (g \u003c b ? 6 : 0); break;  // Red dominant\r\n        case g: h = (b - r) / d + 2; break;                // Green dominant\r\n        case b: h = (r - g) / d + 4; break;                // Blue dominant\r\n      }\r\n      h /= 6;  // Convert to 0-1 range\r\n    }\r\n\r\n    // Return standard HSL format\r\n    return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];\r\n  }, []);\r\n\r\n  /**\r\n   * Generate dynamic colors based on current theme\r\n   * Dark theme uses deeper, more saturated colors\r\n   * Light theme uses brighter, softer colors\r\n   */\r\n  const getThemeColors = useCallback(() =\u003e {\r\n    const [primaryH, primaryS] = hexToHsl(currentTheme.colors.primary);\r\n    const [accentH, accentS] = hexToHsl(currentTheme.colors.accent);\r\n    \r\n    const isDark = currentTheme.id === 'dark';\r\n    \r\n    if (isDark) {\r\n      // Dark theme: increase saturation, decrease lightness\r\n      return {\r\n        background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS + 10, 40)}%, 25%), hsl(${accentH}, ${Math.max(accentS + 5, 35)}%, 20%))`,\r\n        particle: `hsl(${primaryH}, ${Math.max(primaryS + 15, 50)}%, 45%)`\r\n      };\r\n    } else {\r\n      // Light theme: decrease saturation, increase lightness\r\n      return {\r\n        background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS - 20, 20)}%, 60%), hsl(${accentH}, ${Math.max(accentS - 10, 30)}%, 50%))`,\r\n        particle: `hsl(${primaryH}, ${Math.max(primaryS - 10, 35)}%, 75%)`\r\n      };\r\n    }\r\n  }, [currentTheme, hexToHsl]);\r\n\r\n  // ==================== Mouse and Touch Event Handling ====================\r\n  /**\r\n   * Update mouse position\r\n   * Compatible with mouse events and touch events\r\n   */\r\n  const updateMousePos = useCallback((e: MouseEvent | Touch) =\u003e {\r\n    mouseRef.current.x = e.clientX;\r\n    mouseRef.current.y = e.clientY;\r\n  }, []);\r\n\r\n  /**\r\n   * Mouse down event handler\r\n   * Activate interactive force field\r\n   */\r\n  const handleMouseDown = useCallback((e: MouseEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e);\r\n  }, [updateMousePos]);\r\n\r\n  /**\r\n   * Mouse up event handler\r\n   * Deactivate interactive force field\r\n   */\r\n  const handleMouseUp = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n  }, []);\r\n\r\n  /**\r\n   * Mouse move event handler\r\n   * Only update position when pressed to reduce unnecessary calculations\r\n   */\r\n  const handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e);\r\n  }, [updateMousePos]);\r\n\r\n  /**\r\n   * Touch start event handler\r\n   * Mobile device interaction support\r\n   */\r\n  const handleTouchStart = useCallback((e: TouchEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e.touches[0]);  // Only take first touch point\r\n  }, [updateMousePos]);\r\n\r\n  /**\r\n   * Touch end event handler\r\n   */\r\n  const handleTouchEnd = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n  }, []);\r\n\r\n  /**\r\n   * Touch move event handler\r\n   */\r\n  const handleTouchMove = useCallback((e: TouchEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e.touches[0]);\r\n  }, [updateMousePos]);\r\n\r\n  // ==================== Particle System Core ====================\r\n  /**\r\n   * Initialize particle system\r\n   * Create specified number of particles and distribute them on screen\r\n   */\r\n  const initializeParticles = useCallback(() =\u003e {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // Clean existing particles to prevent memory leaks\r\n    particlesRef.current.forEach(p =\u003e p.el.remove());\r\n    particlesRef.current = [];\r\n\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n    const colors = getThemeColors();\r\n\r\n    // Create specified number of particles\r\n    for (let i = 0; i \u003c NUM_PARTICLES; i++) {\r\n      // Create DOM element\r\n      const el = document.createElement('div');\r\n      el.style.position = 'absolute';           // Absolute positioning, out of document flow\r\n      el.style.borderRadius = '50%';            // Circular particles\r\n      el.style.backgroundColor = colors.particle; // Theme color\r\n      el.style.pointerEvents = 'none';          // Don't respond to mouse events\r\n      el.style.willChange = 'transform, opacity'; // Hint browser for optimization\r\n      \r\n      container.appendChild(el);\r\n\r\n      // Random size (2-6px)\r\n      const size = 2 + Math.random() * 4;\r\n      el.style.width = `${size}px`;\r\n      el.style.height = `${size}px`;\r\n\r\n      // Random depth and position\r\n      const depth = Math.random();              // 0-1 depth value\r\n      const x = Math.random() * width;          // Random X position\r\n      const y = Math.random() * height;         // Random Y position\r\n\r\n      // Create particle object\r\n      particlesRef.current.push({\r\n        el,\r\n        x, y,\r\n        vx: 0, vy: 0,    // Initial velocity is 0\r\n        size, depth\r\n      });\r\n    }\r\n  }, [getThemeColors]);\r\n\r\n  /**\r\n   * Animation loop function\r\n   * This is the heart of the entire particle system, called every frame\r\n   */\r\n  const animate = useCallback(() =\u003e {\r\n    const mouse = mouseRef.current;\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    // Traverse all particles for physics updates\r\n    for (let p of particlesRef.current) {\r\n      // ==================== Base Drift Force ====================\r\n      // Simulate natural fluid motion\r\n      p.vx += 0.01 * p.depth;   // X-direction base drift\r\n      p.vy += 0.005 * p.depth;  // Y-direction base drift (slightly smaller, simulating gravity)\r\n\r\n      // ==================== Interactive Force Field Calculation ====================\r\n      if (mouse.down) {\r\n        // Calculate vector from particle to mouse\r\n        const dx = p.x - mouse.x;\r\n        const dy = p.y - mouse.y;\r\n        // Calculate distance (Euclidean distance)\r\n        const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        // Only apply force within interaction range\r\n        if (dist \u003c 100) {\r\n          // Inverse square force field (like gravity)\r\n          const baseForce = 100 / (dist + 10);  // +10 prevents division by zero\r\n          const force = baseForce * p.depth;     // Depth affects force magnitude\r\n\r\n          // Apply force in direction away from mouse\r\n          p.vx += force * (dx / dist);  // Unit vector X component\r\n          p.vy += force * (dy / dist);  // Unit vector Y component\r\n        }\r\n      }\r\n\r\n      // ==================== Apply Friction ====================\r\n      // Gradually slow down particle movement, simulating air resistance\r\n      p.vx *= 0.95;  // Friction coefficient\r\n      p.vy *= 0.95;\r\n\r\n      // ==================== Update Position ====================\r\n      p.x += p.vx;  // Apply X velocity\r\n      p.y += p.vy;  // Apply Y velocity\r\n\r\n      // ==================== Boundary Wrapping ====================\r\n      // Particles loop from one side to the other\r\n      if (p.x \u003c -10) p.x = width + 10;   // Left boundary wrapping\r\n      if (p.x \u003e width + 10) p.x = -10;   // Right boundary wrapping\r\n      if (p.y \u003c -10) p.y = height + 10;  // Top boundary wrapping\r\n      if (p.y \u003e height + 10) p.y = -10;  // Bottom boundary wrapping\r\n\r\n      // ==================== Visual Effect Updates ====================\r\n      // Calculate display properties based on depth\r\n      const scale = 0.6 + 0.4 * p.depth;      // Scale: 0.6-1.0\r\n      const opacity = 0.4 + 0.6 * p.depth;    // Opacity: 0.4-1.0\r\n\r\n      // Apply visual changes to DOM element\r\n      p.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\n      p.el.style.opacity = opacity.toString();\r\n    }\r\n\r\n    // Continue animation loop\r\n    animationIdRef.current = requestAnimationFrame(animate);\r\n  }, []);\r\n\r\n  // ==================== Window Resize Handling ====================\r\n  /**\r\n   * Handle window resize\r\n   * Reinitialize particles to adapt to new screen size\r\n   */\r\n  const handleResize = useCallback(() =\u003e {\r\n    // Reinitialize particle distribution\r\n    initializeParticles();\r\n  }, [initializeParticles]);\r\n\r\n  // Create debounced resize handler (1 second delay)\r\n  const debouncedHandleResize = useCallback(\r\n    debounce(handleResize, 1000),\r\n    [debounce, handleResize]\r\n  );\r\n\r\n  // ==================== Theme Change Handling ====================\r\n  /**\r\n   * Handle theme changes\r\n   * Update particle colors when theme switches\r\n   */\r\n  useEffect(() =\u003e {\r\n    if (particlesRef.current.length \u003e 0) {\r\n      const colors = getThemeColors();\r\n      \r\n      // Update all particle colors\r\n      particlesRef.current.forEach(p =\u003e {\r\n        p.el.style.backgroundColor = colors.particle;\r\n      });\r\n      \r\n      // Update container background\r\n      if (containerRef.current) {\r\n        containerRef.current.style.background = colors.background;\r\n      }\r\n    }\r\n  }, [currentTheme, getThemeColors]);\r\n\r\n  // ==================== Component Lifecycle ====================\r\n  /**\r\n   * Component initialization effect\r\n   * Set up particles, events, and start animation\r\n   */\r\n  useEffect(() =\u003e {\r\n    // Initialize particle system\r\n    initializeParticles();\r\n\r\n    // Start animation loop\r\n    animate();\r\n\r\n    // Add global event listeners\r\n    document.addEventListener('mousedown', handleMouseDown);\r\n    document.addEventListener('mouseup', handleMouseUp);\r\n    document.addEventListener('mousemove', handleMouseMove);\r\n\r\n    // Add resize listener\r\n    window.addEventListener('resize', debouncedHandleResize);\r\n\r\n    // Add container touch event listeners\r\n    const container = containerRef.current;\r\n    if (container) {\r\n      container.addEventListener('touchstart', handleTouchStart);\r\n      container.addEventListener('touchend', handleTouchEnd);\r\n      container.addEventListener('touchmove', handleTouchMove);\r\n    }\r\n\r\n    // Cleanup function\r\n    return () =\u003e {\r\n      // Cancel animation\r\n      if (animationIdRef.current !== null) {\r\n        cancelAnimationFrame(animationIdRef.current);\r\n      }\r\n      \r\n      // Remove event listeners\r\n      document.removeEventListener('mousedown', handleMouseDown);\r\n      document.removeEventListener('mouseup', handleMouseUp);\r\n      document.removeEventListener('mousemove', handleMouseMove);\r\n      window.removeEventListener('resize', debouncedHandleResize);\r\n      \r\n      if (container) {\r\n        container.removeEventListener('touchstart', handleTouchStart);\r\n        container.removeEventListener('touchend', handleTouchEnd);\r\n        container.removeEventListener('touchmove', handleTouchMove);\r\n      }\r\n      \r\n      // Clean up all particles\r\n      particlesRef.current.forEach(p =\u003e p.el.remove());\r\n    };\r\n  }, [animate, initializeParticles, debouncedHandleResize, \r\n      handleMouseDown, handleMouseUp, handleMouseMove,\r\n      handleTouchStart, handleTouchEnd, handleTouchMove]);\r\n\r\n  // ==================== Render ====================\r\n  return (\r\n    \u003cdiv\r\n      ref={containerRef}\r\n      className=\"fixed inset-0 w-full h-full overflow-hidden pointer-events-none z-0\"\r\n      style={{\r\n        background: getThemeColors().background\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n\r\nexport default FoamBackground;\r\n```\r\n\r\n### Performance Analysis and Optimization Strategies\r\n\r\n**1. Memory Management**\r\n```typescript\r\n// Proper cleanup prevents memory leaks\r\nparticlesRef.current.forEach(p =\u003e p.el.remove());\r\nparticlesRef.current = [];\r\n\r\n// Cancel animation frames when component unmounts\r\nif (animationIdRef.current !== null) {\r\n  cancelAnimationFrame(animationIdRef.current);\r\n}\r\n```\r\n\r\n**2. Event Optimization**\r\n```typescript\r\n// Use refs for high-frequency reads to avoid re-renders\r\nconst mouseRef = useRef\u003cMouseState\u003e({ x: 0, y: 0, down: false });\r\n\r\n// Debounce resize events to prevent excessive rebuilds\r\nconst debouncedHandleResize = useCallback(\r\n  debounce(handleResize, 1000),\r\n  [debounce, handleResize]\r\n);\r\n```\r\n\r\n**3. DOM Performance**\r\n```typescript\r\n// Use willChange hint for GPU acceleration\r\nel.style.willChange = 'transform, opacity';\r\n\r\n// Use transform instead of top/left for better performance\r\np.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\n```\r\n\r\n**4. Physics Optimization**\r\n```typescript\r\n// Limit force field range to reduce calculations\r\nif (dist \u003c 100) {\r\n  const baseForce = 100 / (dist + 10);\r\n  // Apply force only to nearby particles\r\n}\r\n```\r\n\r\n### Algorithm Flow Diagram\r\n\r\n```\r\nInitialize → Create Particles → Start Animation Loop\r\n    ↓              ↓                    ↓\r\nTheme Setup   DOM Creation        Physics Update\r\n    ↓              ↓                    ↓\r\nColor Calc   Position/Size         Force Fields\r\n    ↓              ↓                    ↓\r\nEvent Setup   Style Applied        Boundary Check\r\n    ↓              ↓                    ↓\r\nReady State   Visual Setup         Render Frame\r\n                   ↓                    ↓\r\n              Animation Ready      Continue Loop\r\n```\r\n\r\n### Core Mathematical Models\r\n\r\n**1. Force Field Physics**\r\n```typescript\r\n// Inverse square law force calculation\r\nconst baseForce = 100 / (dist + 10);\r\nconst force = baseForce * p.depth;\r\n\r\n// Unit vector calculation\r\nconst unitX = dx / dist;\r\nconst unitY = dy / dist;\r\n\r\n// Apply force\r\np.vx += force * unitX;\r\np.vy += force * unitY;\r\n```\r\n\r\n**2. Depth-Based Layering**\r\n```typescript\r\n// Depth affects multiple visual properties\r\nconst scale = 0.6 + 0.4 * p.depth;      // Size: 60%-100%\r\nconst opacity = 0.4 + 0.6 * p.depth;    // Opacity: 40%-100%\r\nconst speed = 0.01 * p.depth;           // Speed: depth proportional\r\n```\r\n\r\n**3. Color Space Mathematics**\r\n```typescript\r\n// HSL color space conversion for theme adaptation\r\nconst [h, s, l] = hexToHsl(themeColor);\r\n\r\n// Dark theme: +saturation, -lightness\r\nconst darkColor = `hsl(${h}, ${s + 15}%, ${l - 20}%)`;\r\n\r\n// Light theme: -saturation, +lightness  \r\nconst lightColor = `hsl(${h}, ${s - 10}%, ${l + 20}%)`;\r\n```\r\n\r\n*May your particles shine like stardust, light as foam, dancing gracefully at users' fingertips.* ✨\r\n"])</script><script>self.__next_f.push([1,"20:Tbc38,"])</script><script>self.__next_f.push([1,"\r\n# 3D Case Cards: The Interactive Revolution from Flat to Dimensional\r\n\r\nAfter all, we need to add some unnecessary embellishments to the overused card content display~~ (not really)~~ (No, it is! Yeah!)\r\n\r\nThis 3D card system integrates complex spatial layout algorithms, physics-simulated mouse tracking, refined state management, and eye-catching animation effects. In this article, I'll start from the most basic type definitions and gradually dive deep into every implementation detail, providing a comprehensive analysis of this 3D card dimensional interaction system.\r\n\r\n## Component Structure and Type Definitions\r\n\r\nAny complex interaction system needs to start with rigorous type definitions, and our 3D cards are no exception. Let's first look at what's hidden behind these seemingly simple interfaces.\r\n\r\n### Data Model Design\r\n\r\n```typescript\r\ninterface WorkItem {\r\n    id: string;\r\n    title: string;\r\n    description: string;\r\n    tags: string[];\r\n    image?: string;\r\n    accessUrl?: string;\r\n    githubUrl?: string;\r\n    accessible?: boolean;\r\n    tool?: boolean;\r\n}\r\n```\r\n\r\nField explanations:\r\n\r\n- **id**: Unique identifier, used as a key in React's list rendering to avoid unnecessary re-renders. (React warnings are eager to jump out)\r\n- **title \u0026 description**: Basic display information, corresponding to the card's front title and description respectively.\r\n\r\n- **tags**: Technical tag array. There's a little trick here—we only show the first 3 tags on the front, and display the remaining ones on the back after flipping. This avoids information overload on the front while adding value to the flip action.\r\n- **Optional fields**: `image?`, `accessUrl?`, `githubUrl?` and other optional fields make the data structure more flexible, as not every project has complete display information.\r\n\r\n- **accessible \u0026 tool**: These two boolean flags are used to display special marks on the card, `accessible` indicates the project supports accessibility, `tool` indicates this is a utility project.\r\n\r\n### Component Props Passing\r\n\r\n```typescript\r\ninterface WorkCard3DProps {\r\n    work: WorkItem;\r\n    mode: 'tiled' | 'folded';\r\n    isActive: boolean;\r\n    index: number;\r\n    total: number;\r\n    activeIndex?: number;\r\n    onInteractionAction: (type: 'hover' | 'click' | 'flip' | 'detail') =\u003e void;\r\n}\r\n```\r\n\r\nThis Props interface is the core of the entire component design, with each parameter carrying specific responsibilities:\r\n\r\n- **mode**: This is the most critical parameter, determining whether cards are displayed in a grid layout (`tiled`) or in a stacked form (`folded`). One parameter change determines two completely different layout logics.\r\n- **index \u0026 total**: Position information, used to calculate the card's specific coordinates in space. Used for grid layout in tiled mode and stacking order in folded mode.\r\n\r\n- **activeIndex**: Only meaningful in folded mode, indicating the currently active card index. This design allows multiple cards to share the same active state.\r\n\r\n- **onInteractionAction**: Type-safe callback design. Different interaction types (hover, click, flip, detail) correspond to different business logic, with type safety ensuring correct event handling.\r\n\r\n## State Management in the Dimensional World\r\n\r\nState management for 3D interaction systems is much more complex than 2D, as we need to simultaneously handle multi-dimensional states of spatial position, time sequences, and user interactions.\r\n\r\n### State Variable Setup\r\n\r\n```typescript\r\nconst [hovered, setHovered] = useState(false);\r\nconst [flipped, setFlipped] = useState(false);\r\nconst [transform, setTransform] = useState('rotateX(0deg) rotateY(0deg)');\r\nconst [autoReturnTimer, setAutoReturnTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\nconst [hasInitialized, setHasInitialized] = useState(false);\r\n```\r\n\r\nState and lifecycle explanations:\r\n\r\n- **hovered**: The agent of hover state. It not only controls visual effect changes but also affects the enabling of mouse tracking tilt functionality. In folded mode, it also triggers the fan-out effect of cards.\r\n- **flipped**: The switch for flip state. `false` shows the front, `true` shows the back. Seems simple, but it involves complex coordination of CSS 3D transforms.\r\n\r\n- **transform**: Dynamic transform string. Stores real-time 3D transform parameters, mainly used for mouse tracking tilt effects. Why not calculate directly? Because we need smooth transitions between different interaction states.\r\n\r\n- **autoReturnTimer**: Auto-reset timer. When users stop interacting for 1.5 seconds, the card automatically returns to its initial state, avoiding abnormal card display states, such as showing a \"broken\" abnormal tilt state after interaction.\r\n- **hasInitialized**: Initialization flag. Used to control the timing of entrance animations, ensuring cards appear gracefully rather than suddenly \"popping\" out.\r\n\r\n### State Machine Transition Logic\r\n\r\nThese states form a complex state machine:\r\n\r\n```\r\nInitial State → Initialized → Hover State ↔ Tilt State\r\n   ↓                            ↓\r\nEntrance Animation → Breathing Animation → Hover Animation → Flip State\r\n```\r\n\r\nKey state transitions:\r\n- **Initialization trigger**: Based on `index * 150ms` delay, achieving staggered entrance effects\r\n- **Hover trigger**: Mouse enter enables tilt tracking, mouse leave starts auto-reset timer\r\n- **Flip trigger**: Click event triggered, independent of other states\r\n- **Timer management**: Multiple interaction events will clear and reset timers, ensuring behavior consistency\r\n\r\n## Folded and Tiled: Mathematical Poetry of Two Spatial Dimensions\r\n\r\nThis is the most critical part of the entire system—how to use mathematical formulas to describe the position and state of cards in 3D space.\r\n\r\n### Core Algorithm for Position Calculation\r\n\r\n```typescript\r\nconst getCardPosition = (): { x: number, y: number, z: number, opacity: number, scale: number } =\u003e {\r\n    if (mode === 'folded') {\r\n        const isActiveCard = index === activeIndex;\r\n        const relativeIndex = index - activeIndex;\r\n\r\n        if (isActiveCard) {\r\n            return {x: 0, y: 0, z: 0, opacity: 1, scale: 1};\r\n        } else if (Math.abs(relativeIndex) \u003c= 2) {\r\n            const horizontalOffset = relativeIndex * 2;\r\n            const verticalOffset = -Math.abs(relativeIndex) * 8;\r\n            const depth = -Math.abs(relativeIndex) * 15;\r\n            const scale = 1 - Math.abs(relativeIndex) * 0.03;\r\n            return {\r\n                x: horizontalOffset,\r\n                y: verticalOffset,\r\n                z: depth,\r\n                opacity: 1 - Math.abs(relativeIndex) * 0.15,\r\n                scale\r\n            };\r\n        } else {\r\n            const side = relativeIndex \u003e 0 ? 1 : -1;\r\n            return {\r\n                x: side * 200,\r\n                y: 0,\r\n                z: -100,\r\n                opacity: 0,\r\n                scale: 0.8\r\n            };\r\n        }\r\n    } else {\r\n        // Grid calculation for tiled mode\r\n        const cols = Math.ceil(Math.sqrt(total));\r\n        const row = Math.floor(index / cols);\r\n        const col = index % cols;\r\n        const widthSpacing = 320;\r\n        const heightSpacing = 440;\r\n        return {\r\n            x: (col - (cols - 1) / 2) * widthSpacing,\r\n            y: (row - Math.floor((total - 1) / cols) / 2) * heightSpacing,\r\n            z: 0,\r\n            opacity: 1,\r\n            scale: 1\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n### Stacking Aesthetics of Folded Mode\r\n\r\nIn folded mode, card positions are calculated based on `relativeIndex = index - activeIndex`, which is the core of the entire algorithm:\r\n\r\n**Active card** (`relativeIndex === 0`):\r\n- Position: `(0, 0, 0)` - Center front, foremost\r\n- State: Fully visible, original size\r\n\r\n**Adjacent cards** (`Math.abs(relativeIndex) \u003c= 2`):\r\n- **Horizontal offset**: `relativeIndex * 2` - Slight offset of ±2 pixels, creating a stacking feel\r\n- **Vertical offset**: `-Math.abs(relativeIndex) * 8` - Upward offset, simulating card thickness\r\n- **Depth**: `-Math.abs(relativeIndex) * 15` - Backward movement, enhancing dimensionality\r\n- **Scale**: `1 - Math.abs(relativeIndex) * 0.03` - Slight shrinking, distance perspective\r\n- **Opacity**: `1 - Math.abs(relativeIndex) * 0.15` - Gradient transparency, clear layering\r\n\r\n(Adjusting these values was really troublesome)\r\n\r\n**Distant cards** (`Math.abs(relativeIndex) \u003e 2`):\r\n- Completely hidden on the sides, opacity 0\r\n- This optimization avoids rendering too many invisible cards\r\n\r\n### Grid Geometry of Tiled Mode\r\n\r\nTiled mode uses a classic grid layout algorithm:\r\n\r\n```typescript\r\nconst cols = Math.ceil(Math.sqrt(total));  // Calculate columns\r\nconst row = Math.floor(index / cols);      // Calculate row\r\nconst col = index % cols;                  // Calculate column\r\n```\r\n\r\n**Why use square root?** This algorithm creates a grid close to a square, such as 9 cards arranged in 3×3, 10 cards in 4×3, which is most visually balanced.\r\n\r\n**Mathematics of center alignment**:\r\n```typescript\r\nx: (col - (cols - 1) / 2) * widthSpacing\r\ny: (row - Math.floor((total - 1) / cols) / 2) * heightSpacing\r\n```\r\n\r\nThis formula centers the entire grid around the screen center, keeping it centered regardless of the number of cards.\r\n\r\n## Mouse Tracking Tilt: From Cold Formulas to Vibrant Feedback\r\n\r\nCards: Look at me, look at me! (So cute!)\r\n\r\n### Mathematical Foundation of Coordinate Transformation\r\n\r\n```typescript\r\nconst handleMouseMove = (e: React.MouseEvent\u003cHTMLDivElement\u003e) =\u003e {\r\n    if (!cardRef.current || !hovered || mode === 'folded') return;\r\n\r\n    const rect = cardRef.current.getBoundingClientRect();\r\n    const centerX = rect.left + rect.width / 2;\r\n    const centerY = rect.top + rect.height / 2;\r\n\r\n    // Calculate offset from center (-0.5 to 0.5)\r\n    const offsetX = (e.clientX - centerX) / rect.width;\r\n    const offsetY = (e.clientY - centerY) / rect.height;\r\n\r\n    // Convert to rotation angles (-15° to +15°)\r\n    const rotateX = -offsetY * 15;\r\n    const rotateY = offsetX * 15;\r\n\r\n    setTransform(`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\r\n};\r\n```\r\n\r\nDetailed coordinate transformation process:\r\n\r\n### Step 1: Get Precise Position\r\n\r\n```typescript\r\nconst rect = cardRef.current.getBoundingClientRect();\r\nconst centerX = rect.left + rect.width / 2;\r\nconst centerY = rect.top + rect.height / 2;\r\n```\r\n\r\n`getBoundingClientRect()` returns the element's precise position and dimensions relative to the viewport. We calculate the card's geometric center, which is the reference point for all rotations.\r\n\r\n### Step 2: Normalization\r\n\r\n```typescript\r\nconst offsetX = (e.clientX - centerX) / rect.width;\r\nconst offsetY = (e.clientY - centerY) / rect.height;\r\n```\r\n\r\nThis normalization process has multiple effective scenarios:\r\n- When mouse is at card center: `offsetX = 0, offsetY = 0`\r\n- When mouse is at card right edge: `offsetX = 0.5`\r\n- When mouse is at card left edge: `offsetX = -0.5`\r\n\r\nDividing by width and height ensures rotation effects are independent of card size, maintaining consistent tilt amplitude for both large and small cards.\r\n\r\n### Step 3: Angle Mapping\r\n\r\n```typescript\r\nconst rotateX = -offsetY * 15;  // Y-axis inversion\r\nconst rotateY = offsetX * 15;\r\n```\r\n\r\n**Why invert the Y-axis?**\r\n\r\n- When mouse is above, we want the card to tilt upward (positive rotateX)\r\n- But `offsetY` is negative when above\r\n- So we need inversion: `-offsetY`\r\n\r\nFrom a personal visual perspective (disclaimer), 15 degrees is a perfectly appropriate tilt value. ~~(Actually, I just like this value, and I won't change it even if you object!)~~\r\n\r\n### Smart Judgment for Interaction Disable\r\n\r\n```typescript\r\nif (!cardRef.current || !hovered || mode === 'folded') return;\r\n```\r\n\r\nThis conditional judgment includes three important edge cases:\r\n1. **!cardRef.current**: Component not fully mounted\r\n2. **!hovered**: Mouse not hovering, avoiding unexpected tilts\r\n3. **mode === 'folded'**: Disable tilt in folded mode to avoid conflicts with stacking effects\r\n\r\n## Hover and Breathing\r\n\r\nYes, this is what I call unnecessary embellishment (mist)\r\n\r\n### Dynamic Animation Property Calculation\r\n\r\n```typescript\r\nconst getAnimationProps = () =\u003e {\r\n    if (hovered) {\r\n        return {\r\n            scale: 1.02,\r\n            boxShadow: '0 20px 40px rgba(0, 255, 255, 0.3)'\r\n        };\r\n    } else if (!flipped) {\r\n        // Breathing effect\r\n        return {\r\n            scale: [1, 1.01, 1],\r\n            boxShadow: [\r\n                '0 10px 20px rgba(0, 0, 0, 0.1)',\r\n                '0 12px 24px rgba(0, 255, 255, 0.08)',\r\n                '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n            ]\r\n        };\r\n    } else {\r\n        return {\r\n            scale: 1,\r\n            boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n### Animation Parameter Explanations\r\n\r\n**Hover state**:\r\n- **scale: 1.02**: Slight enlargement effect, 2% scaling is both noticeable and not excessive\r\n- **boxShadow**: Cyan shadow enhances tech feel, 40px blur radius creates floating sensation\r\n\r\n**Breathing effect**:\r\n- **scale array**: `[1, 1.01, 1]` achieves reciprocating scaling\r\n- **Shadow changes**: From dark to light and back to dark, enhancing rhythm with scaling\r\n\r\n### Transition Functions\r\n\r\n```typescript\r\nconst getAnimationTransition = () =\u003e {\r\n    if (hovered) {\r\n        return {\r\n            type: \"spring\" as const,\r\n            damping: 20,\r\n            stiffness: 300\r\n        };\r\n    } else if (!flipped) {\r\n        return {\r\n            duration: 4,\r\n            repeat: Infinity,\r\n            ease: \"easeInOut\" as const\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n**Spring animation** (when hovering):\r\n- **damping: 20**: Damping coefficient, controls oscillation degree\r\n- **stiffness: 300**: Stiffness coefficient, controls response speed\r\n- This combination produces natural elasticity, like a real physical spring\r\n\r\n**Breathing animation** (default state):\r\n- **duration: 4**: 4-second cycle, slow enough to be barely noticeable\r\n- **repeat: Infinity**: Infinite loop\r\n- **easeInOut**: Accelerate then decelerate, mimicking natural breathing\r\n\r\n## Timer System: The Art of Time Management\r\n\r\nHonestly, user interaction time control is the part that needs the most careful debugging to ensure interaction continuity and reasonableness may require extensive fine-tuning.\r\n\r\n### Auto-Reset Lifecycle\r\n\r\n```typescript\r\nconst handleMouseEnter = () =\u003e {\r\n    setHovered(true);\r\n    onInteractionAction('hover');\r\n\r\n    // Clear auto-reset timer\r\n    if (autoReturnTimer) {\r\n        clearTimeout(autoReturnTimer);\r\n        setAutoReturnTimer(null);\r\n    }\r\n};\r\n\r\nconst handleMouseLeave = () =\u003e {\r\n    setHovered(false);\r\n\r\n    // Start auto-reset timer\r\n    const timer = setTimeout(() =\u003e {\r\n        setTransform('rotateX(0deg) rotateY(0deg)');\r\n        setFlipped(false);\r\n    }, 1500);\r\n\r\n    setAutoReturnTimer(timer);\r\n\r\n    // Immediate reset for smooth transition\r\n    setTransform('rotateX(0deg) rotateY(0deg)');\r\n};\r\n```\r\n\r\n### Timer Management Explanations\r\n\r\n**On mouse enter**:\r\n- Immediately clear existing timer, preventing unexpected state resets\r\n- Set hover state, enable interaction effects\r\n\r\n**On mouse leave**:\r\n- Immediately reset transform, ensuring quick visual response\r\n- Start 1500ms timer, preparing for deep reset\r\n\r\n**Why two resets?**\r\n- **Immediate reset**: Quickly remove tilt effects, avoiding abnormal tilt styles\r\n- **Delayed reset**: Reset flip state, giving users enough time to view back content\r\n\r\n### Memory Leak Protection\r\n\r\n```typescript\r\n// Clean up timer on component unmount\r\nuseEffect(() =\u003e {\r\n    return () =\u003e {\r\n        if (autoReturnTimer) {\r\n            clearTimeout(autoReturnTimer);\r\n        }\r\n    };\r\n}, [autoReturnTimer]);\r\n```\r\n\r\nThis cleanup function ensures no \"orphaned\" timers remain when components unmount, avoiding memory leaks and abnormal state updates.\r\n\r\n## Flip Effect: The Magic of 3D Transforms\r\n\r\nCard flipping involves the core principles of CSS 3D transforms.\r\n\r\n### Core CSS 3D Transform Settings\r\n\r\n```typescript\r\nconst cardContainerStyle: React.CSSProperties = {\r\n    transformStyle: 'preserve-3d',\r\n    transform: flipped ? 'rotateY(180deg)' : transform,\r\n    transition: flipped ? 'transform 0.6s ease' : 'transform 0.4s ease-out',\r\n};\r\n\r\nconst cardFaceStyle: React.CSSProperties = {\r\n    backfaceVisibility: 'hidden',\r\n};\r\n\r\nconst cardBackStyle: React.CSSProperties = {\r\n    ...cardFaceStyle,\r\n    transform: 'rotateY(180deg)',\r\n};\r\n```\r\n\r\n### Key 3D Transform Property Analysis\r\n\r\n**transformStyle: 'preserve-3d'**:\r\nThis is the foundation of 3D effects, telling the browser to maintain 3D transform relationships of child elements. Without this property, all 3D effects would be \"flattened\" to 2D.\r\n\r\n**backfaceVisibility: 'hidden'**:\r\nHides the element's backface, ensuring no \"see-through\" effect during flipping. Imagine if you could see both front and back of a card simultaneously ~~that would prove you're a four-dimensional being~~, that would cause front and back content to overlap, severely reducing card content readability.\r\n\r\n**Back pre-rotation**:\r\n\r\n```typescript\r\ntransform: 'rotateY(180deg)'\r\n```\r\nBack content is pre-rotated 180 degrees, so when the container rotates 180 degrees, the back content displays in the correct orientation.\r\n\r\n### Flip Animation\r\n\r\n```typescript\r\ntransition: flipped ? 'transform 0.6s ease' : 'transform 0.4s ease-out'\r\n```\r\n\r\nGenerally, when users flip from back to front, they've already read the entire card's front and back content, so the animation can be slightly faster.\r\n\r\nEasing function explanations:\r\n- **ease**: Standard easing for flipping, natural and smooth\r\n- **ease-out**: Quick response for tilting, then gradually stops\r\n\r\n## Entrance Animation: Temporal Art of Elegant Appearance\r\n\r\nEntrance animation is key to users' first impressions, I need to find a way to make cards \"appear elegantly\" rather than \"suddenly pop out.\"\r\n\r\n### Initialization Delay\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    const timer = setTimeout(() =\u003e {\r\n        setHasInitialized(true);\r\n    }, index * 150);\r\n\r\n    return () =\u003e clearTimeout(timer);\r\n}, [index]);\r\n```\r\n\r\nThis `index * 150ms` delay design creates a \"wave-like\" entrance effect:\r\n- Card 0: Starts animation immediately\r\n- Card 1: Starts after 150ms\r\n- Card 2: Starts after 300ms\r\n- And so on...\r\n\r\nThe result is cards appearing elegantly one after another like dominoes.\r\n\r\n### Entrance Animation Keyframe Design\r\n\r\n```typescript\r\ninitial={{ \r\n    opacity: 0, \r\n    scale: 0.8,\r\n    y: 50,\r\n    rotateX: -15\r\n}}\r\nanimate={hasInitialized ? { \r\n    opacity: 1,\r\n    y: 0,\r\n    rotateX: 0,\r\n    ...getAnimationProps()\r\n} : {\r\n    opacity: 0,\r\n    scale: 0.8,\r\n    y: 50,\r\n    rotateX: -15\r\n}}\r\n```\r\n\r\n**Initial state design philosophy**:\r\n\r\n- **opacity: 0**: Completely transparent, initially invisible\r\n- **scale: 0.8**: 80% size, growing from small to large\r\n- **y: 50**: Offset 50px downward, flying in from below\r\n- **rotateX: -15**: Tilted forward 15 degrees, adding dimensionality\r\n\r\n**Target state**:\r\n- All properties return to normal values, while starting breathing animation\r\n\r\n### Breathing Effect Loop Implementation\r\n\r\n```typescript\r\n// In getAnimationProps\r\nscale: [1, 1.01, 1],\r\nboxShadow: [\r\n    '0 10px 20px rgba(0, 0, 0, 0.1)',\r\n    '0 12px 24px rgba(0, 255, 255, 0.08)',\r\n    '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n]\r\n```\r\n\r\n**Array animation**:\r\n\r\n- framer-motion automatically creates loop animations between array elements\r\n- `[1, 1.01, 1]` means: normal→slight enlargement→normal\r\n- Shadow changes coordinate with scaling, enhancing rhythm\r\n\r\n### Animation Configuration\r\n\r\n```typescript\r\ntransition={hasInitialized ? {\r\n    opacity: { duration: 0.6, ease: \"easeOut\" },\r\n    y: { duration: 0.8, ease: \"easeOut\" },\r\n    rotateX: { duration: 0.8, ease: \"easeOut\" }\r\n} : {\r\n    duration: 0.6,\r\n    ease: \"easeOut\"\r\n}}\r\n```\r\n\r\n**Separate control of each property's animation time**:\r\n- **opacity**: 0.6s, quick appearance\r\n- **y \u0026 rotateX**: 0.8s, slightly slower position changes\r\n- **easeOut**: Quick start, gradual end\r\n\r\n## Style Design: Visual Language of Modernity\r\n\r\nFinally, we can explore the visual design philosophy of this 3D card system.\r\n\r\n### Gradient and Transparency Layering\r\n\r\n```typescript\r\nclassName=\"bg-gradient-to-br from-background/90 to-surface/90 backdrop-blur-sm border border-primary/20 shadow-xl\"\r\n```\r\n\r\n**Gradient design**:\r\n- `from-background/90 to-surface/90`: Gradient from background to surface color, 90% transparency\r\n- `bg-gradient-to-br`: Diagonal gradient from top-left to bottom-right, adding dimensionality\r\n\r\n**Blur and borders**:\r\n- `backdrop-blur-sm`: Background blur effect, modern frosted glass texture\r\n- `border-primary/20`: Primary color light border, 20% transparency just right\r\n\r\n### Theme-Adaptive Color System\r\n\r\n```typescript\r\n// Front: Theme colors\r\nclassName=\"bg-gradient-to-br from-background/90 to-surface/90\"\r\n\r\n// Back: Accent colors\r\nclassName=\"bg-gradient-to-br from-secondary/90 to-accent/90\"\r\n```\r\n\r\n### Physical Simulation of Shadows and Lighting\r\n\r\n```typescript\r\nboxShadow: '0 20px 40px rgba(0, 255, 255, 0.3)'\r\n```\r\n\r\n**Shadow parameter analysis**:\r\n- **Y offset 20px**: Light source above, conforming to real-world lighting habits\r\n- **Blur radius 40px**: Large-range soft shadows, creating floating sensation\r\n- **Cyan + 30% transparency**: Tech-feeling color choice, echoing the theme\r\n\r\n## Pattern Extraction and Summary\r\n\r\nThrough this in-depth technical analysis, we can extract several reusable design patterns:\r\n\r\n### Universal Architecture for 3D Interactive Components\r\n\r\n```typescript\r\n// 1. Strict type definitions\r\ninterface ComponentProps {\r\n    mode: 'mode1' | 'mode2';\r\n    data: DataType;\r\n    onInteraction: (type: InteractionType) =\u003e void;\r\n}\r\n\r\n// 2. State management pattern\r\nconst [visualState, setVisualState] = useState(initialState);\r\nconst [interactionTimer, setInteractionTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\n\r\n// 3. Position calculation function\r\nconst calculatePosition = (mode: Mode, index: number, total: number) =\u003e {\r\n    // Mode-based position algorithm\r\n};\r\n```\r\n\r\n### Universal Implementation of Mouse Tracking Tilt\r\n\r\n```typescript\r\nconst useMouseTracking = (ref: RefObject\u003cHTMLElement\u003e, enabled: boolean) =\u003e {\r\n    const handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n        if (!ref.current || !enabled) return;\r\n        \r\n        const rect = ref.current.getBoundingClientRect();\r\n        const centerX = rect.left + rect.width / 2;\r\n        const centerY = rect.top + rect.height / 2;\r\n        \r\n        const offsetX = (e.clientX - centerX) / rect.width;\r\n        const offsetY = (e.clientY - centerY) / rect.height;\r\n        \r\n        const rotateX = -offsetY * maxRotation;\r\n        const rotateY = offsetX * maxRotation;\r\n        \r\n        return `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\r\n    }, [enabled, maxRotation]);\r\n    \r\n    return { handleMouseMove };\r\n};\r\n```\r\n\r\n### Auto-Reset Timer Management Pattern\r\n\r\n```typescript\r\nconst useAutoReset = (resetAction: () =\u003e void, delay: number = 1500) =\u003e {\r\n    const [timer, setTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\n    \r\n    const startTimer = useCallback(() =\u003e {\r\n        if (timer) clearTimeout(timer);\r\n        const newTimer = setTimeout(resetAction, delay);\r\n        setTimer(newTimer);\r\n    }, [timer, resetAction, delay]);\r\n    \r\n    const clearTimer = useCallback(() =\u003e {\r\n        if (timer) {\r\n            clearTimeout(timer);\r\n            setTimer(null);\r\n        }\r\n    }, [timer]);\r\n    \r\n    return { startTimer, clearTimer };\r\n};\r\n```\r\n\r\n### Performance Optimization Best Practices\r\n\r\n1. **Reasonable use of willChange**: Only use on elements that truly need GPU acceleration\r\n2. **Avoid unnecessary re-renders**: Use useCallback and useMemo to optimize calculations\r\n3. **Timely resource cleanup**: Clean up timers and event listeners on component unmount\r\n4. **Conditional rendering optimization**: Consider not rendering elements far from viewport\r\n5. **Animation performance**: Prioritize transform and opacity, avoid triggering reflow\r\n\r\n## Final Words\r\n\r\nThis 3D card system may look like just a few cards arranged and rotated in space, but behind it lies mathematical calculations, state management, performance optimization, and user experience design—each aspect requires careful consideration.\r\n\r\nTechnology will never stop evolving, but users' pursuit of beautiful experiences is eternal.\r\n\r\n## Complete Implementation Source Code\r\n\r\n```typescript\r\n'use client';\r\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\r\nimport { motion } from 'framer-motion';\r\nimport { useTranslation } from '@/lib/hooks/useTranslation';\r\n\r\n// ==================== Type Definitions ====================\r\n/**\r\n * Work item data structure\r\n * Defines all required and optional fields for a project card\r\n */\r\ninterface WorkItem {\r\n    id: string;\r\n    title: string;\r\n    description: string;\r\n    tags: string[];\r\n    image?: string;\r\n    accessUrl?: string;\r\n    githubUrl?: string;\r\n    accessible?: boolean;\r\n    tool?: boolean;\r\n}\r\n\r\n/**\r\n * Component props interface\r\n * Defines all props needed for the 3D card component\r\n */\r\ninterface WorkCard3DProps {\r\n    work: WorkItem;\r\n    mode: 'tiled' | 'folded';\r\n    isActive: boolean;\r\n    index: number;\r\n    total: number;\r\n    activeIndex?: number;\r\n    onInteractionAction: (type: 'hover' | 'click' | 'flip' | 'detail') =\u003e void;\r\n}\r\n\r\n/**\r\n * 3D position calculation result\r\n */\r\ninterface PositionData {\r\n    x: number;\r\n    y: number;\r\n    z: number;\r\n    opacity: number;\r\n    scale: number;\r\n}\r\n\r\nconst WorkCard3D: React.FC\u003cWorkCard3DProps\u003e = ({\r\n    work,\r\n    mode,\r\n    isActive,\r\n    index,\r\n    total,\r\n    activeIndex = 0,\r\n    onInteractionAction\r\n}) =\u003e {\r\n    // ==================== State Management ====================\r\n    const [hovered, setHovered] = useState(false);\r\n    const [flipped, setFlipped] = useState(false);\r\n    const [transform, setTransform] = useState('rotateX(0deg) rotateY(0deg)');\r\n    const [autoReturnTimer, setAutoReturnTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\n    const [hasInitialized, setHasInitialized] = useState(false);\r\n\r\n    // ==================== References ====================\r\n    const cardRef = useRef\u003cHTMLDivElement\u003e(null);\r\n    const { t } = useTranslation();\r\n\r\n    // ==================== Core Algorithm: Position Calculation ====================\r\n    /**\r\n     * Calculate 3D position based on mode and index\r\n     * This is the mathematical heart of the card layout system\r\n     */\r\n    const getCardPosition = useCallback((): PositionData =\u003e {\r\n        if (mode === 'folded') {\r\n            const isActiveCard = index === activeIndex;\r\n            const relativeIndex = index - activeIndex;\r\n\r\n            if (isActiveCard) {\r\n                // Active card: center front position\r\n                return { x: 0, y: 0, z: 0, opacity: 1, scale: 1 };\r\n            } else if (Math.abs(relativeIndex) \u003c= 2) {\r\n                // Adjacent cards: stacked with depth\r\n                const horizontalOffset = relativeIndex * 2;\r\n                const verticalOffset = -Math.abs(relativeIndex) * 8;\r\n                const depth = -Math.abs(relativeIndex) * 15;\r\n                const scale = 1 - Math.abs(relativeIndex) * 0.03;\r\n                \r\n                return {\r\n                    x: horizontalOffset,\r\n                    y: verticalOffset,\r\n                    z: depth,\r\n                    opacity: 1 - Math.abs(relativeIndex) * 0.15,\r\n                    scale\r\n                };\r\n            } else {\r\n                // Distant cards: hidden on sides\r\n                const side = relativeIndex \u003e 0 ? 1 : -1;\r\n                return {\r\n                    x: side * 200,\r\n                    y: 0,\r\n                    z: -100,\r\n                    opacity: 0,\r\n                    scale: 0.8\r\n                };\r\n            }\r\n        } else {\r\n            // Tiled mode: grid calculation\r\n            const cols = Math.ceil(Math.sqrt(total));\r\n            const row = Math.floor(index / cols);\r\n            const col = index % cols;\r\n            const widthSpacing = 320;\r\n            const heightSpacing = 440;\r\n            \r\n            return {\r\n                x: (col - (cols - 1) / 2) * widthSpacing,\r\n                y: (row - Math.floor((total - 1) / cols) / 2) * heightSpacing,\r\n                z: 0,\r\n                opacity: 1,\r\n                scale: 1\r\n            };\r\n        }\r\n    }, [mode, index, total, activeIndex]);\r\n\r\n    // ==================== Animation Properties Calculation ====================\r\n    /**\r\n     * Calculate dynamic animation properties based on card state\r\n     */\r\n    const getAnimationProps = useCallback(() =\u003e {\r\n        if (hovered) {\r\n            return {\r\n                scale: 1.02,\r\n                boxShadow: '0 20px 40px rgba(0, 255, 255, 0.3)'\r\n            };\r\n        } else if (!flipped) {\r\n            // Breathing effect for normal state\r\n            return {\r\n                scale: [1, 1.01, 1],\r\n                boxShadow: [\r\n                    '0 10px 20px rgba(0, 0, 0, 0.1)',\r\n                    '0 12px 24px rgba(0, 255, 255, 0.08)',\r\n                    '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n                ]\r\n            };\r\n        } else {\r\n            return {\r\n                scale: 1,\r\n                boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n            };\r\n        }\r\n    }, [hovered, flipped]);\r\n\r\n    /**\r\n     * Calculate animation transition properties\r\n     */\r\n    const getAnimationTransition = useCallback(() =\u003e {\r\n        if (hovered) {\r\n            return {\r\n                type: \"spring\" as const,\r\n                damping: 20,\r\n                stiffness: 300\r\n            };\r\n        } else if (!flipped) {\r\n            return {\r\n                duration: 4,\r\n                repeat: Infinity,\r\n                ease: \"easeInOut\" as const\r\n            };\r\n        }\r\n    }, [hovered, flipped]);\r\n\r\n    // ==================== Mouse Tracking Algorithm ====================\r\n    /**\r\n     * Handle mouse movement for 3D tilt effect\r\n     * Converts 2D mouse coordinates to 3D rotation angles\r\n     */\r\n    const handleMouseMove = useCallback((e: React.MouseEvent\u003cHTMLDivElement\u003e) =\u003e {\r\n        if (!cardRef.current || !hovered || mode === 'folded') return;\r\n\r\n        const rect = cardRef.current.getBoundingClientRect();\r\n        const centerX = rect.left + rect.width / 2;\r\n        const centerY = rect.top + rect.height / 2;\r\n\r\n        // Normalize mouse position (-0.5 to 0.5)\r\n        const offsetX = (e.clientX - centerX) / rect.width;\r\n        const offsetY = (e.clientY - centerY) / rect.height;\r\n\r\n        // Convert to rotation angles (-15° to +15°)\r\n        const rotateX = -offsetY * 15;  // Invert Y for natural feel\r\n        const rotateY = offsetX * 15;\r\n\r\n        setTransform(`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\r\n    }, [hovered, mode]);\r\n\r\n    // ==================== Event Handlers ====================\r\n    /**\r\n     * Handle mouse enter - start hover state and clear auto-return timer\r\n     */\r\n    const handleMouseEnter = useCallback(() =\u003e {\r\n        setHovered(true);\r\n        onInteractionAction('hover');\r\n\r\n        // Clear auto-return timer\r\n        if (autoReturnTimer) {\r\n            clearTimeout(autoReturnTimer);\r\n            setAutoReturnTimer(null);\r\n        }\r\n    }, [autoReturnTimer, onInteractionAction]);\r\n\r\n    /**\r\n     * Handle mouse leave - end hover state and start auto-return timer\r\n     */\r\n    const handleMouseLeave = useCallback(() =\u003e {\r\n        setHovered(false);\r\n\r\n        // Start auto-return timer\r\n        const timer = setTimeout(() =\u003e {\r\n            setTransform('rotateX(0deg) rotateY(0deg)');\r\n            setFlipped(false);\r\n        }, 1500);\r\n\r\n        setAutoReturnTimer(timer);\r\n\r\n        // Immediate transform reset for smooth transition\r\n        setTransform('rotateX(0deg) rotateY(0deg)');\r\n    }, []);\r\n\r\n    /**\r\n     * Handle card click - toggle flip state\r\n     */\r\n    const handleClick = useCallback(() =\u003e {\r\n        setFlipped(!flipped);\r\n        onInteractionAction(flipped ? 'click' : 'flip');\r\n    }, [flipped, onInteractionAction]);\r\n\r\n    // ==================== Initialization Effect ====================\r\n    /**\r\n     * Staggered initialization for entrance animation\r\n     */\r\n    useEffect(() =\u003e {\r\n        const timer = setTimeout(() =\u003e {\r\n            setHasInitialized(true);\r\n        }, index * 150); // 150ms delay per card\r\n\r\n        return () =\u003e clearTimeout(timer);\r\n    }, [index]);\r\n\r\n    // ==================== Cleanup Effect ====================\r\n    /**\r\n     * Clean up timer on unmount\r\n     */\r\n    useEffect(() =\u003e {\r\n        return () =\u003e {\r\n            if (autoReturnTimer) {\r\n                clearTimeout(autoReturnTimer);\r\n            }\r\n        };\r\n    }, [autoReturnTimer]);\r\n\r\n    // ==================== Style Calculations ====================\r\n    const position = getCardPosition();\r\n    \r\n    /**\r\n     * Container style for 3D transforms\r\n     */\r\n    const cardContainerStyle: React.CSSProperties = {\r\n        transformStyle: 'preserve-3d',\r\n        transform: flipped ? 'rotateY(180deg)' : transform,\r\n        transition: flipped ? 'transform 0.6s ease' : 'transform 0.4s ease-out',\r\n    };\r\n\r\n    /**\r\n     * Common face styles for front and back\r\n     */\r\n    const cardFaceStyle: React.CSSProperties = {\r\n        backfaceVisibility: 'hidden',\r\n    };\r\n\r\n    /**\r\n     * Back face specific style (pre-rotated 180°)\r\n     */\r\n    const cardBackStyle: React.CSSProperties = {\r\n        ...cardFaceStyle,\r\n        transform: 'rotateY(180deg)',\r\n    };\r\n\r\n    // ==================== Fan Effect for Folded Mode ====================\r\n    /**\r\n     * Calculate fan spread effect when hovering in folded mode\r\n     */\r\n    const getFanTransform = useCallback(() =\u003e {\r\n        if (mode !== 'folded' || !hovered) return '';\r\n        \r\n        const relativeIndex = index - activeIndex;\r\n        if (Math.abs(relativeIndex) \u003e 2) return '';\r\n        \r\n        const fanAngle = relativeIndex * 4;\r\n        const translateX = Math.sin(fanAngle * Math.PI / 180) * 12;\r\n        \r\n        return `rotateZ(${fanAngle}deg) translateX(${translateX}px)`;\r\n    }, [mode, hovered, index, activeIndex]);\r\n\r\n    // ==================== Render Component ====================\r\n    return (\r\n        \u003cmotion.div\r\n            ref={cardRef}\r\n            className=\"absolute cursor-pointer\"\r\n            style={{\r\n                left: '50%',\r\n                top: '50%',\r\n                marginLeft: '-160px', // Half of card width\r\n                marginTop: '-220px',  // Half of card height\r\n            }}\r\n            initial={{ \r\n                opacity: 0, \r\n                scale: 0.8,\r\n                y: 50,\r\n                rotateX: -15\r\n            }}\r\n            animate={hasInitialized ? { \r\n                opacity: position.opacity,\r\n                x: position.x,\r\n                y: position.y,\r\n                z: position.z,\r\n                scale: position.scale,\r\n                rotateX: 0,\r\n                ...getAnimationProps()\r\n            } : {\r\n                opacity: 0,\r\n                scale: 0.8,\r\n                y: 50,\r\n                rotateX: -15\r\n            }}\r\n            transition={hasInitialized ? {\r\n                opacity: { duration: 0.6, ease: \"easeOut\" },\r\n                x: { duration: 0.8, ease: \"easeOut\" },\r\n                y: { duration: 0.8, ease: \"easeOut\" },\r\n                z: { duration: 0.8, ease: \"easeOut\" },\r\n                scale: { duration: 0.8, ease: \"easeOut\" },\r\n                rotateX: { duration: 0.8, ease: \"easeOut\" },\r\n                ...getAnimationTransition()\r\n            } : {\r\n                duration: 0.6,\r\n                ease: \"easeOut\"\r\n            }}\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseLeave={handleMouseLeave}\r\n            onMouseMove={handleMouseMove}\r\n            onClick={handleClick}\r\n        \u003e\r\n            {/* 3D Card Container */}\r\n            \u003cdiv\r\n                className=\"w-80 h-96 relative\"\r\n                style={{\r\n                    ...cardContainerStyle,\r\n                    transform: `${cardContainerStyle.transform} ${getFanTransform()}`\r\n                }}\r\n            \u003e\r\n                {/* Card Front */}\r\n                \u003cmotion.div\r\n                    style={cardFaceStyle}\r\n                    className=\"w-full h-full absolute inset-0 rounded-xl p-6 flex flex-col gap-4 bg-gradient-to-br from-background/90 to-surface/90 backdrop-blur-sm border border-primary/20 shadow-xl\"\r\n                \u003e\r\n                    \u003cdiv className=\"flex flex-col h-full gap-4\"\u003e\r\n                        {/* Project Preview */}\r\n                        \u003cdiv className=\"h-40 bg-gradient-to-br from-primary/20 to-accent/20 rounded-lg flex items-center justify-center relative overflow-hidden\"\u003e\r\n                            {work.image ? (\r\n                                \u003cimg\r\n                                    src={work.image}\r\n                                    alt={work.title}\r\n                                    className=\"w-full h-full object-cover rounded-lg\"\r\n                                /\u003e\r\n                            ) : (\r\n                                \u003cdiv className=\"text-center\"\u003e\r\n                                    \u003cdiv className=\"text-primary/60 text-4xl mb-2\"\u003e🚀\u003c/div\u003e\r\n                                    \u003cspan className=\"text-foreground/60 text-sm\"\u003e{t('project.projectPreview')}\u003c/span\u003e\r\n                                \u003c/div\u003e\r\n                            )}\r\n\r\n                            {/* Special badges */}\r\n                            \u003cdiv className=\"absolute top-2 right-2 flex gap-1\"\u003e\r\n                                {work.accessible \u0026\u0026 (\r\n                                    \u003cdiv className=\"bg-green-500 text-white text-xs px-2 py-1 rounded-full\"\u003e\r\n                                        {t('project.accessible')}\r\n                                    \u003c/div\u003e\r\n                                )}\r\n                                {work.tool \u0026\u0026 (\r\n                                    \u003cdiv className=\"bg-blue-500 text-white text-xs px-2 py-1 rounded-full\"\u003e\r\n                                        {t('project.tool')}\r\n                                    \u003c/div\u003e\r\n                                )}\r\n                            \u003c/div\u003e\r\n                        \u003c/div\u003e\r\n\r\n                        {/* Project Title */}\r\n                        \u003ch3 className=\"text-xl font-bold text-foreground line-clamp-2\"\u003e\r\n                            {work.title}\r\n                        \u003c/h3\u003e\r\n\r\n                        {/* Project Description */}\r\n                        \u003cp className=\"text-foreground/80 text-sm line-clamp-3 flex-1\"\u003e\r\n                            {work.description}\r\n                        \u003c/p\u003e\r\n\r\n                        {/* Tech Tags (first 3 only) */}\r\n                        \u003cdiv className=\"flex flex-wrap gap-2\"\u003e\r\n                            {work.tags.slice(0, 3).map((tag) =\u003e (\r\n                                \u003cspan\r\n                                    key={tag}\r\n                                    className=\"px-2 py-1 bg-primary/20 text-primary text-xs rounded-full\"\r\n                                \u003e\r\n                                    {tag}\r\n                                \u003c/span\u003e\r\n                            ))}\r\n                            {work.tags.length \u003e 3 \u0026\u0026 (\r\n                                \u003cspan className=\"text-foreground/60 text-xs\"\u003e\r\n                                    +{work.tags.length - 3} {t('project.moreItems')}\r\n                                \u003c/span\u003e\r\n                            )}\r\n                        \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/motion.div\u003e\r\n\r\n                {/* Card Back */}\r\n                \u003cmotion.div\r\n                    style={cardBackStyle}\r\n                    className=\"w-full h-full absolute inset-0 rounded-xl p-6 bg-gradient-to-br from-secondary/90 to-accent/90 backdrop-blur-sm border border-secondary/20 shadow-xl\"\r\n                    initial={{opacity: 0}}\r\n                    animate={{opacity: flipped ? 1 : 0}}\r\n                    transition={{delay: flipped ? 0.2 : 0}}\r\n                \u003e\r\n                    \u003cdiv className=\"w-full h-full flex flex-col text-white\"\u003e\r\n                        \u003ch3 className=\"text-xl font-bold mb-4\"\u003e{t('project.technicalDetails')}\u003c/h3\u003e\r\n\r\n                        {/* Complete tech tags */}\r\n                        \u003cdiv className=\"mb-4\"\u003e\r\n                            \u003ch4 className=\"text-sm font-semibold mb-2\"\u003e{t('project.technologies')}\u003c/h4\u003e\r\n                            \u003cdiv className=\"flex flex-wrap gap-1\"\u003e\r\n                                {work.tags.map((tag) =\u003e (\r\n                                    \u003cspan\r\n                                        key={tag}\r\n                                        className=\"px-2 py-1 bg-white/20 text-white text-xs rounded-full\"\r\n                                    \u003e\r\n                                        {tag}\r\n                                    \u003c/span\u003e\r\n                                ))}\r\n                            \u003c/div\u003e\r\n                        \u003c/div\u003e\r\n\r\n                        {/* Detailed description */}\r\n                        \u003cdiv className=\"mb-4 flex-1\"\u003e\r\n                            \u003ch4 className=\"text-sm font-semibold mb-2\"\u003e{t('project.description')}\u003c/h4\u003e\r\n                            \u003cp className=\"text-white/90 text-sm\"\u003e\r\n                                {work.description}\r\n                            \u003c/p\u003e\r\n                        \u003c/div\u003e\r\n\r\n                        {/* Action buttons */}\r\n                        \u003cdiv className=\"flex gap-2 mt-auto\"\u003e\r\n                            \u003cmotion.button\r\n                                whileHover={{scale: 1.05}}\r\n                                whileTap={{scale: 0.95}}\r\n                                className=\"flex-1 py-2 px-3 bg-white text-secondary text-sm rounded-lg hover:bg-white/90 transition-colors\"\r\n                                onClick={(e) =\u003e {\r\n                                    e.stopPropagation();\r\n                                    onInteractionAction('detail');\r\n                                }}\r\n                            \u003e\r\n                                {t('project.seeDetails')}\r\n                            \u003c/motion.button\u003e\r\n                            {work.githubUrl \u0026\u0026 (\r\n                                \u003cmotion.button\r\n                                    whileHover={{scale: 1.05}}\r\n                                    whileTap={{scale: 0.95}}\r\n                                    className=\"flex-1 py-2 px-3 border border-white text-white text-sm rounded-lg hover:bg-white/20 transition-colors\"\r\n                                    onClick={(e) =\u003e {\r\n                                        e.stopPropagation();\r\n                                        window.open(work.githubUrl, '_blank');\r\n                                    }}\r\n                                \u003e\r\n                                    {t('project.github')}\r\n                                \u003c/motion.button\u003e\r\n                            )}\r\n                        \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/motion.div\u003e\r\n            \u003c/div\u003e\r\n        \u003c/motion.div\u003e\r\n    );\r\n};\r\n\r\nexport default WorkCard3D;\r\n```\r\n\r\n### System Architecture Flow Diagram\r\n\r\n```\r\n    User Interaction Events\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   Event Handling    │\r\n    │ • Mouse tracking    │ \r\n    │ • Hover management  │\r\n    │ • Click flip control│\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   State Updates     │\r\n    │ • hovered state     │\r\n    │ • flipped state     │  \r\n    │ • transform string  │\r\n    │ • timer management  │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   Position Engine   │\r\n    │ • Folded algorithm  │\r\n    │ • Tiled algorithm   │\r\n    │ • 3D transforms     │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   Animation System  │\r\n    │ • Framer Motion     │\r\n    │ • CSS 3D Transform  │\r\n    │ • Entrance control  │\r\n    │ • Breathing loops   │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   Visual Results    │\r\n    │ • 3D card effects   │\r\n    │ • Smooth transitions│\r\n    │ • Interactive feedback│\r\n    └─────────────────────┘\r\n```\r\n\r\n### Core Algorithm Deep Analysis\r\n\r\n#### 1. 3D Spatial Position Calculation\r\n\r\n```typescript\r\n// Folded mode stacking algorithm\r\nconst relativeIndex = index - activeIndex;\r\nconst horizontalOffset = relativeIndex * 2;\r\nconst verticalOffset = -Math.abs(relativeIndex) * 8;\r\nconst depth = -Math.abs(relativeIndex) * 15;\r\nconst scale = 1 - Math.abs(relativeIndex) * 0.03;\r\n```\r\n\r\nThis algorithm calculates precise positioning for each card through relative indexing, creating a layered visual effect.\r\n\r\n#### 2. Mouse Tracking Tilt Algorithm\r\n\r\n```typescript\r\n// Coordinate normalization\r\nconst offsetX = (e.clientX - centerX) / rect.width;\r\nconst offsetY = (e.clientY - centerY) / rect.height;\r\n\r\n// Angle mapping conversion\r\nconst rotateX = -offsetY * 15;\r\nconst rotateY = offsetX * 15;\r\n```\r\n\r\nConverts 2D mouse coordinates to 3D rotation angles, achieving natural tilt tracking effects.\r\n\r\n#### 3. Smart Grid Layout Algorithm\r\n\r\n```typescript\r\n// Optimal column calculation\r\nconst cols = Math.ceil(Math.sqrt(total));\r\n\r\n// Center alignment mathematics\r\nconst x = (col - (cols - 1) / 2) * widthSpacing;\r\nconst y = (row - Math.floor((total - 1) / cols) / 2) * heightSpacing;\r\n```\r\n\r\nUses square root algorithm to create near-square grids with perfect center alignment through mathematical calculations.\r\n\r\n#### 4. Cascaded Timer Management\r\n\r\n```typescript\r\n// Clear existing timer\r\nif (autoReturnTimer) {\r\n    clearTimeout(autoReturnTimer);\r\n    setAutoReturnTimer(null);\r\n}\r\n\r\n// Start new reset timer\r\nconst timer = setTimeout(() =\u003e {\r\n    setTransform('rotateX(0deg) rotateY(0deg)');\r\n    setFlipped(false);\r\n}, 1500);\r\n```\r\n\r\nThrough cascaded timer management, ensures interaction continuity and correct state resets.\r\n\r\n#### 5. Fan Spread Algorithm\r\n\r\n```typescript\r\n// Fan angle calculation\r\nconst fanAngle = (index - activeIndex) * 4;\r\n\r\n// Horizontal spread distance\r\nconst translateX = Math.sin(fanAngle * Math.PI / 180) * 12;\r\n\r\n// Combined transform\r\nreturn `rotateZ(${fanAngle}deg) translateX(${translateX}px)`;\r\n```\r\n\r\nUses trigonometric functions to calculate precise fan spread positions, creating elegant layered display effects.\r\n\r\n### Performance Optimization Strategies\r\n\r\n**1. Animation Performance**\r\n```typescript\r\n// Use CSS 3D transforms for GPU acceleration\r\ntransformStyle: 'preserve-3d',\r\nbackfaceVisibility: 'hidden',\r\n\r\n// Optimize with willChange hints\r\nstyle={{ willChange: 'transform' }}\r\n```\r\n\r\n**2. State Management Efficiency**\r\n```typescript\r\n// Use useCallback to prevent unnecessary re-renders\r\nconst handleMouseMove = useCallback((e: React.MouseEvent) =\u003e {\r\n    // Only calculate when actually needed\r\n    if (!hovered || mode === 'folded') return;\r\n}, [hovered, mode]);\r\n```\r\n\r\n**3. Memory Cleanup**\r\n```typescript\r\n// Proper timer cleanup to prevent memory leaks\r\nuseEffect(() =\u003e {\r\n    return () =\u003e {\r\n        if (autoReturnTimer) {\r\n            clearTimeout(autoReturnTimer);\r\n        }\r\n    };\r\n}, [autoReturnTimer]);\r\n```\r\n\r\n*May your cards be as light as feathers, as brilliant as diamonds, performing dimensional poetry at users' fingertips in the digital world.* ✨\r\n"])</script><script>self.__next_f.push([1,"21:T9106,"])</script><script>self.__next_f.push([1,"\n# Particle Text: Digital Alchemy from Pixels to Particles\n\nHyperGryph's official website particle effects (This is particle impact! This is particle text! However, this is... particle headache! Ahahahahahaha!!!)\n\nThis particle text system can transform static text into thousands of active particles that fly from all corners of the screen to their target positions, forming the shape of text while responding physically to mouse proximity—like the feeling of reaching your hand into a pile of rice grains. In this article, I'll start from the most basic type definitions and gradually dive deep into every implementation detail, comprehensively dissecting this digital alchemy that transforms pixels into particles.\n\n*Warning: Contains advanced mathematics and may cause temporary dizziness in developers allergic to physics equations! 🤯*\n\n## Component Structure and Type Definitions\n\nIn fact, each particle is an individual object with its own personality and destiny.\n\n### Particle Entity Design\n\n```typescript\ninterface ParticleData {\n    x: number;\n    y: number;\n    color: number[];\n}\n```\n\nField explanations:\n\n- **x \u0026 y**: The target position coordinates of the particle. Note that this stores the final position, not the current position. This design lets particles know their exact destination on the canvas—like giving each particle a GPS coordinate!\n- **color**: RGB values in array format can be directly used for `rgba()` function construction, enjoying JavaScript's syntax support for array element operations in code writing. It's like giving each particle its own personal color palette! 🎨\n\nThis type definition describes the basic properties of a particle without involving motion state or rendering details.\n\n### Component Props\n\n```typescript\ninterface ParticleWordProps {\n    text?: string;\n    className?: string;\n}\n```\n\nField explanations:\n\n- **text?: string**: Optional text content. When not provided, it uses a default value to avoid null pointer exceptions.\n- **className?: string**: Style extension interface, following React component's standard design pattern.\n\n### Particle Class Design\n\n```typescript\nclass Particle {\n    x: number;           // Current X position\n    y: number;           // Current Y position\n    totalX: number;      // Target X position\n    totalY: number;      // Target Y position\n    mx: number = 0;      // X-axis movement distance\n    my: number = 0;      // Y-axis movement distance\n    vx: number = 0;      // X-axis velocity\n    vy: number = 0;      // Y-axis velocity\n    time: number;        // Animation time\n    r: number;           // Particle radius\n    color: number[];     // Particle color\n    opacity: number;     // Opacity\n}\n```\n\nProperty grouping analysis:\n- **Position-related**: `x, y` (current position) vs `totalX, totalY` (target position) separation design lets particles \"know\" where they need to go—like having both a current location and a dream destination!\n- **Motion-related**: `mx, my` are movement distances, `vx, vy` are calculated velocities, a simple but effective kinematic model that would make Newton proud 🍎\n- **Visual-related**: `time` controls animation rhythm, `r` controls size, `color` and `opacity` control appearance—the full makeup kit for our digital particles!\n\n## Configuration Constants Analysis\n\nDefining the basic properties of the canvas.\n\n### Canvas Dimensions\n\n```typescript\nconst CANVAS_WIDTH = 600;\nconst CANVAS_HEIGHT = 200;\n```\n\n### Animation Parameters\n\n```typescript\nconst ANIMATE_TIME = 30;\nconst OPACITY_STEP = 1 / ANIMATE_TIME;\n```\n\n**ANIMATE_TIME = 30**:\n\nNote, this 30 is not 30 milliseconds, but 30 frames! In a 60fps animation loop, particles need 30 frames (about 500ms) to reach their target position. It's like giving each particle exactly half a second to find its way home! ⏱️\n\n**Opacity Gradient**:\n\n```typescript\nconst OPACITY_STEP = 1 / 30 = 0.0333...\n```\n\nEach frame increases opacity by about 3.33%, reaching full opacity after 30 frames. This linear gradient creates a natural \"appearing from the quantum vacuum\" effect for particles—because apparently, our particles have learned quantum mechanics! 🔬\n\n### Interaction Parameters\n\n```typescript\nconst RADIUS = 40;\nconst INTENSITY = 0.95;\n```\n\nParameter explanations:\n\n**RADIUS**: The interaction radius between cursor and particles is 40 pixels\n\n**INTENSITY**: The cursor's \"pushing force\" coefficient, meaning that during the continuous position updates of particles, the force applied by the cursor gradually weakens\n\n## Particle System Design\n\nThe particle system is the core of the entire effect. Each particle is a small intelligent agent with its own lifecycle and behavior patterns—basically, we're running a tiny civilization on your screen!\n\n### Particles Born from Random Positions\n\n```typescript\nconstructor(totalX: number, totalY: number, time: number, color: number[]) {\n    this.x = Math.random() * CANVAS_WIDTH;\n    this.y = Math.random() * CANVAS_HEIGHT;\n    this.totalX = totalX;\n    this.totalY = totalY;\n    this.time = time;\n    this.r = 1.2;\n    this.color = [...color];\n    this.opacity = 0;\n}\n```\n\n**Random Initial Position**:\n\nEach particle starts its journey from a random position on the canvas, creating a visual effect of \"order emerging from chaos.\" If all particles started from the same corner, it would seem too monotonous, lacking that feeling of cosmic stardust condensing into text. It's like having a cosmic Big Bang, but instead of creating the universe, we're creating the word \"Hello\"! 🌌\n\nParameter explanations:\n- `totalX, totalY`: Target coordinates of the particle\n- `time`: Time needed for the particle to reach its destination\n- `color`: Color of the particle\n\n### Particles Decelerate in Diffusion\n\n```typescript\nupdate(mouseX?: number, mouseY?: number) {\n    this.mx = this.totalX - this.x;\n    this.my = this.totalY - this.y;\n    this.vx = this.mx / this.time;\n    this.vy = this.my / this.time;\n    // ...\n}\n```\n\n**Displacement→Velocity Mathematical Transformation**:\n\nKnown kinematic formula: `Velocity = Displacement / Time`\n\n```\nvx = (Target X - Current X) / Time Constant\nvy = (Target Y - Current Y) / Time Constant\n```\n\n**Why divide by the time constant**?\n\nThis creates a \"gradual approach\" effect—the closer to the target, the slower the speed. It's like particles get more and more excited as they approach their destination, but also more careful not to overshoot! Think of it as particles practicing good parking etiquette. 🚗\n\n### Touching the Sea of Particles\n\n```typescript\nif (mouseX !== undefined \u0026\u0026 mouseY !== undefined \u0026\u0026 mouseX \u003e 0 \u0026\u0026 mouseY \u003e 0) {\n    const dx = mouseX - this.x;\n    const dy = mouseY - this.y;\n    const distance = Math.sqrt(dx ** 2 + dy ** 2);\n\n    if (distance \u003c RADIUS) {\n        let disPercent = RADIUS / distance;\n        disPercent = disPercent \u003e 7 ? 7 : disPercent;\n\n        const angle = Math.atan2(dy, dx);\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const repX = cos * disPercent * -INTENSITY;\n        const repY = sin * disPercent * -INTENSITY;\n        this.vx += repX;\n        this.vy += repY;\n    }\n}\n```\n\n**Geometric Principle of Distance Calculation**:\n\n```typescript\nconst distance = Math.sqrt(dx ** 2 + dy ** 2);\n```\n\nUses the Euclidean distance formula to calculate the straight-line distance between mouse and particle. Although square root operations are somewhat computationally heavy, this load is completely not a problem in modern browsers—they've gotten pretty good at math since the 90s! 📐\n\n**Force Decay Function**:\n\n```typescript\nlet disPercent = RADIUS / distance;\ndisPercent = disPercent \u003e 7 ? 7 : disPercent;\n```\n\nThis is an inverse proportional decay function—the closer the distance, the stronger the force:\n- When `distance = RADIUS`, `disPercent = 1` (standard intensity)\n- When `distance = RADIUS/2`, `disPercent = 2` (double intensity)\n- When `distance → 0`, `disPercent → ∞`\n\n**Why limit to within 7**? To prevent particles from gaining excessive acceleration when directly under the mouse and \"flying out of the galaxy.\" We need to keep our particles grounded—or at least within the observable universe! 🚀\n\n**Angle Calculation and Force Decomposition**:\n\n```typescript\nconst angle = Math.atan2(dy, dx);\nconst repX = cos * disPercent * -INTENSITY;\nconst repY = sin * disPercent * -INTENSITY;\n```\n\nThis uses the classic vector decomposition method:\n1. Calculate the angle from particle pointing to mouse\n2. Use trigonometric functions to decompose force into X and Y components\n3. The negative sign creates a \"repulsion\" effect (remove the negative sign for \"attraction\")\n\nIt's basically teaching particles to maintain social distancing from your cursor! 😷\n\n### Rendering Optimization\n\n```typescript\ndraw(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n    ctx.strokeStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n    ctx.fillRect(this.x, this.y, this.r * 2, this.r * 2);\n}\n```\n\n**Why use fillRect instead of arc**?\n\n- **Performance advantage**: Rectangle drawing is about 30% faster than circles, and this difference is obvious when there are thousands of particles\n- **Visual effect**: 1.2×1.2 pixel small rectangles are almost indistinguishable from circles when viewed from a distance—it's the digital equivalent of \"close enough for jazz\"! 🎷\n- **Pixel perfect**: Rectangles avoid the anti-aliasing issues of circles\n\n**Color interpolation string concatenation**:\n\n```typescript\nctx.fillStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n```\n\nWe're basically teaching JavaScript to speak RGB! 🌈\n\n## Text-to-Particle Principles\n\n(The underlying logic of the cyber magnetic board—or as I like to call it, \"How to Turn Letters into Digital Confetti\")\n\n### Off-screen Canvas\n\n```typescript\nconst tempCanvas = document.createElement('canvas');\nconst tempCtx = tempCanvas.getContext('2d')!;\ntempCanvas.width = CANVAS_WIDTH;\ntempCanvas.height = CANVAS_HEIGHT;\n```\n\n**Why need a temporary Canvas**?\n\nOff-screen rendering is a classic technique in computer graphics:\n1. **Isolated environment**: Temporary Canvas doesn't affect the main canvas state—it's like having a secret laboratory where we can experiment without blowing up the main building! 🧪\n2. **Pixel reading**: Only by first \"drawing\" the text can we read pixel data\n3. **Memory efficiency**: Temporary Canvas is garbage collected after use, not occupying long-term memory\n\n**Performance advantages of off-screen rendering**:\n\n- Avoids repeated clearing and redrawing of the main canvas\n- Can be performed in any thread\n- If rendering complexity increases, Web Workers can be used in the future to parallelize rendering for performance improvement (current rendering needs don't require this level of sophistication—yet!)\n\n### Text Rendering Parameters\n\n```typescript\ntempCtx.font = 'bold 100px Arial, sans-serif';\ntempCtx.textAlign = 'center';\ntempCtx.textBaseline = 'middle';\n```\n\n**Mathematical calculation for center alignment**:\n```typescript\ntempCtx.fillText(text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n```\n\nBy drawing text at the geometric center of the canvas (300, 100), it ensures that regardless of text length, it can be centered on the canvas.\n\n**Impact of font choice on particle effects**:\n\n- **sans-serif**: Sans-serif fonts avoid excessive detail that could cause particle noise\n\n### Pixel Sampling Algorithm: Wisdom from Continuous to Discrete\n\nOriginal algorithm author: [XIwE1](https://github.com/XIwE1), thanks and respect orz (The hero we needed but didn't deserve! 🦸‍♂️)\n\n```typescript\nfor (let y = 0; y \u003c CANVAS_HEIGHT; y += 3) {\n    for (let x = 0; x \u003c CANVAS_WIDTH; x += 3) {\n        const index = (x + y * CANVAS_WIDTH) * 4;\n        const a = data[index + 3];\n        if (a \u003e 128) {\n            particles.push({\n                x,\n                y,\n                color: [...rgbColor]\n            });\n        }\n    }\n}\n```\n\n**Sampling logic of nested loops**:\n\nThis nested loop traverses the entire canvas, but not pixel by pixel—rather sampling every 3 pixels. It's like reading every third word in a book and still understanding the story! 📖\n\n**Why is the step size 3**?\n\nThis is a delicate balance between performance and quality:\n- Step size 1: Every pixel is sampled, enormous number of particles (about 40,000), terrible performance—your computer would cry! 😭\n- Step size 5: Too few particles, text outline unclear—it's like trying to draw the Mona Lisa with only 10 pixels\n- Step size 3: Moderate number of particles (about 4,000-8,000), maintaining text clarity while ensuring smooth animation—the Goldilocks zone of particle sampling! 🐻\n\n**Memory layout of RGBA data structure**:\n\n```typescript\nconst index = (x + y * CANVAS_WIDTH) * 4;\n```\n\nCanvas ImageData stores each pixel in RGBA order:\n```\n[R0, G0, B0, A0, R1, G1, B1, A1, R2, G2, B2, A2, ...]\n```\n\nSo the alpha value of pixel (x,y) is located at: `(x + y * width) * 4 + 3`\n\nIt's like having every pixel tell you its life story: \"Hi, I'm Red 255, Green 100, Blue 50, and I'm 80% visible!\" 🎭\n\n**Principle of alpha threshold 128 selection**:\n\n```typescript\nif (a \u003e 128) {\n    particles.push({x, y, color: [...rgbColor]});\n}\n```\n\nAlpha value range is 0-255, 128 is exactly half. This threshold ensures:\n- Completely transparent background (alpha=0) won't generate particles\n- Text edges with some transparency are also included\n- Avoids noise from semi-transparent pixels caused by anti-aliasing\n\nIt's basically asking each pixel: \"Are you at least half-committed to existing?\" 🤔\n\n**RGB decomposition of color conversion**:\n\n```typescript\ncolor: [...rgbColor]\n```\n\nUsing the spread operator to copy the color array avoids the problem of all particles sharing the same color array (shallow copy trap).\n\n## ParticleCanvas Class: ~~Kei \u0026 Zero~~ Particle Commander\n\nIf Particle is the soldier, then ParticleCanvas is the commander, coordinating the entire particle army's actions. Think of it as the general in our microscopic war against boring static text! ⚔️\n\n### Event System Design: Coordinate Transformation\n\n```typescript\nsetupMouseEvents() {\n    this.canvas.addEventListener('mousemove', (e) =\u003e {\n        const rect = this.canvas.getBoundingClientRect();\n        this.mouseX = e.clientX - rect.left;\n        this.mouseY = e.clientY - rect.top;\n    });\n\n    this.canvas.addEventListener('mouseleave', () =\u003e {\n        this.mouseX = 0;\n        this.mouseY = 0;\n    });\n}\n```\n\n**Precise positioning with getBoundingClientRect**:\n\nThis method returns the precise position of elements relative to the viewport, considering:\n- CSS transforms\n- Scroll offsets\n- Border widths\n- Padding\n\nIt's like having a GPS system that works inside your browser! 🗺️\n\n**Mathematical principle of coordinate transformation**:\n\n```typescript\nthis.mouseX = e.clientX - rect.left;\nthis.mouseY = e.clientY - rect.top;\n```\n\n- `e.clientX/Y`: Mouse coordinates relative to viewport\n- `rect.left/top`: Canvas element coordinates relative to viewport\n- Subtraction gives mouse coordinates relative to Canvas\n\nIt's coordinate system translation—we're basically teaching the mouse to speak Canvas! 🖱️\n\n**Why need mouseleave handling**?\n\nWhen the mouse leaves the Canvas, setting coordinates to (0,0) ensures particles don't continue to be affected by a \"ghost mouse.\" This is more natural than maintaining the last position—nobody likes phantom cursors haunting their animations! 👻\n\n### Animation Loop Lifecycle\n\n```typescript\nanimate() {\n    this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    this.particles.forEach(particle =\u003e {\n        particle.update(this.mouseX, this.mouseY);\n        particle.draw(this.ctx);\n    });\n\n    this.animationId = requestAnimationFrame(() =\u003e this.animate());\n}\n```\n\n**Standard cycle of Clear→Update→Draw**:\n\nThis is the classic pattern for Canvas animation:\n1. **Clear**: Erase previous frame content\n2. **Update**: Calculate new states\n3. **Draw**: Render current frame\n\n**Advantages of requestAnimationFrame**:\n\nCompared to `setTimeout`, `requestAnimationFrame` has many advantages:\n- **Vertical sync**: Synchronized with monitor refresh rate, avoiding tearing\n- **Automatic throttling**: Automatically pauses when page is not visible\n- **Performance optimization**: Browser performs better optimization\n\n**Importance of animation ID management**:\n\n```typescript\nthis.animationId = requestAnimationFrame(() =\u003e this.animate());\n```\n\nSaving the animation ID is for subsequent cancellation operations. Without this ID, the animation loop cannot be stopped, causing memory leaks.\n\n### Resource Management and Memory Leak Protection\n\n```typescript\ndestroy() {\n    if (this.animationId) {\n        cancelAnimationFrame(this.animationId);\n    }\n}\n```\n\n**Why need manual destruction**?\n\nAlthough JavaScript's garbage collection mechanism is powerful, the following resources need manual cleanup:\n- Animation loops (requestAnimationFrame)\n- Event listeners (though these auto-clean with DOM element deletion)\n- Timers (setTimeout/setInterval)\n\n**Cleanup work during React component unmounting**:\n\nIn React's lifecycle, these resources must be cleaned up when components unmount, otherwise:\n- Animations continue running, consuming CPU\n- Memory cannot be released\n- Possible erroneous state updates\n\n## React Integration Best Practices\n\nIntegrating Canvas animation into React components requires handling multiple challenges like lifecycle, performance optimization, and state synchronization.\n\n### useEffect Dependency Management\n\n```typescript\nuseEffect(() =\u003e {\n    if (canvasRef.current) {\n        if (particleCanvasRef.current) {\n            particleCanvasRef.current.destroy();\n        }\n        particleCanvasRef.current = new ParticleCanvas(canvasRef.current);\n        particleCanvasRef.current.generateTextParticles(text, currentTheme.colors.primary);\n        particleCanvasRef.current.animate();\n        setIsLoaded(true);\n    }\n\n    return () =\u003e {\n        if (particleCanvasRef.current) {\n            particleCanvasRef.current.destroy();\n        }\n    };\n}, [text, currentTheme.colors.primary]);\n```\n\n**Dependency array selection strategy**:\n\nOnly includes `text` and `currentTheme.colors.primary` as dependencies:\n- **text**: Need to regenerate particles when text changes\n- **currentTheme.colors.primary**: Need to update particle colors when theme changes\n- **No other values**: Avoid unnecessary re-initialization\n\n**Responsive updates for theme color changes**:\n\nWhen users switch themes, particle colors need immediate updates. By monitoring theme changes and regenerating the particle system, visual consistency is ensured.\n\n**Necessity of cleanup function**:\n\nThe returned cleanup function ensures:\n- Stop animation when component unmounts\n- Clean old instance before creating new instance when dependencies change\n- Avoid multiple animation loops running simultaneously\n\n## Mathematical Principles Deep Analysis\n\nNext is the \"what is this magic\" stage (Prepare for mathematical enlightenment or confusion—possibly both!) 🤓\n\n### Vector Operations in Particle Systems\n\n**Relationship between position vectors and velocity vectors**:\n\nIn our system, each particle's motion can be described using vectors:\n- Position vector: $\\vec{P} = (x, y)$\n- Target vector: $\\vec{T} = (totalX, totalY)$\n- Movement vector: $\\vec{M} = \\vec{T} - \\vec{P}$\n- Velocity vector: $\\vec{V} = \\frac{\\vec{M}}{time}$\n\nIt's like giving each particle a mathematical compass and map! 🧭\n\n**Force composition and decomposition**:\n\nWhen the mouse affects particles, particles are acted upon by two forces:\n\n$$\\vec{F_1} = \\frac{\\vec{M}}{time}$$\n\n$$\\vec{F_2} = -INTENSITY \\cdot \\frac{RADIUS}{distance} \\cdot \\vec{u}$$\n\nWhere $\\vec{u}$ is the unit vector from particle pointing to mouse.\n\n**Final velocity** is the vector sum of two forces: \n\n$$\\vec{V_{final}} = \\vec{F_1} + \\vec{F_2}$$\n\nThis is basically physics class, but with more fun and fewer boring lectures! ⚡\n\n### Distance Decay Function Design\n\n**Physical meaning of inverse proportion function**:\n\nThe decay function we use is: \n\n$$f(d) = \\frac{RADIUS}{d}$$\n\nThis simulates the decay law of Coulomb force (although Coulomb force is $\\frac{1}{d^2}$, $\\frac{1}{d}$ has better visual effects). We're not trying to solve electromagnetism here—just make pretty animations! ✨\n\n**Boundary condition handling**:\n\nWhen $d \\to 0$, $f(d) \\to \\infty$, which is mathematically divergent. We solve this by limiting the maximum value:\n\n```typescript\ndisPercent = disPercent \u003e 7 ? 7 : disPercent;\n```\n\nThis is equivalent to adding an upper bound to the function: \n\n$$f(d) = \\min\\left(7, \\frac{RADIUS}{d}\\right)$$\n\nWe're basically telling particles: \"You can be excited, but not TOO excited!\" 📈\n\n### Color Space Conversion\n\n**Mathematical transformation from HEX to RGB**:\n\nThe color conversion function `hexToRGB` performs the following transformation:\n- Input: `\"#ff6432\"`\n- Parse: `ff`(255), `64`(100), `32`(50)\n- Output: `[255, 100, 50]`\n\n**Interpolation algorithm for opacity gradient**:\n\nOpacity changes use linear interpolation: \n\n$$opacity(t) = 0 + \\frac{t}{ANIMATE\\_TIME} \\cdot (1 - 0) = \\frac{t}{30}$$\n\nWhere $t$ is the current frame number, $t \\in [0, 30]$.\n\n## Performance Optimization Deep Thinking\n\nThe following optimizations can be considered for future needs, such as when particles or text to be drawn change frequently. (Also known as \"How to make your animations fast enough to impress your colleagues\") 🚄\n\n### Rendering Performance Optimization\n\n**Minimizing Canvas draw calls**:\n\nEach particle calls `fillRect` once, which is unavoidable, but drawing calls can be reduced through:\n- Batch setting of drawing states\n- Using path drawing instead of multiple fillRect calls\n- Implementing particle pooling to avoid object creation/destruction\n\nIt's like organizing your particles into an efficient assembly line! 🏭\n\n**GPU acceleration enabling conditions**:\n\nModern browsers automatically enable GPU acceleration for Canvas, conditions being:\n- Using specific operations of 2D context\n- Moderate canvas size (current 600×200 meets conditions)\n- No complex transforms or filters\n\nYour graphics card is basically volunteering to help with the particle math—what a team player! 🎮\n\n**Garbage collection timing control**:\n\nGC pressure can be reduced through:\n- Reusing particle objects instead of recreating them\n- Avoiding temporary object creation in animation loops\n- Properly setting object lifecycles\n\nWe're essentially teaching JavaScript to recycle—it's environmentally friendly programming! ♻️\n\n## Complete Source Code Full Analysis\n\n```typescript\n'use client';\n\nimport React, {useEffect, useRef, useState} from 'react';\nimport {useThemeStore} from '@/lib/stores/themeStore';\nimport {hexToRGB} from \"@/lib/utils/color\";\n\n// ==================== Core Configuration Constants ====================\nconst CANVAS_WIDTH = 600;   // Canvas width\nconst CANVAS_HEIGHT = 200;  // Canvas height\n\n// Animation parameters\nconst ANIMATE_TIME = 30;    // Particle animation time (frames)\nconst OPACITY_STEP = 1 / ANIMATE_TIME;  // Opacity gradient step\nconst RADIUS = 40;          // Mouse interaction radius\nconst INTENSITY = 0.95;     // Mouse repulsion intensity\n\n// ==================== Type Definitions ====================\ninterface ParticleData {\n    x: number;          // Particle target X coordinate\n    y: number;          // Particle target Y coordinate\n    color: number[];    // Particle RGB color array\n}\n\ninterface ParticleWordProps {\n    text?: string;      // Text content to display\n    className?: string; // Custom style class name\n}\n\n// ==================== Particle Class: Each Particle's Agent ====================\nclass Particle {\n    // Position-related properties\n    x: number;          // Current X coordinate\n    y: number;          // Current Y coordinate\n    totalX: number;     // Target X coordinate\n    totalY: number;     // Target Y coordinate\n    \n    // Motion-related properties\n    mx: number = 0;     // X-axis movement distance\n    my: number = 0;     // Y-axis movement distance\n    vx: number = 0;     // X-axis velocity\n    vy: number = 0;     // Y-axis velocity\n    time: number;       // Time required to reach target\n    \n    // Visual-related properties\n    r: number;          // Particle radius\n    color: number[];    // Particle color (RGB array)\n    opacity: number;    // Opacity\n\n    /**\n     * Particle constructor\n     * @param totalX Target X coordinate\n     * @param totalY Target Y coordinate\n     * @param time Animation time\n     * @param color Particle color\n     */\n    constructor(totalX: number, totalY: number, time: number, color: number[]) {\n        // Random initial position: let particles \"fly toward\" target position from everywhere on canvas\n        this.x = Math.random() * CANVAS_WIDTH;\n        this.y = Math.random() * CANVAS_HEIGHT;\n        \n        // Set target position\n        this.totalX = totalX;\n        this.totalY = totalY;\n        \n        // Set animation parameters\n        this.time = time;\n        this.r = 1.2;  // Particle size\n        \n        // Copy color array to avoid reference issues\n        this.color = [...color];\n        this.opacity = 0;  // Initial opacity is 0, implementing fade-in effect\n    }\n\n    /**\n     * Draw particle to Canvas\n     * @param ctx Canvas 2D context\n     */\n    draw(ctx: CanvasRenderingContext2D) {\n        // Set fill and stroke colors including opacity\n        ctx.fillStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n        ctx.strokeStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n        \n        // Draw rectangular particle (better performance than circles)\n        ctx.fillRect(this.x, this.y, this.r * 2, this.r * 2);\n    }\n\n    /**\n     * Update particle state\n     * @param mouseX Mouse X coordinate (optional)\n     * @param mouseY Mouse Y coordinate (optional)\n     */\n    update(mouseX?: number, mouseY?: number) {\n        // Calculate distance to target position\n        this.mx = this.totalX - this.x;\n        this.my = this.totalY - this.y;\n        \n        // Calculate base velocity: distance divided by time, implementing gradual approach effect\n        this.vx = this.mx / this.time;\n        this.vy = this.my / this.time;\n\n        // Mouse interaction: calculate repulsion force\n        if (mouseX !== undefined \u0026\u0026 mouseY !== undefined \u0026\u0026 mouseX \u003e 0 \u0026\u0026 mouseY \u003e 0) {\n            // Calculate distance between mouse and particle\n            const dx = mouseX - this.x;\n            const dy = mouseY - this.y;\n            const distance = Math.sqrt(dx ** 2 + dy ** 2);\n\n            // If within interaction radius, apply repulsion force\n            if (distance \u003c RADIUS) {\n                // Calculate repulsion force intensity: closer distance, greater force\n                let disPercent = RADIUS / distance;\n                // Limit maximum repulsion force to prevent particles from \"flying out of the galaxy\"\n                disPercent = disPercent \u003e 7 ? 7 : disPercent;\n\n                // Calculate repulsion force direction\n                const angle = Math.atan2(dy, dx);\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n\n                // Calculate repulsion force components (negative sign indicates repulsion)\n                const repX = cos * disPercent * -INTENSITY;\n                const repY = sin * disPercent * -INTENSITY;\n                \n                // Add repulsion force to velocity\n                this.vx += repX;\n                this.vy += repY;\n            }\n        }\n\n        // Update position\n        this.x += this.vx;\n        this.y += this.vy;\n        \n        // Fade-in effect: gradually increase opacity\n        if (this.opacity \u003c 1) this.opacity += OPACITY_STEP;\n    }\n}\n\n// ==================== Particle Canvas Management Class ====================\nclass ParticleCanvas {\n    canvas: HTMLCanvasElement;      // Canvas element\n    ctx: CanvasRenderingContext2D;  // 2D drawing context\n    particles: Particle[];          // Particle array\n    mouseX: number = 0;             // Mouse X coordinate\n    mouseY: number = 0;             // Mouse Y coordinate\n    animationId: number = 0;        // Animation ID for canceling animation\n\n    /**\n     * Constructor\n     * @param canvas Canvas element\n     */\n    constructor(canvas: HTMLCanvasElement) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d')!;\n        this.particles = [];\n        this.setupMouseEvents();\n    }\n\n    /**\n     * Setup mouse event listeners\n     */\n    setupMouseEvents() {\n        // Mouse move event: update mouse coordinates\n        this.canvas.addEventListener('mousemove', (e) =\u003e {\n            const rect = this.canvas.getBoundingClientRect();\n            // Convert screen coordinates to Canvas coordinates\n            this.mouseX = e.clientX - rect.left;\n            this.mouseY = e.clientY - rect.top;\n        });\n\n        // Mouse leave event: clear mouse coordinates\n        this.canvas.addEventListener('mouseleave', () =\u003e {\n            this.mouseX = 0;\n            this.mouseY = 0;\n        });\n    }\n\n    /**\n     * Generate particles based on text\n     * @param text Text to display\n     * @param color Particle color (hexadecimal)\n     */\n    generateTextParticles(text: string, color: string = '#000000') {\n        // Create temporary Canvas for text rendering\n        const tempCanvas = document.createElement('canvas');\n        const tempCtx = tempCanvas.getContext('2d')!;\n        tempCanvas.width = CANVAS_WIDTH;\n        tempCanvas.height = CANVAS_HEIGHT;\n\n        // Set text style\n        tempCtx.font = 'bold 100px Arial, sans-serif';\n        tempCtx.textAlign = 'center';\n        tempCtx.textBaseline = 'middle';\n\n        // Draw text on temporary Canvas\n        tempCtx.fillText(text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n\n        // Get pixel data\n        const imageData = tempCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        const data = imageData.data;\n\n        const particles: ParticleData[] = [];\n        \n        // Convert hexadecimal color to RGB array\n        const rgbColor = hexToRGB(color);\n\n        // Pixel sampling: sample every 3 pixels, balancing performance and quality\n        for (let y = 0; y \u003c CANVAS_HEIGHT; y += 3) {\n            for (let x = 0; x \u003c CANVAS_WIDTH; x += 3) {\n                // Calculate pixel index in ImageData\n                const index = (x + y * CANVAS_WIDTH) * 4;\n                // Get Alpha channel value\n                const a = data[index + 3];\n\n                // Only generate particles for pixels with Alpha value greater than 128\n                if (a \u003e 128) {\n                    particles.push({\n                        x,\n                        y,\n                        color: [...rgbColor]\n                    });\n                }\n            }\n        }\n\n        // Create Particle instances for each particle data\n        this.particles = particles.map(\n            particle =\u003e new Particle(particle.x, particle.y, ANIMATE_TIME, particle.color)\n        );\n    }\n\n    /**\n     * Animation loop function\n     */\n    animate() {\n        // Clear canvas\n        this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // Update and draw each particle\n        this.particles.forEach(particle =\u003e {\n            particle.update(this.mouseX, this.mouseY);\n            particle.draw(this.ctx);\n        });\n\n        // Request next animation frame\n        this.animationId = requestAnimationFrame(() =\u003e this.animate());\n    }\n\n    /**\n     * Destroy particle system, clean up resources\n     */\n    destroy() {\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n        }\n    }\n}\n\n// ==================== React Component ====================\nexport const ParticleWord: React.FC\u003cParticleWordProps\u003e = ({\n    text = 'MilkWind',  // Default text\n    className = ''      // Default style class\n}) =\u003e {\n    // React Hooks\n    const canvasRef = useRef\u003cHTMLCanvasElement\u003e(null);\n    const particleCanvasRef = useRef\u003cParticleCanvas | null\u003e(null);\n    const [isLoaded, setIsLoaded] = useState(false);\n    const {currentTheme} = useThemeStore();\n\n    // Component lifecycle management\n    useEffect(() =\u003e {\n        if (canvasRef.current) {\n            // Clean up old particle system\n            if (particleCanvasRef.current) {\n                particleCanvasRef.current.destroy();\n            }\n            \n            // Create new particle system\n            particleCanvasRef.current = new ParticleCanvas(canvasRef.current);\n            particleCanvasRef.current.generateTextParticles(text, currentTheme.colors.primary);\n            particleCanvasRef.current.animate();\n            setIsLoaded(true);\n        }\n\n        // Cleanup function: clean up resources when component unmounts\n        return () =\u003e {\n            if (particleCanvasRef.current) {\n                particleCanvasRef.current.destroy();\n            }\n        };\n    }, [text, currentTheme.colors.primary]); // Dependency array: recreate when text or theme color changes\n\n    return (\n        \u003cdiv className={`flex justify-center items-center ${className}`}\u003e\n            \u003cdiv className=\"relative\"\u003e\n                {/* Canvas element */}\n                \u003ccanvas\n                    ref={canvasRef}\n                    width={CANVAS_WIDTH}\n                    height={CANVAS_HEIGHT}\n                    className=\"rounded-lg cursor-default\"\n                    style={{\n                        maxWidth: '100%',\n                        height: 'auto',\n                    }}\n                /\u003e\n                {/* Loading status indicator */}\n                {!isLoaded \u0026\u0026 (\n                    \u003cdiv\n                        className=\"absolute inset-0 flex items-center justify-center\"\n                        style={{color: currentTheme.colors.foreground}}\n                    \u003e\n                        Loading particle animation...\n                    \u003c/div\u003e\n                )}\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n};\n```\n\n### Core Algorithm Flow Chart\n\n```\nText Input → Off-screen Canvas Rendering → Pixel Sampling → Particle Generation → Animation Loop\n    ↓           ↓                         ↓                ↓                    ↓\n \"MilkWind\"  Temporary canvas drawing   Every 3 pixels    Create particle objects  RAF loop\n    ↓           ↓                         ↓                ↓                    ↓\n Set font    Extract pixel data        Alpha\u003e128         Random initial position  Update+Draw\n    ↓           ↓                         ↓                ↓                    ↓\n Center draw  RGBA data structure      Generate coords   Move toward target     Mouse interaction\n```\n\n### Key Function Analysis\n\n**1. Pixel Sampling Core Algorithm**\n```typescript\n// Key: Sample every 3 pixels, balancing performance and quality\nfor (let y = 0; y \u003c CANVAS_HEIGHT; y += 3) {\n    for (let x = 0; x \u003c CANVAS_WIDTH; x += 3) {\n        const index = (x + y * CANVAS_WIDTH) * 4;  // RGBA index calculation\n        const a = data[index + 3];                  // Get Alpha value\n        if (a \u003e 128) {                             // Alpha threshold judgment\n            // Generate particle data\n        }\n    }\n}\n```\n\n**2. Mouse Interaction Physics Calculation**\n```typescript\n// Key: Inverse proportional decay + vector decomposition\nconst distance = Math.sqrt(dx ** 2 + dy ** 2);    // Euclidean distance\nlet disPercent = RADIUS / distance;               // Inverse proportional decay\ndisPercent = disPercent \u003e 7 ? 7 : disPercent;    // Force upper limit\nconst angle = Math.atan2(dy, dx);                 // Angle calculation\nconst repX = cos * disPercent * -INTENSITY;      // Force decomposition\n```\n\n**3. Gradual Motion Algorithm**\n```typescript\n// Key: Distance divided by time, implementing natural deceleration\nthis.vx = (this.totalX - this.x) / this.time;    // Velocity decay\nthis.x += this.vx;                                // Position update\nthis.opacity += OPACITY_STEP;                     // Opacity gradient\n```\n\n## Final Words\n\nDuring development, I couldn't help but marvel repeatedly that mathematics is truly a beautiful discipline. When particles respond with agility to mouse proximity, when the entire particle cloud instantly transforms with theme color switches—these seemingly magical effects are actually the poetic combination of mathematics and code.\n\nTechnology is never just cold logic; it's a tool for creating beautiful experiences, a bridge connecting imagination and reality. And sometimes, it's also an excuse to make thousands of tiny rectangles dance around your screen for no reason other than \"because we can!\" 💃\n\n*May your text shine like stardust, performing particle poetry of the digital world beneath users' fingertips.* ✨\n\n*P.S. If your particles start forming sentences on their own, that's not a bug—that's the beginning of artificial intelligence. Congratulations, you've accidentally created digital life! 🤖*\n"])</script><script>self.__next_f.push([1,"22:T9497,"])</script><script>self.__next_f.push([1,"\r\n# Skills Constellation: Everyone is Their Own Universe\r\n\r\nThe universe flickers... oops, wrong place, sorry.\r\n\r\nAhem, back to the topic. This article will provide a detailed analysis of every design detail used in the skills constellation, including dynamic layout, probability algorithms, SVG connections, and complex animations. I hope it can bring you some inspiration.\r\n\r\n## Dual-Layer Structure Design\r\n\r\nThe masterpiece of a div warrior... well, it's just assigning separate containers for the title and constellation functionality.\r\n\r\n### Container Layer Design\r\n\r\nThe outermost layer of the component is a dual-container system.\r\n\r\n```typescript\r\nconst containerRef = useRef\u003cHTMLDivElement\u003e(null);\r\nconst boxRef = useRef\u003cHTMLDivElement\u003e(null);\r\nconst svgRef = useRef\u003cSVGSVGElement\u003e(null);\r\nconst [containerSize, setContainerSize] = useState\u003cPosition\u003e({x: 320, y: 320});\r\n```\r\n\r\n- **boxRef**: Responsible for the outer wrapper of the entire component, mainly used for title text effect positioning calculations\r\n- **containerRef**: Responsible for the constellation area layout container, specifically handling bubble position calculations and responsive changes\r\n\r\nThe purpose of this separation design is: when I need to calculate text effects, I only care about `boxRef`; when I need to re-layout bubbles, I only care about `containerRef`.\r\n\r\n### SVG Connection Line Layer\r\n\r\n```typescript\r\n{/* Connecting Lines */}\r\n\u003csvg ref={svgRef} className=\"absolute inset-0 w-full h-full pointer-events-none\"/\u003e\r\n```\r\n\r\n**Why do connecting lines need an independent SVG layer**?\r\n\r\n1. **Rendering Performance**: SVG is vector graphics, suitable for drawing dynamic lines, GPU-friendly\r\n2. **Layer Management**: `pointer-events-none` ensures it doesn't interfere with bubble click events\r\n3. **Coordinate System**: SVG has its own coordinate system, convenient for handling percentage positioning\r\n\r\n### Coordinate System Management\r\n\r\n```typescript\r\nconst [containerSize, setContainerSize] = useState\u003cPosition\u003e({x: 320, y: 320});\r\n```\r\n\r\n`containerSize` functions:\r\n\r\n- **Pixel coordinates → Percentage coordinates**: Used for SVG line positioning\r\n- **Responsive calculation**: When container size changes, all elements need position recalculation\r\n- **Boundary constraints**: Ensures all bubbles are within the visible range\r\n\r\n## Bubble Component Lifecycle Management\r\n\r\nEach skill bubble is an independent entity with its own lifecycle and behavior patterns.\r\n\r\n### SkillBubble Component Analysis\r\n\r\n```typescript\r\nconst SkillBubble = React.memo(({\r\n    skill,\r\n    index,\r\n    size,\r\n    colorClass,\r\n    elementRef,\r\n    initialRotation,\r\n    borderRadius\r\n}: {\r\n    skill: string;\r\n    index: number;\r\n    size: number;\r\n    colorClass: string;\r\n    elementRef: React.RefObject\u003cHTMLDivElement | null\u003e;\r\n    initialRotation: number;\r\n    borderRadius: string;\r\n}) =\u003e {\r\n```\r\n\r\n**Performance Optimization Significance of React.memo**:\r\n\r\nIn a system containing multiple bubbles, re-rendering of any bubble might trigger unnecessary updates of other bubbles. `React.memo` ensures bubbles only re-render when props actually change.\r\n\r\n**Props Parameter Explanation**:\r\n\r\n- **skill**: The skill text to display\r\n- **index**: Used for calculating animation delays and various differentiation effects\r\n- **size**: Bubble size, unified at 75px but extensible\r\n- **colorClass**: Predefined gradient color class\r\n- **elementRef**: DOM reference for position operations\r\n- **initialRotation**: Initial rotation angle for natural feel\r\n- **borderRadius**: Border radius style for shape diversity\r\n\r\n### Initialization Animation Sequence: Progressive Entry\r\n\r\n```typescript\r\ninitial={{\r\n    opacity: 0,\r\n    scale: 0,\r\n    rotate: initialRotation,\r\n}}\r\nanimate={{\r\n    opacity: 1,\r\n    scale: 1,\r\n    rotate: initialRotation,\r\n    transition: {\r\n        duration: 0.5,\r\n        delay: 1 + (index * 0.15),\r\n    },\r\n}}\r\n```\r\n\r\n**Animation Delay Calculation**:\r\n\r\n$$Delay\\ Time = 1 + (index \\times 0.15)$$\r\n\r\nAssuming 8 skills, the delay time sequence is: 1.0s, 1.15s, 1.30s, 1.45s, 1.60s, 1.75s, 1.90s, 2.05s\r\n\r\nThe total entry time is about 2.5 seconds, which neither keeps users waiting too long nor fully showcases the animation's layered feel.\r\n\r\n### Hover Interaction System\r\n\r\n```typescript\r\nwhileHover={{\r\n    scale: 1.2,\r\n    rotate: 0,\r\n    zIndex: 10,\r\n}}\r\ntransition={{\r\n    duration: 1.5,\r\n    type: \"spring\" as const,\r\n    stiffness: 120,\r\n    damping: 15,\r\n}}\r\n```\r\n\r\nSpring animation simulates real physical spring systems, more natural than traditional easing functions:\r\n\r\n$$F = -kx - bv$$\r\n\r\nWhere:\r\n- **k (stiffness)**: Spring constant, value 120, determines \"elasticity\" strength\r\n- **b (damping)**: Damping coefficient, value 15, determines \"friction\" magnitude\r\n\r\n**Parameter Settings**:\r\n\r\n- **stiffness: 120**: Moderate elasticity, neither too \"hard\" nor too \"soft\"\r\n- **damping: 15**: Light damping, avoids excessive oscillation but retains elastic feel\r\n- **duration: 1.5s**: Gives enough time to showcase the full spring effect process\r\n\r\n**State Changes**:\r\n\r\n- **scale: 1.2**: 20% enlargement\r\n- **rotate: 0**: Reset rotation, makes tilted bubbles \"stand straight\"\r\n- **zIndex: 10**: Elevate layer, ensures hovered bubble is on top\r\n\r\n## Visual Effects Design\r\n\r\n\"Why is this thing a texture?\"\r\n\r\n\"Damn!\"\r\n\r\n### Orbital Rotation System\r\n\r\n```typescript\r\n{/* Orbital Ring */}\r\n\u003cmotion.div\r\n    animate={{\r\n        rotate: 360,\r\n    }}\r\n    transition={{\r\n        duration: 20 + index * 2,\r\n        repeat: Infinity,\r\n        ease: \"linear\",\r\n    }}\r\n    className=\"absolute inset-0 border border-primary/20\"\r\n    style={{ borderRadius }}\r\n/\u003e\r\n```\r\n\r\n**Orbital Design Thinking**:\r\n\r\nI didn't use complex SVG circular paths, but simply reused the bubble's border style. The `border + borderRadius` combination both creates the orbital ring effect and maintains consistency with the bubble shape.\r\n\r\n**Rotation Cycle Differentiation Strategy**:\r\n\r\n$$Rotation\\ Cycle = 20 + (index \\times 2)$$\r\n\r\nThis means:\r\n- 1st bubble: 20 seconds per rotation\r\n- 2nd bubble: 22 seconds per rotation  \r\n- 3rd bubble: 24 seconds per rotation\r\n- ...\r\n\r\nDifferent rotation speeds simulate real planetary systems, where each planet has its own orbital period.\r\n\r\n### Breathing Effect\r\n\r\n```typescript\r\n\u003cmotion.div\r\n    animate={{\r\n        y: [0, -5, 0],\r\n    }}\r\n    transition={{\r\n        duration: 3 + index * 0.2,\r\n        repeat: Infinity,\r\n        ease: \"easeInOut\",\r\n    }}\r\n```\r\n\r\n**Mathematical Principle of Y-axis Floating**:\r\n\r\nThe keyframe sequence `[0, -5, 0]` creates a complete breathing cycle:\r\n- **Starting position (0)**: Normal position\r\n- **Peak position (-5)**: Float up 5 pixels\r\n- **Ending position (0)**: Return to normal position\r\n\r\n**Natural Feel of Cycle Differentiation**:\r\n\r\n$$Breathing\\ Cycle = 3 + (index \\times 0.2)$$\r\n\r\nThis formula ensures each bubble has a slightly different breathing rhythm, avoiding mechanical synchronized swaying. The 3-second base cycle is close to human natural breathing frequency, and the 0.2-second difference is enough to break synchronization without being too obvious.\r\n\r\n### Shimmer Gradient\r\n\r\n```typescript\r\n{/* Shimmer Effect */}\r\n\u003cmotion.div\r\n    animate={{\r\n        x: ['-100%', '100%'],\r\n    }}\r\n    transition={{\r\n        duration: 2,\r\n        repeat: Infinity,\r\n        repeatDelay: 3,\r\n        ease: \"easeInOut\",\r\n    }}\r\n    className=\"absolute -inset-4 bg-gradient-to-r from-transparent via-white/20 to-transparent transform rotate-45\"\r\n/\u003e\r\n```\r\n\r\n**How Shimmer Glow Works**:\r\n\r\n1. **Gradient Mask**: `from-transparent via-white/20 to-transparent` creates a light band that's bright in the middle and transparent at the ends\r\n2. **Rotation Transform**: `rotate-45` tilts the light band 45 degrees, simulating real light angles\r\n3. **Movement Animation**: `x: ['-100%', '100%']` makes the light band sweep from left to right across the entire bubble\r\n4. **Complete Coverage**: `-inset-4` ensures the light band can completely cover those irregular constellation shapes\r\n\r\n**Animation Timing**:\r\n\r\n- **duration: 2s**: Time for glow to sweep across\r\n- **repeatDelay: 3s**: 3-second interval\r\n- **Total cycle**: 2s animation + 3s interval = 5s\r\n\r\n## Background Star Generation\r\n\r\nAlways felt the blank background was too empty.\r\n\r\n```typescript\r\n// Memoized background stars\r\nconst backgroundStars = useMemo(() =\u003e (\r\n    Array.from({length: 20}).map((_, i) =\u003e (\r\n        \u003cmotion.div\r\n            key={`star-${i}`}\r\n            initial={{opacity: 0, scale: 0}}\r\n            animate={{\r\n                opacity: [0, 1, 0.3, 1],\r\n                scale: [0, 1, 0.8, 1],\r\n            }}\r\n            transition={{\r\n                duration: 2 + Math.random() * 3,\r\n                repeat: Infinity,\r\n                delay: Math.random() * 2,\r\n            }}\r\n            className=\"absolute w-1 h-1 bg-primary/40 rounded-full\"\r\n            style={{\r\n                left: `${Math.random() * 100}%`,\r\n                top: `${Math.random() * 100}%`,\r\n            }}\r\n        /\u003e\r\n    ))\r\n), []);\r\n```\r\n\r\n### Random Distribution Algorithm\r\n\r\n**Position Randomization**:\r\n```typescript\r\nleft: `${Math.random() * 100}%`,\r\ntop: `${Math.random() * 100}%`,\r\n```\r\n\r\n`Math.random()` produces uniformly distributed random numbers in the [0, 1) interval, multiplied by 100 to convert to percentage coordinates. This ensures each star has an equal probability of appearing anywhere in the container.\r\n\r\n**Layered Design of Animation Randomization**:\r\n\r\n- **Duration**: `2 + Math.random() * 3` → Random cycles of [2, 5) seconds\r\n- **Delay Start**: `Math.random() * 2` → Random delays of [0, 2) seconds\r\n- **Twinkling Sequence**: `[0, 1, 0.3, 1]` → Natural twinkling of fade-in, full-bright, half-dim, full-bright\r\n\r\n### useMemo Optimization\r\n\r\n```typescript\r\nconst backgroundStars = useMemo(() =\u003e (\r\n```\r\n\r\n**Why does the starfield need useMemo**?\r\n\r\nStar generation involves 20 random calculations and DOM element creation. If regenerated on every component render, it would cause:\r\n1. **Performance issues**: Repeated random calculations and element creation\r\n2. **Visual issues**: Constantly changing star positions, breaking the static background effect\r\n3. **Animation issues**: Recreated stars would restart animations, causing flickering\r\n\r\nThrough `useMemo`, we ensure the starfield is only generated once during the component's first render, then remains stable.\r\n\r\n## Layout Algorithm: Balance Between Randomness and Order\r\n\r\n~~(Gacha games always have pity systems, right?)~~\r\n\r\nActually, it's because when there are more skills, they become harder to read, so I added a hidden trigger for neat arrangement.\r\n\r\n### Random Distribution Mode\r\n\r\n```typescript\r\n// Generate random positions and update DOM directly\r\nconst updatePositions = useCallback(() =\u003e {\r\n    if (!containerRef.current) return;\r\n\r\n    const containerWidth = containerRef.current.offsetWidth;\r\n    const containerHeight = containerRef.current.offsetHeight;\r\n    const padding = 80;\r\n    // Reduce the width and height of bubble\r\n    const minX = padding - 75;\r\n    const minY = padding - 75;\r\n    const maxX = containerWidth - padding;\r\n    const maxY = containerHeight - padding;\r\n\r\n    setContainerSize({x: containerWidth, y: containerHeight});\r\n\r\n    // Update positions using direct DOM manipulation\r\n    skillRefs.forEach((skillRef) =\u003e {\r\n        if (skillRef.elementRef.current) {\r\n\r\n            const newX = Math.random() * (maxX - minX) + minX;\r\n            const newY = Math.random() * (maxY - minY) + minY;\r\n\r\n            // Update position in ref\r\n            skillRef.position = {x: newX, y: newY};\r\n\r\n            // Animate position using Framer Motion's animate function\r\n            const element = skillRef.elementRef.current;\r\n            if (element.animate) {\r\n                element.animate(\r\n                    {\r\n                        left: `${newX}px`,\r\n                        top: `${newY}px`\r\n                    },\r\n                    {\r\n                        duration: 1500,\r\n                        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n                        fill: 'forwards'\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    // Update connecting lines\r\n    updateConnectingLines();\r\n}, [skillRefs]);\r\n```\r\n\r\n### Boundary Constraint Calculation\r\n\r\n```typescript\r\nconst padding = 80;\r\nconst minX = padding - 75;  // -75 is half the bubble size + margin\r\nconst minY = padding - 75;\r\nconst maxX = containerWidth - padding;\r\nconst maxY = containerHeight - padding;\r\n```\r\n\r\nThis seemingly simple calculation actually solves a complex geometric problem:\r\n\r\n$$Effective\\ Area = Container\\ Size - 2 \\times padding - Bubble\\ Size$$\r\n\r\n**Why does minX subtract 75?**\r\n\r\nBecause CSS's `left` property positions the element's top-left corner, but we want the entire bubble (including center and edges) to be within the visible range. 75px includes:\r\n- Bubble radius: 37.5px\r\n- Safety margin: 37.5px (ensures hover effects don't exceed boundaries)\r\n\r\n### Direct DOM Manipulation\r\n\r\n```typescript\r\n// Animate position using Framer Motion's animate function\r\nconst element = skillRef.elementRef.current;\r\nif (element.animate) {\r\n    element.animate(\r\n        {\r\n            left: `${newX}px`,\r\n            top: `${newY}px`\r\n        },\r\n        {\r\n            duration: 1500,\r\n            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n            fill: 'forwards'\r\n        }\r\n    );\r\n} else {\r\n    // Fallback for browsers without Web Animations API\r\n    element.style.transition = 'left 1.5s ease, top 1.5s ease';\r\n    element.style.left = `${newX}px`;\r\n    element.style.top = `${newY}px`;\r\n}\r\n```\r\n\r\n**Why choose direct DOM manipulation over state updates?**\r\n\r\n8 bubbles updating positions simultaneously would trigger 8 component re-renders if done through state, so I simply chose the Web Animations API to run directly on the compositor thread.\r\n\r\n**Fallback Strategy**:\r\n\r\nFor browsers that don't support the Web Animations API, the program provides an additional CSS transition fallback solution, ensuring smooth animation effects in all environments.\r\n\r\n### Grid Layout Mode\r\n\r\n```typescript\r\n// Generate neat grid arrangement\r\nconst updatePositionsNeat = useCallback(() =\u003e {\r\n    if (!containerRef.current) return;\r\n\r\n    const containerWidth = containerRef.current.offsetWidth;\r\n    const containerHeight = containerRef.current.offsetHeight;\r\n\r\n    setContainerSize({x: containerWidth, y: containerHeight});\r\n\r\n    // Calculate grid layout\r\n    const skillCount = skillRefs.length;\r\n    const cols = Math.ceil(Math.sqrt(skillCount));\r\n    const rows = Math.ceil(skillCount / cols);\r\n\r\n    // Calculate spacing to center the grid\r\n    const padding = 5;\r\n    const availableWidth = containerWidth - (2 * padding);\r\n    const availableHeight = containerHeight - (2 * padding);\r\n    const cellWidth = availableWidth / cols;\r\n    const cellHeight = availableHeight / rows;\r\n\r\n    skillRefs.forEach((skillRef, index) =\u003e {\r\n        if (skillRef.elementRef.current) {\r\n            const col = index % cols;\r\n            const row = Math.floor(index / cols);\r\n\r\n            // Center the grid both horizontally and vertically\r\n            const startX = padding + (cellWidth / 2) - 38;\r\n            const startY = padding + (cellHeight / 2) - 38;\r\n\r\n            const newX = startX + (col * cellWidth);\r\n            const newY = startY + (row * cellHeight);\r\n\r\n            // Update position in ref\r\n            skillRef.position = {x: newX, y: newY};\r\n\r\n            // Animate position using Web Animations API\r\n            const element = skillRef.elementRef.current;\r\n            if (element.animate) {\r\n                element.animate(\r\n                    {\r\n                        left: `${newX}px`,\r\n                        top: `${newY}px`\r\n                    },\r\n                    {\r\n                        duration: 1500,\r\n                        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n                        fill: 'forwards'\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    // Update connecting lines\r\n    updateConnectingLines();\r\n}, [skillRefs]);\r\n```\r\n\r\n**Grid Calculation Analysis**:\r\n\r\nThe core idea is to create a nearly square grid layout:\r\n\r\n$$Columns = \\sqrt{Skill\\ Count}$$\r\n$$Rows = \\frac{Skill\\ Count}{Columns}$$\r\n\r\nFor example, with 8 skills:\r\n- $\\sqrt{8} = 2.83$\r\n- $Columns = \\lceil 2.83 \\rceil = 3$\r\n- $Rows = \\lceil \\frac{8}{3} \\rceil = \\lceil 2.67 \\rceil = 3$\r\n\r\nThis results in a 3×3 grid with the last position empty.\r\n\r\n**Geometric Calculation for Center Alignment**:\r\n\r\n```typescript\r\nconst startX = padding + (cellWidth / 2) - 38;\r\nconst startY = padding + (cellHeight / 2) - 38;\r\n```\r\n\r\nEnsures each bubble's center point aligns to the grid's center point:\r\n- `cellWidth / 2`: Center of the grid cell\r\n- `- 38`: Bubble radius offset (75px / 2 ≈ 38px)\r\n\r\n**Dynamic Calculation of Responsive Spacing**:\r\n\r\n```typescript\r\nconst cellWidth = availableWidth / cols;\r\nconst cellHeight = availableHeight / rows;\r\n```\r\n\r\nNo matter how the container size changes, the grid automatically adjusts spacing to maintain perfect proportions and alignment.\r\n\r\n## Pity System\r\n\r\n### Click Probability Mechanism\r\n\r\n```typescript\r\n// Probability system for neat arrangement\r\nconst [clickCount, setClickCount] = useState(0);\r\nconst baseProbability = 0.1; // 10% base probability\r\n```\r\n\r\n```typescript\r\n// Throttled click handler with probability system\r\nconst handleContainerClick = useCallback(() =\u003e {\r\n    const currentTime = Date.now();\r\n    if (currentTime - lastClickTime.current \u003e= throttleDelay) {\r\n        lastClickTime.current = currentTime;\r\n\r\n        // Calculate current probability (increases with each click)\r\n        const currentProbability = Math.min(baseProbability + (clickCount * 0.15), 0.9); // Max 90%\r\n        const shouldUseNeatArrangement = Math.random() \u003c currentProbability;\r\n\r\n        if (shouldUseNeatArrangement) {\r\n            updatePositionsNeat();\r\n            setClickCount(0); // Reset probability after successful neat arrangement\r\n        } else {\r\n            updatePositions();\r\n            setClickCount(prev =\u003e prev + 1); // Increase click count to raise probability\r\n        }\r\n    }\r\n}, [updatePositions, updatePositionsNeat, clickCount, baseProbability, throttleDelay]);\r\n```\r\n\r\n**Probability Increment Algorithm**:\r\n\r\n$$P(Neat\\ Layout) = \\min(0.1 + Click\\ Count \\times 0.15, 0.9)$$\r\n\r\n| Click Count | Probability |\r\n|------------|-------------|\r\n| 1 | 10% |\r\n| 3 | 55% |\r\n| 5 | 85% |\r\n| 6+ | 90% |\r\n\r\nThis ensures users can clearly read all skills in one go after several clicks.\r\n\r\n### Throttling and Debouncing\r\n\r\n```typescript\r\nconst lastClickTime = useRef\u003cnumber\u003e(0);\r\nconst throttleDelay = 500;\r\n```\r\n\r\n**500ms Interval**\r\n\r\n```typescript\r\nif (currentTime - lastClickTime.current \u003e= throttleDelay) {\r\n    lastClickTime.current = currentTime;\r\n    // Execute layout switching logic\r\n}\r\n```\r\n\r\n## SVG Connection Lines\r\n\r\n### Dynamic Line Generation\r\n\r\n```typescript\r\n// Update SVG connecting lines\r\nconst updateConnectingLines = useCallback(() =\u003e {\r\n    if (!svgRef.current || !containerSize.x || !containerSize.y) return;\r\n\r\n    const svg = svgRef.current;\r\n    // Clear existing lines\r\n    svg.innerHTML = '';\r\n\r\n    skillRefs.forEach((skillRef, index) =\u003e {\r\n        if (index === skillRefs.length - 1) return;\r\n\r\n        const currentPos = skillRef.position;\r\n        const nextPos = skillRefs[index + 1].position;\r\n\r\n        const x1 = (currentPos.x / containerSize.x) * 100 - 80;\r\n        const y1 = (currentPos.y / containerSize.y) * 100;\r\n        const x2 = (nextPos.x / containerSize.x) * 100 - 80;\r\n        const y2 = (nextPos.y / containerSize.y) * 100 + 75;\r\n\r\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n        line.setAttribute(\"x1\", `${x1}%`);\r\n        line.setAttribute(\"y1\", `${y1}%`);\r\n        line.setAttribute(\"x2\", `${x2}%`);\r\n        line.setAttribute(\"y2\", `${y2}%`);\r\n        line.setAttribute(\"stroke\", \"currentColor\");\r\n        line.setAttribute(\"stroke-width\", \"1\");\r\n        line.setAttribute(\"stroke-dasharray\", \"5,5\");\r\n        line.setAttribute(\"class\", \"text-primary/30\");\r\n        line.style.opacity = '0';\r\n\r\n        svg.appendChild(line);\r\n\r\n        // Animate line appearance\r\n        setTimeout(() =\u003e {\r\n            line.style.transition = 'opacity 2s ease-in-out';\r\n            line.style.opacity = '0.3';\r\n        }, 2000 + index * 100);\r\n    });\r\n}, [skillRefs, containerSize]);\r\n```\r\n\r\n**Mathematical Principle of Coordinate Transformation**:\r\n\r\nConversion from pixel coordinates to SVG percentage coordinates:\r\n\r\n$$SVG_x = \\frac{Pixel_x}{Container_{width}} \\times 100\\%$$\r\n$$SVG_y = \\frac{Pixel_y}{Container_{height}} \\times 100\\%$$\r\n\r\n### Line Animation Choreography\r\n\r\n```typescript\r\n// Animate line appearance\r\nsetTimeout(() =\u003e {\r\n    line.style.transition = 'opacity 2s ease-in-out';\r\n    line.style.opacity = '0.3';\r\n}, 2000 + index * 100);\r\n```\r\n\r\n**Timing Design for Progressive Display**:\r\n\r\n$$Delay\\ Time = 2000 + index \\times 100$$\r\n\r\nFormula breakdown:\r\n- **Base delay 2 seconds**: Gives bubbles enough entry time\r\n- **Incremental interval 100ms**: Lines appear in sequence\r\n- **Total time control**: For 8 bubbles, the last line appears at 2.7 seconds\r\n\r\n**Line Connection Logic**:\r\n\r\n```typescript\r\n// Connect last to first\r\nif (skillRefs.length \u003e 2) {\r\n    const lastPos = skillRefs[skillRefs.length - 1].position;\r\n    const firstPos = skillRefs[0].position;\r\n\r\n    const x1 = (lastPos.x / containerSize.x) * 100;\r\n    const y1 = (lastPos.y / containerSize.y) * 100;\r\n    const x2 = (firstPos.x / containerSize.x) * 100;\r\n    const y2 = (firstPos.y / containerSize.y) * 100;\r\n\r\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n    line.setAttribute(\"x1\", `${x1}%`);\r\n    line.setAttribute(\"y1\", `${y1}%`);\r\n    line.setAttribute(\"x2\", `${x2}%`);\r\n    line.setAttribute(\"y2\", `${y2}%`);\r\n    line.setAttribute(\"stroke\", \"currentColor\");\r\n    line.setAttribute(\"stroke-width\", \"1\");\r\n    line.setAttribute(\"stroke-dasharray\", \"5,5\");\r\n    line.setAttribute(\"class\", \"text-primary/30\");\r\n    line.style.opacity = '0';\r\n\r\n    svg.appendChild(line);\r\n\r\n    setTimeout(() =\u003e {\r\n        line.style.transition = 'opacity 2s ease-in-out';\r\n        line.style.opacity = '0.3';\r\n    }, 2000 + skillRefs.length * 100);\r\n}\r\n```\r\n\r\nThis closed-loop design creates a true \"constellation\" effect—all skill bubbles are connected in a complete figure, symbolizing the interconnection between skills.\r\n\r\n## Performance Optimization and Memory Management\r\n\r\n```typescript\r\n// Create stable refs for skill elements\r\nconst skillRefs = useMemo(() =\u003e {\r\n    return skills.map((skill) =\u003e ({\r\n        id: skill,\r\n        elementRef: React.createRef\u003cHTMLDivElement\u003e(),\r\n        position: {x: 0, y: 0}\r\n    }));\r\n}, [skills]);\r\n```\r\n\r\n**Why use useMemo to cache the reference array?**\r\n\r\nEach `skillRef` object contains:\r\n- **id**: Skill name identifier\r\n- **elementRef**: DOM element reference\r\n- **position**: Position state cache\r\n\r\nWithout `useMemo`, every component re-render would create new reference objects, causing:\r\n1. **Unnecessary child component re-renders**\r\n2. **Loss of DOM references**\r\n3. **Position state reset**\r\n\r\n**Position State Cache Design**:\r\n\r\n```typescript\r\nskillRef.position = {x: newX, y: newY};\r\n```\r\n\r\nAvoids frequent getBoundingClientRect calls.\r\n\r\n## Responsive Design\r\n\r\n### Container Size Monitoring: Intelligent Re-layout\r\n\r\n```typescript\r\n// Handle container resize\r\nuseEffect(() =\u003e {\r\n    const handleResize = () =\u003e {\r\n        if (containerRef.current) {\r\n            updatePositions();\r\n        }\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    return () =\u003e window.removeEventListener('resize', handleResize);\r\n}, [updatePositions]);\r\n```\r\n\r\nWhen window size changes, all skills are randomly redistributed.\r\n\r\n### Boundary Protection Algorithm\r\n\r\nNo matter what device size, all bubbles must be completely visible:\r\n\r\n```typescript\r\nconst padding = 80;\r\nconst minX = padding - 75;\r\nconst minY = padding - 75;\r\nconst maxX = containerWidth - padding;\r\nconst maxY = containerHeight - padding;\r\n\r\n// Boundary constraints\r\nnewPos.x = Math.max(minX, Math.min(maxX, newX));\r\nnewPos.y = Math.max(minY, Math.min(maxY, newY));\r\n```\r\n\r\n## Complete Source Code Full Analysis\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';\r\nimport {motion} from 'framer-motion';\r\nimport VariableProximity from \"@/components/ui/text/VariableProximity\";\r\n\r\n// ==================== Type Definitions ====================\r\ninterface SkillsConstellationProps {\r\n    skills: string[];      // Skills list\r\n    title: string;         // Title text\r\n}\r\n\r\ninterface Position {\r\n    x: number;            // X coordinate\r\n    y: number;            // Y coordinate\r\n}\r\n\r\n// ==================== Skill Bubble Component ====================\r\n/**\r\n * Individual skill bubble component, optimized with React.memo for rendering performance\r\n * Contains complete animation lifecycle: entry → hover → interaction\r\n */\r\nconst SkillBubble = React.memo(({\r\n    skill,              // Skill name\r\n    index,              // Index (for calculating animation delays)\r\n    size,               // Bubble size\r\n    colorClass,         // Color style class\r\n    elementRef,         // DOM reference\r\n    initialRotation,    // Initial rotation angle\r\n    borderRadius       // Border radius style\r\n}: {\r\n    skill: string;\r\n    index: number;\r\n    size: number;\r\n    colorClass: string;\r\n    elementRef: React.RefObject\u003cHTMLDivElement | null\u003e;\r\n    initialRotation: number;\r\n    borderRadius: string;\r\n}) =\u003e {\r\n    return (\r\n        \u003cmotion.div\r\n            ref={elementRef}\r\n            key={skill}\r\n            // Entry animation: from transparent scale to normal state\r\n            initial={{\r\n                opacity: 0,\r\n                scale: 0,\r\n                rotate: initialRotation,\r\n            }}\r\n            animate={{\r\n                opacity: 1,\r\n                scale: 1,\r\n                rotate: initialRotation,\r\n                transition: {\r\n                    duration: 0.5,\r\n                    delay: 1 + (index * 0.15),  // Progressive entry\r\n                },\r\n            }}\r\n            // Hover interaction: scale + reset rotation + elevate layer\r\n            whileHover={{\r\n                scale: 1.2,\r\n                rotate: 0,\r\n                zIndex: 10,\r\n            }}\r\n            transition={{\r\n                duration: 1.5,\r\n                type: \"spring\",\r\n                stiffness: 120,    // Spring stiffness\r\n                damping: 15,       // Damping coefficient\r\n            }}\r\n            className=\"absolute group select-none\"\r\n            style={{\r\n                width: `${size}px`,\r\n                height: `${size}px`,\r\n                transform: `translate(-50%, -50%)`,\r\n                left: '50%',\r\n                top: '50%',\r\n            }}\r\n        \u003e\r\n            {/* Orbital ring: creates celestial motion visual effect */}\r\n            \u003cmotion.div\r\n                animate={{\r\n                    rotate: 360,\r\n                }}\r\n                transition={{\r\n                    duration: 20 + index * 2,  // Differentiated rotation cycles\r\n                    repeat: Infinity,\r\n                    ease: \"linear\",\r\n                }}\r\n                className=\"absolute inset-0 border border-primary/20\"\r\n                style={{ borderRadius }}\r\n            /\u003e\r\n\r\n            {/* Main bubble: contains breathing effect and multi-layer effects */}\r\n            \u003cmotion.div\r\n                animate={{\r\n                    y: [0, -5, 0],  // Breathing-style floating\r\n                }}\r\n                transition={{\r\n                    duration: 3 + index * 0.2,  // Differentiated breathing cycles\r\n                    repeat: Infinity,\r\n                    ease: \"easeInOut\",\r\n                }}\r\n                className={`w-full h-full bg-gradient-to-br ${colorClass} backdrop-blur-sm flex items-center justify-center border-2 transition-all duration-300 relative overflow-hidden`}\r\n                style={{ borderRadius }}\r\n            \u003e\r\n                {/* Shimmer glow effect: periodic light sweeps */}\r\n                \u003cmotion.div\r\n                    animate={{\r\n                        x: ['-100%', '100%'],\r\n                    }}\r\n                    transition={{\r\n                        duration: 2,\r\n                        repeat: Infinity,\r\n                        repeatDelay: 3,\r\n                        ease: \"easeInOut\",\r\n                    }}\r\n                    className=\"absolute -inset-4 bg-gradient-to-r from-transparent via-white/20 to-transparent transform rotate-45\"\r\n                /\u003e\r\n\r\n                {/* Skill text: main content display */}\r\n                \u003cspan className=\"text-xs font-semibold text-center px-2 leading-tight z-10 text-foreground\"\u003e\r\n                    {skill}\r\n                \u003c/span\u003e\r\n\r\n                {/* Hover particle effect: 8 particles in circular burst */}\r\n                \u003cmotion.div\r\n                    initial={{opacity: 0, scale: 0}}\r\n                    whileHover={{opacity: 1, scale: 1}}\r\n                    className=\"absolute -inset-2\"\r\n                \u003e\r\n                    {Array.from({length: 8}).map((_, i) =\u003e (\r\n                        \u003cmotion.div\r\n                            key={i}\r\n                            initial={{opacity: 0, scale: 0}}\r\n                            whileHover={{\r\n                                opacity: [0, 1, 0],\r\n                                scale: [0, 1, 0],\r\n                                x: Math.cos(i * 0.785) * 30,  // Circular distribution\r\n                                y: Math.sin(i * 0.785) * 30,\r\n                            }}\r\n                            transition={{\r\n                                duration: 0.6,\r\n                                delay: i * 0.05,\r\n                            }}\r\n                            className=\"absolute top-1/2 left-1/2 w-1 h-1 bg-primary rounded-full\"\r\n                        /\u003e\r\n                    ))}\r\n                \u003c/motion.div\u003e\r\n            \u003c/motion.div\u003e\r\n        \u003c/motion.div\u003e\r\n    );\r\n});\r\n\r\nSkillBubble.displayName = 'SkillBubble';\r\n\r\n// ==================== Main Component: Skills Constellation ====================\r\nexport function SkillsConstellation({skills, title}: SkillsConstellationProps) {\r\n    // ==================== State Management ====================\r\n    const containerRef = useRef\u003cHTMLDivElement\u003e(null);\r\n    const boxRef = useRef\u003cHTMLDivElement\u003e(null);\r\n    const svgRef = useRef\u003cSVGSVGElement\u003e(null);\r\n    const [containerSize, setContainerSize] = useState\u003cPosition\u003e({x: 320, y: 320});\r\n    const lastClickTime = useRef\u003cnumber\u003e(0);\r\n    const throttleDelay = 500;\r\n\r\n    // Probability system: core of intelligent interaction\r\n    const [clickCount, setClickCount] = useState(0);\r\n    const baseProbability = 0.1; // 10% base probability\r\n\r\n    // Stable skill reference array\r\n    const skillRefs = useMemo(() =\u003e {\r\n        return skills.map((skill) =\u003e ({\r\n            id: skill,\r\n            elementRef: React.createRef\u003cHTMLDivElement\u003e(),\r\n            position: {x: 0, y: 0}  // Position state cache\r\n        }));\r\n    }, [skills]);\r\n\r\n    // Pre-computed colors and properties\r\n    const skillColors = useMemo(() =\u003e [\r\n        'from-blue-500/20 to-purple-500/20 border-blue-400/50',\r\n        'from-green-500/20 to-teal-500/20 border-green-400/50',\r\n        'from-orange-500/20 to-red-500/20 border-orange-400/50',\r\n        // ... more color configurations\r\n    ], []);\r\n\r\n    const skillProperties = useMemo(() =\u003e {\r\n        return skills.map((_, index) =\u003e {\r\n            const initialRotation = (Math.random() - 0.5) * 30;\r\n            const borderRadiusVariations = [\r\n                '50%', '40% 60% 60% 40%', '30% 70% 70% 30%',\r\n                // ... more shape variations\r\n            ];\r\n            \r\n            return {\r\n                initialRotation,\r\n                borderRadius: borderRadiusVariations[index % borderRadiusVariations.length],\r\n                colorClass: skillColors[index % skillColors.length]\r\n            };\r\n        });\r\n    }, [skills, skillColors]);\r\n\r\n    // ==================== Core Algorithm: Layout Updates ====================\r\n    \r\n    /**\r\n     * Random distribution mode: simulates real universe randomness\r\n     */\r\n    const updatePositions = useCallback(() =\u003e {\r\n        // Implementation details as shown in previous sections...\r\n    }, [skillRefs]);\r\n\r\n    /**\r\n     * Grid layout mode\r\n     */\r\n    const updatePositionsNeat = useCallback(() =\u003e {\r\n        // Implementation details as shown in previous sections...\r\n    }, [skillRefs]);\r\n\r\n    /**\r\n     * SVG connection system\r\n     */\r\n    const updateConnectingLines = useCallback(() =\u003e {\r\n        // Implementation details as shown in previous sections...\r\n    }, [skillRefs, containerSize]);\r\n\r\n    // ==================== Interaction System ====================\r\n    \r\n    /**\r\n     * Probability-driven click handling\r\n     */\r\n    const handleContainerClick = useCallback(() =\u003e {\r\n        const currentTime = Date.now();\r\n        if (currentTime - lastClickTime.current \u003e= throttleDelay) {\r\n            lastClickTime.current = currentTime;\r\n\r\n            // Probability calculation: base probability + cumulative growth\r\n            const currentProbability = Math.min(baseProbability + (clickCount * 0.15), 0.9);\r\n            const shouldUseNeatArrangement = Math.random() \u003c currentProbability;\r\n\r\n            if (shouldUseNeatArrangement) {\r\n                updatePositionsNeat();\r\n                setClickCount(0); // Reset after success\r\n            } else {\r\n                updatePositions();\r\n                setClickCount(prev =\u003e prev + 1); // Increment after failure\r\n            }\r\n        }\r\n    }, [updatePositions, updatePositionsNeat, clickCount, baseProbability, throttleDelay]);\r\n\r\n    // ==================== Lifecycle Management ====================\r\n    \r\n    // Initialization setup\r\n    useEffect(() =\u003e {\r\n        if (containerRef.current \u0026\u0026 skills.length \u003e 0) {\r\n            setTimeout(() =\u003e {\r\n                updatePositions();\r\n            }, 1500);\r\n        }\r\n    }, [updatePositions, skills]);\r\n\r\n    // Responsive re-layout\r\n    useEffect(() =\u003e {\r\n        const handleResize = () =\u003e {\r\n            if (containerRef.current) {\r\n                updatePositions();\r\n            }\r\n        };\r\n\r\n        window.addEventListener('resize', handleResize);\r\n        return () =\u003e window.removeEventListener('resize', handleResize);\r\n    }, [updatePositions]);\r\n\r\n    // Memoized background starfield generation\r\n    const backgroundStars = useMemo(() =\u003e (\r\n        Array.from({length: 20}).map((_, i) =\u003e (\r\n            \u003cmotion.div\r\n                key={`star-${i}`}\r\n                initial={{opacity: 0, scale: 0}}\r\n                animate={{\r\n                    opacity: [0, 1, 0.3, 1],\r\n                    scale: [0, 1, 0.8, 1],\r\n                }}\r\n                transition={{\r\n                    duration: 2 + Math.random() * 3,\r\n                    repeat: Infinity,\r\n                    delay: Math.random() * 2,\r\n                }}\r\n                className=\"absolute w-1 h-1 bg-primary/40 rounded-full\"\r\n                style={{\r\n                    left: `${Math.random() * 100}%`,\r\n                    top: `${Math.random() * 100}%`,\r\n                }}\r\n            /\u003e\r\n        ))\r\n    ), []);\r\n\r\n    // ==================== Render Structure ====================\r\n    return (\r\n        \u003cmotion.div\r\n            ref={boxRef}\r\n            initial={{opacity: 0, y: 20}}\r\n            animate={{opacity: 1, y: 0}}\r\n            transition={{delay: 1.1, duration: 0.8}}\r\n            className=\"mb-8 relative text-center\"\r\n        \u003e\r\n            {/* Title: responsive text effect */}\r\n            \u003cVariableProximity\r\n                label={title}\r\n                className={'text-2xl text-foreground/90 mb-8 variable-proximity'}\r\n                containerRef={boxRef}\r\n                radius={100}\r\n                falloff='linear'\r\n            /\u003e\r\n\r\n            {/* Constellation container: core of dual-layer structure */}\r\n            \u003cdiv\r\n                className=\"relative w-full h-80 mx-auto overflow-hidden\"\r\n                onClick={handleContainerClick}\r\n            \u003e\r\n                {/* Background starfield layer */}\r\n                \u003cdiv className=\"absolute inset-0\"\u003e\r\n                    {backgroundStars}\r\n                \u003c/div\u003e\r\n\r\n                {/* Skills constellation layer */}\r\n                \u003cdiv ref={containerRef} className=\"relative w-full h-full\"\u003e\r\n                    {skillRefs.map((skillRef, index) =\u003e (\r\n                        \u003cSkillBubble\r\n                            key={skillRef.id}\r\n                            skill={skillRef.id}\r\n                            index={index}\r\n                            size={75}\r\n                            colorClass={skillProperties[index].colorClass}\r\n                            elementRef={skillRef.elementRef}\r\n                            initialRotation={skillProperties[index].initialRotation}\r\n                            borderRadius={skillProperties[index].borderRadius}\r\n                        /\u003e\r\n                    ))}\r\n\r\n                    {/* SVG connection layer */}\r\n                    \u003csvg ref={svgRef} className=\"absolute inset-0 w-full h-full pointer-events-none\"/\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n        \u003c/motion.div\u003e\r\n    );\r\n}\r\n```\r\n\r\n## Final Thoughts\r\n\r\nI always feel that people should create something different to make their work less monotonous. Even a very simple feature can be played out in creative ways. From this perspective, the potential of frontend design is limitless.\r\n\r\n*May your skills shine like constellations, weaving the most beautiful patterns in the universe of code.* ✨\r\n"])</script><script>self.__next_f.push([1,"23:Tad85,"])</script><script>self.__next_f.push([1,"\r\n# Skills Galaxy: From Concept to Implementation\r\n\r\nImagine if your skills could orbit around you like planets in a solar system, rotating in an orderly and beautiful manner around you as the \"sun\" - what kind of visual experience would that be? ...Well, I won't force the metaphor anymore. In summary, I wanted to showcase key but ordinary information through a creative form, breaking away from the so-called \"boring list layout\" to give people a sense of \"Wow! That's interesting!\"\r\n\r\nThrough the tech stack of React, TypeScript, Framer Motion, and native requestAnimationFrame, we can create such high-performance animation effects.\r\n\r\nNext, I will start from the most fundamental mathematical principles and gradually dive deep into every implementation detail, comprehensively analyzing the implementation principles of the Skills Galaxy.\r\n\r\n## Mathematical Foundation of Circular Motion\r\n\r\nEverything begins with mathematics. To make planets rotate around a center, we first need to understand how to convert rotation angles into specific coordinate positions on the screen.\r\n\r\n### Polar Coordinate System Conversion\r\n\r\nIn our galaxy, each planet follows the rules of a polar coordinate system. Polar coordinates use `(r, θ)` to describe a point's position - `r` is the distance to the center (orbital radius), and `θ` is the angle. This description method is perfect for circular motion because we only need to change the angle to make planets move along circular orbits.\r\n\r\nBut the browser world uses a Cartesian coordinate system, using `(x, y)` to position elements. So we need coordinate conversion:\r\n\r\n```typescript\r\n// This is the core formula that makes planets \"spin\"\r\nconst planetX = galaxyCenter.x + Math.cos(angle * Math.PI / 180) * orbitRadius;\r\nconst planetY = galaxyCenter.y + Math.sin(angle * Math.PI / 180) * orbitRadius;\r\n```\r\n\r\nThere are several key points worth noting:\r\n- `galaxyCenter.x` and `galaxyCenter.y` are the center coordinates of the galaxy\r\n- `Math.cos()` and `Math.sin()` are trigonometric functions responsible for converting angles to coordinates\r\n- `angle * Math.PI / 180` converts the angle from degrees to radians (JavaScript's trigonometric functions require radians)\r\n- `orbitRadius` is the orbital radius, determining how far the planet is from the center\r\n\r\n### Simple Example: Making a Point Rotate\r\n\r\nLet me use the simplest example to demonstrate this principle:\r\n\r\n```typescript\r\n// Assume we have a center point (400, 300) and a circle with radius 100px\r\nconst centerX = 400;\r\nconst centerY = 300;\r\nconst radius = 100;\r\nlet angle = 0;\r\n\r\n// Update position every frame\r\nfunction updatePosition() {\r\n    const x = centerX + Math.cos(angle * Math.PI / 180) * radius;\r\n    const y = centerY + Math.sin(angle * Math.PI / 180) * radius;\r\n    \r\n    // Update element position\r\n    element.style.left = x + 'px';\r\n    element.style.top = y + 'px';\r\n    \r\n    // Increment angle to make it rotate\r\n    angle += 1;\r\n    \r\n    requestAnimationFrame(updatePosition);\r\n}\r\n```\r\n\r\nThis is the foundation of circular motion - the Skills Galaxy's rotation effect is built upon this basic principle.\r\n\r\n## Multi-Orbit System Implementation Strategy\r\n\r\nNow we know how to make one planet rotate, but a real galaxy needs multiple orbits, needs to reasonably distribute planets, and needs to make them look natural without being crowded.\r\n\r\n### How is the number of orbits specified? And how are planets evenly distributed among these orbits?\r\n\r\nWe actually specify an upper limit for the number of orbits, which is determined by the number of skills:\r\n\r\n```typescript\r\nconst orbitIndex = index % 7;\r\n```\r\n\r\nHere, this upper limit is 7, meaning there are at most 7 orbits.\r\n\r\nFor example, if we have 15 skills:\r\n\r\n```\r\nSkill 0: index=0, orbitIndex=0%7=0 → 1st orbit\r\nSkill 1: index=1, orbitIndex=1%7=1 → 2nd orbit\r\nSkill 2: index=2, orbitIndex=2%7=2 → 3rd orbit\r\n...\r\nSkill 7: index=7, orbitIndex=7%7=0 → Back to 1st orbit\r\nSkill 8: index=8, orbitIndex=8%7=1 → 2nd orbit\r\n```\r\n\r\n### Orbital Radius Calculation\r\n\r\n```typescript\r\nconst orbitRadius = 100 + orbitIndex * 50; // 100px, 150px, 200px, 250px, 300px, 350px, 400px orbits\r\n```\r\n\r\nThe radius of each orbit increases according to the pattern `100 + orbitIndex * 50`:\r\n- 1st orbit: 100px\r\n- 2nd orbit: 150px \r\n- 3rd orbit: 200px\r\n- ...and so on up to 400px\r\n\r\n### Preventing planets from clustering together at the start\r\n\r\nTo prevent planets from overlapping on the same orbit initially, I assigned different initial angles to each planet:\r\n\r\n```typescript\r\nconst [angle, setAngle] = useState(index * 60); // Initial angle increases by index\r\n```\r\n\r\n### Visual Implementation of Orbits\r\n\r\nThe orbits themselves are created through CSS as transparent circular rings:\r\n\r\n```html\r\n\u003cdiv\r\n    className=\"absolute border border-white/10 rounded-full pointer-events-none\"\r\n    style={{\r\n        width: orbitRadius * 2,\r\n        height: orbitRadius * 2,\r\n        left: galaxyCenter.x - orbitRadius,\r\n        top: galaxyCenter.y - orbitRadius,\r\n    }}\r\n/\u003e\r\n```\r\n\r\nThere's an important detail here: `left: galaxyCenter.x - orbitRadius`. Because CSS positioning is based on the element's top-left corner, we need to offset left and up by one orbital radius distance to align the circle's center with the galaxy center.\r\n\r\n## Z-index and Rendering Layer Control\r\n\r\nIn a 3D effect that requires hierarchical relationships, managing the layering between elements is crucial. Here's how it works:\r\n\r\n```typescript\r\n// Sun center - highest layer\r\n\u003cmotion.div className=\"absolute z-20 w-24 h-24 ...\"\u003e\r\n\r\n// Orbits - no mouse event response\r\n\u003cdiv className=\"... pointer-events-none\"\u003e\r\n\r\n// Planets - interactive layer\r\n\u003cmotion.div className=\"... pointer-events-auto\"\u003e\r\n```\r\n\r\nThis design has several key points:\r\n1. **Sun always in front**: `z-20` ensures the central sun won't be obscured by planets\r\n2. **Orbits don't interfere with interaction**: `pointer-events-none` allows users to click planets on the orbit, not the orbit itself\r\n3. **Planets can interact**: `pointer-events-auto` makes each planet responsive to mouse events\r\n\r\nThis layering design allows users to naturally interact with planets while maintaining clear visual hierarchy.\r\n\r\n## Animation Loop Implementation\r\n\r\nNow we come to the most crucial part - how to make this galaxy smoothly rotate.\r\n\r\n### Why choose requestAnimationFrame?\r\n\r\nCompared to `setInterval` or `setTimeout`, `requestAnimationFrame` has several irreplaceable advantages:\r\n- **Synchronized with browser refresh rate**: Usually 60fps, giving users the smoothest experience\r\n- **Automatic optimization**: Pauses when the page is not visible, saving CPU resources\r\n- **Time precision**: Provides high-precision timestamps\r\n\r\n### Core Animation Loop Implementation\r\n\r\nHere's the core code for achieving smooth animation:\r\n\r\n```typescript\r\nconst animate = (currentTime: number) =\u003e {\r\n    if (!lastTimeRef.current) lastTimeRef.current = currentTime;\r\n    const deltaTime = currentTime - lastTimeRef.current;\r\n    lastTimeRef.current = currentTime;\r\n    \r\n    frameCountRef.current++;\r\n    \r\n    // Frame rate control strategy - update position every 2 frames\r\n    if (frameCountRef.current % 2 === 0) {\r\n        const currentData = planetsDataRef.current;\r\n        \r\n        // Update planet positions and angles\r\n        const updatedPlanets = currentData.map(planet =\u003e {\r\n            if (planet.isPaused) return planet;\r\n\r\n            const baseSpeed = 0.15 + planet.orbitIndex * 0.08;\r\n            const currentSpeed = baseSpeed * planet.speedMultiplier * planet.collisionSpeedBoost;\r\n            const newAngle = (planet.angle + currentSpeed * deltaTime * 0.01) % 360;\r\n            const normalizedAngle = newAngle \u003c 0 ? newAngle + 360 : newAngle;\r\n\r\n            return {\r\n                ...planet,\r\n                angle: normalizedAngle,\r\n                x: galaxyCenter.x + Math.cos(normalizedAngle * Math.PI / 180) * planet.orbitRadius,\r\n                y: galaxyCenter.y + Math.sin(normalizedAngle * Math.PI / 180) * planet.orbitRadius,\r\n            };\r\n        });\r\n\r\n        // Collision detection every 4 frames (maintain high frequency during stirring)\r\n        let finalPlanets = updatedPlanets;\r\n        if (frameCountRef.current % 4 === 0 || isStirring) {\r\n            finalPlanets = detectCollisions(updatedPlanets);\r\n        }\r\n\r\n        // Only update state when there are actual changes\r\n        if (finalPlanets !== currentData) {\r\n            planetsDataRef.current = finalPlanets;\r\n            setPlanetsData(finalPlanets);\r\n        }\r\n    }\r\n    \r\n    animationRef.current = requestAnimationFrame(animate);\r\n};\r\n```\r\n\r\nMain functionality explanation:\r\n\r\n1. **Initialize timestamp**: Set baseline time on first call\r\n2. **Calculate time difference**: `deltaTime` is the milliseconds since the last update\r\n3. **Update timestamp**: Prepare for next calculation\r\n4. **Angle accumulation**: Update angle proportionally based on time difference\r\n\r\n### The 0.01 coefficient controlling initial planet orbital speed\r\n\r\nYou might have noticed the `deltaTime * 0.01` coefficient. Its meaning:\r\n- `deltaTime` is in milliseconds, usually around 16-17ms (60fps)\r\n- After multiplying by 0.01, it increases about 0.16-0.17 degrees per frame\r\n- This speed makes planet movement look neither too fast to be dizzying nor too slow to be sluggish\r\n\r\n### Animation Lifecycle Management\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    animationRef.current = requestAnimationFrame(animate);\r\n    \r\n    return () =\u003e {\r\n        if (animationRef.current) {\r\n            cancelAnimationFrame(animationRef.current);\r\n        }\r\n    };\r\n}, [isPaused, currentSpeed]);\r\n```\r\n\r\nThis effect ensures:\r\n- Start animation when component mounts\r\n- Clean up animation when component unmounts, preventing memory leaks\r\n- Restart animation loop when pause state or speed changes\r\n\r\n## Simulating Celestial Body Orbital Speed Differences\r\n\r\nIn the real solar system, inner planets orbit faster than outer planets. This physical phenomenon is known as Kepler's Third Law, and I've simulated this effect in the galaxy:\r\n\r\n```typescript\r\nconst baseSpeed = 0.15 + orbitIndex * 0.08; // Base speed plus orbital coefficient\r\nconst currentSpeed = baseSpeed * speedMultiplier * collisionSpeedBoost;\r\n```\r\n\r\nLet's look at the actual speed distribution:\r\n- 1st orbit (orbitIndex=0): 0.15 - fastest\r\n- 2nd orbit (orbitIndex=1): 0.23\r\n- 3rd orbit (orbitIndex=2): 0.31\r\n- 4th orbit (orbitIndex=3): 0.39\r\n- 5th orbit (orbitIndex=4): 0.47\r\n- 6th orbit (orbitIndex=5): 0.55\r\n- 7th orbit (orbitIndex=6): 0.63 - slowest\r\n\r\n...But! If you observe closely, you'll notice that in my Skills Galaxy, outer orbits actually rotate faster than inner orbits (higher numerical values). This is opposite to the real physical world.\r\n\r\nI chose to deliberately keep this \"bug\" because from the actual visual experience perspective, having outer orbits rotate slightly faster actually creates better dynamic feeling. This is artistic effect \u003e physical accuracy.\r\n\r\n`speedMultiplier` is an extended property of the planet component that reserves an interface for the \"stir galaxy\" function, normally staying at 1, and can become 4-14 times faster when acceleration is needed.\r\n\r\n## Interaction Feedback\r\n\r\nThe essence of user experience lies in feedback. When the mouse hovers over a planet, the following reactions occur.\r\n\r\n### Smart Pause Mechanism\r\n\r\n```typescript\r\nconst handleMouseEnter = useCallback((index: number) =\u003e {\r\n    const currentData = planetsDataRef.current;\r\n    const newData = currentData.map((planet, i) =\u003e\r\n        i === index ? {...planet, isPaused: true, isHovered: true} : planet\r\n    );\r\n    planetsDataRef.current = newData;\r\n    setPlanetsData(newData);\r\n}, []);\r\n\r\nconst handleMouseLeave = useCallback((index: number) =\u003e {\r\n    const currentData = planetsDataRef.current;\r\n    const newData = currentData.map((planet, i) =\u003e\r\n        i === index ? {...planet, isPaused: false, isHovered: false} : planet\r\n    );\r\n    planetsDataRef.current = newData;\r\n    setPlanetsData(newData);\r\n}, []);\r\n```\r\n\r\nEvent handlers optimized with `useCallback` ensure callback function reference stability. When users hover, the corresponding planet gracefully stops while updating the hover state, as if time has been frozen. This detail allows users to carefully examine planet information without being distracted by continuous motion.\r\n\r\n### Multi-layer State Style System\r\n\r\n```typescript\r\nclassName={`\r\n    w-16 h-16 rounded-full \r\n    bg-gradient-to-br from-white/20 to-white/5\r\n    backdrop-blur-sm border border-white/20\r\n    flex items-center justify-center\r\n    transition-all duration-300\r\n    ${planetData.isHovered ? 'bg-primary/30 border-primary/50 shadow-lg shadow-primary/20' : ''}\r\n    ${planetData.speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n    ${planetData.isCollided ? 'bg-red-500/30 border-red-400/50 shadow-lg shadow-red-400/20' : ''}\r\n    ${planetData.collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30 border-yellow-400/50 shadow-lg shadow-yellow-400/20' : ''}\r\n`}\r\n```\r\n\r\nThis multi-layer conditional style system allows planets to display rich visual feedback based on different states:\r\n- **Default state**: Semi-transparent white, low-key and elegant\r\n- **Hover state**: Theme color highlight with increased shadow\r\n- **Stirring state**: Purple emphasis, indicating high-speed operation\r\n- **Collision state**: Red warning, marking dangerous state\r\n- **Burst state**: Yellow highlight, showing energy release\r\n\r\n### Dynamic Information Panel Updates\r\n\r\nThe information panel at the bottom implements smooth content switching through `AnimatePresence`:\r\n\r\n```typescript\r\n\u003cAnimatePresence mode=\"wait\"\u003e\r\n    \u003cmotion.div\r\n        key={hoveredSkill?.category || 'default'}\r\n        initial={{opacity: 0, y: 20}}\r\n        animate={{opacity: 1, y: 0}}\r\n        exit={{opacity: 0, y: -20}}\r\n        transition={{duration: 0.3}}\r\n    \u003e\r\n        \u003ch4 className=\"text-xl font-bold text-white mb-2\"\u003e\r\n            {hoveredSkill?.category || t('personal.fullStackEngineer')}\r\n        \u003c/h4\u003e\r\n        \u003cp className=\"text-gray-300 text-sm leading-relaxed\"\u003e\r\n            {hoveredSkill?.description || t('personal.galaxyDefaultDescription')}\r\n        \u003c/p\u003e\r\n    \u003c/motion.div\u003e\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n`mode=\"wait\"` ensures that new content only appears after old content completely disappears, avoiding overlapping flicker issues.\r\n\r\n## Dynamic Interaction Randomization Implementation\r\n\r\nThe \"stir galaxy\" function simulates the effect of applying external force to the galaxy, making this galaxy appear less rigid.\r\n\r\n### Random Selection Algorithm\r\n\r\n```typescript\r\nconst numPlanetsToStir = Math.min(resumeData.skills.length, \r\n    Math.floor(resumeData.skills.length * Math.random() + 1));\r\n```\r\n\r\n- `resumeData.skills.length * Math.random() + 1`: Generates a random number between 1 and the total count\r\n- `Math.floor()`: Rounds down to integer\r\n- `Math.min()`: Ensures it doesn't exceed the total number of planets\r\n\r\nThis means each time we stir, a random number of planets will be affected, adding unpredictability.\r\n\r\n### Avoiding Duplicate Selection\r\n\r\n```typescript\r\nconst indicesToStir: number[] = [];\r\n\r\nwhile (indicesToStir.length \u003c numPlanetsToStir) {\r\n    const randomIndex = Math.floor(Math.random() * resumeData.skills.length);\r\n    if (!indicesToStir.includes(randomIndex)) {\r\n        indicesToStir.push(randomIndex);\r\n    }\r\n}\r\n```\r\n\r\nThis while loop ensures each planet is selected at most once, avoiding wasted \"stirring quota\" situations.\r\n\r\n### Speed Increase Algorithm\r\n\r\n```typescript\r\nsetPlanetSpeeds(prev =\u003e {\r\n    const newSpeeds = [...prev];\r\n    indicesToStir.forEach(index =\u003e {\r\n        // Set random speed\r\n        newSpeeds[index] = 4 + Math.random() * 10;\r\n    });\r\n    return newSpeeds;\r\n});\r\n```\r\n\r\nSelected planets receive 4-14x random speed boosts, and the randomness creates different visual effects each time we stir.\r\n\r\n### Recovery Mechanism\r\n\r\n```typescript\r\nsetTimeout(() =\u003e {\r\n    setPlanetSpeeds(prev =\u003e {\r\n        const resetSpeeds = [...prev];\r\n        indicesToStir.forEach(index =\u003e {\r\n            resetSpeeds[index] = 1;\r\n        });\r\n        return resetSpeeds;\r\n    });\r\n}, 3000);\r\n```\r\n\r\nAfter 3 seconds, all planets return to normal speed. This duration is just right: not too short for users to see the effect clearly, nor too long to cause annoyance.\r\n\r\n### Visual Cues for High-Speed State\r\n\r\nWhen planets are in high-speed state, they display special purple styling:\r\n\r\n```typescript\r\n${speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n```\r\n\r\n## Dynamic Light Effect Design for Central Celestial Body\r\n\r\nTo prevent the central sun from looking like a mere decoration, I added some subtle but visually pleasing light effect animations.\r\n\r\n### Breathing-like Glow Changes\r\n\r\n```typescript\r\nanimate={{\r\n    boxShadow: [\r\n        \"0 0 30px rgba(255, 193, 7, 0.5)\",\r\n        \"0 0 50px rgba(255, 193, 7, 0.8)\",\r\n        \"0 0 30px rgba(255, 193, 7, 0.5)\"\r\n    ]\r\n}}\r\ntransition={{\r\n    duration: 3,\r\n    repeat: Infinity,\r\n    ease: \"easeInOut\"\r\n}}\r\n```\r\n\r\nThis animation creates a \"breathing\" effect:\r\n- **30px shadow**: Contracted state, more restrained\r\n- **50px shadow**: Expanded state, radiating light\r\n- **0.5→0.8→0.5 opacity**: Combined with size changes, enhances light-dark contrast\r\n- **3-second cycle**: Not too fast to appear restless, not too slow to seem sluggish\r\n- **easeInOut**: Natural acceleration and deceleration, like real breathing\r\n\r\n### Multi-layer Glow\r\n\r\n```typescript\r\n{/* Main sun body */}\r\n\u003cdiv className=\"w-full h-full rounded-full bg-gradient-to-br from-amber-300 via-yellow-400 to-orange-500\"\u003e\r\n    👨‍💻\r\n\u003c/div\u003e\r\n\r\n{/* Background glow */}\r\n\u003cdiv className=\"absolute inset-0 rounded-full bg-gradient-to-br from-amber-300/30 to-orange-500/30 animate-pulse -z-10 scale-150\"/\u003e\r\n```\r\n\r\nThere are two layers of light effects:\r\n1. **Main sun body**: Solid gradient colors from amber to orange\r\n2. **Background glow**: Larger, more transparent, pulsating light ring\r\n\r\n`scale-150` makes the background glow 50% larger than the main body, `-z-10` ensures it stays in the background, creating multi-layered light effects.\r\n\r\n## Dynamic Layout Central Positioning System\r\n\r\nIn responsive design, the galaxy's center position needs to adjust dynamically based on container size, preventing galaxy displacement when window size changes.\r\n\r\n### Center Calculation\r\n\r\n```typescript\r\nconst updateCenter = () =\u003e {\r\n    if (galaxyRef.current) {\r\n        const rect = galaxyRef.current.getBoundingClientRect();\r\n        setGalaxyCenter({\r\n            x: rect.width / 2,\r\n            y: rect.height / 2\r\n        });\r\n    }\r\n};\r\n```\r\n\r\n`getBoundingClientRect()` is the most reliable method to get DOM element actual dimensions, returning the element's actual rendered size in the page, including padding and all style effects.\r\n\r\n### Responsive Listening\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    updateCenter();\r\n    window.addEventListener('resize', updateCenter);\r\n    \r\n    return () =\u003e window.removeEventListener('resize', updateCenter);\r\n}, []);\r\n```\r\n\r\nThis effect does three things:\r\n1. **Component mount**: Immediately calculate center position once\r\n2. **Window resize**: Recalculate center position\r\n3. **Component unmount**: Clean up event listeners to prevent memory leaks\r\n\r\n### Default Value Safety Strategy\r\n\r\n```typescript\r\nconst [galaxyCenter, setGalaxyCenter] = useState({x: 350, y: 350});\r\n```\r\n\r\nThis default value `{x: 350, y: 350}` is calculated based on a 700x700px container, providing the following functionality:\r\n\r\n- Provides a reasonable initial position before actual size calculation is complete\r\n- Avoids sudden jumping of planet positions during initial render\r\n\r\n### getBoundingClientRect vs offsetWidth\r\n\r\nYou might ask, why not use `offsetWidth` and `offsetHeight`?\r\n\r\n```typescript\r\n// This is less accurate\r\nconst width = galaxyRef.current.offsetWidth;\r\nconst height = galaxyRef.current.offsetHeight;\r\n\r\n// This is more precise\r\nconst rect = galaxyRef.current.getBoundingClientRect();\r\nconst width = rect.width;\r\nconst height = rect.height;\r\n```\r\n\r\n`getBoundingClientRect()` provides more precise decimal values, while `offsetWidth` only returns integers, which might cause 1-2 pixel deviations in some detailed layouts.\r\n\r\n## Planet Collision System\r\n\r\nFrom the moment I made multiple planets operate on the same orbit, I've been pondering: I need to add something reasonable. (Is it really reasonable?)\r\n\r\n### Mathematical Principles of Collision Detection\r\n\r\nTo determine if two planets moving on circular orbits \"collide,\" we need to compare their angular differences in the polar coordinate system.\r\n\r\n```typescript\r\n// Core logic for collision detection\r\nconst angleDiff = Math.abs(otherPlanet.angle - currentPlanet.angle);\r\nconst normalizedAngleDiff = Math.min(angleDiff, 360 - angleDiff);\r\n\r\nif (normalizedAngleDiff \u003c collisionThreshold) {\r\n    // Collision occurred!\r\n}\r\n```\r\n\r\nThere's an important mathematical detail here: **angle difference normalization**.\r\n\r\nImagine if one planet is at 350° position and another at 10° position, simple `Math.abs(350 - 10) = 340°` would tell us they're far apart. But actually, they're only 20° apart (350° → 360° → 10°)!\r\n\r\nSo we use `Math.min(angleDiff, 360 - angleDiff)` to find the minimum angular distance, solving the \"crossing 0° boundary\" problem.\r\n\r\n### Collision Threshold\r\n\r\n```typescript\r\nconst collisionThreshold = 13; // Angular distance threshold in degrees\r\n```\r\n\r\nRandomly set collision threshold, because 13 might be a lucky number (?)\r\n\r\n### Same-Orbit Collision Principle\r\n\r\n```typescript\r\n// Only planets on the same orbit can collide\r\nfor (let j = 0; j \u003c updatedPlanets.length; j++) {\r\n    if (i === j || updatedPlanets[j].orbitIndex !== planet.orbitIndex) continue;\r\n    // ...collision detection logic\r\n}\r\n```\r\n\r\nThis design follows physical intuition: only planets on the same orbit can meet. Planets on different orbits, although they might appear close visually, are at different \"heights\" in three-dimensional space and won't collide.\r\n\r\n~~(Actually, multi-orbit collision implementation was too complex, requiring calculation of two-dimensional Euclidean distance etc., so I just skipped it)~~\r\n\r\n### Collision Lifecycle\r\n\r\nEach planet's collision state follows a simple state machine:\r\n\r\n```\r\nNormal Operation → Detect Nearby Planet → Trigger Collision → Particle Effect → Speed Burst → Return to Normal\r\n   ↑                                                    ↓\r\n   ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←\r\n```\r\n\r\n**Key state control logic**:\r\n\r\n```typescript\r\nif (hasNearbyPlanet \u0026\u0026 !planet.isCollided) {\r\n    // First collision detection - trigger effect\r\n    updatedPlanets[i] = {\r\n        ...planet,\r\n        isCollided: true,\r\n        showParticles: true,\r\n        collisionSpeedBoost: 4 + Math.random() * 10\r\n    };\r\n} else if (!hasNearbyPlanet \u0026\u0026 planet.isCollided) {\r\n    // No more nearby planets - clear collision marker\r\n    updatedPlanets[i] = {\r\n        ...planet,\r\n        isCollided: false\r\n    };\r\n}\r\n```\r\n\r\nThe `!planet.isCollided` condition is important, ensuring:\r\n- **Effect only triggers on first collision detection**, not repeatedly every frame\r\n- **Collision effects don't stack infinitely**, avoiding performance issues\r\n- **Clear state transitions**, each planet has a definite state at any moment\r\n\r\n### Particle Effects\r\n\r\nWhen collision occurs, we generate a spectacular particle explosion effect at the collision point:\r\n\r\n```typescript\r\nfunction ParticleEffect({ x, y, isActive, onComplete }: ParticleEffectProps) {\r\n    // 32 particles, radiating outward\r\n    {[...Array(32)].map((_, i) =\u003e (\r\n        \u003cmotion.div\r\n            key={i}\r\n            className=\"absolute w-5 h-5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full\"\r\n            animate={{\r\n                x: Math.cos((i * 11.25) * Math.PI / 180) * 150,\r\n                y: Math.sin((i * 11.25) * Math.PI / 180) * 150,\r\n                opacity: [1, 0],\r\n                scale: [1, 0.2],\r\n            }}\r\n            transition={{\r\n                duration: 3,\r\n                ease: \"easeOut\"\r\n            }}\r\n        /\u003e\r\n    ))}\r\n}\r\n```\r\n\r\nParameter explanations:\r\n\r\n1. **32 particles, 11.25-degree intervals**: `i * 11.25` ensures particles are evenly distributed across 360 degrees\r\n2. **Radial movement**: Using polar coordinate conversion makes particles scatter in all directions\r\n3. **Simultaneous fade and shrink**: `opacity: [1, 0]` and `scale: [1, 0.2]` create a dissipation effect\r\n4. **3000ms duration**: Not too fast to see clearly, not too slow to feel sluggish\r\n\r\n### Speed Burst\r\n\r\n```typescript\r\ncollisionSpeedBoost: 4 + Math.random() * 10  // 4-14x random speed boost\r\n```\r\n\r\nWhen planets collide, they gain 4-14x random speed boost lasting 0.1 seconds:\r\n\r\n```typescript\r\nconst timeout = setTimeout(() =\u003e {\r\n    setPlanetsData(prev =\u003e prev.map((p, idx) =\u003e \r\n        idx === i ? { ...p, collisionSpeedBoost: 1 } : p\r\n    ));\r\n}, 100); // Reset after 0.1 seconds\r\n```\r\n\r\n### Hierarchical Visual State Design\r\n\r\nThe collision system introduces multi-layered visual states for planets:\r\n\r\n```html\r\nclassName={`\r\n    // Base styles\r\n    w-16 h-16 rounded-full bg-gradient-to-br from-white/20 to-white/5\r\n    // Hover state\r\n    ${planetData.isHovered ? 'bg-primary/30 border-primary/50 shadow-lg shadow-primary/20' : ''}\r\n    // High-speed stir state  \r\n    ${planetData.speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n    // Collision marker state\r\n    ${planetData.isCollided ? 'bg-red-500/30 border-red-400/50 shadow-lg shadow-red-400/20' : ''}\r\n    // Collision acceleration state\r\n    ${planetData.collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30 border-yellow-400/50 shadow-lg shadow-yellow-400/20' : ''}\r\n`}\r\n```\r\n\r\nSpecific states:\r\n- **Default white**: Peaceful operating state\r\n- **Blue highlight**: User is focusing (hovering)\r\n- **Purple emphasis**: Being artificially stirred (stir function)\r\n- **Red warning**: In collision state, with \"danger\" implication\r\n- **Yellow burst**: Collision acceleration, full of energy\r\n\r\n## High-Performance Animation Architecture Design\r\n\r\nTo ensure the galaxy maintains smooth operation even under high load conditions, the entire animation system adopts multi-layered performance optimization strategies.\r\n\r\n### Smart Frame Rate Control Strategy\r\n\r\nThe animation loop adopts differentiated update frequencies, allocating different execution frequencies based on operation computational complexity:\r\n\r\n- **Position updates**: Execute every 2 frames (30fps), maintaining visual smoothness\r\n- **Collision detection**: Execute every 4 frames (15fps), reducing computational overhead\r\n- **Special effects**: Return to high frequency updates during stirring, ensuring effect quality\r\n\r\nThis strategy significantly reduces CPU load while maintaining good visual experience.\r\n\r\n### Dual State Management Mode\r\n\r\nTo avoid frequent state updates and re-renders, the system adopts a dual state management mode with `useRef` and `useState`:\r\n\r\n```typescript\r\nconst planetsDataRef = useRef\u003cPlanetData[]\u003e([]);\r\nconst [planetsData, setPlanetsData] = useState\u003cPlanetData[]\u003e([]);\r\n\r\n// Directly manipulate ref in animation loop, avoiding frequent state updates\r\nconst currentData = planetsDataRef.current;\r\nconst updatedPlanets = currentData.map(planet =\u003e {\r\n    // ... update logic\r\n});\r\n\r\n// Only update React state when truly needing re-render\r\nif (finalPlanets !== currentData) {\r\n    planetsDataRef.current = finalPlanets;\r\n    setPlanetsData(finalPlanets);\r\n}\r\n```\r\n\r\nCore advantages of this architecture:\r\n- **Reduced React scheduling overhead**: Significantly fewer state updates\r\n- **On-demand rendering**: Only update UI when there are visual changes\r\n- **Data consistency**: ref and state always stay synchronized\r\n\r\n### Component Memoization Architecture\r\n\r\nThe entire component system adopts comprehensive memoization strategies, including caching of child components and callback functions:\r\n\r\n```typescript\r\nconst ParticleEffect = React.memo(function ParticleEffect({x, y, isActive, onComplete}: ParticleEffectProps) {\r\n    // ... component logic\r\n});\r\n\r\nconst PlanetRenderer = React.memo(function PlanetRenderer({\r\n    planetData,\r\n    galaxyCenter,\r\n    onHover,\r\n    onMouseEnter,\r\n    onMouseLeave,\r\n    onParticleComplete\r\n}: PlanetRendererProps) {\r\n    // Use useCallback to ensure callback function reference stability\r\n    const handleMouseEnter = useCallback(() =\u003e {\r\n        onMouseEnter(planetData.index);\r\n        onHover(planetData.skill);\r\n    }, [planetData.index, planetData.skill, onMouseEnter, onHover]);\r\n    \r\n    // ... other logic\r\n});\r\n```\r\n\r\nParent component uses `useMemo` to cache the entire planet list:\r\n\r\n```typescript\r\nconst memoizedPlanets = useMemo(() =\u003e \r\n    planetsData.map((planetData) =\u003e (\r\n        \u003cPlanetRenderer\r\n            key={`planet-${planetData.index}`}\r\n            planetData={planetData}\r\n            galaxyCenter={galaxyCenter}\r\n            onHover={setHoveredSkill}\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseLeave={handleMouseLeave}\r\n            onParticleComplete={handleParticleComplete}\r\n        /\u003e\r\n    )), [planetsData, galaxyCenter, handleMouseEnter, handleMouseLeave, handleParticleComplete]);\r\n```\r\n\r\n### Efficient Collision Detection Algorithm\r\n\r\nThe collision detection system adopts a double-loop structure, improving performance by reducing unnecessary comparisons:\r\n\r\n```typescript\r\n// Efficient collision detection implementation\r\nfor (let i = 0; i \u003c planets.length; i++) {\r\n    for (let j = i + 1; j \u003c planets.length; j++) {\r\n        // Early filtering: only check planets on the same orbit\r\n        if (planets[j].orbitIndex !== planets[i].orbitIndex) continue;\r\n        \r\n        // Calculate angle difference for collision determination\r\n        const angleDiff = Math.abs(planets[j].angle - planets[i].angle);\r\n        const normalizedAngleDiff = Math.min(angleDiff, 360 - angleDiff);\r\n        \r\n        if (normalizedAngleDiff \u003c 13) { // 13-degree collision threshold\r\n            // Trigger collision effect\r\n            updatedPlanets[i] = {\r\n                ...planet,\r\n                isCollided: true,\r\n                showParticles: true,\r\n                collisionSpeedBoost: 4 + Math.random() * 10\r\n            };\r\n            \r\n            // Reset collision acceleration after 100ms\r\n            setTimeout(() =\u003e {\r\n                // Reset logic\r\n            }, 100);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAlgorithm design advantages:\r\n- **Avoid duplicate calculations**: (i,j) and (j,i) only need to be calculated once\r\n- **Orbit pre-filtering**: Planets on different orbits are directly skipped from detection\r\n- **Computation optimization**: Reduces unnecessary angle difference calculations\r\n\r\n### Efficient Particle Effect System\r\n\r\nParticle explosion effects need to maximize performance while maintaining visual impact:\r\n\r\n```typescript\r\n// Efficient explosion effect with 32 particles\r\n{[...Array(32)].map((_, i) =\u003e (\r\n    \u003cmotion.div\r\n        key={i}\r\n        className=\"absolute w-5 h-5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full\"\r\n        style={{\r\n            left: 25,\r\n            top: 25,\r\n        }}\r\n        animate={{\r\n            x: Math.cos((i * 11.25) * Math.PI / 180) * 150,\r\n            y: Math.sin((i * 11.25) * Math.PI / 180) * 150,\r\n            opacity: [1, 0],\r\n            scale: [1, 0.2],\r\n        }}\r\n        transition={{\r\n            duration: 3,\r\n            ease: \"easeOut\"\r\n        }}\r\n    /\u003e\r\n))}\r\n```\r\n\r\nParameter explanations:\r\n\r\n- **Particle count**: 32 particles provide rich visual density\r\n- **Particle size**: 5x5 pixels ensure clear visibility\r\n- **Spread radius**: 150-pixel wide spread range\r\n- **Animation duration**: 3-second full display time\r\n\r\n### Stirring Function Debounce Mechanism\r\n\r\nComplete debounce and batch update strategies ensure the galaxy remains stable under high-frequency interactions:\r\n\r\n```typescript\r\nconst [isStirring, setIsStirring] = useState(false);\r\n\r\nconst handleStirPlanets = useCallback(() =\u003e {\r\n    if (isStirring) return; // Debounce protection\r\n    \r\n    setIsStirring(true);\r\n    \r\n    // Randomly select planets to stir\r\n    const numPlanetsToStir = Math.min(currentData.length, \r\n        Math.floor(currentData.length * Math.random() + 1));\r\n    const indicesToStir: number[] = [];\r\n    \r\n    while (indicesToStir.length \u003c numPlanetsToStir) {\r\n        const randomIndex = Math.floor(Math.random() * currentData.length);\r\n        if (!indicesToStir.includes(randomIndex)) {\r\n            indicesToStir.push(randomIndex);\r\n        }\r\n    }\r\n    \r\n    // Batch update all affected planets\r\n    const stirredData = currentData.map((planet, index) =\u003e\r\n        indicesToStir.includes(index)\r\n            ? {...planet, speedMultiplier: 4 + Math.random() * 10}\r\n            : planet\r\n    );\r\n    \r\n    // Single state update\r\n    planetsDataRef.current = stirredData;\r\n    setPlanetsData(stirredData);\r\n    \r\n    // Return to normal speed after 3 seconds\r\n    setTimeout(() =\u003e {\r\n        const resetData = planetsDataRef.current.map((planet, index) =\u003e\r\n            indicesToStir.includes(index)\r\n                ? {...planet, speedMultiplier: 1}\r\n                : planet\r\n        );\r\n        planetsDataRef.current = resetData;\r\n        setPlanetsData(resetData);\r\n        setIsStirring(false);\r\n    }, 3000);\r\n}, [isStirring]);\r\n```\r\n\r\n## Complete Source Code Analysis\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport React, {useCallback, useEffect, useRef, useState, useMemo} from 'react';\r\nimport {AnimatePresence, motion} from 'framer-motion';\r\nimport {useTranslation} from '@/lib/hooks/useTranslation';\r\n\r\n// ==================== Type Definitions ====================\r\ninterface ResumeData {\r\n    skills: {\r\n        category: string;\r\n        description: string;\r\n    }[];\r\n}\r\n\r\ninterface SkillGalaxyProps {\r\n    resumeData: ResumeData;\r\n    personalDescription: string;\r\n    onCloseAction: () =\u003e void;\r\n}\r\n\r\n// Planet data structure: centrally manages all planet states\r\ninterface PlanetData {\r\n    index: number;              // Planet index\r\n    skill: { category: string; description: string };  // Skill information\r\n    angle: number;              // Current angle position\r\n    orbitIndex: number;         // Orbit index (0-6)\r\n    orbitRadius: number;        // Orbit radius\r\n    x: number;                  // Screen X coordinate\r\n    y: number;                  // Screen Y coordinate\r\n    isCollided: boolean;        // Collision state\r\n    showParticles: boolean;     // Particle effect display state\r\n    collisionSpeedBoost: number; // Collision speed boost (4-14x)\r\n    isPaused: boolean;          // Pause state (when mouse hovers)\r\n    speedMultiplier: number;    // Stirring speed multiplier (4-14x)\r\n    isHovered: boolean;         // Hover state\r\n}\r\n\r\n// ==================== Particle Effect Component ====================\r\ninterface ParticleEffectProps {\r\n    x: number;\r\n    y: number;\r\n    isActive: boolean;\r\n    onComplete: () =\u003e void;\r\n}\r\n\r\n// Use React.memo to optimize particle effect component performance\r\nconst ParticleEffect = React.memo(function ParticleEffect({x, y, isActive, onComplete}: ParticleEffectProps) {\r\n    useEffect(() =\u003e {\r\n        if (isActive) {\r\n            // Auto-complete particle effect after 3 seconds\r\n            const timer = setTimeout(onComplete, 3000);\r\n            return () =\u003e clearTimeout(timer);\r\n        }\r\n    }, [isActive, onComplete]);\r\n\r\n    if (!isActive) return null;\r\n\r\n    return (\r\n        \u003cmotion.div\r\n            className=\"absolute pointer-events-none\"\r\n            style={{\r\n                left: x - 25,   // Center positioning\r\n                top: y - 25,\r\n                width: 50,\r\n                height: 50,\r\n            }}\r\n            initial={{opacity: 0, scale: 0}}\r\n            animate={{opacity: 1, scale: 1}}\r\n            exit={{opacity: 0, scale: 0}}\r\n            transition={{duration: 3}}\r\n        \u003e\r\n            {/* 32 particles radiating outward */}\r\n            {[...Array(32)].map((_, i) =\u003e (\r\n                \u003cmotion.div\r\n                    key={i}\r\n                    className=\"absolute w-5 h-5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full\"\r\n                    style={{\r\n                        left: 25,\r\n                        top: 25,\r\n                    }}\r\n                    animate={{\r\n                        // Radial motion: each particle 11.25 degrees apart\r\n                        x: Math.cos((i * 11.25) * Math.PI / 180) * 150,\r\n                        y: Math.sin((i * 11.25) * Math.PI / 180) * 150,\r\n                        opacity: [1, 0],    // Fade effect\r\n                        scale: [1, 0.2],    // Shrink effect\r\n                    }}\r\n                    transition={{\r\n                        duration: 3,        // 3-second animation duration\r\n                        ease: \"easeOut\"     // Natural deceleration\r\n                    }}\r\n                /\u003e\r\n            ))}\r\n        \u003c/motion.div\u003e\r\n    );\r\n});\r\n\r\n// ==================== Single Planet Renderer ====================\r\ninterface PlanetRendererProps {\r\n    planetData: PlanetData;\r\n    galaxyCenter: { x: number; y: number };\r\n    onHover: (skill: { category: string; description: string } | null) =\u003e void;\r\n    onMouseEnter: (index: number) =\u003e void;\r\n    onMouseLeave: (index: number) =\u003e void;\r\n    onParticleComplete: (index: number) =\u003e void;\r\n}\r\n\r\n// Use React.memo to optimize single planet rendering performance\r\nconst PlanetRenderer = React.memo(function PlanetRenderer({\r\n                            planetData,\r\n                            galaxyCenter,\r\n                            onHover,\r\n                            onMouseEnter,\r\n                            onMouseLeave,\r\n                            onParticleComplete\r\n                        }: PlanetRendererProps) {\r\n    \r\n    // Use useCallback to ensure callback function reference stability\r\n    const handleMouseEnter = useCallback(() =\u003e {\r\n        onMouseEnter(planetData.index);\r\n        onHover(planetData.skill);\r\n    }, [planetData.index, planetData.skill, onMouseEnter, onHover]);\r\n\r\n    const handleMouseLeave = useCallback(() =\u003e {\r\n        onMouseLeave(planetData.index);\r\n        onHover(null);\r\n    }, [planetData.index, onMouseLeave, onHover]);\r\n\r\n    const handleParticleComplete = useCallback(() =\u003e {\r\n        onParticleComplete(planetData.index);\r\n    }, [planetData.index, onParticleComplete]);\r\n\r\n    return (\r\n        \u003cdiv className=\"absolute inset-0 pointer-events-none\"\u003e\r\n            {/* Orbit path: semi-transparent circular ring */}\r\n            \u003cdiv\r\n                className=\"absolute border border-white/10 rounded-full pointer-events-none\"\r\n                style={{\r\n                    width: planetData.orbitRadius * 2,\r\n                    height: planetData.orbitRadius * 2,\r\n                    left: galaxyCenter.x - planetData.orbitRadius,\r\n                    top: galaxyCenter.y - planetData.orbitRadius,\r\n                }}\r\n            /\u003e\r\n\r\n            {/* Planet body */}\r\n            \u003cmotion.div\r\n                className=\"absolute pointer-events-auto select-none\"\r\n                style={{\r\n                    left: planetData.x - 32,   // Center 64px planet\r\n                    top: planetData.y - 32,\r\n                }}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseLeave={handleMouseLeave}\r\n                whileHover={{scale: 1.2}}      // Hover zoom effect\r\n                transition={{duration: 0.2}}\r\n            \u003e\r\n                {/* Multi-layer state style system */}\r\n                \u003cdiv className={`\r\n                    w-16 h-16 rounded-full \r\n                    bg-gradient-to-br from-white/20 to-white/5\r\n                    backdrop-blur-sm border border-white/20\r\n                    flex items-center justify-center\r\n                    transition-all duration-300\r\n                    ${planetData.isHovered ? 'bg-primary/30 border-primary/50 shadow-lg shadow-primary/20' : ''}\r\n                    ${planetData.speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n                    ${planetData.isCollided ? 'bg-red-500/30 border-red-400/50 shadow-lg shadow-red-400/20' : ''}\r\n                    ${planetData.collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30 border-yellow-400/50 shadow-lg shadow-yellow-400/20' : ''}\r\n                `}\u003e\r\n                    \u003cspan className=\"text-xs font-medium text-white text-center px-1\"\u003e\r\n                        {planetData.skill.category}\r\n                    \u003c/span\u003e\r\n                \u003c/div\u003e\r\n            \u003c/motion.div\u003e\r\n\r\n            {/* Particle explosion effect */}\r\n            \u003cAnimatePresence\u003e\r\n                {planetData.showParticles \u0026\u0026 (\r\n                    \u003cParticleEffect\r\n                        x={planetData.x}\r\n                        y={planetData.y}\r\n                        isActive={planetData.showParticles}\r\n                        onComplete={handleParticleComplete}\r\n                    /\u003e\r\n                )}\r\n            \u003c/AnimatePresence\u003e\r\n        \u003c/div\u003e\r\n    );\r\n});\r\n\r\n// ==================== Main Component: Skills Galaxy ====================\r\nexport function SkillGalaxy({resumeData, personalDescription, onCloseAction}: SkillGalaxyProps) {\r\n    // State management, refs management, and initialization...\r\n    // [The complete implementation continues with all the logic we discussed]\r\n}\r\n```\r\n\r\n### Core Algorithm Architecture Diagram\r\n\r\n```\r\nInitialization Phase → Responsive Layout → Animation Loop → Interaction Handling → Performance Optimization\r\n    ↓                   ↓                  ↓               ↓                   ↓\r\nPlanet Data Generation  Center Positioning RAF-driven      Event Callbacks     Component Caching\r\n    ↓                   ↓                  ↓               ↓                   ↓\r\nOrbit Allocation       Coordinate Transform Position Update State Sync        Memory Management\r\n    ↓                   ↓                  ↓               ↓                   ↓\r\nAngle Distribution     Window Listening   Collision Detection Debounce Mechanism Batch Updates\r\n```\r\n\r\n### Key Technical Points Summary\r\n\r\n**1. Dual State Management Architecture**\r\n```typescript\r\n// Shadow state: high-frequency updates, avoiding React re-renders\r\nconst planetsDataRef = useRef\u003cPlanetData[]\u003e([]);\r\n// React state: UI sync, on-demand updates\r\nconst [planetsData, setPlanetsData] = useState\u003cPlanetData[]\u003e([]);\r\n```\r\n\r\n**2. Frame Rate Control and Performance Optimization**\r\n```typescript\r\n// Position updates: every 2 frames (30fps)\r\nif (frameCountRef.current % 2 === 0) { /* Update positions */ }\r\n// Collision detection: every 4 frames (15fps)\r\nif (frameCountRef.current % 4 === 0 || isStirring) { /* Collision detection */ }\r\n```\r\n\r\n**3. Mathematical Model: Polar Coordinate Conversion**\r\n```typescript\r\n// Core conversion formula\r\nx = galaxyCenter.x + Math.cos(angle * Math.PI / 180) * orbitRadius;\r\ny = galaxyCenter.y + Math.sin(angle * Math.PI / 180) * orbitRadius;\r\n```\r\n\r\n**4. Collision Detection Optimization Algorithm**\r\n```typescript\r\n// Double-loop optimization: avoid duplicate comparisons (i,j) and (j,i)\r\nfor (let i = 0; i \u003c planets.length; i++) {\r\n    for (let j = i + 1; j \u003c planets.length; j++) {\r\n        // Same-orbit pre-filtering + angle difference calculation\r\n    }\r\n}\r\n```\r\n\r\n**5. Multi-layer Visual State System**\r\n```typescript\r\n// Conditional styles: hover, stirring, collision, acceleration four states\r\n${isHovered ? 'bg-primary/30' : ''}\r\n${speedMultiplier \u003e 1 ? 'bg-purple-500/30' : ''}\r\n${isCollided ? 'bg-red-500/30' : ''}\r\n${collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30' : ''}\r\n```\r\n\r\n## Conclusion\r\n\r\nThe Skills Galaxy can be said to be the most complex and comprehensive dynamic effect I've implemented to date, especially in terms of performance optimization. Before actual optimization of this effect, frequent re-renders would cause\r\n\r\n*May your code shine like stars and run harmoniously like a galaxy.* ✨"])</script><script>self.__next_f.push([1,"24:Tbf31,"])</script><script>self.__next_f.push([1,"\r\n# Style Injection: Phoenix Rising from TailwindCSS Preflight's Destruction\r\n\r\nYou can't have your fish and bear's paw at the same time. — Impossible! I want them all!\r\n\r\nImagine a sunny spring day... when you eagerly render your carefully crafted MDX documents to a webpage, only to discover that all your headings, paragraphs, and code blocks have become \"naked HTML\" without any styling! Well — congratulations, you've encountered the \"dark side\" of TailwindCSS Preflight. This seemingly harmless CSS reset mechanism is like an overly enthusiastic cleaner who treats all your home decorations as garbage to be thrown away!\r\n\r\nFor this, your most convenient solution might be to coax TailwindCSS: \"Alright, alright, the CSS rendering authority is in your hands, I'll follow your lead! Let's compromise with MDX and inject some of your stuff into her!\"\r\n\r\nIf your mind went to the gutter, that's your problem, not mine (shrugs, with a cheeky face).\r\n\r\nSo... ta-da! The style injection system is born!\r\n\r\nBack to the main topic, in this article, I'll start from the root of the problem and gradually delve into every technical detail, comprehensively dissecting this art of document style renaissance. (Is it really that grand?)\r\n\r\n## Root Cause Analysis: The Double-Edged Sword Effect of Preflight\r\n\r\nBefore diving into the solution, we need to understand Preflight's working mechanism.\r\n\r\n### TailwindCSS Preflight Mechanism Analysis\r\n\r\n```css\r\n/* Example of Preflight reset styles */\r\nh1, h2, h3, h4, h5, h6 {\r\n  font-size: inherit;\r\n  font-weight: inherit;\r\n}\r\n\r\np, blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre {\r\n  margin: 0;\r\n}\r\n\r\nol, ul {\r\n  list-style: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n```\r\n\r\n**Preflight's design intention** is to eliminate browser default style differences, providing a \"clean canvas.\" This idea is great in itself — maintaining a consistent starting point across different browsers, avoiding various strange default style differences.\r\n\r\nBut! When we use Remarkable to convert MDX to HTML, the generated structure is semantic HTML:\r\n\r\n```html\r\n\u003ch1\u003eTitle\u003c/h1\u003e\r\n\u003cp\u003eParagraph content\u003c/p\u003e\r\n\u003ccode\u003eCode snippet\u003c/code\u003e\r\n\u003cul\u003e\r\n  \u003cli\u003eList item\u003c/li\u003e\r\n\u003c/ul\u003e\r\n```\r\n\r\nThese HTML tags should originally have browser default styles to make them look like \"headings,\" \"paragraphs,\" \"code.\" But once Preflight steps in, it directly resets all default styles — all text looks the same, without hierarchy or emphasis, like a document with rendering issues.\r\n\r\n**Why can't we simply disable Preflight?**\r\n\r\nDisabling Preflight seems like the simplest solution, but this would bring bigger problems:\r\n- Default style differences between browsers would reappear\r\n- Your other UI components might experience unexpected styling issues\r\n- Many of TailwindCSS's utility classes are designed based on reset foundation styles\r\n\r\n### MDX to HTML Rendering Pipeline\r\n\r\nLet's summarize the complete pipeline where the problem occurs:\r\n\r\n```typescript\r\nMDX Source File → Remarkable Parsing → HTML String → Preflight Reset → Style-less Result\r\n```\r\n\r\n1. **MDX Source File**: Contains semantic Markdown syntax\r\n2. **Remarkable Parsing**: Generates clean HTML structure without CSS class names\r\n3. **HTML String**: Inserted into React components for rendering\r\n4. **Preflight Reset**: TailwindCSS's base layer removes all default styles\r\n5. **Final Result**: A bunch of unstyled HTML elements\r\n\r\n**Why do traditional CSS class name approaches fail here?**\r\n\r\nYou might think: \"Why not just add CSS class names to these tags?\" The problem is:\r\n- Remarkable generates HTML as strings, not React components\r\n- We can't manually add class names to each tag in Markdown syntax\r\n- Even if we could, it would make Markdown lose its simplicity\r\n\r\nThis leads to the necessity of style injection — we need a system that can automatically add appropriate TailwindCSS class names to generated HTML tags.\r\n\r\n## Style Mapping Configuration Design\r\n\r\nBefore writing complex injection algorithms, we need to design a highly flexible configuration system (~~I can write however I want, all styles are under my control!~~).\r\n\r\n### JSON Configuration File\r\n\r\n```json\r\n{\r\n  \"h1\": \"text-4xl font-bold mt-8 mb-4 text-foreground leading-tight\",\r\n  \"h2\": \"text-3xl font-semibold mt-6 mb-3 text-foreground leading-tight\",\r\n  \"p\": \"text-base leading-7 mb-4 text-foreground\",\r\n  \"code\": \"bg-surface text-primary px-1.5 py-0.5 rounded text-sm font-mono\",\r\n  \"ul\": \"list-disc list-inside mb-4 pl-6 space-y-2\",\r\n  \"li\": \"text-foreground leading-relaxed\"\r\n}\r\n```\r\n\r\n**Tag to Style Class Mapping Strategy**:\r\n\r\nEach HTML tag corresponds to a TailwindCSS class name string. This one-to-one mapping relationship is simple and direct, avoiding complex conditional judgments.\r\n\r\n**Theme System Adaptation Design Considerations**:\r\n\r\nNotice that each style class uses theme system color variables:\r\n```\r\ntext-foreground\r\nbg-surface\r\ntext-primary\r\n```\r\n\r\nThese class names map to CSS custom properties, ensuring that document content can seamlessly adapt to new color schemes when themes switch.\r\n\r\n## Core Injection Algorithm: Regex-Driven Capture and Replace\r\n\r\nFrom my personal experience, at least 95% of matching needs can be generated by AI using regex. (scratches head, pondering)\r\n\r\n### Tag Matching Regex Magic\r\n\r\n```typescript\r\nconst tagRegex = new RegExp(`\u003c${tag}(\\\\s[^\u003e]*)?(?:\u003e|\\\\s*/\u003e)`, 'gi');\r\n```\r\n\r\nCharacter-by-character regex analysis:\r\n\r\n- `\u003c${tag}`: Match opening angle bracket and tag name\r\n- `(\\\\s[^\u003e]*)?`: Optional attribute part\r\n  - `\\\\s`: At least one whitespace character\r\n  - `[^\u003e]*`: Any number of non-`\u003e` characters (attribute content)\r\n  - `?`: The entire attribute part is optional\r\n- `(?:\u003e|\\\\s*/\u003e)` Non-capturing group, match ending part\r\n  - `\u003e`: Regular tag ending\r\n  - `|`: Or\r\n  - `\\\\s*/\u003e`: Self-closing tag ending (may have spaces)\r\n- `gi`: Global match, case-insensitive\r\n\r\n**Why match opening tags instead of complete tag pairs?**\r\n\r\nBecause we only need to add `class` attributes in opening tags; closing tags don't need modification. This design avoids considering complex nested matching and supports self-closing tags (like `\u003cimg/\u003e`, `\u003cbr/\u003e`).\r\n\r\n**Different handling for self-closing and regular tags**:\r\n\r\nThe `(?:\u003e|\\\\s*/\u003e)` part in the regex handles both cases simultaneously, without requiring additional conditional judgments.\r\n\r\n### Class Name Injection Algorithm\r\n\r\n```typescript\r\nstyledContent = styledContent.replace(tagRegex, (match) =\u003e {\r\n    // Prevent duplicate injection check\r\n    if (match.includes(classes.split(' ')[0])) {\r\n        return match;\r\n    }\r\n\r\n    // Check if class attribute already exists\r\n    const classMatch = match.match(/class=[\"']([^\"']*)[\"']/);\r\n\r\n    if (classMatch) {\r\n        // Logic for merging existing class names\r\n        const existingClasses = classMatch[1];\r\n        const newClasses = classes.split(' ').filter(cls =\u003e !existingClasses.includes(cls)).join(' ');\r\n        if (newClasses) {\r\n            return match.replace(/class=[\"']([^\"']*)[\"']/, `class=\"$1 ${newClasses}\"`);\r\n        }\r\n        return match;\r\n    } else {\r\n        // Logic for adding new class names\r\n        if (match.endsWith('/\u003e')) {\r\n            // Self-closing tag\r\n            return match.replace(/\\s*\\/\u003e$/, ` class=\"${classes}\" /\u003e`);\r\n        } else {\r\n            // Regular opening tag\r\n            return match.replace(/\u003e$/, ` class=\"${classes}\"\u003e`);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n**Judgment logic for class name merging vs addition**:\r\n\r\nThe system first checks if the tag already has a `class` attribute:\r\n- **Has**: Merge new class names with existing ones, avoiding duplicates\r\n- **Doesn't have**: Directly add new `class` attribute\r\n\r\n**Duplicate class name deduplication algorithm**:\r\n\r\n```typescript\r\nconst newClasses = classes.split(' ').filter(cls =\u003e !existingClasses.includes(cls)).join(' ');\r\n```\r\n\r\nThis line ensures no duplicate class names are added.\r\n\r\n**Attribute quote handling**:\r\n\r\nThe regex `/class=[\"']([^\"']*)[\"']/` supports both single and double quotes, ensuring compatibility in different situations.\r\n\r\n### Anti-Duplicate Injection Protection Mechanism\r\n\r\n```typescript\r\nif (match.includes(classes.split(' ')[0])) {\r\n    return match;\r\n}\r\n```\r\n\r\n**Why is checking the first class name sufficient?**\r\n\r\nThis is a judgment method that can only be used in situations with two states (injected/not injected). Suppose the algorithm injects class names `\"text-4xl font-bold mt-8 mb-4\"` for `h1` tags, then during checking, we only need to check if `text-4xl` already exists.\r\n\r\n**Performance optimization vs accuracy trade-off**:\r\n\r\nAlthough theoretically there could be false positives (other places also use `text-4xl`), this probability is extremely low in practice, while the performance improvement is significant.\r\n\r\n## Code Block Enhancement: This Little Box is Code's Forever Home\r\n\r\nRegular style injection can only give people something passable to look at, but for code blocks, programmers' obsession demands more features — syntax highlighting, copy functionality, theme switching, and modern interactive experiences.\r\n\r\n### Code Block Recognition and Deconstruction\r\n\r\n```typescript\r\nconst preCodeRegex = /\u003cpre\u003e\u003ccode([^\u003e]*?)\u003e([\\s\\S]*?)\u003c\\/code\u003e\u003c\\/pre\u003e/g;\r\n```\r\n\r\n**Nested Tag Regex Matching Challenge**:\r\n\r\nCode block HTML structure is nested: `\u003cpre\u003e\u003ccode\u003econtent\u003c/code\u003e\u003c/pre\u003e`. This regex needs to:\r\n- Precisely match the beginning `\u003cpre\u003e\u003ccode\u003e`\r\n- Capture `\u003ccode\u003e` tag attributes (containing language information)\r\n- Capture code content (may include line breaks)\r\n- Match the ending `\u003c/code\u003e\u003c/pre\u003e`\r\n\r\n**Importance of non-greedy matching**:\r\n\r\nThe `?` in `([\\s\\S]*?)` achieves non-greedy matching, ensuring proper matching when there are multiple code blocks.\r\n\r\n**Attribute extraction technique**:\r\n\r\n`([^\u003e]*?)` captures all attributes within the `\u003ccode\u003e` tag, preparing for subsequent language identification.\r\n\r\n### Language Identifier Extraction Algorithm\r\n\r\n```typescript\r\nconst languageMatch = attributes.match(/class=[\"']([^\"']*language-([^\"'\\s]+)[^\"']*)[\"']/);\r\nconst language = languageMatch ? languageMatch[2] : '';\r\n```\r\n\r\n**highlight.js Class Name Convention Analysis**:\r\n\r\nhighlight.js uses the `language-xxx` class name format to identify code languages, such as:\r\n- `language-typescript`\r\n- `language-javascript`\r\n- `language-python`\r\n- ......\r\n\r\n**Complex Regex Group Capture**:\r\n\r\n- First capture group `([^\"']*language-([^\"'\\s]+)[^\"']*)`: Captures entire class attribute value\r\n- Second capture group `([^\"'\\s]+)`: Captures specific language name\r\n\r\n**Graceful degradation with default values**:\r\n\r\nIf language cannot be identified, it defaults to displaying `'code'`, ensuring UI consistency.\r\n\r\n### HTML Entity Restoration Processing\r\n\r\n```typescript\r\nconst cleanContent = content\r\n    .replace(/\u0026lt;/g, '\u003c')\r\n    .replace(/\u0026gt;/g, '\u003e')\r\n    .replace(/\u0026amp;/g, '\u0026')\r\n    .replace(/\u0026quot;/g, '\"')\r\n    .replace(/\u0026#x27;/g, \"'\");\r\n```\r\n\r\n**Why HTML entity restoration is needed?**\r\n\r\nRemarkable converts special characters to HTML entities when processing code content to prevent XSS attacks. But in copy functionality, users expect original code, not HTML entities.\r\n\r\n**Importance of replacement order**:\r\n\r\nNote that `\u0026amp;` replacement must be last, because other entities (like `\u0026lt;`) contain `\u0026` characters themselves. Wrong order would cause double replacement.\r\n\r\n**URL encoding application in data attributes**:\r\n\r\n```typescript\r\ndata-code=\"${encodeURIComponent(cleanContent)}\"\r\n```\r\n\r\nCleaned code is stored in data attributes through URL encoding, ensuring copy functionality can retrieve correct content.\r\n\r\n### Enhanced Code Block HTML Structure Design\r\n\r\nThe generated enhanced code block has a complex HTML structure:\r\n\r\n```html\r\n\u003cdiv class=\"enhanced-codeblock relative mb-6 rounded-lg border bg-background border-gray-200...\"\u003e\r\n    \u003cdiv class=\"codeblock-header flex items-center justify-between px-4 py-2 bg-surface...\"\u003e\r\n        \u003cspan class=\"codeblock-language text-xs font-medium text-foreground opacity-70...\"\u003etypescript\u003c/span\u003e\r\n        \u003cbutton class=\"codeblock-copy-btn inline-flex items-center bg-background hover:bg-surface text-foreground hover:text-primary...\"\u003e\r\n            \u003c!-- SVG icons and text --\u003e\r\n        \u003c/button\u003e\r\n    \u003c/div\u003e\r\n    \u003cpre class=\"codeblock-content p-4 overflow-x-auto bg-surface text-foreground...\"\u003e\r\n        \u003ccode class=\"language-typescript\"\u003eOriginal code content\u003c/code\u003e\r\n    \u003c/pre\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n**CSS Grid vs Flexbox layout choice**:\r\n\r\nThe header area uses Flexbox (`flex items-center justify-between`) to achieve alignment of language identifier and copy button at both ends, which is more suitable for this one-dimensional layout than Grid.\r\n\r\n**Theme system seamless switching mechanism**:\r\n\r\nEach element uses theme system color variables:\r\n```css\r\nbg-background\r\nbg-surface\r\ntext-foreground\r\ntext-primary\r\n```\r\n\r\nThese class names connect to the theme system through CSS custom properties, ensuring automatic adaptation during theme switching.\r\n\r\n### Dynamic Theme Switching Implementation Mechanism\r\n\r\nTo make code blocks responsive to theme changes, there's also a dynamic CSS injection system:\r\n\r\n```typescript\r\n// Theme detection and CSS injection\r\nfunction injectThemeCSS() {\r\n    const existingStyle = document.getElementById('codeblock-theme-styles');\r\n    if (existingStyle) {\r\n        existingStyle.remove();\r\n    }\r\n    \r\n    // Detect current theme\r\n    const isDark = document.documentElement.classList.contains('dark');\r\n    \r\n    // Generate theme-appropriate CSS\r\n    const themeStyles = `\r\n        .enhanced-codeblock {\r\n            background-color: var(--color-background) !important;\r\n            border-color: ${isDark ? '#374151' : '#e5e7eb'} !important;\r\n        }\r\n        .codeblock-header {\r\n            background-color: var(--color-surface) !important;\r\n            border-bottom-color: ${isDark ? '#374151' : '#e5e7eb'} !important;\r\n        }\r\n        .codeblock-copy-btn {\r\n            background-color: var(--color-background) !important;\r\n            color: var(--color-foreground) !important;\r\n        }\r\n        .codeblock-copy-btn:hover {\r\n            background-color: var(--color-surface) !important;\r\n            color: var(--color-primary) !important;\r\n        }\r\n        .codeblock-content {\r\n            background-color: var(--color-surface) !important;\r\n            color: var(--color-foreground) !important;\r\n        }\r\n    `;\r\n    \r\n    // Inject into document head\r\n    const styleElement = document.createElement('style');\r\n    styleElement.id = 'codeblock-theme-styles';\r\n    styleElement.textContent = themeStyles;\r\n    document.head.appendChild(styleElement);\r\n}\r\n```\r\n\r\n**Theme change listening mechanism**:\r\n\r\n```typescript\r\n// Listen to DOM changes, detect theme switching\r\nconst observer = new MutationObserver(function(mutations) {\r\n    mutations.forEach(function(mutation) {\r\n        if (mutation.type === 'attributes' \u0026\u0026 \r\n            mutation.attributeName === 'class' \u0026\u0026 \r\n            mutation.target === document.documentElement) {\r\n            setTimeout(injectThemeCSS, 10);\r\n        }\r\n    });\r\n});\r\n\r\nobserver.observe(document.documentElement, {\r\n    attributes: true,\r\n    attributeFilter: ['class']\r\n});\r\n```\r\n\r\n**Why use dynamic CSS injection instead of static class names?**\r\n\r\n1. **Real-time response**: Immediately update styles when theme switches, no need to re-render components\r\n2. **Performance optimization**: Avoid lots of conditional class name judgments\r\n3. **Flexibility**: Can dynamically adjust border colors and other details based on theme state\r\n4. **Priority control**: Use `!important` to ensure theme styles take precedence over default styles\r\n\r\n**Advantages of CSS custom properties**:\r\n\r\nThe theme system sets CSS custom properties on the root element through `ThemeProvider`:\r\n```typescript\r\nObject.entries(currentTheme.colors).forEach(([key, value]) =\u003e {\r\n    root.style.setProperty(`--color-${key}`, value);\r\n});\r\n```\r\n\r\nThis way code blocks can automatically get current theme color values through `var(--color-background)`, `var(--color-surface)`, etc.\r\n\r\n## Client-Side Interaction Scripts: Monitoring and Notifications\r\n\r\nEnhanced code block copy, notifications, and dynamic feature initialization.\r\n\r\n### Gracefully Degradable Copy Functionality\r\n\r\n```typescript\r\nif (navigator.clipboard \u0026\u0026 navigator.clipboard.writeText) {\r\n    await navigator.clipboard.writeText(code);\r\n} else {\r\n    // Compatibility fallback solution\r\n    const textArea = document.createElement('textarea');\r\n    textArea.value = code;\r\n    textArea.style.position = 'fixed';\r\n    textArea.style.left = '-999999px';\r\n    textArea.style.top = '-999999px';\r\n    document.body.appendChild(textArea);\r\n    textArea.focus();\r\n    textArea.select();\r\n    document.execCommand('copy');\r\n    textArea.remove();\r\n}\r\n```\r\n\r\n**Modern Clipboard API vs Traditional Solution Comparison**:\r\n\r\n| Feature | Clipboard API | document.execCommand |\r\n|------|---------------|---------------------|\r\n| Security | Requires HTTPS or localhost | Relatively lenient |\r\n| Async Support | Native Promise | Synchronous operation |\r\n| Browser Support | Modern browsers | Wide support but deprecated |\r\n| User Experience | No user interaction needed | Requires focus and select |\r\n\r\n**Error handling for async operations**:\r\n\r\n```typescript\r\ntry {\r\n    await navigator.clipboard.writeText(code);\r\n    showToast('Code copied to clipboard!', 'success');\r\n} catch (err) {\r\n    console.error('Failed to copy code:', err);\r\n    showToast('Copy failed', 'error');\r\n}\r\n```\r\n\r\n**Security policy impact on copy functionality**:\r\n\r\nModern browser security policies require the Clipboard API to only work in secure contexts (HTTPS), which is why we need fallback solutions.\r\n\r\n### Dynamic Content Listening: MutationObserver\r\n\r\n```typescript\r\nconst observer = new MutationObserver(function(mutations) {\r\n    let shouldReinitialize = false;\r\n    mutations.forEach(function(mutation) {\r\n        mutation.addedNodes.forEach(function(node) {\r\n            if (node.nodeType === 1 \u0026\u0026 (node.classList.contains('enhanced-codeblock') || node.querySelector('.enhanced-codeblock'))) {\r\n                shouldReinitialize = true;\r\n            }\r\n        });\r\n    });\r\n    \r\n    if (shouldReinitialize) {\r\n        // Debounce mechanism\r\n        clearTimeout(window['__codeblock_reinit_timeout__']);\r\n        window['__codeblock_reinit_timeout__'] = setTimeout(initializeCodeBlocks, 100);\r\n    }\r\n});\r\n```\r\n\r\n**Why DOM change listening is needed?**\r\n\r\nIn React applications, components may dynamically update content. If new code blocks are added, we need to rebind event listeners for them.\r\n\r\n**Debounce mechanism performance optimization**:\r\n\r\nWhen DOM changes frequently, the debounce mechanism ensures the initialization function isn't called excessively, avoiding performance issues and UI anomalies.\r\n\r\n**Memory leak protection strategy**:\r\n\r\n```typescript\r\nif (!window['__codeblock_observers__']) {\r\n    window['__codeblock_observers__'] = new Set();\r\n}\r\n\r\nif (!window['__codeblock_observers__'].has(observerId)) {\r\n    window['__codeblock_observers__'].add(observerId);\r\n    // Create observer\r\n}\r\n```\r\n\r\nUse a global Set to track already created observers, avoiding memory leaks from duplicate creation.\r\n\r\n### Toast Notification System Implementation\r\n\r\n```typescript\r\nfunction showToast(message, type = 'success') {\r\n    // Remove existing notifications\r\n    const existingToasts = document.querySelectorAll('.copy-toast');\r\n    existingToasts.forEach(toast =\u003e toast.remove());\r\n    \r\n    // Create new notification\r\n    const toast = document.createElement('div');\r\n    toast.className = 'copy-toast fixed top-4 right-4 z-[9999] px-4 py-2 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full opacity-0';\r\n    \r\n    // Animation effects\r\n    setTimeout(() =\u003e {\r\n        toast.classList.remove('translate-x-full', 'opacity-0');\r\n    }, 10);\r\n    \r\n    // Auto removal\r\n    setTimeout(() =\u003e {\r\n        toast.classList.add('translate-x-full', 'opacity-0');\r\n        setTimeout(() =\u003e toast.remove(), 300);\r\n    }, 3000);\r\n}\r\n```\r\n\r\n**Floating notification positioning strategy**:\r\n\r\nUse `fixed top-4 right-4` to fix notifications in the top-right corner of the viewport, ensuring visibility at any scroll position.\r\n\r\n**CSS animation performance considerations**:\r\n\r\nUse `transform` instead of changing `top`/`right` values for animations, leveraging GPU acceleration for better performance.\r\n\r\n**Z-index layer management**:\r\n\r\n`z-[9999]` ensures notifications display above all other elements, including possible modals and dropdown menus.\r\n\r\n## Table of Contents Generation: Document Navigation Construction\r\n\r\nTo some extent, this is actually part of JS reverse engineering.\r\n\r\n### Title Extraction Regex\r\n\r\n```typescript\r\nconst headingRegex = /\u003ch([1-6])(?:\\s[^\u003e]*)?\u003e[\\s\\S]*?\u003c\\/h[1-6]\u003e/gi;\r\n```\r\n\r\n**Multi-line content matching**:\r\n\r\nTitle content may contain line breaks, nested HTML tags, and other complex structures. `[\\s\\S]*?` ensures matching content that includes line breaks.\r\n\r\n**Nested HTML handling**:\r\n\r\nTitles may contain inline tags like `\u003ccode\u003e`, `\u003cstrong\u003e`. The regex needs to accurately match complete title structures.\r\n\r\n### Precise Text Content Extraction\r\n\r\n```typescript\r\nconst text = tagContent\r\n    .replace(/\u003c[^\u003e]*\u003e/g, '')           // Remove HTML tags\r\n    .replace(/\u0026lt;/g, '\u003c')            // Decode HTML entities\r\n    .replace(/\u0026gt;/g, '\u003e')\r\n    .replace(/\u0026amp;/g, '\u0026')\r\n    .replace(/\u0026quot;/g, '\"')\r\n    .replace(/\u0026#x27;/g, \"'\")\r\n    .replace(/\u0026#39;/g, \"'\")\r\n    .replace(/\u0026nbsp;/g, ' ')\r\n    .replace(/\\s+/g, ' ')              // Normalize whitespace\r\n    .trim();\r\n```\r\n\r\n**HTML tag stripping algorithm**:\r\n\r\n`/\u003c[^\u003e]*\u003e/g` removes all HTML tags, keeping pure text content for TOC items.\r\n\r\n**Entity decoding coverage solution**:\r\n\r\nCovers common HTML entities, ensuring correct display of TOC text.\r\n\r\n**Whitespace normalization processing**:\r\n\r\n`\\s+` matches all types of whitespace characters (spaces, tabs, line breaks), uniformly replacing them with single spaces.\r\n\r\n### ID Generation Algorithm Design\r\n\r\n```typescript\r\nlet id = text\r\n    .toLowerCase()                                       // Convert to lowercase\r\n    .replace(/[^\\w\\s\\u00A0-\\uFFFF-]/g, '')               // Keep letters, numbers, and Unicode characters\r\n    .replace(/\\s+/g, '-')                                // Convert spaces to hyphens\r\n    .replace(/-+/g, '-')                                 // Merge multiple hyphens\r\n    .replace(/^-+|-+$/g, '');                            // Remove leading/trailing hyphens\r\n```\r\n\r\n**URL-safe ID generation rules**:\r\n\r\n- Only keep letters, numbers, Unicode characters (supports Chinese, etc.)\r\n- Convert spaces to hyphens\r\n- Remove special characters to avoid URL issues\r\n\r\n**Internationalization character support strategy**:\r\n\r\nThe `\\u00A0-\\uFFFF` range covers most Unicode characters, ensuring titles in Chinese, Japanese, etc., can correctly generate IDs.\r\n\r\n**ID conflict resolution mechanism**:\r\n\r\n```typescript\r\nlet uniqueId = id;\r\nlet counter = 1;\r\nwhile (toc.some(item =\u003e item.id === uniqueId)) {\r\n    uniqueId = `${id}-${counter}`;\r\n    counter++;\r\n}\r\n```\r\n\r\nEnsure ID uniqueness by adding numeric suffixes.\r\n\r\n## Anchor Generation: Navigable Document Implementation\r\n\r\nOnly when Staraglar plus Felgen can successfully summon Tadius. Missing any one makes the other a useless blank board... Well, even if Tadius is summoned, it's quite ordinary, but it's better than nothing.\r\n\r\n### Anchor HTML Structure Design\r\n\r\n```typescript\r\nreturn `\u003c${tag} id=\"${tocItem.id}\" class=\"group relative\"\u003e\r\n    \u003ca href=\"#${tocItem.id}\" class=\"absolute -left-6 top-0 opacity-0 group-hover:opacity-100 transition-opacity text-primary/60 hover:text-primary\" aria-label=\"Link to ${tocItem.text}\"\u003e\r\n        \u003csvg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n            \u003cpath fill-rule=\"evenodd\" d=\"M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 11.414-1.414 4 4 0 105.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 10-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z\" clip-rule=\"evenodd\" /\u003e\r\n        \u003c/svg\u003e\r\n    \u003c/a\u003e\r\n    ${content}\r\n\u003c/${tag}\u003e`;\r\n```\r\n\r\n**CSS Group selector**:\r\n\r\nThe `group` class combined with `group-hover:opacity-100` achieves the effect of \"anchor links only show when mouse hovers over the title.\"\r\n\r\n**Relative positioning control**:\r\n\r\n`absolute -left-6 top-0` positions the anchor icon 6 units to the left of the title, where there's at least some empty space.\r\n\r\n**SVG icon selection and optimization**:\r\n\r\nUses the SVG version of link icons, `fill=\"currentColor\"` ensures icon color stays consistent with text color.\r\n\r\n### Comprehensive Accessibility Considerations\r\n\r\n```html\r\naria-label=\"Link to ${tocItem.text}\"\r\n```\r\n\r\n**Screen reader support**:\r\n\r\n`aria-label` provides link description information for visually impaired users.\r\n\r\n**Keyboard navigation friendliness**:\r\n\r\nAnchor links can be focused via Tab key and activated with Enter key, ensuring keyboard users can use them normally.\r\n\r\n## Complete Source Code Analysis\r\n\r\n### Style Injection Core Module\r\n\r\n```typescript\r\n// src/lib/utils/styleInject.ts\r\nimport markdownStyles from '../../../public/styles/markdown.json';\r\n\r\n/**\r\n * Main style injection function: Inject Tailwind CSS classes into HTML elements\r\n * Solves display issues after Preflight reset styles\r\n */\r\nexport function styleInject(htmlContent: string, translations?: any): string {\r\n    let styledContent = htmlContent;\r\n\r\n    // Step 1: Process code block enhancement functionality\r\n    styledContent = processCodeBlocks(styledContent, translations);\r\n\r\n    // Step 2: Inject style classes for other HTML tags\r\n    Object.entries(markdownStyles).forEach(([tag, classes]) =\u003e {\r\n        if (typeof classes === 'string' \u0026\u0026 classes.trim()) {\r\n            // Skip tags already processed by enhanced code blocks\r\n            if (tag === 'pre' || tag === 'code') {\r\n                return;\r\n            }\r\n\r\n            // Create regex for matching this tag\r\n            const tagRegex = new RegExp(`\u003c${tag}(\\\\s[^\u003e]*)?(?:\u003e|\\\\s*/\u003e)`, 'gi');\r\n\r\n            styledContent = styledContent.replace(tagRegex, (match) =\u003e {\r\n                // Prevent duplicate injection check\r\n                if (match.includes(classes.split(' ')[0])) {\r\n                    return match;\r\n                }\r\n\r\n                // Check if class attribute already exists\r\n                const classMatch = match.match(/class=[\"']([^\"']*)[\"']/);\r\n\r\n                if (classMatch) {\r\n                    // Merge existing class names\r\n                    const existingClasses = classMatch[1];\r\n                    const newClasses = classes.split(' ').filter(cls =\u003e !existingClasses.includes(cls)).join(' ');\r\n                    if (newClasses) {\r\n                        return match.replace(/class=[\"']([^\"']*)[\"']/, `class=\"$1 ${newClasses}\"`);\r\n                    }\r\n                    return match;\r\n                } else {\r\n                    // Add new class attribute\r\n                    if (match.endsWith('/\u003e')) {\r\n                        return match.replace(/\\s*\\/\u003e$/, ` class=\"${classes}\" /\u003e`);\r\n                    } else {\r\n                        return match.replace(/\u003e$/, ` class=\"${classes}\"\u003e`);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    return styledContent;\r\n}\r\n\r\n/**\r\n * Code block enhancement processing function\r\n * Converts regular code blocks into enhanced code blocks with copy functionality and theme support\r\n */\r\nexport function processCodeBlocks(htmlContent: string, translations?: any): string {\r\n    const preCodeRegex = /\u003cpre\u003e\u003ccode([^\u003e]*?)\u003e([\\s\\S]*?)\u003c\\/code\u003e\u003c\\/pre\u003e/g;\r\n    return htmlContent.replace(preCodeRegex, (match, attributes, content) =\u003e {\r\n        // Avoid duplicate processing\r\n        if (match.includes('data-enhanced-codeblock')) {\r\n            return match;\r\n        }\r\n\r\n        // Extract language information\r\n        const languageMatch = attributes.match(/class=[\"']([^\"']*language-([^\"'\\s]+)[^\"']*)[\"']/);\r\n        const language = languageMatch ? languageMatch[2] : '';\r\n\r\n        // Clean HTML entities\r\n        const cleanContent = content\r\n            .replace(/\u0026lt;/g, '\u003c')\r\n            .replace(/\u0026gt;/g, '\u003e')\r\n            .replace(/\u0026amp;/g, '\u0026')\r\n            .replace(/\u0026quot;/g, '\"')\r\n            .replace(/\u0026#x27;/g, \"'\");\r\n\r\n        // Get internationalization text\r\n        const copyText = translations?.codeblock?.copy || 'Copy';\r\n        const copyTooltip = translations?.codeblock?.copyTooltip || 'Copy code';\r\n\r\n        // Generate enhanced code block HTML structure\r\n        return `\r\n            \u003cdiv class=\"enhanced-codeblock relative mb-6 rounded-lg border bg-background border-gray-200 dark:border-gray-700 overflow-hidden shadow-sm\" data-enhanced-codeblock=\"true\" data-language=\"${language}\" data-code=\"${encodeURIComponent(cleanContent)}\"\u003e\r\n                \u003cdiv class=\"codeblock-header flex items-center justify-between px-4 py-2 bg-surface border-b border-gray-200 dark:border-gray-700\"\u003e\r\n                    \u003cspan class=\"codeblock-language text-xs font-medium uppercase tracking-wide text-foreground opacity-70\"\u003e${language || 'code'}\u003c/span\u003e\r\n                    \u003cbutton class=\"codeblock-copy-btn inline-flex items-center gap-1.5 px-2 py-1 text-xs font-medium border rounded transition-all duration-200 bg-background hover:bg-surface text-foreground hover:text-primary border-gray-300 dark:border-gray-600 hover:scale-105 active:scale-95\" title=\"${copyTooltip}\"\u003e\r\n                        \u003csvg class=\"copy-icon w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n                            \u003cpath d=\"M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z\" /\u003e\r\n                            \u003cpath d=\"M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z\" /\u003e\r\n                        \u003c/svg\u003e\r\n                        \u003csvg class=\"copied-icon w-4 h-4 hidden\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n                            \u003cpath fill-rule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clip-rule=\"evenodd\" /\u003e\r\n                        \u003c/svg\u003e\r\n                        \u003cspan class=\"copy-text\"\u003e${copyText}\u003c/span\u003e\r\n                    \u003c/button\u003e\r\n                \u003c/div\u003e\r\n                \u003cpre class=\"codeblock-content p-4 overflow-x-auto font-mono text-sm leading-relaxed bg-surface text-foreground\"\u003e\u003ccode${attributes}\u003e${content}\u003c/code\u003e\u003c/pre\u003e\r\n            \u003c/div\u003e\r\n        `;\r\n    });\r\n}\r\n\r\n/**\r\n * Extract table of contents structure\r\n */\r\nexport function extractTOC(htmlContent: string): Array\u003c{ id: string, text: string, level: number }\u003e {\r\n    const toc: Array\u003c{ id: string, text: string, level: number }\u003e = [];\r\n    const headingRegex = /\u003ch([1-6])(?:\\s[^\u003e]*)?\u003e[\\s\\S]*?\u003c\\/h[1-6]\u003e/gi;\r\n    let match;\r\n\r\n    while ((match = headingRegex.exec(htmlContent)) !== null) {\r\n        const level = parseInt(match[1]);\r\n        const fullMatch = match[0];\r\n        const tagContent = fullMatch.replace(/\u003ch[1-6](?:\\s[^\u003e]*)?\u003e|\u003c\\/h[1-6]\u003e/gi, '');\r\n\r\n        const text = tagContent\r\n            .replace(/\u003c[^\u003e]*\u003e/g, '')\r\n            .replace(/\u0026lt;/g, '\u003c')\r\n            .replace(/\u0026gt;/g, '\u003e')\r\n            .replace(/\u0026amp;/g, '\u0026')\r\n            .replace(/\u0026quot;/g, '\"')\r\n            .replace(/\u0026#x27;/g, \"'\")\r\n            .replace(/\u0026#39;/g, \"'\")\r\n            .replace(/\u0026nbsp;/g, ' ')\r\n            .replace(/\\s+/g, ' ')\r\n            .trim();\r\n\r\n        if (!text) continue;\r\n\r\n        let id = text\r\n            .toLowerCase()\r\n            .replace(/[^\\w\\s\\u00A0-\\uFFFF-]/g, '')\r\n            .replace(/\\s+/g, '-')\r\n            .replace(/-+/g, '-')\r\n            .replace(/^-+|-+$/g, '');\r\n\r\n        let uniqueId = id;\r\n        let counter = 1;\r\n        while (toc.some(item =\u003e item.id === uniqueId)) {\r\n            uniqueId = `${id}-${counter}`;\r\n            counter++;\r\n        }\r\n\r\n        if (text \u0026\u0026 uniqueId) {\r\n            toc.push({id: uniqueId, text, level});\r\n        }\r\n    }\r\n\r\n    return toc;\r\n}\r\n\r\n/**\r\n * Add anchor links to headings\r\n */\r\nexport function addHeadingAnchors(htmlContent: string): string {\r\n    const tocItems = extractTOC(htmlContent);\r\n    \r\n    if (tocItems.length === 0) {\r\n        return htmlContent;\r\n    }\r\n\r\n    const headingRegex = /\u003ch([1-6])(?:\\s[^\u003e]*)?\u003e[\\s\\S]*?\u003c\\/h[1-6]\u003e/gi;\r\n    let tocIndex = 0;\r\n\r\n    return htmlContent.replace(headingRegex, (match, level) =\u003e {\r\n        if (tocIndex \u003e= tocItems.length) return match;\r\n        if (match.includes(' id=')) return match;\r\n\r\n        const tocItem = tocItems[tocIndex];\r\n        tocIndex++;\r\n\r\n        const tag = `h${level}`;\r\n        const content = match.replace(/\u003ch[1-6](?:\\s[^\u003e]*)?\u003e|\u003c\\/h[1-6]\u003e/gi, '');\r\n\r\n        return `\u003c${tag} id=\"${tocItem.id}\" class=\"group relative\"\u003e\r\n            \u003ca href=\"#${tocItem.id}\" class=\"absolute -left-6 top-0 opacity-0 group-hover:opacity-100 transition-opacity text-primary/60 hover:text-primary\" aria-label=\"Link to ${tocItem.text}\"\u003e\r\n                \u003csvg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n                    \u003cpath fill-rule=\"evenodd\" d=\"M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 11.414-1.414 4 4 0 105.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 10-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z\" clip-rule=\"evenodd\" /\u003e\r\n                \u003c/svg\u003e\r\n            \u003c/a\u003e\r\n            ${content}\r\n        \u003c/${tag}\u003e`;\r\n    });\r\n}\r\n\r\n/**\r\n * Generate client-side interaction scripts\r\n * Includes copy functionality, theme switching, DOM monitoring, etc.\r\n */\r\nexport function getCodeBlockScript(translations?: any): string {\r\n    const copySuccessText = translations?.codeblock?.copySuccess || 'Code copied to clipboard!';\r\n    const copyErrorText = translations?.codeblock?.copyError || 'Failed to copy code';\r\n    \r\n    return `\r\n        \u003cscript\u003e\r\n            (function() {\r\n                // Theme CSS injection function\r\n                function injectThemeCSS() {\r\n                    const existingStyle = document.getElementById('codeblock-theme-styles');\r\n                    if (existingStyle) {\r\n                        existingStyle.remove();\r\n                    }\r\n                    \r\n                    const isDark = document.documentElement.classList.contains('dark');\r\n                    \r\n                    const themeStyles = \\`\r\n                        .enhanced-codeblock {\r\n                            background-color: var(--color-background) !important;\r\n                            border-color: \\${isDark ? '#374151' : '#e5e7eb'} !important;\r\n                        }\r\n                        .codeblock-header {\r\n                            background-color: var(--color-surface) !important;\r\n                            border-bottom-color: \\${isDark ? '#374151' : '#e5e7eb'} !important;\r\n                        }\r\n                        .codeblock-copy-btn {\r\n                            background-color: var(--color-background) !important;\r\n                            color: var(--color-foreground) !important;\r\n                        }\r\n                        .codeblock-copy-btn:hover {\r\n                            background-color: var(--color-surface) !important;\r\n                            color: var(--color-primary) !important;\r\n                        }\r\n                        .codeblock-content {\r\n                            background-color: var(--color-surface) !important;\r\n                            color: var(--color-foreground) !important;\r\n                        }\r\n                    \\`;\r\n                    \r\n                    const styleElement = document.createElement('style');\r\n                    styleElement.id = 'codeblock-theme-styles';\r\n                    styleElement.textContent = themeStyles;\r\n                    document.head.appendChild(styleElement);\r\n                }\r\n                \r\n                // Copy functionality initialization\r\n                function initializeCodeBlocks() {\r\n                    const codeBlocks = document.querySelectorAll('.enhanced-codeblock');\r\n                    \r\n                    codeBlocks.forEach(function(block, blockIndex) {\r\n                        const copyBtn = block.querySelector('.codeblock-copy-btn');\r\n                        if (!copyBtn || copyBtn.hasAttribute('data-initialized')) return;\r\n                        \r\n                        copyBtn.setAttribute('data-initialized', 'true');\r\n                        \r\n                        copyBtn.addEventListener('click', async function(e) {\r\n                            e.preventDefault();\r\n                            \r\n                            try {\r\n                                let code = block.getAttribute('data-code');\r\n                                if (code) {\r\n                                    code = decodeURIComponent(code);\r\n                                } else {\r\n                                    const codeElement = block.querySelector('pre code');\r\n                                    if (codeElement) {\r\n                                        code = codeElement.textContent || '';\r\n                                    }\r\n                                }\r\n                                \r\n                                // Copy to clipboard\r\n                                if (navigator.clipboard \u0026\u0026 navigator.clipboard.writeText) {\r\n                                    await navigator.clipboard.writeText(code);\r\n                                } else {\r\n                                    // Fallback solution\r\n                                    const textArea = document.createElement('textarea');\r\n                                    textArea.value = code;\r\n                                    textArea.style.position = 'fixed';\r\n                                    textArea.style.left = '-999999px';\r\n                                    document.body.appendChild(textArea);\r\n                                    textArea.select();\r\n                                    document.execCommand('copy');\r\n                                    textArea.remove();\r\n                                }\r\n                                \r\n                                showToast('${copySuccessText}', 'success');\r\n                                \r\n                            } catch (err) {\r\n                                showToast('${copyErrorText}', 'error');\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                \r\n                // Toast notification system\r\n                function showToast(message, type = 'success') {\r\n                    const existingToasts = document.querySelectorAll('.copy-toast');\r\n                    existingToasts.forEach(toast =\u003e toast.remove());\r\n                    \r\n                    const toast = document.createElement('div');\r\n                    toast.className = 'copy-toast fixed top-4 right-4 z-[9999] px-4 py-2 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full opacity-0';\r\n                    \r\n                    if (type === 'success') {\r\n                        toast.className += ' bg-green-500 text-white';\r\n                    } else {\r\n                        toast.className += ' bg-red-500 text-white';\r\n                    }\r\n                    \r\n                    toast.textContent = message;\r\n                    document.body.appendChild(toast);\r\n                    \r\n                    setTimeout(() =\u003e {\r\n                        toast.classList.remove('translate-x-full', 'opacity-0');\r\n                    }, 10);\r\n                    \r\n                    setTimeout(() =\u003e {\r\n                        toast.classList.add('translate-x-full', 'opacity-0');\r\n                        setTimeout(() =\u003e toast.remove(), 300);\r\n                    }, 3000);\r\n                }\r\n                \r\n                // Initialization and monitoring\r\n                if (document.readyState === 'loading') {\r\n                    document.addEventListener('DOMContentLoaded', function() {\r\n                        initializeCodeBlocks();\r\n                        injectThemeCSS();\r\n                    });\r\n                } else {\r\n                    initializeCodeBlocks();\r\n                    injectThemeCSS();\r\n                }\r\n                \r\n                // Theme change monitoring\r\n                const observer = new MutationObserver(function(mutations) {\r\n                    mutations.forEach(function(mutation) {\r\n                        if (mutation.type === 'attributes' \u0026\u0026 \r\n                            mutation.attributeName === 'class' \u0026\u0026 \r\n                            mutation.target === document.documentElement) {\r\n                            setTimeout(injectThemeCSS, 10);\r\n                        }\r\n                    });\r\n                });\r\n                \r\n                observer.observe(document.documentElement, {\r\n                    attributes: true,\r\n                    attributeFilter: ['class']\r\n                });\r\n            })();\r\n        \u003c/script\u003e\r\n    `;\r\n}\r\n```\r\n\r\n### Style Configuration File\r\n\r\n```json\r\n// public/styles/markdown.json\r\n{\r\n  \"h1\": \"text-4xl font-bold mt-8 mb-4 text-foreground leading-tight\",\r\n  \"h2\": \"text-3xl font-semibold mt-6 mb-3 text-foreground leading-tight\",\r\n  \"h3\": \"text-2xl font-semibold mt-5 mb-2 text-foreground leading-snug\",\r\n  \"h4\": \"text-xl font-medium mt-4 mb-2 text-foreground leading-snug\",\r\n  \"p\": \"text-base leading-7 mb-4 text-foreground\",\r\n  \"code\": \"bg-surface text-primary px-1.5 py-0.5 rounded text-sm font-mono\",\r\n  \"pre\": \"bg-surface text-foreground p-4 rounded-lg overflow-x-auto mb-4 font-mono text-sm leading-relaxed border border-gray-200\",\r\n  \"ul\": \"list-disc list-inside mb-4 pl-6 space-y-2\",\r\n  \"ol\": \"list-decimal list-inside mb-4 pl-6 space-y-2\", \r\n  \"li\": \"text-foreground leading-relaxed\",\r\n  \"strong\": \"font-bold text-foreground\",\r\n  \"em\": \"italic text-foreground\",\r\n  \"a\": \"text-primary hover:text-accent underline transition-colors duration-200\",\r\n  \"img\": \"max-w-full h-auto rounded-lg shadow-sm my-4 mx-auto block\",\r\n  \"table\": \"w-full border-collapse mb-4 shadow-sm rounded-lg overflow-hidden\",\r\n  \"th\": \"px-4 py-3 text-left text-xs font-medium text-foreground uppercase tracking-wider bg-surface\",\r\n  \"td\": \"px-4 py-3 text-sm text-foreground\",\r\n  \"blockquote\": \"border-l-4 border-primary pl-4 py-2 my-4 bg-surface text-foreground italic\",\r\n  \"hr\": \"border-0 h-px bg-gray-300 my-8\"\r\n}\r\n```\r\n\r\n### Server-Side Rendering Integration\r\n\r\n```typescript\r\n// src/app/documents/[...slug]/page.tsx\r\nexport default async function DocumentPage({params}: PageProps) {\r\n    try {\r\n        const {slug} = await params;\r\n        const [lang, category, fileName] = slug;\r\n        const {content, frontMatter, readingTime} = getArticlesData(fileName, lang, false, category);\r\n\r\n        // Configure Remarkable parser\r\n        const md = new Remarkable({\r\n            html: true,\r\n            breaks: true,\r\n            typographer: true,\r\n            highlight: function (str: string, lang: string) {\r\n                if (lang \u0026\u0026 hljs.getLanguage(lang)) {\r\n                    try {\r\n                        return hljs.highlight(str, {language: lang}).value;\r\n                    } catch (err) {}\r\n                }\r\n                try {\r\n                    return hljs.highlightAuto(str).value;\r\n                } catch (err) {}\r\n                return '';\r\n            }\r\n        })\r\n        .use(linkify)\r\n        .use(rkatex, {delimiter: '$'});\r\n\r\n        let htmlContent = md.render(content, frontMatter);\r\n\r\n        // Load internationalization text\r\n        let translations = null;\r\n        try {\r\n            const translationsPath = path.join(process.cwd(), 'public', 'locales', lang, 'common.json');\r\n            if (fs.existsSync(translationsPath)) {\r\n                translations = JSON.parse(fs.readFileSync(translationsPath, 'utf8'));\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to load translations:', error);\r\n        }\r\n\r\n        // Processing pipeline: Extract TOC → Add anchors → Style injection\r\n        const tocItems = extractTOC(htmlContent);\r\n        htmlContent = addHeadingAnchors(htmlContent);\r\n        htmlContent = styleInject(htmlContent, translations);\r\n\r\n        return (\r\n            \u003cDocumentPageClient\r\n                htmlContent={htmlContent}\r\n                frontMatter={frontMatter}\r\n                readingTime={readingTime}\r\n                category={category}\r\n                tocItems={tocItems}\r\n                translations={translations}\r\n                lang={lang}\r\n            /\u003e\r\n        );\r\n    } catch (error) {\r\n        console.error('Error rendering document:', error);\r\n        notFound();\r\n    }\r\n}\r\n```\r\n\r\n### Client Component Integration\r\n\r\n```typescript\r\n// src/app/documents/[...slug]/DocumentPageClient.tsx\r\nexport function DocumentPageClient({\r\n    htmlContent,\r\n    frontMatter,\r\n    readingTime,\r\n    category,\r\n    tocItems,\r\n    translations,\r\n    lang\r\n}: DocumentPageClientProps) {\r\n    const {t} = useTranslation();\r\n    const [formattedDate, setFormattedDate] = useState\u003cstring\u003e('');\r\n\r\n    // Inject client-side interaction scripts\r\n    useEffect(() =\u003e {\r\n        const codeBlockScript = getCodeBlockScript(translations);\r\n        const tempDiv = document.createElement('div');\r\n        tempDiv.innerHTML = codeBlockScript;\r\n        const scriptElement = tempDiv.querySelector('script');\r\n        \r\n        if (scriptElement) {\r\n            const newScript = document.createElement('script');\r\n            newScript.textContent = scriptElement.textContent;\r\n            document.head.appendChild(newScript);\r\n            \r\n            return () =\u003e {\r\n                if (document.head.contains(newScript)) {\r\n                    document.head.removeChild(newScript);\r\n                }\r\n            };\r\n        }\r\n    }, [translations]);\r\n\r\n    return (\r\n        \u003c\u003e\r\n            \u003cdiv className=\"relative z-30 min-h-screen bg-background\"\u003e\r\n                \u003cdiv className=\"container mx-auto px-4 py-8 max-w-4xl\"\u003e\r\n                    \u003carticle className=\"prose max-w-none\"\u003e\r\n                        \u003cdiv \r\n                            className=\"prose-pre:p-4 prose-pre:bg-surface w-full\"\r\n                            dangerouslySetInnerHTML={{__html: htmlContent}}\r\n                        /\u003e\r\n                    \u003c/article\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n            \u003cTableOfContents tocItems={tocItems}/\u003e\r\n        \u003c/\u003e\r\n    );\r\n}\r\n```\r\n\r\n### Core Algorithm Flow Chart\r\n\r\n```\r\nMDX Input → Remarkable Parsing → Style Injection System → Enhanced HTML Output\r\n    ↓           ↓                    ↓                      ↓\r\nOriginal      HTML String       Style Class Injection   Complete Rendering\r\nSyntax            ↓                    ↓                      ↓\r\n    ↓        Code Block         Theme Adaptation       Interactive Features\r\nSyntax        Recognition            ↓                      ↓\r\nHighlighting      ↓             Client Scripts        User Experience\r\n    ↓        Anchor Generation       ↓                      ↓\r\nTOC Extraction    ↓             Copy Functionality    Accessibility\r\n```\r\n\r\n### Key Implementation Principles Summary\r\n\r\n**1. Regex-Driven Style Injection**\r\n- Precisely match HTML tag opening parts\r\n- Intelligently handle existing class attribute merging\r\n- Support special handling of self-closing tags\r\n\r\n**2. Three-Layer Architecture for Code Block Enhancement**\r\n- HTML Structure Layer: Semantic enhanced code blocks\r\n- Style Layer: Dynamic theme-adaptive CSS\r\n- Interaction Layer: Copy functionality and user feedback\r\n\r\n**3. Text Processing Algorithm for TOC Generation**\r\n- Accurate extraction of multi-line content\r\n- Complete HTML entity decoding\r\n- URL-safe ID generation strategy\r\n\r\n**4. Memory Management in Client Scripts**\r\n- Global state tracking to prevent duplicate listeners\r\n- Automatic cleanup mechanism to avoid memory leaks\r\n- Debounce optimization to reduce unnecessary re-initialization\r\n\r\n## Conclusion\r\n\r\nThe overall implementation of the style injection solution is not actually complex, and the approach is relatively simple. But as the saying goes: *\"Simplicity is the ultimate sophistication.\"* Behind the complex technical implementation, the style injection system presents users with a simple, beautiful, and easy-to-use document experience.\r\n\r\n*May your documents shine like works of art, radiating brilliant light in the digital age with the power of style injection.* ✨"])</script><script>self.__next_f.push([1,"25:Tb5ce,"])</script><script>self.__next_f.push([1,"\n# Remarkable KaTeX Plus Plugin Code Analysis\n\n**Plugin Version: v1.1.2**\n\nThis article will provide a line-by-line analysis of the `remarkable-katex-plus` plugin code, including the main plugin file `index.js` and test file `index.test.js`. This analysis not only explains the purpose of each line of code but also provides detailed explanations of all non-JavaScript standard library functions, their usage, and principles.\n\n## Overview\n\n`remarkable-katex-plus` is a plugin for the Remarkable Markdown processor that can convert `$...$` and `$$..$$` sequences into mathematical formula HTML rendered using the KaTeX package.\n\n## Dependency Library Functions\n\nBefore diving into the code analysis, let's first understand the main non-standard library functions used by this plugin:\n\n### Node.js Related Functions\n- **`require(moduleName)`**: Node.js module loading function, used to import external modules or libraries\n  - **Parameters**: \n    - `moduleName` (string): Module name or path string\n  - **Return value**: Imported module object or function\n  - **Usage examples**:\n    ```javascript\n    // Import external npm package\n    const katex = require('katex');\n    \n    // Import local file module\n    const plugin = require('./index.js');\n    \n    // Use destructuring syntax to import specific exports\n    const { Remarkable } = require('remarkable');\n    ```\n- **`module.exports`**: Node.js module export object, used to provide module functionality to external modules\n  - **Parameters**: None (this is a property, not a function)\n  - **Return value**: None\n  - **Usage examples**:\n    ```javascript\n    // Export single function\n    module.exports = rkatex;\n    \n    // Export object containing multiple functions\n    module.exports = { renderKatex, parseInlineKatex };\n    ```\n\n### KaTeX Library Functions\n- **`katex.renderToString(expression, options)`**: KaTeX core rendering function\n  - **Parameters**:\n    - `expression` (string): LaTeX mathematical expression string to render\n    - `options` (Object): Rendering options object, containing the following optional configurations:\n      - `displayMode` (boolean): Whether to use block display mode, default false\n      - `throwOnError` (boolean): Whether to throw exception on error, default true\n      - `errorColor` (string): Error text color, default '#cc0000'\n      - `macros` (Object): Custom macro definitions\n      - `strict` (boolean): Whether to use strict mode, default true\n  - **Return value**: Rendered HTML string\n  - **Usage examples**:\n    ```javascript\n    // Render inline mathematical formula\n    const inlineHtml = katex.renderToString('x^2 + y^2 = z^2', {\n      displayMode: false,    // Inline mode\n      throwOnError: false    // Don't throw exception on error\n    });\n    \n    // Render block mode fraction formula\n    const blockHtml = katex.renderToString('\\\\frac{a}{b}', {\n      displayMode: true,     // Block display mode\n      throwOnError: false,   // Don't throw exception on error\n      errorColor: '#ff0000'  // Custom error color to red\n    });\n    ```\n\n### Remarkable Parser State Object Properties\n- **`state.bMarks[line]`**: Array of beginning markers for each line (begin marks)\n  - **Type**: Array\u003cnumber\u003e\n  - **Description**: Stores the character index of the beginning position of each line (excluding leading spaces)\n  - **Usage examples**:\n    ```javascript\n    // Get the beginning position index of the first line\n    const lineStart = state.bMarks[0];\n    ```\n- **`state.tShift[line]`**: Array of leading spaces for each line (tab shift)\n  - **Type**: Array\u003cnumber\u003e\n  - **Description**: Stores the indentation amount (number of spaces and tabs) for each line\n  - **Usage examples**:\n    ```javascript\n    // Get the indentation amount (number of spaces) of the first line\n    const indent = state.tShift[0];\n    ```\n- **`state.eMarks[line]`**: Array of ending markers for each line (end marks)\n  - **Type**: Array\u003cnumber\u003e\n  - **Description**: Stores the character index of the ending position of each line\n  - **Usage examples**:\n    ```javascript\n    // Get the ending position index of the first line\n    const lineEnd = state.eMarks[0];\n    ```\n- **`state.src`**: Complete source text string\n  - **Type**: string\n  - **Description**: Contains the entire Markdown text to be parsed\n  - **Usage examples**:\n    ```javascript\n    // Get the character at the specified position\n    const char = state.src.charAt(pos);\n    ```\n- **`state.pos`**: Current parsing position\n  - **Type**: number\n  - **Description**: Current position index of the parser in the source text\n  - **Usage examples**:\n    ```javascript\n    // Update current parsing position\n    state.pos = newPos;\n    ```\n- **`state.posMax`**: Maximum parsing position\n  - **Type**: number\n  - **Description**: Maximum position index that the parser can handle\n  - **Usage examples**:\n    ```javascript\n    // Check if reaching the end of parsing\n    if (state.pos \u003e= state.posMax) { \n      return false; \n    }\n    ```\n- **`state.level`**: Current nesting level\n  - **Type**: number\n  - **Description**: Nesting depth of the current parsing element\n  - **Usage examples**:\n    ```javascript\n    // Get the nesting level of the current element\n    const tokenLevel = state.level;\n    ```\n- **`state.line`**: Current line number\n  - **Type**: number\n  - **Description**: Line number currently being processed by the parser (starting from 0)\n  - **Usage examples**:\n    ```javascript\n    // Update the current line number being processed\n    state.line = nextLine;\n    ```\n- **`state.blkIndent`**: Block-level element indentation amount\n  - **Type**: number\n  - **Description**: Indentation amount of the current block-level element\n  - **Usage examples**:\n    ```javascript\n    // Get the indentation amount of the current block-level element\n    const blockIndent = state.blkIndent;\n    ```\n\n### Remarkable Parser State Methods\n- **`state.skipChars(pos, char)`**: Skip consecutive identical characters from the specified position\n  - **Parameters**:\n    - `pos` (number): Starting position index\n    - `char` (string): Character to skip\n  - **Return value**: (number) New position index after skipping consecutive characters\n  - **Usage examples**:\n    ```javascript\n    // Skip consecutive $ characters starting from position 0\n    const pos = state.skipChars(0, '$');\n    ```\n- **`state.skipSpaces(pos)`**: Skip space characters from the specified position\n  - **Parameters**:\n    - `pos` (number): Starting position index\n  - **Return value**: (number) Position index after skipping spaces and tabs\n  - **Usage examples**:\n    ```javascript\n    // Skip spaces and tabs from the current position\n    const newPos = state.skipSpaces(pos);\n    ```\n- **`state.getLines(startLine, endLine, indent, keepLastLF)`**: Get text from the specified line range\n  - **Parameters**:\n    - `startLine` (number): Starting line number (inclusive)\n    - `endLine` (number): Ending line number (exclusive)\n    - `indent` (number): Indentation amount to remove\n    - `keepLastLF` (boolean): Whether to keep the last line feed\n  - **Return value**: (string) Extracted text string\n  - **Usage examples**:\n    ```javascript\n    // Get content from lines 1-4, no indentation removal, keep line feeds\n    const content = state.getLines(1, 5, 0, true);\n    ```\n- **`state.push(token)`**: Add a new token object to the tokens array\n  - **Parameters**:\n    - `token` (Object): Token object to add\n  - **Return value**: None\n  - **Usage examples**:\n    ```javascript\n    // Add inline math formula token\n    state.push({ \n      type: 'katex',          // Token type\n      content: 'x^2',         // Math expression content\n      block: false,           // Inline mode\n      level: state.level      // Current nesting level\n    });\n    ```\n- **`state.tokens.push(token)`**: Directly add token to the tokens array\n  - **Parameters**:\n    - `token` (Object): Token object to add\n  - **Return value**: (number) New length of the array\n  - **Usage examples**:\n    ```javascript\n    // Directly add block math formula token to tokens array\n    state.tokens.push({\n      type: 'katex',            // Token type\n      content: '\\\\frac{a}{b}',  // LaTeX fraction expression\n      block: true,              // Block mode\n      level: state.level        // Current nesting level\n    });\n    ```\n\n### Remarkable Plugin API\n- **`md.inline.ruler.push(name, fn, options)`**: Register inline parsing rules\n  - **Parameters**:\n    - `name` (string): Rule name for identifying the parsing rule\n    - `fn` (function): Parsing function that receives state and silent parameters\n    - `options` (Object): Parsing options (optional)\n  - **Return value**: None\n  - **Usage examples**:\n    ```javascript\n    // Register inline KaTeX parsing rule\n    md.inline.ruler.push('katex', parseInlineKatex, {\n      alt: ['paragraph', 'text']  // Optional alternative rules\n    });\n    ```\n- **`md.block.ruler.push(name, fn, options)`**: Register block-level parsing rules\n  - **Parameters**:\n    - `name` (string): Rule name for identifying the parsing rule\n    - `fn` (function): Parsing function that receives state, startLine, and endLine parameters\n    - `options` (Object): Parsing options (optional)\n  - **Return value**: None\n  - **Usage examples**:\n    ```javascript\n    // Register block-level KaTeX parsing rule\n    md.block.ruler.push('katex', parseBlockKatex, {\n      alt: ['paragraph', 'blockquote']  // Optional alternative rules\n    });\n    ```\n- **`md.renderer.rules[name]`**: Rendering rules object, used to define how tokens are converted to HTML\n  - **Parameters**:\n    - `name` (string): Token type name\n  - **Return value**: Rendering function\n  - **Usage examples**:\n    ```javascript\n    // Define rendering rule for KaTeX tokens\n    md.renderer.rules.katex = function(tokens, idx) {\n      const token = tokens[idx];  // Get current token\n      // Call KaTeX rendering function\n      return renderKatex(token.content, token.block);\n    };\n    ```\n- **`md.use(plugin, options)`**: Use plugin\n  - **Parameters**:\n    - `plugin` (function): Plugin function\n    - `options` (Object): Plugin options (optional)\n  - **Return value**: Remarkable instance (supports method chaining)\n  - **Usage examples**:\n    ```javascript\n    // Create Remarkable instance and use KaTeX plugin\n    const md = new Remarkable();\n    md.use(katexPlugin, { \n      delimiter: '$',         // Use $ as delimiter\n      throwOnError: false     // Don't throw exception on error\n    });\n    ```\n- **`md.render(markdown)`**: Render Markdown text to HTML\n  - **Parameters**:\n    - `markdown` (string): Markdown text to render\n  - **Return value**: (string) Rendered HTML string\n  - **Usage examples**:\n    ```javascript\n    // Render Markdown text containing inline math formula\n    const html = md.render('This is $x^2$ inline math.');\n    ```\n\n### Testing Framework Functions\n- **`vows.describe(name)`**: Create test suite\n  - **Parameters**:\n    - `name` (string): Test suite name\n  - **Return value**: Test suite object\n  - **Usage examples**:\n    ```javascript\n    // Create test suite named 'KatexPlugin'\n    vows.describe('KatexPlugin').addBatch({\n      'Test case 1': {\n        topic: function() { /* Prepare test data */ },\n        'should work': function(topic) { /* Verify result */ }\n      }\n    });\n    ```\n- **`addBatch(tests)`**: Add test batch\n  - **Parameters**:\n    - `tests` (Object): Test cases object\n  - **Return value**: Test suite object (supports method chaining)\n  - **Usage examples**:\n    ```javascript\n    // Add test batch to test suite\n    suite.addBatch({\n      'Basic functionality': {\n        topic: 'test data',                    // Test topic data\n        'should pass': function(topic) {       // Assertion test\n          assert.equal(topic, 'test data');   // Verify equality\n        }\n      }\n    });\n    ```\n- **`assert.*`**: Various assertion methods from Node.js assertion library\n  - **Common methods**:\n    - `assert.equal(actual, expected)`: Strict equality comparison\n    - `assert.isTrue(value)`: Check if value is true\n    - `assert.notEqual(actual, unexpected)`: Check if values are not equal\n    - `assert.throws(fn)`: Check if function throws exception\n    - `assert.isObject(value)`: Check if value is an object\n  - **Usage examples**:\n    ```javascript\n    // Verify result equals expected value\n    assert.equal(result, '\u003cp\u003etest\u003c/p\u003e');\n    \n    // Verify HTML contains KaTeX element\n    assert.isTrue(html.includes('\u003cspan class=\"katex\"\u003e'));\n    \n    // Verify function throws exception\n    assert.throws(function() { throw new Error(); });\n    ```\n\n---\n\n## index.js Code Line-by-Line Analysis\n\n### File Header and Module Declaration\n\n```javascript\n\"use strict\";\n```\n**Line 1**: Use strict mode to ensure the code runs in a strict JavaScript environment, helping to catch common programming errors and improve code quality.\n\n```javascript\n/**\n * Plugin for Remarkable Markdown processor which transforms $..$ and $$..$$ sequences into math HTML using the\n * Katex package.\n */\n```\n**Lines 3-6**: JSDoc comment describing the plugin's purpose: provides plugin functionality for the Remarkable Markdown processor, converting mathematical formula markers to KaTeX-rendered HTML.\n\n```javascript\nconst rkatex = (md, options) =\u003e {\n```\n**Line 7**: Define the main function `rkatex`, which accepts two parameters:\n- `md`: Remarkable instance\n- `options`: Configuration options object\n\n### Basic Configuration and Variable Declaration\n\n```javascript\n  const backslash = '\\\\';\n  const dollar = '$';\n```\n**Lines 8-9**: Define constant characters:\n- `backslash`: Backslash character, used for escaping\n- `dollar`: Dollar sign, default mathematical formula delimiter\n\n```javascript\n  const opts = options || {};\n  const delimiter = opts.delimiter || dollar;\n```\n**Lines 10-11**: Process configuration options:\n- `opts`: Ensure options exists, use empty object if null\n- `delimiter`: Get delimiter from options, default to dollar sign\n\n```javascript\n  if (delimiter.length !== 1) { throw new Error('invalid delimiter'); }\n```\n**Line 12**: Validate delimiter length, only allow single character delimiters, otherwise throw error.\n\n### Utility Module Import and Styling Configuration\n\n```javascript\n  // Import styling utilities\n  const { applyCustomStyling } = require('./utils');\n```\n**Lines 14-15**: Import custom styling processing function from utils module.\n- **`require('./utils')`**: Node.js module loading function, relative path loads utils.js file in same directory\n- **Destructuring assignment**: Extract applyCustomStyling function from utils module\n\n```javascript\n  // Extract styling configuration (kept for backward compatibility)\n  const stylingConfig = {\n    useTailwind: opts.useTailwind || false,\n    // Add other styling options here as needed\n  };\n```\n**Lines 17-21**: Create styling configuration object:\n- `useTailwind`: Whether to use Tailwind CSS, default false\n- Preserve backward compatibility, can add other styling options\n\n```javascript\n  const katex = require(\"katex\");\n```\n**Line 23**: Import KaTeX library for mathematical formula rendering.\n- **`require(\"katex\")`**: Load KaTeX npm package, a fast mathematical formula rendering library\n- **KaTeX**: JavaScript mathematical formula rendering library developed by Khan Academy, supports LaTeX syntax\n\n### KaTeX Rendering Function\n\n```javascript\n  /**\n   * Render the contents as KaTeX\n   */\n  const renderKatex = (source, displayMode) =\u003e {\n```\n**Lines 25-28**: Define KaTeX rendering function, accepting source content and display mode parameters.\n\n```javascript\n    const rendered = katex.renderToString(source, {\n      displayMode: displayMode,\n      throwOnError: false\n    });\n```\n**Lines 29-32**: Use KaTeX to render mathematical formulas:\n- **`katex.renderToString()`**: KaTeX core rendering function, converts LaTeX expressions to HTML strings\n  - `source`: Input LaTeX mathematical expression string\n  - `options`: Rendering configuration object\n- `displayMode`: Boolean value, true uses block display mode (centered, large font), false uses inline mode\n- `throwOnError: false`: Don't throw exceptions on LaTeX syntax errors, instead render error messages\n\n```javascript\n    // Always apply custom styling to process aria-hidden elements\n    return applyCustomStyling(rendered, stylingConfig);\n```\n**Lines 34-35**: Apply custom styling processing to rendered results, especially for aria-hidden elements.\n\n### Block-level KaTeX Parsing Function\n\n```javascript\n  /**\n   * Parse '$$' as a block. Based off of similar method in remarkable.\n   */\n  const parseBlockKatex = (state, startLine, endLine) =\u003e {\n```\n**Lines 39-42**: Define block-level KaTeX parsing function, based on similar methods in Remarkable.\n\n```javascript\n    let haveEndMarker = false;\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n```\n**Lines 43-45**: Initialize parsing state:\n- `haveEndMarker`: Boolean flag, tracks whether matching end marker is found\n- **`state.bMarks[startLine]`**: Remarkable state object property, get starting character position of specified line (excluding leading spaces)\n- **`state.tShift[startLine]`**: Remarkable state object property, get leading space/tab count of specified line\n- `pos`: Calculated actual parsing starting position (position after skipping leading spaces)\n- **`state.eMarks[startLine]`**: Remarkable state object property, get ending character position of specified line\n\n```javascript\n    if (pos + 1 \u003e max) { return false; }\n```\n**Line 47**: Check if there are enough characters to form a marker, return false if not enough.\n\n```javascript\n    const marker = state.src.charAt(pos);\n    if (marker !== delimiter) { return false; }\n```\n**Lines 49-50**: Check if current character is delimiter, return false if not.\n\n```javascript\n    // scan marker length\n    let mem = pos;\n    pos = state.skipChars(pos, marker);\n    let len = pos - mem;\n```\n**Lines 52-55**: Scan marker length:\n- `mem`: Remember starting position for subsequent length calculation\n- **`state.skipChars(pos, marker)`**: Remarkable state method, skip consecutive identical characters from specified position\n  - `pos`: Starting position\n  - `marker`: Character to skip (here delimiter, like '$')\n  - Return value: New position after skipping consecutive characters\n- `len`: Calculate marker length (number of consecutive delimiters)\n\n```javascript\n    if (len !== 2) { return false; }\n```\n**Line 57**: Block-level formulas need exactly two delimiters (like $$), otherwise return false.\n\n```javascript\n    // search end of block\n    let nextLine = startLine;\n\n    for (; ;) {\n      ++nextLine;\n      if (nextLine \u003e= endLine) { break; }\n```\n**Lines 59-64**: Start searching for block end marker, iterate through subsequent lines.\n\n```javascript\n      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos \u003c max \u0026\u0026 state.tShift[nextLine] \u003c state.blkIndent) { break; }\n      if (state.src.charAt(pos) !== delimiter) { continue; }\n      if (state.tShift[nextLine] - state.blkIndent \u003e= 4) { continue; }\n```\n**Lines 66-71**: Check each line:\n- Calculate current line position information\n- Check if indentation is appropriate\n- Check if it starts with delimiter\n- Check if indentation exceeds 4 spaces (code block rule)\n\n```javascript\n      pos = state.skipChars(pos, marker);\n      if (pos - mem \u003c len) { continue; }\n\n      pos = state.skipSpaces(pos);\n      if (pos \u003c max) { continue; }\n\n      haveEndMarker = true;\n      break;\n```\n**Lines 73-80**: Validate end marker:\n- **`state.skipChars(pos, marker)`**: Skip consecutive delimiter characters\n- Check if number of skipped characters matches starting marker length\n- **`state.skipSpaces(pos)`**: Remarkable state method, skip spaces and tabs from specified position\n  - `pos`: Starting position\n  - Return value: New position after skipping spaces\n- If there's other content on the line after skipping spaces, it's not a valid end marker\n- Found valid end marker, set flag and exit loop\n\n```javascript\n    // Only process if we found a complete block (with end marker)\n    if (!haveEndMarker) { return false; }\n```\n**Lines 83-84**: Only continue processing if complete block (with end marker) is found.\n\n```javascript\n    // If a fence has heading spaces, they should be removed from its inner block\n    len = state.tShift[startLine];\n    state.line = nextLine + 1; // Always advance past the end marker\n    const content = state.getLines(startLine + 1, nextLine, len, true)\n      .replace(/[ \\n]+/g, ' ')\n      .trim();\n```\n**Lines 86-91**: Extract block content:\n- Record starting line indentation for consistent indentation processing in subsequent content extraction\n- **`state.line`**: Update Remarkable state object's current line number, skip end marker line\n- **`state.getLines(startLine + 1, nextLine, len, true)`**: Remarkable state method, extract text from specified line range\n  - `startLine + 1`: Start from next line after starting marker (skip starting $$ line)\n  - `nextLine`: End at end marker line (exclude ending $$ line)\n  - `len`: Indentation amount to remove (consistent with starting line indentation)\n  - `true`: Keep final line feed\n- **`.replace(/[ \\n]+/g, ' ')`**: Use regex to replace multiple consecutive spaces and line feeds with single space\n- **`.trim()`**: Remove leading and trailing whitespace characters\n\n```javascript\n    state.tokens.push({\n      type: 'katex', params: null, content: content, lines: [startLine, state.line],\n      level: state.level, block: true\n    });\n    return true;\n```\n**Lines 93-97**: Create and add token:\n- **`state.tokens.push()`**: Add new token object to Remarkable state object's tokens array\n- **Token object structure**:\n  - `type: 'katex'`: Specify token type for subsequent renderer identification\n  - `params: null`: Additional parameters (empty here)\n  - `content: content`: Extracted LaTeX mathematical expression content\n  - `lines: [startLine, state.line]`: Record token's line number range in source document\n  - `level: state.level`: Current nesting level\n  - `block: true`: Mark as block-level element (distinguish from inline elements)\n- `return true`: Return true to indicate successful parsing and processing of this block\n\n### Inline KaTeX Parsing Function\n\n```javascript\n  /**\n   * Look for '$' or '$$' spans in Markdown text. Based off of the 'fenced' parser in remarkable.\n   */\n  const parseInlineKatex = (state, silent) =\u003e {\n```\n**Lines 101-104**: Define inline KaTeX parsing function, based on Remarkable's fenced parser.\n\n```javascript\n    const start = state.pos;\n    const max = state.posMax;\n    let pos = start;\n\n    // Unexpected starting character\n    if (state.src.charAt(pos) !== delimiter) { return false; }\n```\n**Lines 105-110**: Initialize parsing state and check if starting character is delimiter.\n\n```javascript\n    ++pos;\n    while (pos \u003c max \u0026\u0026 state.src.charAt(pos) === delimiter) { ++pos; }\n\n    // Capture the length of the starting delimiter -- closing one must match in size\n    const marker = state.src.slice(start, pos);\n    if (marker.length \u003e 2) { return false; }\n```\n**Lines 112-117**: Scan starting marker:\n- Skip first delimiter\n- Continue skipping consecutive delimiters\n- Record marker content\n- Limit marker length to no more than 2 ($ or $$)\n\n```javascript\n    const spanStart = pos;\n    let escapedDepth = 0;\n```\n**Lines 119-120**: Initialize content parsing:\n- `spanStart`: Record content starting position\n- `escapedDepth`: Track brace nesting depth\n\n```javascript\n    while (pos \u003c max) {\n      const char = state.src.charAt(pos);\n      if (char === '{' \u0026\u0026 (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth += 1;\n      } else if (char === '}' \u0026\u0026 (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\n        escapedDepth -= 1;\n        if (escapedDepth \u003c 0) { return false; }\n```\n**Lines 121-127**: Handle brace nesting:\n- Increase depth when encountering unescaped `{`\n- Decrease depth when encountering unescaped `}`\n- If depth is negative, brackets don't match\n\n```javascript\n      } else if (char === delimiter \u0026\u0026 escapedDepth === 0) {\n        const matchStart = pos;\n        let matchEnd = pos + 1;\n        while (matchEnd \u003c max \u0026\u0026 state.src.charAt(matchEnd) === delimiter) { ++matchEnd; }\n\n        if (matchEnd - matchStart === marker.length) {\n```\n**Lines 128-133**: Look for matching end marker:\n- Only consider delimiters when braces are balanced\n- Calculate consecutive delimiter length\n- Check if length matches starting marker\n\n```javascript\n          if (!silent) {\n            const content = state.src.slice(spanStart, matchStart)\n              .replace(/[ \\n]+/g, ' ')\n              .trim();\n            state.push({ type: 'katex', content: content, block: marker.length \u003e 1, level: state.level });\n          }\n          state.pos = matchEnd;\n          return true;\n```\n**Lines 134-141**: Process matching markers:\n- `!silent`: Check if non-silent mode (silent mode only checks syntax, doesn't create tokens)\n- **`state.src.slice(spanStart, matchStart)`**: Extract content from specified range in source text\n  - `spanStart`: Content starting position (after skipping starting delimiter)\n  - `matchStart`: End delimiter starting position (exclude end delimiter)\n- Content cleanup: replace multiple spaces/line feeds with single space, remove leading/trailing whitespace\n- **`state.push(tokenObject)`**: Remarkable state method, add token to tokens array\n  - `type: 'katex'`: Token type\n  - `content: content`: Processed LaTeX expression\n  - `block: marker.length \u003e 1`: Determine if block-level based on delimiter length ($$ is block, $ is inline)\n  - `level: state.level`: Current nesting level\n- **`state.pos`**: Update Remarkable state object's current parsing position to after end delimiter\n\n```javascript\n        }\n      }\n      pos += 1;\n    }\n\n    // If we reach here, no matching closing delimiter was found\n    // Don't add anything to pending and don't advance position to avoid partial rendering\n    return false;\n```\n**Lines 142-148**: Handle case where no matching marker is found:\n- Continue searching forward\n- If reaching end without finding matching end marker\n- Return false, don't create token, avoid partial rendering\n\n### Plugin Registration\n\n```javascript\n  md.inline.ruler.push('katex', parseInlineKatex, options);\n  md.block.ruler.push('katex', parseBlockKatex, options);\n```\n**Lines 151-152**: Register parsing rules with Remarkable:\n- **`md.inline.ruler.push()`**: Remarkable plugin API, register new parsing rule with inline parser\n  - `'katex'`: Rule name for identification and ordering\n  - `parseInlineKatex`: Inline parsing function\n  - `options`: Parsing options (optional)\n- **`md.block.ruler.push()`**: Remarkable plugin API, register new parsing rule with block parser\n  - `'katex'`: Rule name\n  - `parseBlockKatex`: Block parsing function\n  - `options`: Parsing options (optional)\n\n```javascript\n  md.renderer.rules.katex = (tokens, idx) =\u003e {\n    const token = tokens[idx];\n    const rendered = renderKatex(token.content, token.block);\n    // Return clean HTML without any markdown artifacts\n    return rendered;\n  };\n```\n**Lines 153-158**: Define rendering rule:\n- **`md.renderer.rules.katex`**: Remarkable renderer API, define rendering function for 'katex' type tokens\n- **Rendering function parameters**:\n  - `tokens`: Complete tokens array\n  - `idx`: Index of current token to render in array\n- `tokens[idx]`: Get current token object to render\n- `renderKatex(token.content, token.block)`: Call previously defined KaTeX rendering function\n- Return rendered HTML string, no Markdown syntax artifacts\n\n```javascript\n  md.renderer.rules.katex.delimiter = delimiter;\n```\n**Line 159**: Attach delimiter information to rendering rule for debugging and configuration checking.\n\n```javascript\n};\n\nmodule.exports = rkatex;\n```\n**Lines 160-162**: End function definition and export module.\n- `};`: End rkatex function definition\n- **`module.exports`**: Node.js module export mechanism, makes rkatex function importable by other modules via require()\n\n---\n\n## index.test.js Code Line-by-Line Analysis\n\n### Test File Header\n\n```javascript\n\"use strict\";\n```\n**Line 1**: Enable strict mode.\n\n```javascript\nconst vows = require('vows');\nconst assert = require('assert');\nconst { Remarkable } = require('remarkable');\n\nconst plugin = require('./index.js');\n```\n**Lines 3-6**: Import test dependencies:\n- **`require('vows')`**: Import vows testing framework, a BDD (Behavior Driven Development) testing framework for Node.js\n- **`require('assert')`**: Import Node.js built-in assertion library, provides various assertion methods for test verification\n- **`require('remarkable')`**: Import Remarkable Markdown processor, use destructuring syntax to get Remarkable constructor\n- **`require('./index.js')`**: Import plugin main file from current directory (relative path import)\n\n### Test Instance Preparation\n\n```javascript\nconst mdWithDollar = new Remarkable();\nmdWithDollar.use(plugin);\n\nconst mdWithAt = new Remarkable();\nmdWithAt.use(plugin, {delimiter: '@'});\n```\n**Lines 8-12**: Create test instances:\n- **`new Remarkable()`**: Create Remarkable Markdown processor instance\n- **`mdWithDollar.use(plugin)`**: Use Remarkable plugin API to load KaTeX plugin (use default configuration)\n  - `plugin`: Previously imported KaTeX plugin function\n- **`mdWithAt.use(plugin, {delimiter: '@'})`**: Load plugin and pass custom configuration\n  - `{delimiter: '@'}`: Configuration object, specify using @ symbol as mathematical formula delimiter instead of default $ symbol\n\n### Test Suite Start\n\n```javascript\nvows.describe('KatexPlugin').addBatch({\n```\n**Line 14**: Use vows framework to create test suite named 'KatexPlugin'.\n- **`vows.describe('KatexPlugin')`**: vows testing framework API, create a test suite (Test Suite)\n  - `'KatexPlugin'`: Test suite name for test output and organization\n- **`.addBatch(testObject)`**: vows framework method, add batch of test cases to test suite\n  - `testObject`: Object containing multiple test cases\n\n### Configuration Tests\n\n```javascript\n  'Config empty delimiter': {\n    topic() {\n      const md = new Remarkable();\n      md.use(plugin, {delimiter: ''});\n      return md;\n    },\n    'Uses default delimiter': function(topic) {\n      assert.equal(topic.renderer.rules.katex.delimiter, '$');\n    }\n  },\n```\n**Lines 15-24**: Test empty delimiter configuration:\n- Create instance with empty delimiter\n- Verify fallback to default $ delimiter\n\n```javascript\n  'Multi-char delimiter': {\n    topic() {\n      return () =\u003e {\n        const md = new Remarkable();\n        md.use(plugin, {delimiter: '$$'});\n        return md;\n      };\n    },\n    'Throws exception': function(topic) {\n      assert.throws(topic);\n    }\n  },\n```\n**Lines 25-36**: Test multi-character delimiter:\n- Try using two-character delimiter\n- **`assert.throws(topic)`**: Node.js assertion library method, verify if function call throws exception\n  - `topic`: Function to test (here function returning Remarkable instance creation function)\n  - If function doesn't throw exception, assertion fails\n\n### Basic Text Rendering Tests\n\n```javascript\n  'Render plain text': {\n    topic: mdWithDollar.render('This is a test.'),\n    'Nothing done': function(topic) {\n      assert.equal(topic, '\u003cp\u003eThis is a test.\u003c/p\u003e\\n');\n    }\n  },\n```\n**Lines 37-42**: Test plain text rendering:\n- **`mdWithDollar.render('This is a test.')`**: Use Remarkable instance's render method to process Markdown text\n  - `render()`: Remarkable core method, converts Markdown text to HTML\n  - Return value: Rendered HTML string\n- **`assert.equal(actual, expected)`**: Node.js assertion library method, verify two values are strictly equal\n  - `actual`: Actually obtained value (render method return value)\n  - `expected`: Expected value ('\u003cp\u003eThis is a test.\u003c/p\u003e\\n')\n- Ensure plugin doesn't affect normal text rendering\n\n```javascript\n  'Render with single $ in text': {\n    topic: mdWithDollar.render('The car cost $20,000 new.'),\n    'Nothing done': function(topic) {\n      assert.equal(topic, '\u003cp\u003eThe car cost $20,000 new.\u003c/p\u003e\\n');\n    }\n  },\n```\n**Lines 43-48**: Test single dollar sign:\n- Verify single $ symbol not mistaken for mathematical formula marker\n- Ensure currency symbols in normal text display correctly\n\n### Inline Mathematical Formula Tests\n\n```javascript\n  'Render $...$ in text': {\n    topic: mdWithDollar.render('Equation $x + y$.'),\n    'Starts with \"\u003cp\u003eEquation \"': function(topic) {\n      assert.isTrue(topic.startsWith('\u003cp\u003eEquation '));\n    },\n    'Ends with \".\u003c/p\u003e\"': function(topic) {\n      assert.isTrue(topic.endsWith('\u003c/span\u003e.\u003c/p\u003e\\n'));\n    },\n    'Contains math span': function(topic) {\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\n    }\n  },\n```\n**Lines 49-61**: Test basic inline mathematical formula:\n- **`assert.isTrue(condition)`**: Node.js assertion library method, verify condition is truthy\n  - `topic.startsWith('\u003cp\u003eEquation ')`: JavaScript string method, check if string starts with specified prefix\n  - `topic.endsWith('\u003c/span\u003e.\u003c/p\u003e\\n')`: JavaScript string method, check if string ends with specified suffix\n- **`assert.notEqual(actual, unexpected)`**: Node.js assertion library method, verify two values are not equal\n  - `topic.indexOf('\u003cspan class=\"katex\"\u003e')`: JavaScript string method, find substring position in string\n  - `-1`: indexOf method return value when not found\n  - This assertion ensures HTML contains KaTeX-rendered span element\n\n```javascript\n  'Render $...$ in text with embedded {$...$}': {\n    topic: mdWithDollar.render('Equation $\\\\colorbox{aqua}{$F=ma$}$.'),\n    // ... similar assertions\n  },\n```\n**Lines 62-74**: Test complex formula with nested braces:\n- Verify plugin correctly handles nested brace structures\n- Ensure complex LaTeX commands render correctly\n\n### Block-level Mathematical Formula Tests\n\n```javascript\n  'Render $$...$$ in text': {\n    topic: mdWithDollar.render('Before\\n$$\\nx + y\\n$$\\nafter.'),\n    'Starts with \"\u003cp\u003eBefore \"': function(topic) {\n      assert.isTrue(topic.startsWith('\u003cp\u003eBefore\\n'));\n    },\n    'Ends with \"after.\u003c/p\u003e\"': function(topic) {\n      assert.isTrue(topic.endsWith('\u003c/span\u003e\\nafter.\u003c/p\u003e\\n'));\n    },\n    'Contains math span': function(topic) {\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\n    }\n  },\n```\n**Lines 87-99**: Test block-level mathematical formula:\n- Verify multi-line $$ blocks render correctly\n- Ensure katex-display class name is used\n\n### Custom Delimiter Tests\n\n```javascript\n  'Render @...@ in text': {\n    topic: mdWithAt.render('Equation @x + y@.'),\n    // ... verify inline formula using @ delimiter\n  },\n  'Render @@...@@ in text': {\n    topic: mdWithAt.render('Before @@x + y@@ after.'),\n    // ... verify block formula using @ delimiter\n  },\n```\n**Lines 75-86 and 100-112**: Test custom delimiter:\n- Verify plugin supports custom delimiters (@ instead of $)\n- Ensure both inline and block formulas work correctly with custom delimiter\n\n### Error Handling Tests\n\n```javascript\n  'Incomplete inline expression (no closing delimiter)': {\n    topic: mdWithDollar.render('This has $incomplete math expression.'),\n    'Original text preserved': function(topic) {\n      assert.equal(topic, '\u003cp\u003eThis has $incomplete math expression.\u003c/p\u003e\\n');\n    },\n    'No KaTeX HTML generated': function(topic) {\n      assert.equal(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\n    }\n  },\n```\n**Lines 113-122**: Test incomplete inline expression:\n- Verify original text preserved when missing end delimiter\n- Ensure no erroneous KaTeX HTML generated\n\n```javascript\n  'Incomplete block expression (no closing delimiter)': {\n    topic: mdWithDollar.render('Before\\n$$\\nincomplete block\\nafter.'),\n    'Original text preserved': function(topic) {\n      assert.equal(topic, '\u003cp\u003eBefore\\n$$\\nincomplete block\\nafter.\u003c/p\u003e\\n');\n    },\n    'No KaTeX HTML generated': function(topic) {\n      assert.equal(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\n    }\n  },\n```\n**Lines 123-132**: Test incomplete block expression:\n- Verify original text preserved when missing end marker\n- Ensure no partial mathematical formula HTML generated\n\n### Content Cleanup Tests\n\n```javascript\n  'Original expression completely removed in inline math': {\n    topic: mdWithDollar.render('Test $x^2$ here.'),\n    'No dollar signs in output': function(topic) {\n      // Should not contain the original $ delimiters\n      assert.equal(topic.indexOf('$x^2$'), -1);\n    },\n    'Contains rendered math': function(topic) {\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\n    },\n    'Contains x^2 in rendered form': function(topic) {\n      // KaTeX should render x^2 as superscript\n      assert.notEqual(topic.indexOf('x'), -1);\n      assert.notEqual(topic.indexOf('2'), -1);\n    }\n  },\n```\n**Lines 133-149**: Test complete removal of original expression:\n- Verify original $ delimiters don't appear in output\n- Ensure content correctly converted to KaTeX HTML\n- Verify mathematical symbols render correctly\n\n### KaTeX Annotation Preservation Tests\n\n```javascript\n  'Original expression completely removed in block math': {\n    topic: mdWithDollar.render('Before\\n$$\\n\\\\frac{a}{b}\\n$$\\nafter.'),\n    'No double dollar signs in output': function(topic) {\n      // Should not contain the original $$ delimiters\n      assert.equal(topic.indexOf('$$'), -1);\n    },\n    'Raw LaTeX preserved in annotation (correct behavior)': function(topic) {\n      // KaTeX preserves original LaTeX in annotation tags - this is correct\n      assert.notEqual(topic.indexOf('\\\\frac{a}{b}'), -1);\n      assert.notEqual(topic.indexOf('\u003cannotation encoding=\"application/x-tex\"\u003e'), -1);\n    },\n    'Contains rendered math': function(topic) {\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\n    }\n  },\n```\n**Lines 150-165**: Test block formula processing:\n- Verify $$ delimiters removed\n- Confirm KaTeX preserves original LaTeX in annotation tags (this is correct behavior)\n- Verify contains rendered mathematical elements\n\n### Multiple Expression Tests\n\n```javascript\n  'Multiple expressions all converted': {\n    topic: mdWithDollar.render('First $a+b$ and second $c+d$ expressions.'),\n    'No dollar signs remain': function(topic) {\n      assert.equal(topic.indexOf('$a+b$'), -1);\n      assert.equal(topic.indexOf('$c+d$'), -1);\n    },\n    'Two math spans created': function(topic) {\n      const matches = topic.match(/\u003cspan class=\"katex\"\u003e/g);\n      assert.equal(matches ? matches.length : 0, 2);\n    }\n  },\n```\n**Lines 166-177**: Test multiple mathematical expressions:\n- Verify all original delimiters removed\n- **`topic.match(/\u003cspan class=\"katex\"\u003e/g)`**: JavaScript string regex matching method\n  - `/\u003cspan class=\"katex\"\u003e/g`: Global regex, find all KaTeX span tags\n  - `g` flag: Global match, return all matches instead of just first\n  - Return value: Array of matches or null (when no matches)\n- **Ternary operator `matches ? matches.length : 0`**: Safely get match count\n  - If matches not null, return array length\n  - If matches null (no matches), return 0\n- Ensure correct number (2) of mathematical span elements created\n\n### Mixed Expression Tests\n\n```javascript\n  'Mixed inline and block expressions': {\n    topic: mdWithDollar.render('Inline $x$ and block:\\n$$\\ny = mx + b\\n$$\\ndone.'),\n    'No original delimiters remain': function(topic) {\n      assert.equal(topic.indexOf('$x$'), -1);\n      assert.equal(topic.indexOf('$$'), -1);\n      // Note: \"y = mx + b\" will be preserved in KaTeX annotation - this is correct\n    },\n    'Contains both inline and block math': function(topic) {\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\n    },\n    'LaTeX content preserved in annotations': function(topic) {\n      // KaTeX correctly preserves LaTeX in annotations\n      assert.notEqual(topic.indexOf('\u003cannotation encoding=\"application/x-tex\"\u003ex\u003c/annotation\u003e'), -1);\n      assert.notEqual(topic.indexOf('\u003cannotation encoding=\"application/x-tex\"\u003ey = mx + b\u003c/annotation\u003e'), -1);\n    }\n  },\n```\n**Lines 178-194**: Test mixed inline and block expressions:\n- Verify all original delimiters removed\n- Ensure both inline and block mathematical elements included\n- Verify LaTeX content correctly preserved in annotations\n\n### Error Handling Configuration Tests\n\n```javascript\nHere's the complete remaining content for the English translation:\n\n```markdown\n  'KaTeX error handling (throwOnError: false)': {\n    topic: mdWithDollar.render('Invalid math: $\\\\invalidcommand{test}$.'),\n    'Renders without throwing': function(topic) {\n      // Should render something even with invalid LaTeX (due to throwOnError: false)\n      assert.isTrue(topic.length \u003e 0);\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\n    },\n    'No original delimiters remain': function(topic) {\n      assert.equal(topic.indexOf('$\\\\invalidcommand{test}$'), -1);\n    }\n  },\n```\n**Lines 195-206**: Test KaTeX error handling:\n- Verify invalid LaTeX commands don't throw exceptions\n- Ensure still generates some output (error display)\n- Verify original delimiters removed\n\n### Configuration Option Tests\n\n```javascript\n  'Config with useTailwind=false (default)': {\n    topic() {\n      const md = new Remarkable();\n      md.use(plugin, { useTailwind: false });\n      return md;\n    },\n    'Configuration applied correctly': function(topic) {\n      // Test that configuration is accepted without error\n      assert.isObject(topic);\n    }\n  },\n  'Config with useTailwind=true': {\n    topic() {\n      const md = new Remarkable();\n      md.use(plugin, { useTailwind: true });\n      return md;\n    },\n    'Configuration applied correctly': function(topic) {\n      // Test that configuration is accepted without error\n      assert.isObject(topic);\n    }\n  },\n```\n**Lines 207-225**: Test Tailwind configuration options:\n- Verify `useTailwind: false` configuration applied correctly\n- Verify `useTailwind: true` configuration applied correctly\n- Ensure configuration accepted without errors\n\n### Styling Processing Tests\n\n```javascript\n  'Aria-hidden processing with default styling': {\n    topic() {\n      const md = new Remarkable();\n      md.use(plugin, { useTailwind: false });\n      // Create a mock rendered output with aria-hidden elements\n      const { applyCustomStyling } = require('./utils');\n      const mockHtml = '\u003cspan class=\"inline\" aria-hidden=\"true\"\u003ehidden content\u003c/span\u003e';\n      return applyCustomStyling(mockHtml, { useTailwind: false });\n    },\n    'Removes inline class and adds display:none style': function(topic) {\n      assert.equal(topic.indexOf('class=\"inline\"'), -1);\n      assert.notEqual(topic.indexOf('style=\"display:none\"'), -1);\n    }\n  },\n  'Aria-hidden processing with Tailwind styling': {\n    topic() {\n      const md = new Remarkable();\n      md.use(plugin, { useTailwind: true });\n      // Create a mock rendered output with aria-hidden elements\n      const { applyCustomStyling } = require('./utils');\n      const mockHtml = '\u003cspan class=\"inline\" aria-hidden=\"true\"\u003ehidden content\u003c/span\u003e';\n      return applyCustomStyling(mockHtml, { useTailwind: true });\n    },\n    'Removes inline class and adds display:none style': function(topic) {\n      assert.equal(topic.indexOf('class=\"inline\"'), -1);\n      assert.notEqual(topic.indexOf('style=\"display:none\"'), -1);\n    }\n  }\n```\n**Lines 226-250**: Test aria-hidden element styling processing:\n- **`require('./utils')`**: Re-import utils module to directly test applyCustomStyling function\n- **Mock HTML testing**: Create test HTML fragment containing aria-hidden attributes\n- **`applyCustomStyling(mockHtml, config)`**: Call styling processing function\n  - `mockHtml`: Mock KaTeX rendered HTML\n  - `config`: Styling configuration object (containing useTailwind and other options)\n- Test styling processing behavior under different configurations\n- Verify accessibility improvements: inline class removed, display:none style added\n\n```javascript\n}).export(module);\n```\n**Line 251**: Export test suite module.\n- **`.export(module)`**: vows testing framework method, export test suite for execution by test runner\n  - `module`: Node.js current module object\n  - This enables test file to be run via command line tools\n\n---\n\n## Summary\n\nThe core functionality of this plugin includes:\n\n1. **Flexible delimiter support**: Supports custom delimiters (default $)\n2. **Inline and block support**: Simultaneously supports `$...$` (inline) and `$$...$$` (block)\n3. **Intelligent parsing**: Correctly handles nested braces and escape characters\n4. **Error handling**: Incomplete expressions preserve original text, invalid LaTeX displays errors without crashing\n5. **Style customization**: Supports Tailwind CSS and custom styling processing\n6. **Accessibility**: Processes aria-hidden elements to improve accessibility\n\n### Non-Standard Library Function Usage Summary\n\nThis plugin primarily relies on the following non-JavaScript standard library functions and APIs:\n\n#### Node.js Ecosystem\n- **Module system**: `require()`, `module.exports` for module import/export\n- **Assertion library**: `assert.*` method group for test verification\n\n#### Remarkable Markdown Processor\n- **Parser state management**: `state.bMarks`, `state.tShift`, `state.eMarks` and other properties manage text position information\n- **Text processing methods**: `state.skipChars()`, `state.skipSpaces()`, `state.getLines()` and other methods handle text parsing\n- **Token management**: `state.push()`, `state.tokens.push()` for creating syntax tree nodes\n- **Plugin registration**: `md.inline.ruler.push()`, `md.block.ruler.push()` register parsing rules\n- **Rendering system**: `md.renderer.rules.*` define HTML rendering logic\n\n#### KaTeX Mathematical Rendering Library\n- **Core rendering**: `katex.renderToString()` converts LaTeX to HTML\n\n#### Vows Testing Framework\n- **Test organization**: `vows.describe()`, `.addBatch()`, `.export()` build test structure\n- **Behavior verification**: Various assert methods for functionality verification\n\nTests cover all major functionality and edge cases, ensuring deep understanding of plugin architecture and implementation through detailed function-level analysis.\n```\n\nThis completes the full English translation of the `remarkable-katex-plus.mdx` file. The translation maintains all the technical details, code examples, and comprehensive explanations from the original Chinese version."])</script><script>self.__next_f.push([1,"26:Ta9c4,"])</script><script>self.__next_f.push([1,"\r\n# Remarkable Mermaid Plus Plugin Code Analysis\r\n\r\n**Plugin Version: v1.0.26**\r\n\r\nThis article will provide a line-by-line analysis of the `remarkable-mermaid-plus` plugin code, including the main plugin file `index.js` and the utility function file `mermaid-utils.js`. This analysis not only explains the purpose of each line of code but also provides detailed explanations of all non-JavaScript standard library functions and their principles.\r\n\r\n## Overview\r\n\r\n`remarkable-mermaid-plus` is a plugin for the Remarkable Markdown processor that transforms `mermaid` code blocks in Markdown into interactive Mermaid diagrams. The plugin works as a post-processor, performing secondary processing on HTML content after Remarkable completes basic rendering.\r\n\r\n## Dependency Library Function Descriptions\r\n\r\nBefore diving into the code analysis, let's understand the main non-standard library functions used by this plugin:\r\n\r\n### Node.js Related Functions\r\n- **`require(moduleName)`**: Node.js module loading function, used to import external modules or libraries\r\n  - **Parameters**: \r\n    - `moduleName` (string): Module name or path string\r\n  - **Return Value**: Imported module object or function\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Import processing functions from utility module\r\n    const { processMermaidInHTML } = require('./mermaid-utils');\r\n    \r\n    // Import Node.js core modules\r\n    const fs = require('fs');\r\n    ```\r\n- **`module.exports`**: Node.js module export object, used to provide module functionality to external modules\r\n  - **Parameters**: None (this is a property, not a function)\r\n  - **Return Value**: None\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Export single plugin function\r\n    module.exports = rmermaid;\r\n    \r\n    // Export object containing multiple functions\r\n    module.exports = { processMermaidInHTML };\r\n    ```\r\n\r\n### Remarkable Plugin API\r\n- **`md.render(src, env)`**: Remarkable's core rendering method\r\n  - **Parameters**:\r\n    - `src` (string): Input Markdown text string\r\n    - `env` (Object): Rendering environment object (optional), containing rendering context information\r\n  - **Return Value**: (string) Rendered HTML string\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Render basic Markdown text\r\n    const html = md.render('# Hello World\\n\\nThis is **bold** text.');\r\n    \r\n    // Render with environment object\r\n    const htmlWithEnv = md.render('# Title', { customData: 'value' });\r\n    ```\r\n- **`originalRender.call(this, src, env)`**: JavaScript function call method\r\n  - **Parameters**:\r\n    - `this` (Object): Call context (here the Remarkable instance)\r\n    - `src` (string): Markdown text passed to the original render method\r\n    - `env` (Object): Environment object passed to the original render method\r\n  - **Return Value**: (string) Original rendering result\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Save original rendering method\r\n    const originalRender = md.render;\r\n    \r\n    // Override rendering method to add post-processing\r\n    md.render = function(src, env) {\r\n      // Call original rendering method\r\n      const htmlContent = originalRender.call(this, src, env);\r\n      // Post-process HTML\r\n      return processHTML(htmlContent);\r\n    };\r\n    ```\r\n\r\n### Browser DOM API\r\n- **`document.querySelectorAll(selector)`**: Find all matching DOM elements based on CSS selector\r\n  - **Parameters**:\r\n    - `selector` (string): CSS selector string\r\n  - **Return Value**: NodeList object containing all matching elements\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Find all elements with class mermaid\r\n    const mermaidDivs = document.querySelectorAll('.mermaid');\r\n    \r\n    // Find all code elements under pre tags\r\n    const codeBlocks = document.querySelectorAll('pre code');\r\n    ```\r\n- **`document.createElement(tagName)`**: Create new DOM element with specified tag name\r\n  - **Parameters**:\r\n    - `tagName` (string): HTML tag name string\r\n  - **Return Value**: Newly created DOM element object\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Create new div element\r\n    const div = document.createElement('div');\r\n    \r\n    // Create new span element\r\n    const span = document.createElement('span');\r\n    ```\r\n- **`document.body`**: Reference to document's body element\r\n  - **Type**: HTMLElement\r\n  - **Description**: Get document's body element\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Add temporary container to page body\r\n    document.body.appendChild(tempContainer);\r\n    ```\r\n- **`element.appendChild(child)`**: Add child element to parent element\r\n  - **Parameters**:\r\n    - `child` (Node): Child element to add\r\n  - **Return Value**: Added child element\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Get parent container element\r\n    const parent = document.getElementById('container');\r\n    \r\n    // Create new child element\r\n    const child = document.createElement('div');\r\n    \r\n    // Add child element to parent container\r\n    parent.appendChild(child);\r\n    ```\r\n- **`element.removeChild(child)`**: Remove child element from parent element\r\n  - **Parameters**:\r\n    - `child` (Node): Child element to remove\r\n  - **Return Value**: Removed child element\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Get parent container element\r\n    const parent = document.getElementById('container');\r\n    \r\n    // Get child element to remove\r\n    const child = document.getElementById('temp');\r\n    \r\n    // Remove child element from parent container\r\n    parent.removeChild(child);\r\n    ```\r\n- **`element.textContent`**: Get or set element's text content\r\n  - **Type**: string\r\n  - **Description**: Get element's plain text content (excluding HTML tags)\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Get element's plain text content\r\n    const text = div.textContent;\r\n    \r\n    // Set element's text content\r\n    div.textContent = 'New text content';\r\n    ```\r\n- **`element.innerText`**: Get or set element's visible text content\r\n  - **Type**: string\r\n  - **Description**: Get element's visible text content (considering CSS styles)\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Get element's visible text content\r\n    const visibleText = div.innerText;\r\n    \r\n    // Set element's visible text\r\n    div.innerText = 'Visible text';\r\n    ```\r\n- **`element.innerHTML`**: Get or set element's HTML content\r\n  - **Type**: string\r\n  - **Description**: Get or set element's HTML content\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const html = div.innerHTML;               // Get HTML content\r\n    div.innerHTML = '\u003cspan\u003eNew HTML\u003c/span\u003e';  // Set HTML content\r\n    ```\r\n- **`element.offsetParent`**: Get element's positioned parent element\r\n  - **Type**: Element | null\r\n  - **Description**: Get element's positioned parent element, returns null if element is not visible\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const isVisible = div.offsetParent !== null;\r\n    ```\r\n- **`element.style`**: Element's style object, used to set CSS styles\r\n  - **Type**: CSSStyleDeclaration\r\n  - **Description**: Get element's style object, can set CSS properties\r\n  - **Usage Example**:\r\n    ```javascript\r\n    div.style.display = 'block';\r\n    div.style.width = '100%';\r\n    div.style.backgroundColor = 'red';\r\n    ```\r\n\r\n### JavaScript Built-in Objects and Methods\r\n- **`Date.now()`**: Return current timestamp (milliseconds)\r\n  - **Parameters**: None\r\n  - **Return Value**: (number) Current timestamp (milliseconds)\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Get current timestamp\r\n    const timestamp = Date.now();\r\n    \r\n    // Generate unique ID with timestamp\r\n    const uniqueId = 'mermaid-' + Date.now();\r\n    ```\r\n- **`Math.random()`**: Generate random number between 0 and 1\r\n  - **Parameters**: None\r\n  - **Return Value**: (number) Random number between 0 and 1 (exclusive of 1)\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const randomValue = Math.random();\r\n    const randomId = Math.random().toString(36).substring(2, 9);\r\n    ```\r\n- **`parseInt(value, radix)`**: Convert string to integer\r\n  - **Parameters**:\r\n    - `value` (string): String to convert\r\n    - `radix` (number): Base radix, between 2-36 (optional)\r\n  - **Return Value**: (number) Converted integer, returns NaN on failure\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const num = parseInt('123', 10);        // Decimal: 123\r\n    const hex = parseInt('FF', 16);         // Hexadecimal: 255\r\n    ```\r\n- **`JSON.stringify(obj)`**: Convert JavaScript object to JSON string\r\n  - **Parameters**:\r\n    - `obj` (any): JavaScript value to convert\r\n  - **Return Value**: (string) JSON string\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const config = { theme: 'dark', fontSize: 16 };\r\n    const jsonString = JSON.stringify(config);\r\n    ```\r\n- **`setInterval(callback, interval)`**: Set timer to execute callback function at specified intervals\r\n  - **Parameters**:\r\n    - `callback` (function): Callback function to execute\r\n    - `interval` (number): Time interval (milliseconds)\r\n  - **Return Value**: (number) Timer ID, used to clear timer\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const timerId = setInterval(function() {\r\n      console.log('Execute once per second');\r\n    }, 1000);\r\n    ```\r\n- **`clearInterval(intervalId)`**: Clear timer\r\n  - **Parameters**:\r\n    - `intervalId` (number): Timer ID\r\n  - **Return Value**: None\r\n  - **Usage Example**:\r\n    ```javascript\r\n    clearInterval(timerId); // Clear timer\r\n    ```\r\n- **`setTimeout(callback, delay)`**: Set delayed execution\r\n  - **Parameters**:\r\n    - `callback` (function): Callback function to execute\r\n    - `delay` (number): Delay time (milliseconds)\r\n  - **Return Value**: (number) Timer ID\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const timeoutId = setTimeout(function() {\r\n      console.log('Execute after 3 seconds');\r\n    }, 3000);\r\n    ```\r\n\r\n### Regular Expressions\r\n- **`string.replace(regex, replacement)`**: Use regular expression to replace string content\r\n  - **Parameters**:\r\n    - `regex` (RegExp): Regular expression object\r\n    - `replacement` (string | function): Replacement string or replacement function\r\n  - **Return Value**: (string) New string after replacement\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const html = '\u003cspan class=\"hljs-keyword\"\u003egraph\u003c/span\u003e';\r\n    const clean = html.replace(/\u003cspan[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi, '$1');\r\n    ```\r\n- **`string.match(regex)`**: Use regular expression to match string\r\n  - **Parameters**:\r\n    - `regex` (RegExp): Regular expression object\r\n  - **Return Value**: (Array | null) Match result array, returns null if no match\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const matches = topic.match(/\u003cspan class=\"katex\"\u003e/g);\r\n    const count = matches ? matches.length : 0;\r\n    ```\r\n- **`string.includes(substring)`**: Check if string contains substring\r\n  - **Parameters**:\r\n    - `substring` (string): Substring to search for\r\n  - **Return Value**: (boolean) Whether it contains the specified substring\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const hasSvg = content.includes('\u003csvg');\r\n    const isGraph = content.includes('graph');\r\n    ```\r\n- **`string.toLowerCase()`**: Convert string to lowercase\r\n  - **Parameters**: None\r\n  - **Return Value**: (string) New string converted to lowercase\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const lowerType = type.toLowerCase();\r\n    const comparison = content.toLowerCase().includes('flowchart');\r\n    ```\r\n- **`string.substring(start, end)`**: Extract substring from string\r\n  - **Parameters**:\r\n    - `start` (number): Starting position index\r\n    - `end` (number): Ending position index (optional, exclusive)\r\n  - **Return Value**: (string) Extracted substring\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const preview = content.substring(0, 50);\r\n    const randomStr = Math.random().toString(36).substring(2, 9);\r\n    ```\r\n- **`string.trim()`**: Remove leading and trailing whitespace from string\r\n  - **Parameters**: None\r\n  - **Return Value**: (string) New string with leading and trailing whitespace removed\r\n  - **Usage Example**:\r\n    ```javascript\r\n    const cleanContent = mermaidContent.trim();\r\n    ```\r\n\r\n### Mermaid Library Functions\r\n- **`mermaid.initialize(config)`**: Initialize Mermaid library configuration\r\n  - **Parameters**:\r\n    - `config` (Object): Configuration object, containing the following optional properties:\r\n      - `theme` (string): Theme name, such as 'default', 'dark', 'forest', etc.\r\n      - `startOnLoad` (boolean): Whether to automatically start rendering on page load\r\n      - `securityLevel` (string): Security level, 'strict', 'loose', 'sandbox'\r\n      - `fontFamily` (string): Font family name\r\n      - `fontSize` (number): Font size\r\n      - `flowchart` (Object): Flowchart specific configuration\r\n      - `sequence` (Object): Sequence diagram specific configuration\r\n  - **Return Value**: None\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Initialize Mermaid library configuration\r\n    mermaid.initialize({\r\n      theme: 'dark',          // Use dark theme\r\n      startOnLoad: false,     // Don't start rendering automatically\r\n      securityLevel: 'loose', // Set security level to loose\r\n      fontFamily: 'arial',    // Set font to Arial\r\n      fontSize: 16            // Set font size to 16px\r\n    });\r\n    ```\r\n- **`mermaid.render(id, definition, element)`**: Render Mermaid diagram\r\n  - **Parameters**:\r\n    - `id` (string): Unique identifier for the diagram\r\n    - `definition` (string): Mermaid diagram definition code\r\n    - `element` (Element): DOM element for rendering (optional)\r\n  - **Return Value**: Promise\u003cObject\u003e resolves to result object containing SVG\r\n    - `svg` (string): Rendered SVG string\r\n    - `bindFunctions` (function): Bind interaction functions (optional)\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Render simple flowchart\r\n    const result = await mermaid.render('graph-1', 'graph TD; A--\u003eB');\r\n    const svgString = result.svg;  // Get SVG string\r\n    \r\n    // Render in temporary container\r\n    const tempDiv = document.createElement('div');\r\n    const result2 = await mermaid.render('graph-2', 'flowchart LR; C--\u003eD', tempDiv);\r\n    ```\r\n\r\n### Array Methods\r\n- **`array.some(callback)`**: Check if at least one element in array satisfies condition\r\n  - **Parameters**:\r\n    - `callback` (function): Test function, receives three parameters:\r\n      - `element` (any): Current element\r\n      - `index` (number): Current index (optional)\r\n      - `array` (Array): Original array (optional)\r\n  - **Return Value**: (boolean) Whether there exists an element satisfying the condition\r\n  - **Usage Example**:\r\n    ```javascript\r\n    // Define valid Mermaid diagram types\r\n    const validMermaidTypes = ['graph', 'flowchart', 'sequence'];\r\n    \r\n    // Check if content contains any valid diagram type\r\n    const isValid = validMermaidTypes.some(function(type) {\r\n      return content.toLowerCase().includes(type.toLowerCase());\r\n    });\r\n    \r\n    // Simplified arrow function syntax\r\n    const hasGraph = types.some(type =\u003e type === 'graph');\r\n    ```\r\n\r\n---\r\n\r\n## index.js Code Line-by-Line Analysis\r\n\r\n### File Header and Module Declaration\r\n\r\n```javascript\r\n\"use strict\";\r\n```\r\n**Line 1**: Use strict mode to ensure code runs in a strict JavaScript environment, helping to catch common programming errors and improve code quality.\r\n\r\n```javascript\r\n/**\r\n * Plugin for Remarkable Markdown processor which transforms mermaid code blocks into Mermaid diagrams.\r\n * Works as a post-processor on HTML content when html: true is enabled.\r\n */\r\n```\r\n**Lines 3-6**: JSDoc comment describing the plugin's purpose and working principle:\r\n- Provides plugin functionality for Remarkable Markdown processor\r\n- Transforms mermaid code blocks into Mermaid diagrams\r\n- Works as a post-processor, performing secondary processing on HTML content\r\n\r\n### Main Function Definition\r\n\r\n```javascript\r\nconst rmermaid = (md, options) =\u003e {\r\n```\r\n**Line 7**: Define main function `rmermaid`, the plugin's entry point, accepting two parameters:\r\n- `md`: Remarkable instance object, providing Markdown processing functionality\r\n- `options`: Configuration options object, containing various plugin settings\r\n\r\n### Utility Function Import\r\n\r\n```javascript\r\n  // Import HTML processing utilities\r\n  const { processMermaidInHTML } = require('./mermaid-utils');\r\n```\r\n**Lines 8-9**: Import HTML processing utility functions:\r\n- **`require('./mermaid-utils')`**: Node.js module loading function, using relative path to import mermaid-utils.js file in the same directory\r\n- **Destructuring assignment**: Extract processMermaidInHTML function from mermaid-utils module\r\n- `processMermaidInHTML`: Core processing function responsible for finding and transforming mermaid code blocks in HTML content\r\n\r\n### Render Method Override\r\n\r\n```javascript\r\n  // Override the render method to post-process HTML content\r\n  const originalRender = md.render;\r\n```\r\n**Lines 11-12**: Save the original rendering method:\r\n- **`md.render`**: Remarkable instance's core rendering method, converting Markdown text to HTML\r\n- `originalRender`: Save reference to original rendering method for calling in subsequent custom rendering\r\n\r\n```javascript\r\n  md.render = function(src, env) {\r\n```\r\n**Line 13**: Override Remarkable instance's render method, using function expression instead of arrow function to ensure correct this context:\r\n- `src`: Input Markdown source text string\r\n- `env`: Rendering environment object (optional), containing rendering context information\r\n\r\n```javascript\r\n    // First, let Remarkable do its normal rendering\r\n    let htmlContent = originalRender.call(this, src, env);\r\n```\r\n**Lines 14-15**: Execute original Markdown rendering:\r\n- **`originalRender.call(this, src, env)`**: JavaScript function call method, ensuring original rendering method executes in correct context\r\n  - `this`: Current Remarkable instance object\r\n  - `src, env`: Parameters passed to original rendering method\r\n- `htmlContent`: Store HTML content produced by Remarkable's standard rendering process\r\n\r\n```javascript\r\n    // Then, post-process the HTML to transform mermaid code blocks\r\n    htmlContent = processMermaidInHTML(htmlContent, options);\r\n```\r\n**Lines 17-18**: Post-process HTML content:\r\n- **`processMermaidInHTML(htmlContent, options)`**: Call utility function to process HTML content\r\n  - `htmlContent`: HTML string after Remarkable's standard rendering\r\n  - `options`: Plugin configuration options, passed to processing function\r\n- Return value: HTML content processed by mermaid, where mermaid code blocks are converted to renderable chart containers\r\n\r\n```javascript\r\n    return htmlContent;\r\n  };\r\n```\r\n**Lines 20-21**: Return processed HTML content and end function definition.\r\n\r\n### Module Export\r\n\r\n```javascript\r\n};\r\n\r\nmodule.exports = rmermaid;\r\n```\r\n**Lines 22-24**: End main function definition and export module:\r\n- `};`: End rmermaid function definition\r\n- **`module.exports`**: Node.js module export mechanism, making rmermaid function importable by other modules through require()\r\n\r\n---\r\n\r\n## mermaid-utils.js Code Line-by-Line Analysis\r\n\r\n### File Header Comment\r\n\r\n```javascript\r\n/**\r\n * Utility functions for processing Mermaid diagrams in Remarkable\r\n */\r\n```\r\n**Lines 1-3**: File description comment describing the purpose of this utility file.\r\n\r\n### wrapWithDiv Function\r\n\r\n```javascript\r\n/**\r\n * Wrap Mermaid mermaidCode code with a div element\r\n * @param {string} mermaidCode - The Mermaid mermaidCode code\r\n * @returns {string} - HTML div for client-side rendering\r\n */\r\nfunction wrapWithDiv(mermaidCode) {\r\n```\r\n**Lines 5-10**: Define wrapper function's JSDoc comment and function declaration:\r\n- Function purpose: Wrap Mermaid code in div element\r\n- Parameter: mermaidCode - Mermaid diagram definition code string\r\n- Return value: HTML div string for client-side rendering\r\n\r\n```javascript\r\n    if (typeof mermaidCode !== 'string') {\r\n        return '\u003cdiv class=\"mermaid-error\"\u003eInvalid Mermaid Code\u003c/div\u003e';\r\n    }\r\n```\r\n**Lines 11-13**: Input validation:\r\n- **`typeof mermaidCode`**: JavaScript operator checking variable's data type\r\n- If input is not string type, return error prompt HTML div element\r\n\r\n```javascript\r\n    // Generate a unique ID for this diagram\r\n    const diagramId = `mermaid-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n```\r\n**Lines 15-16**: Generate unique diagram ID:\r\n- **`Date.now()`**: JavaScript built-in method, returns current timestamp (milliseconds)\r\n- **`Math.random()`**: Generate random number between 0 and 1\r\n- **`.toString(36)`**: Convert number to base-36 string (containing 0-9 and a-z)\r\n- **`.substring(2, 9)`**: Extract characters 2 to 9 from string (skipping \"0.\" prefix)\r\n- Combine to generate unique ID like \"mermaid-1703123456789-abc123\"\r\n\r\n```javascript\r\n    return `\u003cdiv class=\"mermaid\" id=\"${diagramId}\"\u003e${mermaidCode}\u003c/div\u003e`;\r\n```\r\n**Line 18**: Return wrapped HTML:\r\n- Use template string to create div element\r\n- `class=\"mermaid\"`: CSS class name for Mermaid library identification and rendering\r\n- `id=\"${diagramId}\"`: Unique identifier to avoid conflicts between multiple diagrams\r\n- `${mermaidCode}`: Embed original Mermaid code\r\n\r\n### applyMermaidStyling Function\r\n\r\n```javascript\r\n/**\r\n * Apply custom styling to Mermaid containers\r\n * @param {string} htmlContent - The HTML content to process\r\n * @param {Object} config - Configuration object\r\n * @returns {string} - Processed HTML content\r\n */\r\nfunction applyMermaidStyling(htmlContent, config = {}) {\r\n```\r\n**Lines 21-27**: Define styling application function:\r\n- Parameter: htmlContent - HTML content string to process\r\n- Parameter: config - Configuration object, using default parameter syntax to set default value as empty object\r\n- Return value: Processed HTML content\r\n\r\n```javascript\r\n    if (!htmlContent || typeof htmlContent !== 'string') {\r\n        return htmlContent;\r\n    }\r\n```\r\n**Lines 28-30**: Input validation, ensuring htmlContent is a valid string.\r\n\r\n```javascript\r\n    let processedContent = htmlContent;\r\n```\r\n**Line 32**: Create copy of processing content to avoid directly modifying original input.\r\n\r\n```javascript\r\n    // Add custom CSS classes if specified\r\n    if (config.customClass) {\r\n        processedContent = processedContent.replace(\r\n            /class=\"mermaid\"/g,\r\n            `class=\"mermaid ${config.customClass}\"`\r\n        );\r\n    }\r\n```\r\n**Lines 34-39**: Add custom CSS classes:\r\n- Check if custom class name is specified in configuration\r\n- **`string.replace(regex, replacement)`**: Use regular expression to replace string content\r\n- **`/class=\"mermaid\"/g`**: Global regular expression matching all occurrences of `class=\"mermaid\"`\r\n- `g` flag: Global replacement, replace all matches instead of just the first\r\n- Add custom class name to existing class name\r\n\r\n```javascript\r\n    return processedContent;\r\n```\r\n**Line 41**: Return processed content.\r\n\r\n### addRenderingScript Function\r\n\r\n```javascript\r\nfunction addRenderingScript(htmlContent, config) {\r\n    return htmlContent + `\r\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.3/mermaid.min.js\" integrity=\"sha512-HvxxeyPSnbU7/x0g15v3OMxTFeADyCUnCN3iCam3BDTxgFPKxa+ujRCbFuwjE8PASDwOH5LpzFfGGNWks7tuJQ==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"\u003e\u003c/script\u003e\r\n```\r\n**Lines 44-46**: Define script addition function and begin adding Mermaid library:\r\n- Load Mermaid version 10.9.3 from CDN\r\n- `integrity`: SRI (Subresource Integrity) attribute ensuring script hasn't been tampered with\r\n- `crossorigin=\"anonymous\"`: Cross-origin setting, loading resource anonymously\r\n- `referrerpolicy=\"no-referrer\"`: Don't send referrer information, improving privacy\r\n\r\n```javascript\r\n    \u003cscript\u003e\r\n(function() {\r\n        const initializeMermaid = async function() {\r\n```\r\n**Lines 47-49**: Begin inline script using immediately invoked function expression (IIFE) and async function:\r\n- **Immediately invoked function expression**: Avoid global variable pollution\r\n- **async function**: Use async function to support await syntax\r\n\r\n```javascript\r\n            try {\r\n                // Configure mermaid with provided config\r\n                mermaid.initialize({\r\n                    startOnLoad: ${config.startOnLoad || false},\r\n                    theme: '${config.theme}',\r\n                    securityLevel: '${config.securityLevel}',\r\n                    fontFamily: '${config.fontFamily}',\r\n                    fontSize: ${config.fontSize},\r\n                    flowchart: ${JSON.stringify(config.flowchart)},\r\n                    sequence: ${JSON.stringify(config.sequence)},\r\n                    class: ${JSON.stringify(config.class)},\r\n                    gitGraph: ${JSON.stringify(config.gitGraph)}\r\n                });\r\n```\r\n**Lines 50-62**: Initialize Mermaid configuration:\r\n- **`mermaid.initialize()`**: Mermaid library's initialization method, setting global configuration\r\n- **Template string interpolation**: Use ${} syntax to insert configuration values into generated script\r\n- **`JSON.stringify()`**: Convert JavaScript objects to JSON strings, ensuring complex objects are properly serialized\r\n- Configuration item descriptions:\r\n  - `startOnLoad`: Whether to automatically start rendering on page load\r\n  - `theme`: Theme setting (such as 'default', 'dark', etc.)\r\n  - `securityLevel`: Security level setting\r\n  - `fontFamily`: Font family setting\r\n  - `fontSize`: Font size setting\r\n  - `flowchart`, `sequence`, `class`, `gitGraph`: Specific configurations for various chart types\r\n\r\n```javascript\r\n                // Find all mermaid divs and render them\r\n                const mermaidDivs = document.querySelectorAll('.mermaid');\r\n```\r\n**Lines 64-65**: Find all Mermaid containers:\r\n- **`document.querySelectorAll('.mermaid')`**: DOM API method finding all matching elements based on CSS selector\r\n- Returns NodeList object containing all div elements with class \"mermaid\"\r\n\r\n```javascript\r\n                for (let i = 0; i \u003c mermaidDivs.length; i++) {\r\n                    const div = mermaidDivs[i];\r\n```\r\n**Lines 67-68**: Iterate through all found Mermaid containers:\r\n- Use traditional for loop instead of forEach for better control over async operations\r\n- Get current div element being processed\r\n\r\n```javascript\r\n                    // Get clean text content, avoiding any HTML that might be mixed in\r\n                    let mermaidContent = div.textContent || div.innerText || '';\r\n```\r\n**Lines 70-71**: Extract plain text content:\r\n- **`div.textContent`**: Get element's text content (excluding HTML tags)\r\n- **`div.innerText`**: Get element's visible text content (considering CSS display effects)\r\n- Use logical OR operator to provide fallback options\r\n\r\n```javascript\r\n                    // Clean up the content - remove any extra whitespace and HTML artifacts\r\n                    mermaidContent = mermaidContent.trim();\r\n```\r\n**Lines 73-74**: Clean content:\r\n- **`string.trim()`**: Remove leading and trailing whitespace characters (spaces, tabs, newlines, etc.)\r\n\r\n```javascript\r\n                    // Skip if content is empty or contains HTML tags (already processed)\r\n                    if (!mermaidContent || mermaidContent.includes('\u003csvg') || mermaidContent.includes('\u003cpath')) {\r\n                        continue;\r\n                    }\r\n```\r\n**Lines 76-79**: Skip empty content or already processed content:\r\n- Check if content is empty\r\n- **`string.includes(substring)`**: Check if string contains specified substring\r\n- If contains `\u003csvg` or `\u003cpath` tags, indicates it's already been rendered, skip processing\r\n\r\n```javascript\r\n                    // Validate that this is actually mermaid content\r\n                    const validMermaidTypes = ['graph', 'flowchart', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'erDiagram', 'journey', 'gantt', 'pie', 'gitgraph', 'mindmap', 'timeline'];\r\n                    const isValidMermaid = validMermaidTypes.some(function(type) {\r\n                        return mermaidContent.toLowerCase().includes(type.toLowerCase());\r\n                    });\r\n```\r\n**Lines 81-85**: Validate if it's valid Mermaid content:\r\n- Define array of valid Mermaid chart types\r\n- **`array.some(callback)`**: Array method checking if at least one element satisfies condition\r\n- **`string.toLowerCase()`**: Convert string to lowercase for case-insensitive comparison\r\n- Check if content contains any valid Mermaid chart type keywords\r\n\r\n```javascript\r\n                    if (!isValidMermaid) {\r\n                        console.warn('Skipping non-mermaid content:', mermaidContent.substring(0, 50) + '...');\r\n                        continue;\r\n                    }\r\n```\r\n**Lines 87-90**: Skip non-Mermaid content:\r\n- If content is not valid Mermaid code, output warning message\r\n- **`console.warn()`**: Output warning message in console\r\n- **`string.substring(start, end)`**: Extract substring from string, here taking first 50 characters for log display\r\n\r\n```javascript\r\n                    try {\r\n                        // Ensure the div is properly mounted and visible\r\n                        if (!div.offsetParent \u0026\u0026 div.style.display !== 'none') {\r\n                            div.style.display = 'block';\r\n                        }\r\n```\r\n**Lines 92-96**: Ensure div element is properly mounted and visible:\r\n- **`div.offsetParent`**: DOM property, null if element is not visible or not mounted\r\n- **`div.style.display`**: Element's display style property\r\n- If element is not visible and not explicitly hidden, set to block display\r\n\r\n```javascript\r\n                        // Create a temporary container to avoid DOM issues\r\n                        const tempContainer = document.createElement('div');\r\n                        tempContainer.style.width = '100%';\r\n                        tempContainer.style.height = 'auto';\r\n                        tempContainer.style.visibility = 'hidden';\r\n                        tempContainer.style.position = 'absolute';\r\n                        tempContainer.style.top = '-9999px';\r\n                        document.body.appendChild(tempContainer);\r\n```\r\n**Lines 98-105**: Create temporary container to avoid DOM issues:\r\n- **`document.createElement('div')`**: Create new div element\r\n- Set temporary container styles:\r\n  - `width: '100%'`: Width fills parent container\r\n  - `height: 'auto'`: Height automatic\r\n  - `visibility: 'hidden'`: Hidden but preserves layout space\r\n  - `position: 'absolute'`: Absolute positioning\r\n  - `top: '-9999px'`: Move out of visible area\r\n- **`document.body.appendChild()`**: Add temporary container to page\r\n\r\n```javascript\r\n                        // Generate unique ID for this diagram\r\n                        const id = 'mermaid-render-' + Date.now() + '-' + i;\r\n```\r\n**Lines 107-108**: Generate unique ID for rendering:\r\n- Combine timestamp and loop index to create unique identifier\r\n- Used for internal identification during Mermaid rendering\r\n\r\n```javascript\r\n                        // Use mermaid v10+ async API with proper DOM context\r\n                        const result = await mermaid.render(id, mermaidContent, tempContainer);\r\n                        const svg = result.svg;\r\n```\r\n**Lines 110-112**: Use Mermaid async API to render chart:\r\n- **`await mermaid.render()`**: Call Mermaid's async rendering method\r\n  - `id`: Unique identifier for chart\r\n  - `mermaidContent`: Mermaid code to render\r\n  - `tempContainer`: Temporary DOM container\r\n- **`result.svg`**: Extract SVG string from rendering result\r\n\r\n```javascript\r\n                        // Remove temporary container\r\n                        document.body.removeChild(tempContainer);\r\n```\r\n**Lines 114-115**: Remove temporary container:\r\n- **`document.body.removeChild()`**: Remove temporary container element from DOM\r\n\r\n```javascript\r\n                        // Replace the div content with the SVG\r\n                        div.innerHTML = svg;\r\n```\r\n**Lines 117-118**: Replace div content:\r\n- **`div.innerHTML`**: Set element's HTML content\r\n- Replace original Mermaid code with rendered SVG chart\r\n\r\n```javascript\r\n                    } catch (renderError) {\r\n                        console.error('Error rendering mermaid diagram:', renderError);\r\n                        console.error('Content that failed:', mermaidContent);\r\n                        // Keep the original content if rendering fails\r\n                        const errorMessage = renderError instanceof Error ? renderError.message : String(renderError);\r\n                        div.innerHTML = '\u003cpre style=\"color: red; background: #fee; padding: 10px; border-radius: 4px;\"\u003e' +\r\n                            'Error rendering mermaid diagram: ' + errorMessage + '\\\\n\\\\n' +\r\n                            'Original content:\\\\n' + mermaidContent + '\u003c/pre\u003e';\r\n                    }\r\n```\r\n**Lines 120-128**: Handle rendering errors:\r\n- **`console.error()`**: Output error message in console\r\n- **`instanceof Error`**: Check if it's Error object instance\r\n- **`String(renderError)`**: Convert error object to string\r\n- Create error display HTML containing:\r\n  - Red text and light red background\r\n  - Error message\r\n  - Original content for debugging\r\n\r\n```javascript\r\n                }\r\n            } catch (error) {\r\n                console.error('Error initializing mermaid:', error);\r\n            }\r\n        };\r\n```\r\n**Lines 129-133**: Handle overall initialization errors and end initializeMermaid function.\r\n\r\n```javascript\r\n        // Wait for DOM to be fully ready and ensure proper mounting\r\n        const timeoutId = setInterval(function() {\r\n            // Check if mermaid is available\r\n            if (typeof mermaid === 'undefined') {\r\n                console.warn('Mermaid library is not loaded yet.');\r\n                return;\r\n            }\r\n            // Double-check that we're in a browser environment\r\n            if (typeof window !== 'undefined' \u0026\u0026 document.body) {\r\n                initializeMermaid();\r\n                clearInterval(timeoutId)\r\n            }\r\n        }, 1000);\r\n```\r\n**Lines 135-147**: Wait for DOM and Mermaid library to be ready:\r\n- **`setInterval(callback, interval)`**: Set timer to execute check every 1000 milliseconds\r\n- **`typeof mermaid === 'undefined'`**: Check if Mermaid library is loaded\r\n- **`typeof window !== 'undefined'`**: Check if in browser environment\r\n- **`document.body`**: Check if DOM is ready\r\n- **`clearInterval(timeoutId)`**: Clear timer to avoid repeated execution\r\n\r\n```javascript\r\n    })();\r\n    \u003c/script\u003e\r\n    `;\r\n}\r\n```\r\n**Lines 148-151**: End immediately invoked function expression, script tag, and addRenderingScript function.\r\n\r\n### processMermaidInHTML Function\r\n\r\n```javascript\r\n/**\r\n * Process HTML content to transform mermaid code blocks into mermaid divs\r\n * @param {string} htmlContent - The HTML content to process\r\n * @param {Object} options - Processing options\r\n * @returns {string} - Processed HTML content\r\n */\r\nfunction processMermaidInHTML(htmlContent, options = {}) {\r\n```\r\n**Lines 153-159**: Define main processing function:\r\n- Parameter: htmlContent - HTML content string to process\r\n- Parameter: options - Processing options object, defaulting to empty object\r\n- Return value: Processed HTML content\r\n\r\n```javascript\r\n    if (typeof htmlContent !== 'string') {\r\n        return htmlContent;\r\n    }\r\n```\r\n**Lines 160-162**: Input validation, ensuring htmlContent is string type.\r\n\r\n```javascript\r\n    const mermaidConfiguration = {\r\n        startOnLoad: options.startOnLoad || false,\r\n        theme: options.theme === 'light' ? 'default' : 'dark',\r\n        securityLevel: options.securityLevel || 'loose',\r\n        fontFamily: options.fontFamily || 'arial',\r\n        fontSize: options.fontSize || 16,\r\n        flowchart: options.flowchart || {\r\n            useMaxWidth: true,\r\n            htmlLabels: true,\r\n        },\r\n        sequence: options.sequence || {\r\n            useMaxWidth: true,\r\n            wrap: true,\r\n        },\r\n        class: options.class || {\r\n            useMaxWidth: true,\r\n        },\r\n        gitGraph: options.gitGraph || {\r\n            useMaxWidth: true,\r\n        },\r\n    };\r\n```\r\n**Lines 164-183**: Create Mermaid configuration object:\r\n- Use logical OR operator to set default values\r\n- **Ternary operator**: `options.theme === 'light' ? 'default' : 'dark'` set corresponding Mermaid theme based on theme option\r\n- Configurations for various chart types:\r\n  - `useMaxWidth: true`: Charts use maximum available width\r\n  - `htmlLabels: true`: Flowcharts use HTML labels\r\n  - `wrap: true`: Sequence diagrams enable text wrapping\r\n\r\n```javascript\r\n    // Find all mermaid code blocks in the HTML\r\n    // Pattern matches: \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e...\u003c/code\u003e\u003c/pre\u003e\r\n    const mermaidCodeBlockRegex = /\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e([\\s\\S]*?)\u003c\\/code\u003e\u003c\\/pre\u003e/gi;\r\n```\r\n**Lines 185-187**: Define regular expression to match Mermaid code blocks:\r\n- **Regular expression explanation**:\r\n  - `\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e`: Match code block start tags\r\n  - `([\\s\\S]*?)`: Capture group, match any characters (including newlines)\r\n    - `[\\s\\S]`: Match any whitespace or non-whitespace characters (equivalent to matching any character)\r\n    - `*?`: Non-greedy match, match as few characters as possible\r\n  - `\u003c\\/code\u003e\u003c\\/pre\u003e`: Match code block end tags\r\n  - `g`: Global match flag\r\n  - `i`: Case-insensitive flag\r\n\r\n```javascript\r\n    htmlContent = htmlContent.replace(mermaidCodeBlockRegex, (match, content) =\u003e {\r\n```\r\n**Line 189**: Use regular expression to replace matched code blocks:\r\n- **`string.replace(regex, callback)`**: Use callback function to process each match\r\n- `match`: Complete matched string\r\n- `content`: Content of first capture group (i.e., mermaid code)\r\n\r\n```javascript\r\n        // Check if content has been syntax highlighted by hljs\r\n        let cleanContent;\r\n        if (content.includes('\u003cspan class=\"hljs-')) {\r\n            // Extract text content from syntax-highlighted spans\r\n            cleanContent = content\r\n                .replace(/\u003cspan[^\u003e]*class=\"hljs-[^\"]*\"[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi, '$1')\r\n                .replace(/\u003cspan[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi, '$1')\r\n                .replace(/\u0026lt;/g, '\u003c')\r\n                .replace(/\u0026gt;/g, '\u003e')\r\n                .replace(/\u0026amp;/g, '\u0026')\r\n                .replace(/\u0026quot;/g, '\"')\r\n                .replace(/\u0026#39;/g, \"'\")\r\n                .replace(/\u0026#x27;/g, \"'\")\r\n                .trim();\r\n```\r\n**Lines 190-202**: Process syntax-highlighted content:\r\n- **`content.includes('\u003cspan class=\"hljs-')`**: Check if contains highlight.js syntax highlighting markers\r\n- **Regular expression replacement chain**:\r\n  - `/\u003cspan[^\u003e]*class=\"hljs-[^\"]*\"[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi`: Remove hljs span tags, preserve content\r\n  - `/\u003cspan[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi`: Remove other span tags\r\n  - `/\u0026lt;/g, '\u003c'`: Convert HTML entity `\u0026lt;` to `\u003c`\r\n  - `/\u0026gt;/g, '\u003e'`: Convert HTML entity `\u0026gt;` to `\u003e`\r\n  - `/\u0026amp;/g, '\u0026'`: Convert HTML entity `\u0026amp;` to `\u0026`\r\n  - `/\u0026quot;/g, '\"'`: Convert HTML entity `\u0026quot;` to `\"`\r\n  - `/\u0026#39;/g, \"'\"`: Convert HTML entity `\u0026#39;` to `'`\r\n  - `/\u0026#x27;/g, \"'\"`: Convert HTML entity `\u0026#x27;` to `'`\r\n- **`.trim()`**: Remove leading and trailing whitespace\r\n\r\n```javascript\r\n        } else {\r\n            // Decode HTML entities in the content (no syntax highlighting)\r\n            cleanContent = content\r\n                .replace(/\u0026lt;/g, '\u003c')\r\n                .replace(/\u0026gt;/g, '\u003e')\r\n                .replace(/\u0026amp;/g, '\u0026')\r\n                .replace(/\u0026quot;/g, '\"')\r\n                .replace(/\u0026#39;/g, \"'\")\r\n                .replace(/\u0026#x27;/g, \"'\")\r\n                .trim();\r\n        }\r\n```\r\n**Lines 203-213**: Process content without syntax highlighting:\r\n- Directly decode HTML entities\r\n- Use same entity conversion rules\r\n\r\n```javascript\r\n        // Transform into mermaid div\r\n        cleanContent = wrapWithDiv(cleanContent);\r\n        return applyMermaidStyling(cleanContent, options);\r\n```\r\n**Lines 215-217**: Transform into Mermaid div:\r\n- **`wrapWithDiv(cleanContent)`**: Call previously defined function to wrap content in div\r\n- **`applyMermaidStyling(cleanContent, options)`**: Apply custom styling\r\n- Return final HTML string\r\n\r\n```javascript\r\n    });\r\n\r\n    return addRenderingScript(htmlContent, mermaidConfiguration);\r\n}\r\n```\r\n**Lines 218-221**: Complete replacement and add rendering script:\r\n- End replace callback function\r\n- **`addRenderingScript(htmlContent, mermaidConfiguration)`**: Add Mermaid library and initialization script\r\n\r\n### Module Export\r\n\r\n```javascript\r\nmodule.exports = {\r\n    processMermaidInHTML\r\n};\r\n```\r\n**Lines 223-225**: Export module:\r\n- **`module.exports`**: Node.js module export mechanism\r\n- Use object form to export processMermaidInHTML function, convenient for destructuring import\r\n\r\n---\r\n\r\n## Summary\r\n\r\nThe core functionality and features of this plugin include:\r\n\r\n1. **Post-processing Architecture**: Doesn't modify Remarkable's parsing process, but performs secondary processing after HTML rendering is complete\r\n2. **Code Block Recognition**: Identifies code blocks in `\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e` format through regular expressions\r\n3. **Syntax Highlighting Compatibility**: Intelligently processes HTML structures produced by syntax highlighting libraries like highlight.js\r\n4. **HTML Entity Decoding**: Correctly processes HTML entities produced during Markdown rendering\r\n5. **Client-side Rendering**: Generates complete HTML containing Mermaid library and initialization scripts\r\n6. **Error Handling**: Provides comprehensive error handling and debugging information\r\n7. **Flexible Configuration**: Supports rich Mermaid configuration options\r\n8. **DOM Safety**: Uses temporary containers to avoid DOM operation issues\r\n\r\n### Non-Standard Library Function Usage Summary\r\n\r\nThis plugin primarily relies on the following non-JavaScript standard library functions and APIs:\r\n\r\n#### Node.js Ecosystem\r\n- **Module System**: `require()`, `module.exports` for module import/export\r\n- **File System**: Relative path module imports\r\n\r\n#### Remarkable Markdown Processor\r\n- **Core Rendering**: `md.render()` executes Markdown to HTML conversion\r\n- **Method Override**: Extends functionality by saving original method references\r\n\r\n#### Mermaid Chart Library\r\n- **Library Loading**: Loads Mermaid version 10.9.3 via CDN\r\n- **Initialization**: `mermaid.initialize()` configures global parameters\r\n- **Async Rendering**: `mermaid.render()` async API renders charts\r\n\r\n#### Browser DOM API\r\n- **Element Finding**: `document.querySelectorAll()` finds target elements\r\n- **Element Creation**: `document.createElement()` creates temporary containers\r\n- **DOM Operations**: `appendChild()`, `removeChild()` manages DOM tree\r\n- **Content Access**: `textContent`, `innerHTML` gets and sets element content\r\n\r\n#### Regular Expression Processing\r\n- **Pattern Matching**: Complex regular expressions match HTML structures\r\n- **Content Extraction**: Uses capture groups to extract code block content\r\n- **Entity Conversion**: Batch HTML entity decoding\r\n\r\n#### Async Programming\r\n- **Timers**: `setInterval()`, `clearInterval()` wait for library readiness\r\n- **Async Functions**: `async/await` handles Mermaid async rendering\r\n\r\nThe plugin achieves seamless integration with Remarkable for Mermaid chart rendering through clever post-processing mechanisms while maintaining good compatibility and error handling capabilities."])</script><script>self.__next_f.push([1,"27:T7640,"])</script><script>self.__next_f.push([1,"\r\n# Prompt Generation and Response Parsing: The Birth of Another Machine Language\r\n\r\nI often wonder, if making computers recognize machine language was the first major milestone in programming, then making AI recognize natural language today—could that be considered the second major milestone?\r\n\r\nThis article will comprehensively analyze the prompt management system in the Questions Party project, from the architectural design of PromptLoader to the robust implementation of response parsing, taking you through the original principles of MCP.\r\n\r\n## PromptLoader Core Architecture\r\n\r\n### Singleton Pattern Design\r\n\r\n```javascript\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nclass PromptLoader {\r\n    constructor() {\r\n        this.promptCache = new Map();\r\n        this.promptsDir = path.join(__dirname, '../prompts');\r\n    }\r\n}\r\n\r\n**Why Choose Singleton Pattern**:\r\n\r\nThroughout the entire application lifecycle, PromptLoader only needs one instance—after all, prompt templates won't run away, and the file system won't suddenly change its face.\r\n\r\n### Directory Structure Convention\r\n\r\n```typescript\r\n// Actual directory structure\r\nsrc/prompts/\r\n├── sentence-check-pure.txt        # Pure English sentence check template\r\n├── sentence-check-combined.txt    # Bilingual sentence check template\r\n├── sentence-generation-pure.txt   # Pure English sentence generation template\r\n├── sentence-generation-combined.txt  # Bilingual sentence generation template\r\n└── README.md                      # Documentation\r\n```\r\n\r\n### Map Caching\r\n\r\n```javascript\r\nthis.promptCache = new Map();\r\n```\r\n\r\n**Why Choose Map Instead of Object**?\r\n\r\nThis is a classic data structure selection problem:\r\n\r\n| Feature | Map | Object |\r\n|---------|-----|---------|\r\n| Key Type | Any type | String/Symbol |\r\n| Size Retrieval | O(1) | O(n) |\r\n| Iteration Performance | Excellent | Average |\r\n| Prototype Pollution | None | Risk |\r\n\r\n**Cache Performance Mathematical Analysis**:\r\n\r\nAssuming each prompt file averages 2KB, with 4 template files in the system:\r\n- **No Cache**: Each request requires file reading, IO time ~1-5ms\r\n- **With Cache**: After initial read, access time drops to below 0.01ms\r\n\r\nWhen cache hit rate reaches 90%, performance improvement is approximately:\r\n$$Performance Improvement = \\frac{5ms}{0.01ms} \\times 0.9 = 450x$$\r\n\r\n## loadPrompt Function\r\n\r\n### Cache-First Strategy\r\n\r\n```javascript\r\nloadPrompt(type, grammarLanguageOption = 'combined') {\r\n    const cacheKey = `${type}-${grammarLanguageOption}`;\r\n    \r\n    // If cache has it, return cached version\r\n    if (this.promptCache.has(cacheKey)) {\r\n        return this.promptCache.get(cacheKey);\r\n    }\r\n\r\n    try {\r\n        const filename = `${type}-${grammarLanguageOption}.txt`;\r\n        const filepath = path.join(this.promptsDir, filename);\r\n        \r\n        if (!fs.existsSync(filepath)) {\r\n            throw new Error(`Prompt file not found: ${filepath}`);\r\n        }\r\n\r\n        const promptTemplate = fs.readFileSync(filepath, 'utf8');\r\n```\r\n\r\n**Cache Key Design**:\r\n\r\n`${type}-${grammarLanguageOption}` is a composite key corresponding to \"function-language\" respectively.\r\n\r\n### File System Safe Operations\r\n\r\n```javascript\r\nif (!fs.existsSync(filepath)) {\r\n    throw new Error(`Prompt file not found: ${filepath}`);\r\n}\r\n```\r\n\r\n**Why Check File Existence First**?\r\n\r\nThis is a classic case of defensive programming:\r\n\r\n```typescript\r\n// ❌ Unsafe approach\r\nconst content = fs.readFileSync(filepath, 'utf8');  // May throw ENOENT error\r\n\r\n// ✅ Safe approach\r\nif (!fs.existsSync(filepath)) {\r\n    throw new Error(`Prompt file not found: ${filepath}`);\r\n}\r\nconst content = fs.readFileSync(filepath, 'utf8');  // Clear error message\r\n```\r\n\r\n**Path Concatenation Compatibility**:\r\n\r\n```typescript\r\nconst filepath = path.join(this.promptsDir, filename);\r\n```\r\n\r\nUsing `path.join` instead of string concatenation avoids cross-platform path separator issues:\r\n- Windows: `\\`\r\n- Unix/Linux: `/`\r\n- Node.js handles automatically\r\n\r\n### Prompt Loading Fallback Handling\r\n\r\n```javascript\r\n} catch (error) {\r\n    console.error(`Error loading prompt ${type}-${grammarLanguageOption}:`, error.message);\r\n    \r\n    // If pure version fails, fallback to combined version\r\n    if (grammarLanguageOption === 'pure') {\r\n        console.warn(`Falling back to combined prompt for ${type}`);\r\n        return this.loadPrompt(type, 'combined');\r\n    }\r\n    \r\n    // If combined version also fails, throw error\r\n    throw new Error(`Failed to load prompt template: ${type}-${grammarLanguageOption}`);\r\n}\r\n```\r\n\r\nRecursive fallback order: `pure → combined → error`\r\n\r\nError handling decision tree:\r\n```\r\nLoad pure version\r\n    ↓\r\nFailed? → Yes → Try combined version\r\n    ↓         ↓\r\n   No        Failed? → Yes → Throw error\r\n    ↓         ↓\r\nReturn content   No\r\n              ↓\r\n            Return content\r\n```\r\n\r\n## Prompt Structured Design\r\n\r\n### Combined vs Pure: Bilingual Teaching\r\n\r\n**Pure Version (English Only)**:\r\n\r\n```\r\nAnalyze this sentence: \"{sentence}\"\r\n\r\nFollow this exact format (Output Example):\r\n\r\nGRAMMAR_ANALYSIS(Parsing required):\r\n1. Grammar and Style Issues\r\n```\r\n\r\n**Combined Version (Bilingual)**:\r\n```\r\nAnalyze this sentence: \"{sentence}\"\r\n\r\nPlease strictly follow this format (Output Example):\r\n\r\nGRAMMAR_ANALYSIS(Parsing required):\r\n1. Grammar and Style Issues\r\n```\r\n\r\n- **Pure Version**: For English learners, providing authentic English environment\r\n- **Combined Version**: For Chinese users, lowering comprehension threshold, providing bilingual reference\r\n\r\n## Cache Mechanism and Performance Optimization\r\n\r\n### Map vs Object Performance Comparison\r\n\r\n```javascript\r\n// Performance test pseudo-code\r\nconst iterations = 1000000;\r\n\r\n// Map performance test\r\nconst mapCache = new Map();\r\nconsole.time('Map');\r\nfor (let i = 0; i \u003c iterations; i++) {\r\n    mapCache.set(`key${i}`, `value${i}`);\r\n    mapCache.get(`key${i}`);\r\n}\r\nconsole.timeEnd('Map');\r\n\r\n// Object performance test\r\nconst objCache = {};\r\nconsole.time('Object');\r\nfor (let i = 0; i \u003c iterations; i++) {\r\n    objCache[`key${i}`] = `value${i}`;\r\n    const value = objCache[`key${i}`];\r\n}\r\nconsole.timeEnd('Object');\r\n```\r\n\r\n**Actual Test Results**:\r\n- Map: ~661.084ms\r\n- Object: ~1005ms\r\n\r\nMap has about 52% performance advantage in large-scale operations!\r\n\r\n## Fallback Strategy Fault Tolerance Design\r\n\r\n### Pure → Combined Fallback Logic\r\n\r\n```javascript\r\n// If pure version fails, fallback to combined version\r\nif (grammarLanguageOption === 'pure') {\r\n    console.warn(`Falling back to combined prompt for ${type}`);\r\n    return this.loadPrompt(type, 'combined');\r\n}\r\n```\r\n\r\n**Fallback Decision State Machine**:\r\n\r\n```\r\n                    ┌─────────────┐\r\n                    │ Load Pure   │\r\n                    └─────┬───────┘\r\n                          │\r\n                     ┌────▼────┐     No\r\n                     │Success? │────────────\r\n                     └────┬────┘           │\r\n                       Yes │               │\r\n                     ┌────▼────┐    ┌───────▼───────┐\r\n                     │Return   │    │Try Combined   │\r\n                     │Content  │    └───────┬───────┘\r\n                     └─────────┘            │\r\n                                       ┌────▼────┐\r\n                                       │Success? │\r\n                                       └────┬────┘\r\n                                         Yes │  No\r\n                                   ┌────▼────┐    ┌─────────┐\r\n                                   │Return   │    │Throw    │\r\n                                   │Content  │    │Error    │\r\n                                   └─────────┘    └─────────┘\r\n```\r\n\r\n### System Robustness Guarantee\r\n\r\n```javascript\r\nvalidatePromptFiles() {\r\n    const requiredPrompts = [\r\n        'sentence-check-pure.txt',\r\n        'sentence-check-combined.txt',\r\n        'sentence-generation-pure.txt',\r\n        'sentence-generation-combined.txt'\r\n    ];\r\n\r\n    const missing = [];\r\n    const existing = [];\r\n\r\n    for (const filename of requiredPrompts) {\r\n        const filepath = path.join(this.promptsDir, filename);\r\n        if (fs.existsSync(filepath)) {\r\n            existing.push(filename);\r\n        } else {\r\n            missing.push(filename);\r\n        }\r\n    }\r\n```\r\n\r\n**Startup Validation**:\r\n\r\nSystem performs integrity check at startup, following \"Fast Fail\" principle:\r\n- **Early Discovery**: Problems found during deployment\r\n- **Clear Feedback**: Missing files clearly visible\r\n- **Ops Friendly**: Reduces debugging time in production environment\r\n\r\n## parseSentenceCheckResponse Deep Analysis\r\n\r\n### Tokenized Response Format Design\r\n\r\n```javascript\r\n// Sentence check response format configuration\r\nthis.checkResponseFormat = {\r\n    grammarAnalysisMarker: \"GRAMMAR_ANALYSIS:\",\r\n    grammarCorrectionMarker: \"GRAMMAR_CORRECTION:\",\r\n    keywordAnalysisMarker: \"KEYWORD_ANALYSIS:\",\r\n    chineseDefinitionMarker: \"CHINESE_DEFINITION:\",\r\n    endMarker: \"END_FORMAT\"\r\n};\r\n```\r\n\r\n### Robust Parsing Algorithm\r\n\r\n```javascript\r\nparseSentenceCheckResponse(content, locale = 'en') {\r\n    try {\r\n        const {\r\n            grammarAnalysisMarker,\r\n            grammarCorrectionMarker,\r\n            keywordAnalysisMarker,\r\n            chineseDefinitionMarker,\r\n            endMarker\r\n        } = this.checkResponseFormat;\r\n\r\n        // Store original content for fallback\r\n        const rawContent = content;\r\n\r\n        // Clean content - remove \"(Parsing required)\" and other unwanted text\r\n        let cleanedContent = this.cleanResponseContent(content);\r\n```\r\n\r\n**Content Cleaning**:\r\n\r\nAI-generated content may contain:\r\n- Extra markers: `(Parsing required)`\r\n- Format errors: Excessive blank lines\r\n- Irrelevant content: Additional explanatory text\r\n\r\n```javascript\r\ncleanResponseContent(content) {\r\n    if (!content) return '';\r\n\r\n    let cleaned = content;\r\n\r\n    // Remove \"(Parsing required)\" text\r\n    cleaned = cleaned.replace(/\\(Parsing required\\)/gi, '');\r\n\r\n    // Remove excessive whitespace while maintaining structure\r\n    cleaned = cleaned.replace(/\\n{3,}/g, '\\n\\n');\r\n\r\n    // Remove leading/trailing whitespace from each line while maintaining overall structure\r\n    cleaned = cleaned.split('\\n')\r\n        .map(line =\u003e line.trim())\r\n        .join('\\n');\r\n```\r\n\r\n**Cleaning Algorithm Design Philosophy**:\r\n\r\n1. **Preserve Structure**: Don't break original paragraph structure\r\n2. **Remove Noise**: Remove AI-generated marker text\r\n3. **Standardize Whitespace**: Unify blank lines and indentation\r\n\r\n### Partial Parsing Fault Tolerance Mechanism\r\n\r\n```javascript\r\n// Track which markers exist\r\nconst markerPresence = {\r\n    grammarAnalysis: cleanedContent.includes(grammarAnalysisMarker),\r\n    grammarCorrection: cleanedContent.includes(grammarCorrectionMarker),\r\n    keywordAnalysis: cleanedContent.includes(keywordAnalysisMarker),\r\n    chineseDefinition: cleanedContent.includes(chineseDefinitionMarker)\r\n};\r\n\r\nconst presentMarkers = Object.values(markerPresence).filter(Boolean).length;\r\n\r\n// If no markers exist, this is complete failure\r\nif (presentMarkers === 0) {\r\n    return {\r\n        isValid: false,\r\n        error: i18n.t('ai.noValidMarkers', locale) + ` | Response preview: \"${cleanedContent.substring(0, 200)}...\"`,\r\n        grammarAnalysis: '',\r\n        grammarCorrection: '',\r\n        keywordAnalysis: '',\r\n        chineseDefinition: '',\r\n        rawResponseContent: rawContent\r\n    };\r\n}\r\n```\r\n\r\n**Partial Parsing Philosophy**:\r\n\r\nBetter to give users some useful information than to completely reject due to incomplete format.\r\n\r\n## parseStructuredResponse Structured Parsing\r\n\r\n### Structured Marker Extraction Logic\r\n\r\n```javascript\r\nparseStructuredResponse(content, locale = 'en') {\r\n    try {\r\n        const {sentenceMarker, grammarMarker, chineseMarker, endMarker} = this.responseFormat;\r\n\r\n        // Store original content for fallback\r\n        const rawContent = content;\r\n\r\n        // Clean content - remove \"(Parsing required)\" and other unwanted text\r\n        let cleanedContent = this.cleanResponseContent(content);\r\n\r\n        // If END_FORMAT is missing but other markers exist, add it\r\n        if (!cleanedContent.includes(endMarker)) {\r\n            const hasOtherMarkers = [sentenceMarker, grammarMarker, chineseMarker]\r\n                .some(marker =\u003e cleanedContent.includes(marker));\r\n```\r\n\r\n**Auto-Fix Mechanism**:\r\n\r\nSystem automatically adds missing end markers, this detection and fix logic can greatly improve parsing success rate:\r\n\r\n```typescript\r\n// Auto-fix logic\r\nif (!cleanedContent.includes(endMarker)) {\r\n    const hasOtherMarkers = [sentenceMarker, grammarMarker, chineseMarker]\r\n        .some(marker =\u003e cleanedContent.includes(marker));\r\n\r\n    if (hasOtherMarkers) {\r\n        cleanedContent += `\\n\\n${endMarker}`;  // Auto-add end marker\r\n    }\r\n}\r\n```\r\n\r\n### Response Validation Mechanism\r\n\r\n```javascript\r\nextractSectionsRobust(content, markers) {\r\n    const sections = {};\r\n\r\n    // For sentence check response\r\n    if (markers.grammarAnalysisMarker) {\r\n        sections.grammarAnalysis = this.extractSection(\r\n            content,\r\n            markers.grammarAnalysisMarker,\r\n            [markers.grammarCorrectionMarker, markers.keywordAnalysisMarker, markers.chineseDefinitionMarker, markers.endMarker]\r\n        );\r\n```\r\n\r\n**Robust Extraction Algorithm Design**:\r\n\r\nEach section extraction uses priority queue thinking:\r\n\r\n```typescript\r\nextractSection(content, startMarker, endMarkers = []) {\r\n    const startIndex = content.indexOf(startMarker);\r\n    if (startIndex === -1) {\r\n        return null; // Marker not found\r\n    }\r\n\r\n    const contentStart = startIndex + startMarker.length;\r\n\r\n    // Find earliest end marker\r\n    let endIndex = content.length; // Default to content end\r\n\r\n    for (const endMarker of endMarkers) {\r\n        const markerIndex = content.indexOf(endMarker, contentStart);\r\n        if (markerIndex !== -1 \u0026\u0026 markerIndex \u003c endIndex) {\r\n            endIndex = markerIndex;  // Update to earlier position\r\n        }\r\n    }\r\n\r\n    const extractedContent = content.substring(contentStart, endIndex).trim();\r\n    return extractedContent.length \u003e= 5 ? extractedContent : null;\r\n}\r\n```\r\n\r\n**Algorithm Complexity Analysis**:\r\n\r\n- **Time Complexity**: O(n × m), where n is content length, m is number of end markers\r\n- **Space Complexity**: O(1), no additional storage space needed\r\n\r\n### Data Cleaning and Formatting\r\n\r\n```javascript\r\n// Clean potential markdown traces that may interfere\r\ncleaned = cleaned.replace(/```[\\s\\S]*?```/g, ''); // Remove code blocks\r\ncleaned = cleaned.replace(/^\\s*#{1,6}\\s*/gm, ''); // Remove markdown headers\r\n\r\nreturn cleaned.trim();\r\n```\r\n\r\n**Cleaning Rule Design Principles**:\r\n\r\n1. **Preserve Content**: Don't delete meaningful text\r\n2. **Remove Interference**: Delete formatting markers\r\n3. **Standardize**: Unify whitespace character handling\r\n\r\n**Regex Performance Considerations**:\r\n\r\n```typescript\r\n// Code block cleaning\r\ncleaned = cleaned.replace(/```[\\s\\S]*?```/g, '');\r\n\r\n// Header cleaning\r\ncleaned = cleaned.replace(/^\\s*#{1,6}\\s*/gm, '');\r\n```\r\n\r\nPerformance characteristics of these regex patterns:\r\n- **Non-greedy Matching**: `*?` ensures minimal matching\r\n- **Multiline Mode**: `m` flag handles multiline text\r\n- **Character Classes**: `\\s` more efficient than `[ \\t\\n\\r]`\r\n\r\n## Complete Parsing Flow Architecture Design\r\n\r\n### Lifecycle from Template Loading to Response Parsing\r\n\r\nComplete request flow:\r\n\r\n```mermaid\r\ngraph TD\r\n    A[User Request] --\u003e B[AIService.checkSentence]\r\n    B --\u003e C[promptLoader.getSentenceCheckPrompt]\r\n    C --\u003e D[loadPrompt cache lookup]\r\n    D --\u003e E{Cache hit?}\r\n    E --\u003e|Yes| F[Return cached content]\r\n    E --\u003e|No| G[Read file]\r\n    G --\u003e H[Cache storage]\r\n    H --\u003e I[Template variable replacement]\r\n    I --\u003e J[Send AI request]\r\n    J --\u003e K[Receive AI response]\r\n    K --\u003e L[parseSentenceCheckResponse]\r\n    L --\u003e M[Content cleaning]\r\n    M --\u003e N[Marker recognition]\r\n    N --\u003e O[Section extraction]\r\n    O --\u003e P[Integrity validation]\r\n    P --\u003e Q[Return structured result]\r\n```\r\n\r\n**Component Responsibilities**:\r\n\r\n- **PromptLoader**: Responsible for template management and caching\r\n- **AIService**: Responsible for request processing and response parsing\r\n- **HttpUtils**: Responsible for HTTP request encapsulation\r\n- **i18n**: Responsible for internationalization and error messages\r\n\r\n### Data Flow and State Management\r\n\r\n```typescript\r\n// Data flow TypeScript type definitions\r\ninterface RequestFlow {\r\n    input: {\r\n        sentence: string;\r\n        userId?: string;\r\n        grammarLanguageOption: 'pure' | 'combined';\r\n    };\r\n    \r\n    processing: {\r\n        promptTemplate: string;\r\n        filledPrompt: string;\r\n        aiResponse: string;\r\n        cleanedContent: string;\r\n    };\r\n    \r\n    output: {\r\n        grammarAnalysis: string;\r\n        grammarCorrection: string;\r\n        keywordAnalysis: string;\r\n        chineseDefinition: string;\r\n        success: boolean;\r\n        error?: string;\r\n    };\r\n}\r\n```\r\n\r\n**Immutable State Management**:\r\n\r\nEach processing step produces new state rather than modifying existing state:\r\n\r\n```typescript\r\n// Immutable state transitions\r\nconst state1 = { content: rawContent };\r\nconst state2 = { ...state1, content: cleanedContent };\r\nconst state3 = { ...state2, sections: extractedSections };\r\n```\r\n\r\nAdvantages of this design:\r\n- **Debug Friendly**: Each state can be independently inspected\r\n- **Error Tracking**: Easy to locate where problems occur\r\n- **Concurrency Safe**: Avoid state race conditions\r\n\r\n## System Architecture Diagram and Technical Points Summary\r\n\r\n### Complete System Architecture Flow Chart\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"User Request Layer\"\r\n        A[User Input] --\u003e B[API Routes]\r\n    end\r\n    \r\n    subgraph \"Business Logic Layer\"\r\n        B --\u003e C[AIService]\r\n        C --\u003e D[Dynamic Model Selection]\r\n        D --\u003e E[Prompt Loading]\r\n    end\r\n    \r\n    subgraph \"Prompt Management Layer\"\r\n        E --\u003e F[PromptLoader]\r\n        F --\u003e G{Cache Hit?}\r\n        G --\u003e|Yes| H[Return Cache]\r\n        G --\u003e|No| I[File Reading]\r\n        I --\u003e J[Cache Update]\r\n        J --\u003e K[Template Replacement]\r\n    end\r\n    \r\n    subgraph \"AI Interaction Layer\"\r\n        K --\u003e L[HTTP Request]\r\n        L --\u003e M[AI Response]\r\n        M --\u003e N[Response Parsing]\r\n    end\r\n    \r\n    subgraph \"Parsing Processing Layer\"\r\n        N --\u003e O[Content Cleaning]\r\n        O --\u003e P[Marker Recognition]\r\n        P --\u003e Q[Section Extraction]\r\n        Q --\u003e R[Integrity Validation]\r\n        R --\u003e S[Structured Output]\r\n    end\r\n    \r\n    subgraph \"Fault Tolerance Layer\"\r\n        I --\u003e T{File Exists?}\r\n        T --\u003e|Yes| J\r\n        T --\u003e|No| U[Fallback Strategy]\r\n        U --\u003e V[Combined Version]\r\n        V --\u003e W{Load Success?}\r\n        W --\u003e|Yes| J\r\n        W --\u003e|No| X[Error Handling]\r\n        N --\u003e Y{Parse Success?}\r\n        Y --\u003e|Yes| S\r\n        Y --\u003e|No| Z[Partial Parsing]\r\n    end\r\n    \r\n    S --\u003e AA[Return Result]\r\n    X --\u003e AA\r\n    Z --\u003e AA\r\n    H --\u003e K\r\n```\r\n\r\n## Complete Source Code Full Analysis\r\n\r\n### PromptLoader Complete Source Code Analysis\r\n\r\n```javascript\r\n// ==================== Dependency Imports ====================\r\nconst fs = require('fs');        // Node.js file system module for file operations\r\nconst path = require('path');    // Node.js path module for cross-platform path handling\r\n\r\n// ==================== PromptLoader Core Class ====================\r\nclass PromptLoader {\r\n    constructor() {\r\n        // Use Map instead of Object for cache storage, gaining better performance and type safety\r\n        this.promptCache = new Map();\r\n        \r\n        // Use path.join to ensure cross-platform path compatibility\r\n        // __dirname points to current file directory, ../prompts points to prompts folder\r\n        this.promptsDir = path.join(__dirname, '../prompts');\r\n    }\r\n\r\n    /**\r\n     * Core method: Load prompt template from file and cache\r\n     * @param {string} type - Prompt type ('sentence-check' or 'sentence-generation')\r\n     * @param {string} grammarLanguageOption - Grammar language option ('combined' or 'pure')\r\n     * @returns {string} Prompt template string\r\n     */\r\n    loadPrompt(type, grammarLanguageOption = 'combined') {\r\n        // Construct cache key: composite key of type-language option\r\n        // Example: 'sentence-check-combined', 'sentence-generation-pure'\r\n        const cacheKey = `${type}-${grammarLanguageOption}`;\r\n        \r\n        // Cache-first strategy: if exists in cache, return directly\r\n        // Map.has() and Map.get() are both O(1) time complexity\r\n        if (this.promptCache.has(cacheKey)) {\r\n            return this.promptCache.get(cacheKey);\r\n        }\r\n\r\n        try {\r\n            // Construct filename according to convention: type-option.txt\r\n            const filename = `${type}-${grammarLanguageOption}.txt`;\r\n            \r\n            // Construct complete file path, path.join automatically handles path separators\r\n            const filepath = path.join(this.promptsDir, filename);\r\n            \r\n            // Defensive programming: check file existence first\r\n            // Avoid fs.readFileSync throwing hard-to-understand ENOENT errors\r\n            if (!fs.existsSync(filepath)) {\r\n                throw new Error(`Prompt file not found: ${filepath}`);\r\n            }\r\n\r\n            // Synchronously read file content, use utf8 encoding to ensure Chinese displays correctly\r\n            const promptTemplate = fs.readFileSync(filepath, 'utf8');\r\n            \r\n            // Cache strategy: only successfully read content gets cached\r\n            // Avoid caching errors or incomplete data\r\n            this.promptCache.set(cacheKey, promptTemplate);\r\n            \r\n            return promptTemplate;\r\n        } catch (error) {\r\n            // Error handling first layer: log detailed error information\r\n            console.error(`Error loading prompt ${type}-${grammarLanguageOption}:`, error.message);\r\n            \r\n            // Fallback strategy: if pure version fails, try combined version\r\n            // This is an elegant fallback mechanism ensuring service availability\r\n            if (grammarLanguageOption === 'pure') {\r\n                console.warn(`Falling back to combined prompt for ${type}`);\r\n                // Recursive call to self, but using combined option\r\n                return this.loadPrompt(type, 'combined');\r\n            }\r\n            \r\n            // Error handling final defense: if combined version also fails, throw clear error\r\n            throw new Error(`Failed to load prompt template: ${type}-${grammarLanguageOption}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get sentence check prompt (with variable replacement)\r\n     * @param {string} sentence - Sentence to analyze\r\n     * @param {string} grammarLanguageOption - Language option\r\n     * @returns {string} Formatted prompt\r\n     */\r\n    getSentenceCheckPrompt(sentence, grammarLanguageOption = 'combined') {\r\n        // Get template first, leveraging loadPrompt's cache mechanism\r\n        const template = this.loadPrompt('sentence-check', grammarLanguageOption);\r\n        \r\n        // Simple and effective template variable replacement\r\n        // Use String.replace instead of complex template engine, reducing dependencies and complexity\r\n        return template.replace('{sentence}', sentence);\r\n    }\r\n\r\n    /**\r\n     * Get sentence generation prompt (with variable replacement)\r\n     * @param {Array} words - Array of words to use\r\n     * @param {string} grammarLanguageOption - Language option\r\n     * @returns {string} Formatted prompt\r\n     */\r\n    getSentenceGenerationPrompt(words, grammarLanguageOption = 'combined') {\r\n        const template = this.loadPrompt('sentence-generation', grammarLanguageOption);\r\n        \r\n        // Type-safe array handling: ensure words is array before joining\r\n        // If not array, use original value directly\r\n        const wordsString = Array.isArray(words) ? words.join(', ') : words;\r\n        \r\n        return template.replace('{words}', wordsString);\r\n    }\r\n\r\n    /**\r\n     * Clear cache (useful for development and testing)\r\n     */\r\n    clearCache() {\r\n        // Map.clear() is O(1) operation, directly clear all cache\r\n        this.promptCache.clear();\r\n    }\r\n\r\n    /**\r\n     * Get cache status information (for debugging)\r\n     * @returns {Object} Information containing cache size and cached items\r\n     */\r\n    getCacheInfo() {\r\n        return {\r\n            // Map.size is O(1) operation, get number of cached items\r\n            cacheSize: this.promptCache.size,\r\n            // Convert Map keys to array for easy debugging inspection\r\n            cachedPrompts: Array.from(this.promptCache.keys())\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Validate all required prompt files exist\r\n     * @returns {Object} Validation result, containing existing/missing file lists\r\n     */\r\n    validatePromptFiles() {\r\n        // Define system required prompt file list\r\n        // This array defines system integrity requirements\r\n        const requiredPrompts = [\r\n            'sentence-check-pure.txt',\r\n            'sentence-check-combined.txt',\r\n            'sentence-generation-pure.txt',\r\n            'sentence-generation-combined.txt'\r\n        ];\r\n\r\n        const missing = [];   // Missing files\r\n        const existing = [];  // Existing files\r\n\r\n        // Iterate through all required files, check existence\r\n        for (const filename of requiredPrompts) {\r\n            const filepath = path.join(this.promptsDir, filename);\r\n            // fs.existsSync is synchronous check, suitable for one-time validation at startup\r\n            if (fs.existsSync(filepath)) {\r\n                existing.push(filename);\r\n            } else {\r\n                missing.push(filename);\r\n            }\r\n        }\r\n\r\n        return {\r\n            // System integrity flag: only true when all files exist\r\n            valid: missing.length === 0,\r\n            existing,\r\n            missing,\r\n            // Provide prompts directory path for ops personnel to locate issues\r\n            promptsDirectory: this.promptsDir\r\n        };\r\n    }\r\n}\r\n\r\n// ==================== Module Export ====================\r\n// Export singleton instance instead of class itself\r\n// This ensures only one PromptLoader instance globally, saving memory and ensuring cache consistency\r\nmodule.exports = new PromptLoader();\r\n```\r\n\r\n### Response Parsing Core Algorithm Analysis\r\n\r\n```javascript\r\n// ==================== Content Cleaning Algorithm ====================\r\ncleanResponseContent(content) {\r\n    if (!content) return '';\r\n\r\n    let cleaned = content;\r\n\r\n    // Step 1: Remove AI-generated meta markers\r\n    cleaned = cleaned.replace(/\\(Parsing required\\)/gi, '');\r\n\r\n    // Step 2: Standardize whitespace characters, maintaining structural integrity\r\n    cleaned = cleaned.replace(/\\n{3,}/g, '\\n\\n');\r\n\r\n    // Step 3: Clean edge whitespace from each line while maintaining overall layout\r\n    cleaned = cleaned.split('\\n')\r\n        .map(line =\u003e line.trim())\r\n        .join('\\n');\r\n\r\n    // Step 4: Remove markdown elements that may interfere with parsing\r\n    cleaned = cleaned.replace(/```[\\s\\S]*?```/g, '');\r\n    cleaned = cleaned.replace(/^\\s*#{1,6}\\s*/gm, '');\r\n\r\n    return cleaned.trim();\r\n}\r\n\r\n// ==================== Marker Extraction Algorithm ====================\r\nextractSection(content, startMarker, endMarkers = []) {\r\n    // Step 1: Locate start marker\r\n    const startIndex = content.indexOf(startMarker);\r\n    if (startIndex === -1) {\r\n        return null; // Marker not found, return null instead of throwing exception\r\n    }\r\n\r\n    // Step 2: Calculate content start position\r\n    const contentStart = startIndex + startMarker.length;\r\n\r\n    // Step 3: Find nearest end marker (greedy algorithm)\r\n    let endIndex = content.length; // Default to content end\r\n\r\n    for (const endMarker of endMarkers) {\r\n        const markerIndex = content.indexOf(endMarker, contentStart);\r\n        if (markerIndex !== -1 \u0026\u0026 markerIndex \u003c endIndex) {\r\n            endIndex = markerIndex;  // Update to earlier position\r\n        }\r\n    }\r\n\r\n    // Step 4: Extract and validate content\r\n    const extractedContent = content.substring(contentStart, endIndex).trim();\r\n    \r\n    // Content quality check: length at least 5 characters to be considered valid content\r\n    return extractedContent.length \u003e= 5 ? extractedContent : null;\r\n}\r\n```\r\n\r\n**Extraction Algorithm Time Complexity Analysis**:\r\n\r\n- **Best Case**: O(n), where n is content length (only need to scan once)\r\n- **Worst Case**: O(n × m), where m is number of end markers\r\n- **Average Case**: O(n), because usually first marker can match\r\n\r\n**Space Complexity**: O(1), only uses constant level additional space\r\n\r\n## Final Words\r\n\r\nAs you can see, the original design philosophy of MCP is actually this simple and unpretentious. Agree on a set of data interaction formats with AI, and let other applications read this format to understand AI's output, ultimately achieving the effect of \"AI calling external tools.\"\r\n\r\nAfter this complete source code analysis, we've seen the ingenious design behind what appears to be a simple prompt management system: from singleton pattern memory optimization, to Map cache performance improvements, from fallback strategy service availability, to defensive programming robustness guarantees.\r\n\r\n**Every line of code is not accidental, every design decision has its profound considerations.**\r\n\r\n*May your prompts be like spring breeze and gentle rain, letting AI understand your every intention; may your parsing algorithms be like a skilled butcher, transforming complex responses into clear structures. In this era where AI and human wisdom intertwine, let us together weave a more beautiful tomorrow with code!* ✨"])</script><script>self.__next_f.push([1,"28:Tcfca,"])</script><script>self.__next_f.push([1,"\n# The Double-Edged Sword of Keys: RSA Encryption's Security Protection Path in Modern Web Applications\n\nIn the long river of cryptography, if symmetric encryption is a precise lock, then asymmetric encryption is a magical double-edged sword—one edge can encrypt, the other can decrypt, yet it never harms the wielder.\n\nLooking back to the early days of information security, developers were still struggling with how to securely transmit API keys. Plaintext transmission? That's running naked. Symmetric encryption? Key distribution became the new challenge. It wasn't until the emergence of the RSA algorithm that this seemingly unsolvable key distribution problem was truly resolved.\n\nThis article will deeply analyze the complete RSA encryption implementation in the Questions Party project, from mathematical principles to engineering practice, from key generation to data transmission, taking you through the true power of this \"double-edged sword of keys.\"\n\n## Mathematical Foundation of the RSA Algorithm\n\n### The Mathematical Challenge of Large Number Factorization\n\nThe security of the RSA algorithm is built on a seemingly simple yet extremely difficult mathematical problem: **prime factorization of large integers**.\n\nIt's easy to multiply two large prime numbers:\n$$p = 61, q = 53$$\n$$n = p \\times q = 61 \\times 53 = 3233$$\n\nBut if I now tell you $n = 3233$ and ask you to find $p$ and $q$, you might need to try many times to find the answer.\n\n**Now imagine if $p$ and $q$ were both 1024-bit prime numbers...**\n\nThis is the core idea of RSA: **forward computation is simple, reverse computation is difficult**.\n\n### Euler's Totient Function and Modular Arithmetic\n\nThe key to the RSA algorithm lies in Euler's totient function $\\phi(n)$:\n\n$$\\phi(n) = \\phi(p \\times q) = (p-1)(q-1)$$\n\nContinuing with our example:\n$$\\phi(3233) = (61-1)(53-1) = 60 \\times 52 = 3120$$\n\n**Why calculate Euler's totient function?** Because it tells us how many numbers are coprime with $n$ under modulo $n$.\n\n### Mathematical Process of Public-Private Key Generation\n\n**Step 1: Choose the public key exponent $e$**\n\nHere's a small example, choosing $e = 17$, which satisfies RSA conditions:\n- 1 \u003c e \u003c φ(n), i.e., 1 \u003c 17 \u003c 3120 ✓\n- gcd(17, 3120) = 1, i.e., 17 is coprime with 3120 ✓\n\n**Note**: In practical applications, $e = 65537$ is usually chosen, but that requires larger prime numbers so that $\\phi(n)$ is much greater than 65537.\n\n**Step 2: Calculate the private key exponent $d$**\n\nMust satisfy:\n$$e \\times d \\equiv 1 \\pmod{\\phi(n)}$$\n\nUsing our example:\n$$17 \\times d \\equiv 1 \\pmod{3120}$$\n\nThrough the extended Euclidean algorithm, we can calculate $d = 2753$.\n\n**Verification**: $17 \\times 2753 = 46801$, $46801 = 15 \\times 3120 + 1 = 46800 + 1$, so $17 \\times 2753 \\equiv 1 \\pmod{3120}$ ✓\n\n### Detailed Explanation of the Extended Euclidean Algorithm\n\nThe extended Euclidean algorithm is a classic algorithm for solving linear Diophantine equations $ax + by = \\gcd(a,b)$. In RSA, we need to solve:\n\n$$e \\cdot d + \\phi(n) \\cdot k = 1$$\n\nThat is, find $d$ and $k$ such that $e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$.\n\n**Algorithm Steps**:\n\nUsing our example, solving $17 \\cdot d \\equiv 1 \\pmod{3120}$:\n\n1. **Initialization**:\n   - $r_0 = 3120, r_1 = 17$\n   - $s_0 = 1, s_1 = 0$  \n   - $t_0 = 0, t_1 = 1$\n\n2. **Iteration Process**:\n   ```\n   Step 1: q₁ = ⌊3120/17⌋ = 183\n   r₂ = 3120 - 183×17 = 3120 - 3111 = 9\n   s₂ = 1 - 183×0 = 1\n   t₂ = 0 - 183×1 = -183\n   \n   Step 2: q₂ = ⌊17/9⌋ = 1\n   r₃ = 17 - 1×9 = 8\n   s₃ = 0 - 1×1 = -1\n   t₃ = 1 - 1×(-183) = 184\n   \n   Step 3: q₃ = ⌊9/8⌋ = 1\n   r₄ = 9 - 1×8 = 1\n   s₄ = 1 - 1×(-1) = 2\n   t₄ = -183 - 1×184 = -367\n   \n   Step 4: r₄ = 1, algorithm ends\n   ```\n\n3. **Final Result**:\n   When $r_4 = 1$, the corresponding $t_4 = -367$.\n   \n   Since we need a positive number, $d = -367 + 3120 = 2753$.\n   \n   **Verification**: $17 \\times 2753 = 46801 = 15 \\times 3120 + 1$, indeed $17 \\times 2753 \\equiv 1 \\pmod{3120}$ ✓\n\n**Mathematical Principle of the Algorithm**:\nThe extended Euclidean algorithm is based on the fact that if $\\gcd(e, \\phi(n)) = 1$, then there must exist integers $d$ and $k$ such that:\n$$e \\cdot d + \\phi(n) \\cdot k = 1$$\n\nThis is equivalent to:\n$$e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$$\n\nThat is, $d$ is the **modular multiplicative inverse** of $e$ under modulo $\\phi(n)$.\n\n### Mathematical Principles of Encryption and Decryption\n\n**Symbol Explanation**:\n\nLet's first clarify the meaning of each mathematical symbol:\n\n- **$m$** (message): **Plaintext message**, the original data to be encrypted, must satisfy $0 \\leq m \u003c n$\n- **$c$** (ciphertext): **Ciphertext**, the encrypted data\n- **$e$** (encryption exponent): **Public key exponent**, 17 in our example, usually 65537 in practical applications\n- **$d$** (decryption exponent): **Private key exponent**, the modular multiplicative inverse of e under modulo φ(n), 2753 in our example\n- **$n$**: **Modulus**, equal to the product of two large prime numbers, i.e., $n = p \\times q$\n- **$\\phi(n)$**: **Euler's totient function value**, equal to $(p-1)(q-1)$, representing the number of positive integers less than n and coprime with n\n- **$k$**: **Arbitrary integer**, auxiliary variable appearing in mathematical proofs\n\n**Encryption Process**:\n$$c = m^e \\bmod n$$\n\n**Decryption Process**:\n$$m = c^d \\bmod n$$\n\n**Mathematical Proof of RSA Correctness**:\n\n**Step 1: Apply Euler's Theorem**\nAccording to Euler's theorem, for coprime $m$ and $n$ (i.e., $\\gcd(m,n) = 1$):\n$$m^{\\phi(n)} \\equiv 1 \\pmod{n}$$\n\n**Step 2: Utilize the Definition of the Private Key**\nSince $d$ is the modular multiplicative inverse of $e$, we have:\n$$e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$$\n\nThis means there exists some integer $k$ such that:\n$$e \\cdot d = 1 + k \\cdot \\phi(n)$$\n\n**Step 3: Verify the Decryption Process**\nNow we prove that decryption can indeed recover the original message:\n\n$$c^d = (m^e)^d = m^{ed} = m^{1 + k\\phi(n)} = m^1 \\cdot m^{k\\phi(n)} = m \\cdot (m^{\\phi(n)})^k$$\n\nAccording to Euler's theorem, $m^{\\phi(n)} \\equiv 1 \\pmod{n}$, therefore:\n\n$$m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}$$\n\n**Conclusion**:\n$$c^d \\equiv m \\pmod{n}$$\n\n**Specific Numerical Verification**:\n\n- Let plaintext $m = 123$\n- Encryption: $c = 123^{17} \\bmod 3233$\n- Decryption: $m' = c^{2753} \\bmod 3233 = 123$\n\n**Important Note**: This example uses small prime numbers for demonstration purposes only. In practical applications, RSA uses 1024-bit or 2048-bit large prime numbers, where $e = 65537$ is usually chosen because it provides good computational performance while ensuring security.\n\n## RSA's Role Positioning in Web Security\n\n### Selection Strategy: Symmetric vs Asymmetric Encryption\n\nIn modern web applications, RSA is typically not used for encrypting large amounts of data, but rather plays the role of a \"key protector\":\n\n```\nTraditional Dilemma:\nUser --[Plaintext API Key]--\u003e Server  ❌ Insecure\nUser --[Symmetric Encryption]--\u003e Server    ❌ Key Distribution Problem\n\nRSA Solution:\nUser --[RSA Public Key Encryption]--\u003e Server --[RSA Private Key Decryption]--\u003e Secure Storage  ✅\n```\n\n**Performance Comparison**:\n\n| Encryption Method | Encryption Speed | Decryption Speed | Key Distribution | Applicable Scenarios |\n|------------------|------------------|------------------|------------------|---------------------|\n| AES-256 | Very Fast | Very Fast | Difficult | Large Data |\n| RSA-2048 | Slow | Very Slow | Simple | Small Data/Key Exchange |\n\n### Security of RSA-OAEP Padding Scheme\n\n**Why is padding needed?**\n\nIf using raw RSA directly:\n- Same plaintext always produces same ciphertext\n- Vulnerable to chosen plaintext attacks\n- Plaintext length information leakage\n\n**How OAEP Padding Works**:\n\n```\nPlaintext → Add Random Number → Mask Generation → Final Ciphertext\n```\n\nOAEP ensures:\n1. **Randomness**: Same plaintext produces different encryption results each time\n2. **Integrity**: Any tampering will cause decryption to fail\n3. **Semantic Security**: Attackers cannot infer plaintext information from ciphertext\n\n### Questions Party Security Architecture Design\n\nUpdating API Key:\n\n```\nUser Input API Key → Frontend RSA Encryption → HTTPS Transmission → Database Storage (stores ciphertext)\n```\n\nUsing API Key to Send Requests:\n\n```\nUser Input Request Content → HTTPS Transmission → Backend RSA Decryption → Use Decrypted Plaintext Key to Call Large Model API → Parse Response and Return\n```\n\n## RSA Implementation Architecture in the Questions Party Project\n\n### Overall Security Architecture Design\n\n```mermaid\ngraph TB\n    subgraph \"Frontend Browser\"\n        A[User Input API Key] --\u003e B[Get RSA Public Key]\n        B --\u003e C[Frontend RSA Encryption]\n        C --\u003e D[HTTPS Transmission]\n    end\n    \n    subgraph \"Backend Server\"\n        D --\u003e E[Receive Encrypted Data]\n        E --\u003e G[Database Storage]\n    end\n    \n    subgraph \"Key Management\"\n        H[Environment Variable File] --\u003e I[RSA Key Pair]\n        I --\u003e J[Public Key Distribution]\n        I --\u003e K[Private Key Protection]\n    end\n    \n    J --\u003e B\n    K --\u003e G\n```\n\n### Encryption Strategy in Frontend-Backend Separation Architecture\n\n**Frontend Responsibilities**:\n- Get public key\n- Encrypt sensitive data\n- Transmit encrypted data\n\n**Backend Responsibilities**:\n- Key pair management\n- Public key distribution\n- Store encrypted data\n\n**Security Boundaries**:\n- Private key never leaves the server\n- Public key can be freely distributed\n- Sensitive data is only decrypted when necessary\n\n### Key Management and Distribution Mechanism\n\n```javascript\nconst jsrsasign = require('jsrsasign');\nconst { KEYUTIL } = jsrsasign;\nconst crypto = require('crypto');\n\nclass RSACrypto {\n  constructor() {\n    this.keySize = 2048;\n    this.initializeKeys();\n  }\n\n  // Initialize RSA key pair from environment variables or generate new key pair\n  initializeKeys() {\n    if (process.env.RSA_PUBLIC_KEY \u0026\u0026 process.env.RSA_PRIVATE_KEY) {\n      // Handle escaped and non-escaped newlines (compatibility consideration)\n      this.publicKeyPEM = process.env.RSA_PUBLIC_KEY.includes('\\\\n') \n        ? process.env.RSA_PUBLIC_KEY.replace(/\\\\n/g, '\\n')\n        : process.env.RSA_PUBLIC_KEY;\n      this.privateKeyPEM = process.env.RSA_PRIVATE_KEY.includes('\\\\n')\n        ? process.env.RSA_PRIVATE_KEY.replace(/\\\\n/g, '\\n')\n        : process.env.RSA_PRIVATE_KEY;\n    } else {\n      console.warn('RSA keys not found in environment. Generating new keys...');\n      const keyPair = this.generateKeyPair();\n      this.publicKeyPEM = keyPair.publicKeyPEM;\n      this.privateKeyPEM = keyPair.privateKeyPEM;\n      \n      console.log('Generated RSA Public Key:', this.publicKeyPEM);\n      console.log('Generated RSA Private Key:', this.privateKeyPEM);\n      console.log('Please add these keys to your .env file:');\n      console.log('RSA_PUBLIC_KEY=\"' + this.publicKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\n      console.log('RSA_PRIVATE_KEY=\"' + this.privateKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\n    }\n  }\n\n  // RSA key pair generation: use jsrsasign to generate standard format keys\n  generateKeyPair(keySize = 2048) {\n    try {\n      const keyPair = KEYUTIL.generateKeypair('RSA', keySize);\n      const publicKeyPEM = KEYUTIL.getPEM(keyPair.pubKeyObj);       // Public key PEM format\n      const privateKeyPEM = KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV');  // Private key PKCS8 format\n      \n      return { publicKeyPEM, privateKeyPEM };\n    } catch (error) {\n      throw new Error(`RSA key generation failed: ${error.message}`);\n    }\n  }\n\n  // Public key distribution interface: for frontend to get public key\n  getPublicKey() {\n    return this.publicKeyPEM;\n  }\n\n  // RSA-OAEP encryption implementation: use Node.js crypto module to ensure optimal performance and security\n  encrypt(plaintext) {\n    try {\n      // Input validation: ensure plaintext is valid\n      if (!plaintext || typeof plaintext !== 'string') {\n        throw new Error('Invalid plaintext for encryption');\n      }\n\n      // UTF-8 encoding conversion: ensure proper handling of Chinese and other characters\n      const buffer = Buffer.from(plaintext, 'utf8');\n      \n      // Core encryption logic: RSA encryption with OAEP padding\n      // Choose Node.js crypto over jsrsasign: more reliable OAEP implementation\n      const encrypted = crypto.publicEncrypt(\n        {\n          key: this.publicKeyPEM,                              // PEM format public key\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // OAEP padding, prevents padding attacks\n          oaepHash: 'sha256',                                  // SHA-256 hash function\n        },\n        buffer\n      );\n\n      // Base64 encoding: convenient for network transmission and storage\n      return encrypted.toString('base64');\n    } catch (error) {\n      throw new Error(`RSA encryption failed: ${error.message}`);\n    }\n  }\n\n  // RSA-OAEP decryption implementation: core of temporary decryption strategy\n  decrypt(encryptedData) {\n    try {\n      // Input validation: ensure ciphertext format is correct\n      if (!encryptedData || typeof encryptedData !== 'string') {\n        throw new Error('Invalid encrypted data for decryption');\n      }\n\n      // Base64 decoding: restore binary ciphertext\n      const encryptedBuffer = Buffer.from(encryptedData, 'base64');\n      \n      // Core decryption logic: decrypt using private key\n      const decrypted = crypto.privateDecrypt(\n        {\n          key: this.privateKeyPEM,                             // PEM format private key\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // Consistent padding with encryption\n          oaepHash: 'sha256',                                  // Consistent hash with encryption\n        },\n        encryptedBuffer\n      );\n\n      // UTF-8 decoding: restore original string\n      return decrypted.toString('utf8');\n    } catch (error) {\n      throw new Error(`RSA decryption failed: ${error.message}`);\n    }\n  }\n\n  // Flexible encryption interface: support encryption with arbitrary public key (for testing)\n  encryptWithPublicKey(plaintext, publicKeyPEM) {\n    try {\n      if (!plaintext || typeof plaintext !== 'string') {\n        throw new Error('Invalid plaintext for encryption');\n      }\n\n      const buffer = Buffer.from(plaintext, 'utf8');\n      \n      // Encrypt using externally provided public key\n      const encrypted = crypto.publicEncrypt(\n        {\n          key: publicKeyPEM,                                   // External public key\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n          oaepHash: 'sha256',\n        },\n        buffer\n      );\n\n      return encrypted.toString('base64');\n    } catch (error) {\n      throw new Error(`RSA encryption with provided key failed: ${error.message}`);\n    }\n  }\n\n  // Key validation utility: ensure key format is correct\n  validateKey(keyPEM, isPrivate = false) {\n    try {\n      const keyObj = KEYUTIL.getKey(keyPEM);\n      return keyObj \u0026\u0026 (isPrivate ? keyObj.isPrivate : keyObj.isPublic);\n    } catch (error) {\n      return false;   // Return false on validation failure instead of throwing exception\n    }\n  }\n}\n\n// Singleton pattern export: global unique instance, saves memory and ensures cache consistency\nconst rsaCrypto = new RSACrypto();\n\n// Module export: provide multiple usage methods\nmodule.exports = {\n  RSACrypto,                                                    // Export class (for extension)\n  rsaCrypto,                                                   // Export singleton instance\n  generateKeyPair: (keySize) =\u003e rsaCrypto.generateKeyPair(keySize),     // Convenience function\n  encrypt: (plaintext) =\u003e rsaCrypto.encrypt(plaintext),                 // Convenience function\n  decrypt: (encryptedData) =\u003e rsaCrypto.decrypt(encryptedData),         // Convenience function\n  getPublicKey: () =\u003e rsaCrypto.getPublicKey(),                         // Convenience function\n  encryptWithPublicKey: (plaintext, publicKey) =\u003e rsaCrypto.encryptWithPublicKey(plaintext, publicKey),\n  validateKey: (keyPEM, isPrivate) =\u003e rsaCrypto.validateKey(keyPEM, isPrivate)\n};\n```\n\n### Key Initialization Design\n\n1. **Environment Variable Priority**: Production environment uses pre-configured keys\n2. **Auto-generation Fallback**: Development environment auto-generates temporary keys\n3. **Format Compatibility**: Handle escape character compatibility issues\n\n### Encrypted Data Storage Strategy\n\n```javascript\n// Method to decrypt API key using RSA\nuserSchema.methods.decryptApiKey = function(encryptedKey = null) {\n  try {\n    const keyToDecrypt = encryptedKey || this.apiKey;\n    \n    if (!keyToDecrypt) {\n      return null;\n    }\n\n    // Check if it's RSA encrypted (base64 format from frontend)\n    if (keyToDecrypt.startsWith('rsa:')) {\n      const encryptedData = keyToDecrypt.substring(4);\n      return decrypt(encryptedData);\n    }\n    \n    // If not encrypted, return directly (for development/testing)\n    return keyToDecrypt;\n  } catch (error) {\n    throw new Error(`API key decryption failed: ${error.message}`);\n  }\n};\n```\n\n**Storage Strategy**:\n\n1. **Prefix Identification**: `rsa:` prefix identifies encrypted data\n2. **Compatibility Handling**: Support plaintext storage (development environment)\n\n## Backend RSA Key Management and Encryption Service\n\n### Singleton Pattern Design of RSACrypto Class\n\n```javascript\n// Export singleton instance\nconst rsaCrypto = new RSACrypto();\n\nmodule.exports = {\n  RSACrypto,\n  rsaCrypto,\n  generateKeyPair: (keySize) =\u003e rsaCrypto.generateKeyPair(keySize),\n  encrypt: (plaintext) =\u003e rsaCrypto.encrypt(plaintext),\n  decrypt: (encryptedData) =\u003e rsaCrypto.decrypt(encryptedData),\n  getPublicKey: () =\u003e rsaCrypto.getPublicKey(),\n  encryptWithPublicKey: (plaintext, publicKey) =\u003e rsaCrypto.encryptWithPublicKey(plaintext, publicKey),\n  validateKey: (keyPEM, isPrivate) =\u003e rsaCrypto.validateKey(keyPEM, isPrivate)\n};\n```\n\n### Key Initialization Strategy\n\n**Generation Strategy**:\n\n```javascript\n// Production environment: use environment variables\nif (process.env.RSA_PUBLIC_KEY \u0026\u0026 process.env.RSA_PRIVATE_KEY) {\n  // Use pre-configured key pair\n} else {\n  // Development environment: dynamic generation\n  const keyPair = this.generateKeyPair();\n}\n```\n\n**Mathematical Process of Key Generation**:\n\n```javascript\n// Generate RSA key pair\ngenerateKeyPair(keySize = 2048) {\n  try {\n    const keyPair = KEYUTIL.generateKeypair('RSA', keySize);\n    const publicKeyPEM = KEYUTIL.getPEM(keyPair.pubKeyObj);\n    const privateKeyPEM = KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV');\n    \n    return { publicKeyPEM, privateKeyPEM };\n  } catch (error) {\n    throw new Error(`RSA key generation failed: ${error.message}`);\n  }\n}\n```\n\n### Node.js Crypto Module's OAEP Implementation\n\n```javascript\n// Use RSA-OAEP and public key to encrypt data\nencrypt(plaintext) {\n  try {\n    if (!plaintext || typeof plaintext !== 'string') {\n      throw new Error('Invalid plaintext for encryption');\n    }\n\n    // Convert plaintext to Buffer\n    const buffer = Buffer.from(plaintext, 'utf8');\n    \n    // Use Node.js crypto module for RSA-OAEP encryption (more reliable than jsrsasign)\n    const encrypted = crypto.publicEncrypt(\n      {\n        key: this.publicKeyPEM,\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        oaepHash: 'sha256',\n      },\n      buffer\n    );\n\n    return encrypted.toString('base64');\n  } catch (error) {\n    throw new Error(`RSA encryption failed: ${error.message}`);\n  }\n}\n```\n\n**OAEP Parameter Analysis**:\n\n1. **padding: RSA_PKCS1_OAEP_PADDING**: Use OAEP padding scheme\n2. **oaepHash: 'sha256'**: Use SHA-256 as hash function\n3. **Output Format**: Base64 encoding for easy transmission\n\n**Why Mix jsrsasign and crypto?**\n\n- **jsrsasign**: Key generation and management\n- **crypto**: Encryption and decryption operations (better performance)\n\n## Deep Analysis of Frontend RSA Encryption Implementation\n\n### Usage of Web Crypto API\n\n```typescript\n// Use RSA-OAEP for encryption (compatible with backend)\nasync encrypt(plaintext: string): Promise\u003cstring\u003e {\n  if (!this.publicKey) {\n    throw new Error('Public key not set. Call setPublicKey() first.');\n  }\n\n  if (!plaintext || typeof plaintext !== 'string') {\n    throw new Error('Invalid plaintext for encryption');\n  }\n\n  try {\n    // Use Web Crypto API for RSA-OAEP encryption\n    // First, import the public key\n    const publicKeyBuffer = this.pemToArrayBuffer(this.publicKey);\n\n    const cryptoKey = await window.crypto.subtle.importKey(\n      'spki',\n      publicKeyBuffer,\n      {\n        name: 'RSA-OAEP',\n        hash: 'SHA-256',\n      },\n      false,\n      ['encrypt']\n    );\n\n    // Encrypt plaintext\n    const plaintextBuffer = new TextEncoder().encode(plaintext);\n    const encryptedBuffer = await window.crypto.subtle.encrypt(\n      {\n        name: 'RSA-OAEP',\n      },\n      cryptoKey,\n      plaintextBuffer\n    );\n\n    // Convert to base64 to match backend format\n    return this.arrayBufferToBase64(encryptedBuffer);\n  } catch (error) {\n    throw new Error(`RSA encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n```\n\n### Processing of PEM Format Keys\n\n```typescript\n// Helper method: convert PEM format to ArrayBuffer\nprivate pemToArrayBuffer(pem: string): ArrayBuffer {\n  // Remove header and footer\n  const pemHeader = '-----BEGIN PUBLIC KEY-----';\n  const pemFooter = '-----END PUBLIC KEY-----';\n  const pemContents = pem.replace(pemHeader, '').replace(pemFooter, '').replace(/\\s/g, '');\n\n  // Base64 decode to binary string\n  const binaryString = atob(pemContents);\n\n  // Binary string to ArrayBuffer\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i \u003c binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  return bytes.buffer;\n}\n```\n\n**PEM Format Parsing**:\n\n1. **Header/Footer Removal**: Remove PEM format identifiers\n2. **Whitespace Cleanup**: Remove all whitespace characters\n3. **Base64 Decoding**: Convert Base64 string to binary\n4. **ArrayBuffer Conversion**: Convert to Web Crypto API required format\n\n### ArrayBuffer and Base64 Conversion\n\n```typescript\n// Helper method: convert ArrayBuffer to base64\nprivate arrayBufferToBase64(buffer: ArrayBuffer): string {\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i \u003c bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}\n```\n\n**Data Conversion**:\n\n```\nUser Input(String) → TextEncoder → ArrayBuffer → Web Crypto API → ArrayBuffer → Base64 → Network Transmission\n```\n\nConversion step explanation:\n- **TextEncoder**: Convert string to UTF-8 bytes\n- **ArrayBuffer**: Standard format for Web Crypto API\n- **Base64**: Safe encoding for network transmission\n\n**Fallback Strategy**:\n\n```typescript\n// Check Web Crypto API support\nif (!window.crypto || !window.crypto.subtle) {\n  // Fallback to jsrsasign implementation\n  return this.jsrsasignEncrypt(plaintext);\n}\n```\n\n## Complete Implementation of API Key Update Process\n\n### Design Philosophy of updateApiKey Interface\n\n```javascript\n// @desc    Update user API key\n// @route   PUT /api/auth/api-key\n// @access  Private\nexports.updateApiKey = async (req, res) =\u003e {\n  try {\n    const { apiKey, useCustomApiKey } = req.body;\n\n    // Validate input, only require apiKey when useCustomApiKey is true and apiKey has value\n    // Allow useCustomApiKey to be true but apiKey to be empty (user intends to customize but hasn't entered yet)\n    if (useCustomApiKey \u0026\u0026 apiKey \u0026\u0026 apiKey.trim().length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: req.t('auth.apiKeyRequired')\n      });\n    }\n\n    const user = await User.findById(req.user.id);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: req.t('auth.userNotFound')\n      });\n    }\n\n    // Update user API key settings\n    if (useCustomApiKey) {\n      // If apiKey has value and is not empty, directly store the frontend encrypted API key\n      // Frontend sends RSA encrypted API key with 'rsa:' prefix—no decryption here\n      if (apiKey \u0026\u0026 apiKey.trim().length \u003e 0) {\n        user.apiKey = apiKey.trim(); // Directly store encrypted data\n      } else {\n        user.apiKey = undefined;\n      }\n      user.useCustomApiKey = true;\n    } else {\n      user.apiKey = undefined;\n      user.useCustomApiKey = false;\n    }\n\n    await user.save();\n\n    res.status(200).json({\n      success: true,\n      message: req.t('auth.apiKeyUpdatedSuccessfully'),\n      useCustomApiKey: user.useCustomApiKey\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      message: req.t('auth.serverError')\n    });\n  }\n};\n```\n\n### Complete Flow: Frontend Encryption → Transmission → Backend Decryption\n\n```typescript\nconst updateApiKey = async (apiKey: string, shouldUseCustomKey: boolean) =\u003e {\n  loading.value = true\n  try {\n    // Get latest public key before encryption\n    if (shouldUseCustomKey \u0026\u0026 apiKey) {\n      const keyResult = await fetchPublicKey()\n      if (!keyResult.success) {\n        toast.error(t('apiKey.publicKeyFetchFailed'))\n        return {success: false, message: t('apiKey.publicKeyFetchError')}\n      }\n    }\n\n    // Encrypt if there's custom key and apiKey\n    let encryptedApiKey = ''\n    if (shouldUseCustomKey \u0026\u0026 apiKey \u0026\u0026 publicKey.value) {\n      try {\n        const encrypted = await rsaCrypto.encrypt(apiKey)\n        encryptedApiKey = 'rsa:' + encrypted\n      } catch (encryptError) {\n        toast.error(t('apiKey.encryptionFailed'))\n        console.error(encryptedApiKey)\n        return {success: false, message: t('apiKey.encryptionError')}\n      }\n    }\n\n    const response = await aiConfigAPI.updateApiKey({\n      apiKey: shouldUseCustomKey ? encryptedApiKey : '',\n      useCustomApiKey: shouldUseCustomKey\n    })\n\n    if (response.data.success) {\n      useCustomApiKey.value = response.data.useCustomApiKey\n      hasCustomApiKey.value = shouldUseCustomKey \u0026\u0026 !!apiKey\n      customApiKey.value = apiKey\n      toast.success(t('apiKey.updateSuccess'))\n      return {success: true}\n    } else {\n      const message = response.data.message || t('common.error')\n      toast.error(message)\n      return {success: false, message}\n    }\n  } catch (error: any) {\n    const message = error.response?.data?.message || t('common.error')\n    toast.error(message)\n    return {success: false, message}\n  } finally {\n    loading.value = false\n  }\n}\n```\n\n**Complete Flow Data Changes**:\n\n**When Updating API Key**:\n```\nUser Input: \"sk-1234567890abcdef\"\n  ↓\nFrontend Encryption: \"rsa:Base64EncryptedData...\"\n  ↓\nHTTPS Transmission: [TLS Encrypted RSA Encrypted Data]\n  ↓\nBackend Reception: \"rsa:Base64EncryptedData...\"\n  ↓\nDatabase Storage: \"rsa:Base64EncryptedData...\" (directly store ciphertext)\n```\n\n**When Using API Key to Call Model**:\n```\nDatabase Read: \"rsa:Base64EncryptedData...\"\n  ↓\nTemporary Decryption: \"sk-1234567890abcdef\"\n  ↓\nCall Large Model API: use plaintext key\n  ↓\nImmediate Cleanup: plaintext key destroyed from memory\n```\n\n### Error Handling and User Experience Optimization\n\n**Multi-layer Error Handling**:\n\n```typescript\n// Layer 1: Encryption failure\ntry {\n  const encrypted = await rsaCrypto.encrypt(apiKey)\n  encryptedApiKey = 'rsa:' + encrypted\n} catch (encryptError) {\n  toast.error(t('apiKey.encryptionFailed'))\n  return {success: false, message: t('apiKey.encryptionError')}\n}\n\n// Layer 2: Network request failure\ntry {\n  const response = await aiConfigAPI.updateApiKey({...})\n} catch (error: any) {\n  const message = error.response?.data?.message || t('common.error')\n  toast.error(message)\n  return {success: false, message}\n}\n```\n\n## Data Storage and Decryption Strategy\n\n### Database Storage Format for Encrypted Data\n\n```javascript\n// Custom API key (optional, uses platform default when not set)\n// Stored in database as encrypted form\napiKey: {\n  type: String,\n  required: false,\n  trim: true\n},\n// Whether to use custom API key\nuseCustomApiKey: {\n  type: Boolean,\n  default: false\n},\n```\n\n**Database Storage Data Format**:\n\n```javascript\n// User document example\n{\n  _id: ObjectId(\"...\"),\n  username: \"testuser\",\n  email: \"test@example.com\",\n  apiKey: \"rsa:Base64EncodedEncryptedData...\",  // Encrypted storage\n  useCustomApiKey: true,\n  // ... other fields\n}\n```\n\n### rsa: Prefix Identification Mechanism\n\n```javascript\n// Method to decrypt API key using RSA\nuserSchema.methods.decryptApiKey = function(encryptedKey = null) {\n  try {\n    const keyToDecrypt = encryptedKey || this.apiKey;\n    \n    if (!keyToDecrypt) {\n      return null;\n    }\n\n    // Check if it's RSA encrypted (base64 format from frontend)\n    if (keyToDecrypt.startsWith('rsa:')) {\n      const encryptedData = keyToDecrypt.substring(4);\n      return decrypt(encryptedData);\n    }\n    \n    // If not encrypted, return directly (for development/testing)\n    return keyToDecrypt;\n  } catch (error) {\n    throw new Error(`API key decryption failed: ${error.message}`);\n  }\n};\n```\n\n### Decryption Timing Selection Strategy\n\n```javascript\n// Method to get decrypted API key for AI service\nuserSchema.methods.getDecryptedApiKey = function() {\n  if (!this.apiKey || !this.useCustomApiKey) {\n    return null;\n  }\n  return this.decryptApiKey();\n};\n```\n\n**Questions Party's Choice**: **On-demand Temporary Decryption**\n\n- When storing: Directly store encrypted data, no decryption\n- When using: Only temporarily decrypt when calling large model API\n- After decryption: Immediately clean plaintext data from memory\n- Advantage: Maximize security, minimize plaintext exposure time\n\n### Lifecycle Management of Plaintext Data in Memory\n\n```javascript\n// Helper function to get decrypted platform API key\nfunction getPlatformApiKey() {\n    // First try to get encrypted API key\n    if (process.env.ENCRYPTED_PLATFORM_API_KEY) {\n        try {\n            const {decrypt} = require('../utils/rsaCrypto');\n\n            if (process.env.ENCRYPTED_PLATFORM_API_KEY.startsWith('rsa:')) {\n                const encryptedData = process.env.ENCRYPTED_PLATFORM_API_KEY.substring(4);\n                return decrypt(encryptedData);\n            }\n        } catch (error) {\n            console.warn('Failed to decrypt platform API key:', error.message);\n        }\n    }\n\n    // Return decrypted key if available, otherwise return null\n    return null;\n}\n```\n\n## Security Analysis and Attack Prevention\n\n### Common RSA Attack Methods and Protection Measures\n\n**1. Small Public Exponent Attack**\n\n```javascript\n// ❌ Dangerous choice\ne = 3  // Too small, vulnerable to attacks\n\n// ✅ Safe choice\ne = 65537  // Large enough, good computational efficiency\n```\n\n**2. Timing Attack**\n\n```javascript\n// ❌ Vulnerable to timing attacks\nfunction unsafeDecrypt(ciphertext) {\n  // Decryption time related to private key\n  return privateKey.decrypt(ciphertext);\n}\n\n// ✅ Use constant-time algorithm\nfunction safeDecrypt(ciphertext) {\n  // Node.js crypto module already implements timing attack protection\n  return crypto.privateDecrypt({\n    key: privateKey,\n    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n  }, ciphertext);\n}\n```\n\n### Padding Attack Principles and OAEP Protection Mechanisms\n\n**PKCS#1 v1.5 Padding Vulnerabilities**:\n\n```\nRaw RSA: c = m^e mod n\nPKCS#1 v1.5: 00 || BT || PS || 00 || D\n\nProblem: Fixed padding format, vulnerable to padding attacks\n```\n\n**OAEP Padding Protection Mechanisms**:\n\n```\nOAEP: Uses random numbers and mask generation functions\nResult: Same plaintext produces different encryption each time\n```\n\n**Mathematical Representation**:\n\n$$\\text{OAEP}(m, r) = (X \\oplus G(Y)) \\| (Y \\oplus H(X))$$\n\nWhere:\n- $m$: Original message\n- $r$: Random number\n- $G$, $H$: Mask generation functions\n\n## Complete Code Analysis\n\n### Backend RSA Key Management Core Implementation (`src/utils/rsaCrypto.js`)\n\n```javascript\n// Module imports: key generation library and Node.js native crypto module\nconst jsrsasign = require('jsrsasign');    // For key generation and management\nconst { KEYUTIL } = jsrsasign;            // Key utility class\nconst crypto = require('crypto');          // Node.js native crypto module, better performance\n\nclass RSACrypto {\n  constructor() {\n    this.keySize = 2048;\n    this.initializeKeys();\n  }\n\n  // Initialize RSA key pair from environment variables or generate new key pair\n  initializeKeys() {\n    if (process.env.RSA_PUBLIC_KEY \u0026\u0026 process.env.RSA_PRIVATE_KEY) {\n      // Handle escaped and non-escaped newlines (compatibility consideration)\n      this.publicKeyPEM = process.env.RSA_PUBLIC_KEY.includes('\\\\n') \n        ? process.env.RSA_PUBLIC_KEY.replace(/\\\\n/g, '\\n')\n        : process.env.RSA_PUBLIC_KEY;\n      this.privateKeyPEM = process.env.RSA_PRIVATE_KEY.includes('\\\\n')\n        ? process.env.RSA_PRIVATE_KEY.replace(/\\\\n/g, '\\n')\n        : process.env.RSA_PRIVATE_KEY;\n    } else {\n      console.warn('RSA keys not found in environment. Generating new keys...');\n      \n      const keyPair = this.generateKeyPair();\n      this.publicKeyPEM = keyPair.publicKeyPEM;\n      this.privateKeyPEM = keyPair.privateKeyPEM;\n      \n      console.log('Generated RSA Public Key:', this.publicKeyPEM);\n      console.log('Generated RSA Private Key:', this.privateKeyPEM);\n      console.log('Please add these keys to your .env file:');\n      console.log('RSA_PUBLIC_KEY=\"' + this.publicKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\n      console.log('RSA_PRIVATE_KEY=\"' + this.privateKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\n    }\n  }\n\n  // RSA key pair generation: use jsrsasign to generate standard format keys\n  generateKeyPair(keySize = 2048) {\n    try {\n      const keyPair = KEYUTIL.generateKeypair('RSA', keySize);\n      const publicKeyPEM = KEYUTIL.getPEM(keyPair.pubKeyObj);       // Public key PEM format\n      const privateKeyPEM = KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV');  // Private key PKCS8 format\n      \n      return { publicKeyPEM, privateKeyPEM };\n    } catch (error) {\n      throw new Error(`RSA key generation failed: ${error.message}`);\n    }\n  }\n\n  // Public key distribution interface: for frontend to get public key\n  getPublicKey() {\n    return this.publicKeyPEM;\n  }\n\n  // RSA-OAEP encryption implementation: use Node.js crypto module to ensure optimal performance and security\n  encrypt(plaintext) {\n    try {\n      // Input validation: ensure plaintext is valid\n      if (!plaintext || typeof plaintext !== 'string') {\n        throw new Error('Invalid plaintext for encryption');\n      }\n\n      // UTF-8 encoding conversion: ensure proper handling of Chinese and other characters\n      const buffer = Buffer.from(plaintext, 'utf8');\n      \n      // Core encryption logic: RSA encryption with OAEP padding\n      // Choose Node.js crypto over jsrsasign: more reliable OAEP implementation\n      const encrypted = crypto.publicEncrypt(\n        {\n          key: this.publicKeyPEM,                              // PEM format public key\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // OAEP padding, prevents padding attacks\n          oaepHash: 'sha256',                                  // SHA-256 hash function\n        },\n        buffer\n      );\n\n      // Base64 encoding: convenient for network transmission and storage\n      return encrypted.toString('base64');\n    } catch (error) {\n      throw new Error(`RSA encryption failed: ${error.message}`);\n    }\n  }\n\n  // RSA-OAEP decryption implementation: core of temporary decryption strategy\n  decrypt(encryptedData) {\n    try {\n      // Input validation: ensure ciphertext format is correct\n      if (!encryptedData || typeof encryptedData !== 'string') {\n        throw new Error('Invalid encrypted data for decryption');\n      }\n\n      // Base64 decoding: restore binary ciphertext\n      const encryptedBuffer = Buffer.from(encryptedData, 'base64');\n      \n      // Core decryption logic: decrypt using private key\n      const decrypted = crypto.privateDecrypt(\n        {\n          key: this.privateKeyPEM,                             // PEM format private key\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // Consistent padding with encryption\n          oaepHash: 'sha256',                                  // Consistent hash with encryption\n        },\n        encryptedBuffer\n      );\n\n      // UTF-8 decoding: restore original string\n      return decrypted.toString('utf8');\n    } catch (error) {\n      throw new Error(`RSA decryption failed: ${error.message}`);\n    }\n  }\n\n  // Flexible encryption interface: support encryption with arbitrary public key (for testing)\n  encryptWithPublicKey(plaintext, publicKeyPEM) {\n    try {\n      if (!plaintext || typeof plaintext !== 'string') {\n        throw new Error('Invalid plaintext for encryption');\n      }\n\n      const buffer = Buffer.from(plaintext, 'utf8');\n      \n      // Encrypt using externally provided public key\n      const encrypted = crypto.publicEncrypt(\n        {\n          key: publicKeyPEM,                                   // External public key\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n          oaepHash: 'sha256',\n        },\n        buffer\n      );\n\n      return encrypted.toString('base64');\n    } catch (error) {\n      throw new Error(`RSA encryption with provided key failed: ${error.message}`);\n    }\n  }\n\n  // Key validation utility: ensure key format is correct\n  validateKey(keyPEM, isPrivate = false) {\n    try {\n      const keyObj = KEYUTIL.getKey(keyPEM);\n      return keyObj \u0026\u0026 (isPrivate ? keyObj.isPrivate : keyObj.isPublic);\n    } catch (error) {\n      return false;   // Return false on validation failure instead of throwing exception\n    }\n  }\n}\n\n// Singleton pattern export: global unique instance, saves memory and ensures cache consistency\nconst rsaCrypto = new RSACrypto();\n\n// Module export: provide multiple usage methods\nmodule.exports = {\n  RSACrypto,                                                    // Export class (for extension)\n  rsaCrypto,                                                   // Export singleton instance\n  generateKeyPair: (keySize) =\u003e rsaCrypto.generateKeyPair(keySize),     // Convenience function\n  encrypt: (plaintext) =\u003e rsaCrypto.encrypt(plaintext),                 // Convenience function\n  decrypt: (encryptedData) =\u003e rsaCrypto.decrypt(encryptedData),         // Convenience function\n  getPublicKey: () =\u003e rsaCrypto.getPublicKey(),                         // Convenience function\n  encryptWithPublicKey: (plaintext, publicKey) =\u003e rsaCrypto.encryptWithPublicKey(plaintext, publicKey),\n  validateKey: (keyPEM, isPrivate) =\u003e rsaCrypto.validateKey(keyPEM, isPrivate)\n};\n```\n\n### Frontend RSA Encryption Core Implementation (`src/utils/rsaCrypto.ts`)\n\n```typescript\nimport * as jsrsasign from 'jsrsasign';   // RSA key operation library\n\nconst {KEYUTIL} = jsrsasign;\n\nexport class RSACrypto {\n    private publicKey: string | null = null;   // Store public key obtained from backend\n\n    // Static utility method: encrypt using specified public key (for testing)\n    static async encryptWithKey(plaintext: string, publicKeyPEM: string): Promise\u003cstring\u003e {\n        const rsa = new RSACrypto();\n        rsa.setPublicKey(publicKeyPEM);\n        return await rsa.encrypt(plaintext);\n    }\n\n    // Static security validation: ensure public key format is correct and doesn't contain private key information\n    static validatePublicKey(keyPEM: string): boolean {\n        try {\n            const keyObj = KEYUTIL.getKey(keyPEM);\n            // Critical security check: RSA public key should only contain modulus(n) and public key exponent(e)\n            // Must never contain private key exponent(d) - this is the core of security protection\n            return keyObj \u0026\u0026 \n                   'n' in keyObj \u0026\u0026    // Modulus n must exist\n                   'e' in keyObj \u0026\u0026    // Public key exponent e must exist\n                   !('d' in keyObj);   // Private key exponent d must never exist!\n        } catch {\n            return false;   // Parse failed, safely reject\n        }\n    }\n\n    // Key setting: receive public key distributed from backend\n    setPublicKey(publicKeyPEM: string) {\n        this.publicKey = publicKeyPEM;\n    }\n\n    // Key retrieval: return currently set public key\n    getPublicKey(): string | null {\n        return this.publicKey;\n    }\n\n    // Core encryption method: implement RSA-OAEP encryption using Web Crypto API\n    async encrypt(plaintext: string): Promise\u003cstring\u003e {\n        // Pre-check: ensure public key is set\n        if (!this.publicKey) {\n            throw new Error('Public key not set. Call setPublicKey() first.');\n        }\n\n        // Input validation: ensure plaintext is valid\n        if (!plaintext || typeof plaintext !== 'string') {\n            throw new Error('Invalid plaintext for encryption');\n        }\n\n        try {\n            // Step 1: Convert PEM format key to ArrayBuffer required by Web Crypto API\n            const publicKeyBuffer = this.pemToArrayBuffer(this.publicKey);\n\n            // Step 2: Import public key to Web Crypto API\n            // Use standard SPKI format and RSA-OAEP algorithm\n            const cryptoKey = await window.crypto.subtle.importKey(\n                'spki',                     // Subject Public Key Info format\n                publicKeyBuffer,            // Binary key data\n                {\n                    name: 'RSA-OAEP',       // Algorithm name, consistent with backend\n                    hash: 'SHA-256',        // Hash function, consistent with backend\n                },\n                false,                      // Don't allow key extraction (security consideration)\n                ['encrypt']                 // Only allow encryption operations\n            );\n\n            // Step 3: Plaintext encoding and encryption\n            const plaintextBuffer = new TextEncoder().encode(plaintext);  // UTF-8 encoding\n            const encryptedBuffer = await window.crypto.subtle.encrypt(\n                {\n                    name: 'RSA-OAEP',      // Use OAEP padding\n                },\n                cryptoKey,\n                plaintextBuffer\n            );\n\n            // Step 4: Base64 encoding to match backend format\n            return this.arrayBufferToBase64(encryptedBuffer);\n        } catch (error) {\n            throw new Error(`RSA encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n\n    // Private utility method: PEM format to ArrayBuffer\n    private pemToArrayBuffer(pem: string): ArrayBuffer {\n        // Step 1: Remove PEM format header/footer and all whitespace characters\n        const pemHeader = '-----BEGIN PUBLIC KEY-----';\n        const pemFooter = '-----END PUBLIC KEY-----';\n        const pemContents = pem.replace(pemHeader, '')\n                              .replace(pemFooter, '')\n                              .replace(/\\s/g, '');   // Remove all whitespace characters\n\n        // Step 2: Base64 decode to binary string\n        const binaryString = atob(pemContents);\n\n        // Step 3: Binary string to ArrayBuffer (Web Crypto API standard format)\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i \u003c binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);   // Convert byte by byte\n        }\n\n        return bytes.buffer;\n    }\n\n    // Private utility method: ArrayBuffer to Base64 (network transmission format)\n    private arrayBufferToBase64(buffer: ArrayBuffer): string {\n        const bytes = new Uint8Array(buffer);\n        let binary = '';\n        // Convert byte by byte to binary string\n        for (let i = 0; i \u003c bytes.byteLength; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        return btoa(binary);   // Base64 encoding\n    }\n}\n\n// Export singleton instance: globally unique, convenient for state management\nexport const rsaCrypto = new RSACrypto();\n\n// Export utility functions: convenient for direct calls\nexport const encryptWithKey = RSACrypto.encryptWithKey;\nexport const validatePublicKey = RSACrypto.validatePublicKey;\n```\n\n### User Model Decryption Logic Core Implementation (`src/models/User.js`)\n\n```javascript\n// Method to decrypt API key using RSA\nuserSchema.methods.decryptApiKey = function(encryptedKey = null) {\n  try {\n    const keyToDecrypt = encryptedKey || this.apiKey;\n    \n    if (!keyToDecrypt) {\n      return null;\n    }\n\n    // Check if it's RSA encrypted (base64 format from frontend)\n    if (keyToDecrypt.startsWith('rsa:')) {\n      const encryptedData = keyToDecrypt.substring(4);\n      return decrypt(encryptedData);\n    }\n    \n    // If not encrypted, return directly (for development/testing)\n    return keyToDecrypt;\n  } catch (error) {\n    throw new Error(`API key decryption failed: ${error.message}`);\n  }\n};\n\n// On-demand decryption security strategy: only decrypt when truly needed\nuserSchema.methods.getDecryptedApiKey = function() {\n  // Dual security check: must satisfy both having key and enabling custom key\n  if (!this.apiKey || !this.useCustomApiKey) {\n    return null;   // Conditions not met, return null\n  }\n  // Temporary decryption: call decryption method to get plaintext key\n  return this.decryptApiKey();\n};\n```\n\n### Authentication Controller Key Management Core Implementation (`src/controllers/authController.js`)\n\n```javascript\n// API interface: update user API key\n// @desc    Update user API key\n// @route   PUT /api/auth/api-key\n// @access  Private (requires authentication)\nexports.updateApiKey = async (req, res) =\u003e {\n  try {\n    const { apiKey, useCustomApiKey } = req.body;\n\n    // Input validation boundary condition handling: precise validation logic\n    // Only report error when explicitly wanting to use custom key and empty string is provided\n    // Allow setting useCustomApiKey = true but not providing key yet\n    if (useCustomApiKey \u0026\u0026 apiKey \u0026\u0026 apiKey.trim().length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: req.t('auth.apiKeyRequired')   // Internationalized error message\n      });\n    }\n\n    // User authentication: ensure user exists\n    const user = await User.findById(req.user.id);\n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        message: req.t('auth.userNotFound')\n      });\n    }\n\n    // Core logic of key update: atomic operation of state management\n    if (useCustomApiKey) {\n      // Critical security decision: directly store frontend encrypted data, never decrypt here\n      // Frontend sends RSA encrypted data, format is 'rsa:Base64EncryptedData'\n      if (apiKey \u0026\u0026 apiKey.trim().length \u003e 0) {\n        user.apiKey = apiKey.trim();   // Directly store ciphertext, maintain encrypted state\n      } else {\n        user.apiKey = undefined;       // Clear key data\n      }\n      user.useCustomApiKey = true;     // Enable custom key flag\n    } else {\n      // Disable custom key: clear both key data and flag, ensure data consistency\n      user.apiKey = undefined;\n      user.useCustomApiKey = false;\n    }\n\n    // Atomic database operation: ensure consistency of state changes\n    await user.save();\n\n    // Success response: return operation result and new state\n    res.status(200).json({\n      success: true,\n      message: req.t('auth.apiKeyUpdatedSuccessfully'),\n      useCustomApiKey: user.useCustomApiKey    // Return current state for frontend confirmation\n    });\n  } catch (error) {\n    // Unified error handling: log error and return user-friendly error message\n    res.status(500).json({\n      success: false,\n      message: req.t('auth.serverError')\n    });\n  }\n};\n```\n\n**Core Design Principles of Code Architecture**:\n\n1. **Security First Principle**: Backend never stores plaintext keys, only temporarily decrypts when using\n2. **Separation of Responsibilities Principle**: Frontend responsible for encryption, backend responsible for storage and on-demand decryption\n3. **Data Consistency Principle**: Ensure atomic updates of key data and usage flags\n4. **Error Handling Principle**: Each layer has detailed error handling and internationalization support\n5. **Forward Compatibility Principle**: Support debugging needs in development environment, maintain system flexibility\n\nThrough detailed analysis of these codes, we can see that every detail of the RSA implementation in the Questions Party project has been carefully considered, ensuring both security and maintainability and usability. The entire architecture reflects the best practices of modern web security development.\n\n## Complete End-to-End Encryption Flow Tracking\n\n### Complete Tracking from User Input to Database Storage\n\n**API Key Update Flow**:\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant F as Frontend\n    participant B as Backend\n    participant D as Database\n    \n    U-\u003e\u003eF: Input API Key\n    F-\u003e\u003eB: Get RSA Public Key\n    B-\u003e\u003eF: Return Public Key\n    F-\u003e\u003eF: RSA Encrypt Key\n    F-\u003e\u003eB: Send Encrypted Data\n    B-\u003e\u003eD: Directly Store Encrypted Data\n    D-\u003e\u003eB: Confirm Storage\n    B-\u003e\u003eF: Return Success Status\n    F-\u003e\u003eU: Display Success Message\n```\n\n**API Key Usage Flow**:\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant F as Frontend\n    participant B as Backend\n    participant D as Database\n    participant A as Large Model API\n    \n    U-\u003e\u003eF: Send Request\n    F-\u003e\u003eB: Request Processing\n    B-\u003e\u003eD: Read Encrypted Key\n    D-\u003e\u003eB: Return Encrypted Data\n    B-\u003e\u003eB: Temporarily Decrypt Key\n    B-\u003e\u003eA: Use Plaintext Key to Call API\n    A-\u003e\u003eB: Return API Response\n    B-\u003e\u003eB: Clean Plaintext Key\n    B-\u003e\u003eF: Return Processing Result\n    F-\u003e\u003eU: Display Result\n```\n\n### Data State Changes at Each Step\n\n**API Key Update Flow Data State**:\n\n| Step | Location | Data State | Format | Security |\n|------|----------|------------|--------|----------|\n| 1 | User Input | Plaintext | String | Low |\n| 2 | Frontend Memory | Plaintext | String | Low |\n| 3 | Frontend Encryption | Ciphertext | Base64 | High |\n| 4 | Network Transmission | Ciphertext+TLS | Encrypted | Very High |\n| 5 | Backend Reception | Ciphertext | Base64 | High |\n| 6 | Database Storage | Ciphertext | rsa:Base64 | High |\n\n**API Key Usage Flow Data State**:\n\n| Step | Location | Data State | Format | Security |\n|------|----------|------------|--------|----------|\n| 1 | Database Read | Ciphertext | rsa:Base64 | High |\n| 2 | Backend Temporary Decryption | Plaintext | String | Medium |\n| 3 | Call Large Model API | Plaintext | String | Medium |\n| 4 | Memory Cleanup | Destroyed | - | Very High |\n\n### Debugging and Monitoring Best Practices\n\n**Logging Strategy**:\n\n```javascript\n// ✅ Safe logging\nconsole.log('API key updated for user:', user.id);\nconsole.log('Using custom API key:', user.useCustomApiKey);\n\n// ❌ Dangerous logging\nconsole.log('API key:', apiKey);  // Never log sensitive data\nconsole.log('Decrypted key:', decryptedKey);\n```\n\n**Monitoring Metrics**:\n\n```javascript\nconst securityMetrics = {\n  encryptionSuccessRate: '99.9%',\n  decryptionErrorRate: '0.1%',\n  keyRotationFrequency: '90 days',\n  suspiciousActivityCount: 0\n};\n```\n\n## System Architecture Summary and Best Practices\n\n### Complete RSA Architecture in Modern Web Applications\n\nThrough in-depth analysis of the Questions Party project, we can summarize a complete RSA encryption architecture:\n\n```mermaid\ngraph TB\n    subgraph \"Security Boundaries\"\n        subgraph \"Frontend Security Domain\"\n            A[User Input] --\u003e B[Data Validation]\n            B --\u003e C[Get Public Key]\n            C --\u003e D[RSA Encryption]\n            D --\u003e E[Secure Transmission]\n        end\n        \n        subgraph \"Transmission Security Domain\"\n            E --\u003e F[HTTPS Tunnel]\n            F --\u003e G[TLS Termination]\n        end\n        \n        subgraph \"Backend Security Domain\"\n            G --\u003e H[Data Reception]\n            H --\u003e I[Authentication]\n            I --\u003e J[Direct Ciphertext Storage]\n            J --\u003e K[On-Demand Temporary Decryption]\n            K --\u003e L[Business Processing]\n            L --\u003e M[Memory Cleanup]\n        end\n        \n        subgraph \"Storage Security Domain\"\n            M --\u003e N[Database]\n            N --\u003e O[Backup Encryption]\n        end\n    end\n    \n    subgraph \"Key Management Domain\"\n        P[Key Generation] --\u003e Q[Key Distribution]\n        Q --\u003e R[Key Rotation]\n        R --\u003e S[Key Destruction]\n    end\n    \n    Q --\u003e C\n    P --\u003e K\n```\n\n## Final Words\n\nWhen designing a secure encryption architecture, I assume: the frontend code has been reverse engineered, and the intermediate transmission has been intercepted, their algorithms and data are completely exposed to the attacker's eyes, only the backend is secure. In this case, what kind of encryption process can ensure security?\n\nIf only the backend is secure, then to solve this problem, we can only start from the backend. That is—I need something secure to guard the decryption step, ensuring that plaintext keys only temporarily exist in the backend, minimizing the possibility of attackers stealing keys.\n\nLater I thought of asymmetric encryption.\n\n*May your encryption be as unpredictable as the scars on an ancient planet. The public key and the private key are at opposite ends. Cross the long river of the unknown in the middle and safely bring the message in your heart to the other side.* 🔐✨\n"])</script><script>self.__next_f.push([1,"29:Td4b1,"])</script><script>self.__next_f.push([1,"\r\n# Vocabulary Collection: Building the Sea of Words Together\r\n\r\nHave you ever wondered why words can only be added successfully when they are spelled correctly? And... where do the word definitions come from after they are successfully added?\r\n\r\nThis article will comprehensively analyze the vocabulary recognition and storage system in the Questions Party project, covering the complete pipeline from users entering a word in the frontend, to backend AI technology identifying its part of speech and meaning, to database storage.\r\n\r\n## System Architecture Overview\r\n\r\n### Overall Data Flow\r\n\r\n```\r\nUser Input → Frontend Validation → Backend Verification → Spell Checking → Part of Speech Analysis → Data Storage → Frontend Display\r\n```\r\n\r\n### Modern MVC Architecture Application\r\n\r\nThe word management system adopts the classic MVC architecture pattern:\r\n\r\n- **Model (Model Layer)**: MongoDB + Mongoose ODM\r\n- **View (View Layer)**: Vue 3 + TypeScript + Pinia\r\n- **Controller (Controller Layer)**: Node.js + Express + Middleware\r\n\r\n```javascript\r\n// Core structure of the controller layer\r\nconst wordController = {\r\n  getUserWords: async (req, res) =\u003e { /* Get user vocabulary */ },\r\n  addWord: async (req, res) =\u003e { /* Add new vocabulary */ },\r\n  deleteWord: async (req, res) =\u003e { /* Delete vocabulary */ },\r\n  getRandomWords: async (req, res) =\u003e { /* Smart recommendations */ }\r\n};\r\n```\r\n\r\n## Frontend Interactive Interface Design\r\n\r\n### Composition API State Management\r\n\r\nThe frontend uses Vue 3's Composition API:\r\n\r\n```javascript\r\n// Reactive state management in Words.vue\r\nconst showAddForm = ref(false)\r\nconst loadingRandom = ref(false)\r\nconst randomWords = ref\u003cany[]\u003e([])\r\n\r\n// Spelling error handling\r\nconst spellingError = ref(false)\r\nconst spellingSuggestions = ref\u003cstring[]\u003e([])\r\n\r\n// Filtering and search\r\nconst searchQuery = ref('')\r\nconst selectedFilter = ref('all')\r\n```\r\n\r\n### Debounced Search\r\n\r\n```javascript\r\n// Debounced search function\r\nconst debouncedSearch = () =\u003e {\r\n  if (searchTimeout.value) {\r\n    clearTimeout(searchTimeout.value)\r\n  }\r\n  \r\n  searchTimeout.value = setTimeout(() =\u003e {\r\n    wordsStore.setSearchQuery(searchQuery.value)\r\n  }, 300)\r\n}\r\n```\r\n\r\n**Debouncing Principle**:\r\n\r\nAssuming a user inputs n characters within 300ms, the traditional approach would make n requests, while the debounced approach only makes 1 request.\r\n\r\n### Pinia State Management\r\n\r\n```typescript\r\n// stores/words.ts - Core logic of state management\r\nexport const useWordsStore = defineStore('words', () =\u003e {\r\n  const words = ref\u003cWord[]\u003e([])\r\n  const selectedWords = ref\u003cSet\u003cstring\u003e\u003e(new Set())\r\n  const loading = ref(false)\r\n  \r\n  // Computed property: intelligent filtering\r\n  const filteredWords = computed(() =\u003e {\r\n    let filtered = words.value\r\n    \r\n    // Part of speech filtering\r\n    if (currentFilter.value \u0026\u0026 currentFilter.value !== 'all') {\r\n      filtered = filtered.filter(word =\u003e \r\n        word.primaryPartOfSpeech === currentFilter.value\r\n      )\r\n    }\r\n    \r\n    // Search filtering\r\n    if (searchQuery.value.trim()) {\r\n      const query = searchQuery.value.toLowerCase().trim()\r\n      filtered = filtered.filter(word =\u003e \r\n        word.word.toLowerCase().includes(query) ||\r\n        word.primaryDefinition?.toLowerCase().includes(query)\r\n      )\r\n    }\r\n    \r\n    return filtered\r\n  })\r\n  \r\n  return {\r\n    words,\r\n    selectedWords,\r\n    loading,\r\n    filteredWords,\r\n    // ... other methods\r\n  }\r\n})\r\n```\r\n\r\n### Frontend Spelling Suggestion UI Design\r\n\r\n```vue\r\n\u003c!-- Words.vue - Spelling suggestion UI component --\u003e\r\n\u003cdiv v-if=\"spellingError \u0026\u0026 spellingSuggestions.length \u003e 0\"\r\n     class=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4\"\u003e\r\n  \u003cdiv class=\"flex items-start space-x-2\"\u003e\r\n    \u003cdiv class=\"flex-shrink-0 mt-0.5\"\u003e\r\n      \u003csvg class=\"w-5 h-5 text-blue-600 dark:text-blue-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"\u003e\r\n        \u003cpath stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\u003e\u003c/path\u003e\r\n      \u003c/svg\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"flex-1\"\u003e\r\n      \u003cp class=\"text-sm font-medium text-blue-800 dark:text-blue-200 mb-2\"\u003e\r\n        {{ $t('words.spellingNotRecognized') }}\r\n      \u003c/p\u003e\r\n      \u003cp class=\"text-sm text-blue-700 dark:text-blue-300 mb-3\"\u003e\r\n        {{ $t('words.didYouMean') }}\r\n      \u003c/p\u003e\r\n      \u003c!-- Spelling suggestion buttons --\u003e\r\n      \u003cdiv class=\"flex flex-wrap gap-2\"\u003e\r\n        \u003cbutton\r\n            v-for=\"suggestion in spellingSuggestions\"\r\n            :key=\"suggestion\"\r\n            class=\"inline-flex items-center px-3 py-1.5 text-sm font-medium text-blue-700 dark:text-blue-200 bg-blue-100 dark:bg-blue-800 rounded-md hover:bg-blue-200 dark:hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\r\n            @click=\"selectSuggestion(suggestion)\"\r\n        \u003e\r\n          {{ suggestion }}\r\n        \u003c/button\u003e\r\n      \u003c/div\u003e\r\n      \u003c!-- User action options --\u003e\r\n      \u003cdiv class=\"mt-3 flex items-center space-x-2\"\u003e\r\n        \u003cbutton\r\n            class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n            @click=\"addWordAnyway\"\r\n        \u003e\r\n          {{ $t('words.addAnyway') }}\r\n        \u003c/button\u003e\r\n        \u003cspan class=\"text-xs text-blue-500 dark:text-blue-400\"\u003e{{ $t('words.or') }}\u003c/span\u003e\r\n        \u003cbutton\r\n            class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n            @click=\"cancelSpelling\"\r\n        \u003e\r\n          {{ $t('words.tryAgain') }}\r\n        \u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n### Frontend Spelling Suggestion Processing Logic\r\n\r\n```javascript\r\n// Words.vue - Complete logic for spelling suggestion processing\r\nconst addWord = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim()\r\n  })\r\n\r\n  if (result.success) {\r\n    // Successfully added word\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n    spellingError.value = false\r\n    spellingSuggestions.value = []\r\n  } else if (result.spellingError \u0026\u0026 result.suggestions?.length \u003e 0) {\r\n    // Display spelling suggestions\r\n    spellingError.value = true\r\n    spellingSuggestions.value = result.suggestions\r\n  }\r\n}\r\n\r\n// Select suggested word\r\nconst selectSuggestion = (suggestion: string) =\u003e {\r\n  newWord.word = suggestion\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n}\r\n\r\n// Force add word\r\nconst addWordAnyway = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n  \r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  \r\n  // Force add through forceAdd flag\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim(),\r\n    forceAdd: true\r\n  })\r\n  \r\n  if (result.success) {\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n  }\r\n}\r\n\r\n// Cancel and retry\r\nconst cancelSpelling = () =\u003e {\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  newWord.word = ''\r\n}\r\n```\r\n\r\n## Internationalization Mechanism\r\n\r\n### Frontend Language Specification Process\r\n\r\nThe frontend specifies the language for backend responses through HTTP request headers:\r\n\r\n```typescript\r\n// services/api.ts - Request interceptor\r\napi.interceptors.request.use(\r\n  (config) =\u003e {\r\n    // Get current language environment\r\n    const locale = getCurrentLocale()\r\n    \r\n    // Add language header\r\n    if (locale) {\r\n      config.headers['x-language'] = locale\r\n    }\r\n    \r\n    // Add authentication token\r\n    const token = localStorage.getItem('token')\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`\r\n    }\r\n    \r\n    return config\r\n  },\r\n  (error) =\u003e {\r\n    return Promise.reject(error)\r\n  }\r\n)\r\n```\r\n\r\n### Backend Language Processing Mechanism\r\n\r\nThe backend uses middleware to identify and process language settings:\r\n\r\n```javascript\r\n// Backend middleware internationalization processing\r\nconst i18nMiddleware = (req, res, next) =\u003e {\r\n  const locale = req.headers['x-language'] || 'en'\r\n  req.locale = locale\r\n  req.t = (key, options) =\u003e i18n.t(key, { locale, ...options })\r\n  next()\r\n}\r\n```\r\n\r\n### Dynamic Implementation of Part of Speech Translation\r\n\r\nThe system supports real-time part of speech translation:\r\n\r\n```javascript\r\n// wordController.js - Dynamic loading of part of speech translation\r\nconst wordsWithTranslation = words.map(word =\u003e {\r\n  const wordObj = word.toObject()\r\n  if (wordObj.primaryPartOfSpeech) {\r\n    // Dynamic translation of part of speech\r\n    wordObj.primaryPartOfSpeechTranslated = req.t(`words.${wordObj.primaryPartOfSpeech}`)\r\n  }\r\n  return wordObj\r\n})\r\n```\r\n\r\n## Spell Checking Engine Analysis: Typo.js\r\n\r\n### JavaScript Implementation of Hunspell Algorithm\r\n\r\nTypo.js is based on the famous Hunspell spell checking engine, an algorithm widely used in projects like OpenOffice and Mozilla:\r\n\r\n```javascript\r\n// wordUtils.js - Core implementation of spell checking\r\nconst Typo = require('typo-js')\r\n\r\n// Initialize spell checker\r\nlet spellChecker\r\ntry {\r\n  spellChecker = new Typo('en_US')\r\n} catch (error) {\r\n  console.error('Failed to initialize spell checker:', error)\r\n}\r\n\r\n// Spell checking function\r\nconst isWordSpelledCorrectly = (word) =\u003e {\r\n  if (!spellChecker) {\r\n    console.warn('Spell checker not available, assuming word is correct')\r\n    return true\r\n  }\r\n  \r\n  try {\r\n    const cleanWord = word.toLowerCase().trim()\r\n    return spellChecker.check(cleanWord)\r\n  } catch (error) {\r\n    console.error('Error checking spelling:', error)\r\n    return true // Defensive programming: default to correct\r\n  }\r\n}\r\n```\r\n\r\n### Intelligent Spelling Suggestion System\r\n\r\nWhen users input incorrect words, the system automatically provides spelling suggestions instead of throwing errors directly:\r\n\r\n```javascript\r\n// Spelling suggestion processing in backend controller\r\nif (!wordProcessing.success) {\r\n  // Return spelling suggestions (200 status code, not error)\r\n  return res.status(200).json({\r\n    success: false,\r\n    needsConfirmation: true,\r\n    spellingError: true,\r\n    message: req.t('words.spellingError'),\r\n    suggestions: wordProcessing.suggestions || [],\r\n    originalWord: wordProcessing.word,\r\n    suggestedCorrection: wordProcessing.suggestions \u0026\u0026 wordProcessing.suggestions.length \u003e 0 \r\n      ? wordProcessing.suggestions[0] : null\r\n  });\r\n}\r\n```\r\n\r\n### Force Add Mechanism\r\n\r\nThe system supports users forcing the addition of \"incorrectly\" spelled words, such as proper nouns or new words:\r\n\r\n```javascript\r\n// Validation schema supporting force add\r\nconst addWordSchema = Joi.object({\r\n  word: Joi.string().min(1).max(50).pattern(/^[a-zA-Z\\-']+$/).required(),\r\n  forceAdd: Joi.boolean().default(false) // New force add flag\r\n});\r\n\r\n// Decide whether to skip spell checking based on forceAdd parameter\r\nif (forceAdd) {\r\n  // Skip spell checking, directly get WordNet data\r\n  const wordNetData = await require('../utils/wordUtils').getWordNetData(cleanWord);\r\n  wordProcessing = {\r\n    success: true,\r\n    word: cleanWord,\r\n    ...wordNetData\r\n  };\r\n} else {\r\n  // Normal spell checking process\r\n  wordProcessing = await processWord(cleanWord);\r\n}\r\n```\r\n\r\n### Edit Distance Algorithm\r\n\r\nSpelling suggestions are generated based on the edit distance algorithm (Levenshtein Distance), a classic dynamic programming problem:\r\n\r\n**Mathematical Definition of Edit Distance**:\r\n\r\nEdit distance refers to the minimum number of single-character edit operations required to transform string A into string B. These operations include:\r\n- **Insert** a character\r\n- **Delete** a character  \r\n- **Replace** a character\r\n\r\nFor strings A and B, the recursive formula for edit distance D(A,B) is:\r\n\r\n$$D(A,B) = \\min \\begin{cases}\r\nD(A_{i-1}, B_j) + 1 \u0026 \\text{(Delete A[i])} \\\\\r\nD(A_i, B_{j-1}) + 1 \u0026 \\text{(Insert B[j])} \\\\\r\nD(A_{i-1}, B_{j-1}) + cost \u0026 \\text{(Replace A[i] with B[j])}\r\n\\end{cases}$$\r\n\r\nWhere:\r\n- cost = 0 (if A[i] = B[j], characters are the same, no operation needed)\r\n- cost = 1 (if A[i] ≠ B[j], replacement operation needed)\r\n\r\n**A Concrete Example**:\r\n\r\nSuppose we want to calculate the edit distance between \"cat\" and \"cut\":\r\n\r\n```\r\n    \"\"  c  u  t\r\n\"\"   0  1  2  3\r\nc    1  0  1  2\r\na    2  1  1  2\r\nt    3  2  2  1\r\n```\r\n\r\n**Calculation Process**:\r\n1. Initialization: Distance from empty string to any string equals the length of the target string\r\n2. Fill the table step by step:\r\n   - D(\"c\", \"c\") = 0 (characters are the same)\r\n   - D(\"ca\", \"c\") = 1 (delete 'a')\r\n   - D(\"ca\", \"cu\") = 1 (replace 'a' with 'u')\r\n   - D(\"cat\", \"cut\") = 1 (replace 'a' with 'u')\r\n\r\n**Algorithm Implementation Approach**:\r\n\r\n```javascript\r\nfunction editDistance(str1, str2) {\r\n  const m = str1.length\r\n  const n = str2.length\r\n  \r\n  // Create DP table\r\n  const dp = Array(m + 1).fill().map(() =\u003e Array(n + 1).fill(0))\r\n  \r\n  // Initialize boundary conditions\r\n  for (let i = 0; i \u003c= m; i++) dp[i][0] = i\r\n  for (let j = 0; j \u003c= n; j++) dp[0][j] = j\r\n  \r\n  // Fill DP table\r\n  for (let i = 1; i \u003c= m; i++) {\r\n    for (let j = 1; j \u003c= n; j++) {\r\n      if (str1[i-1] === str2[j-1]) {\r\n        dp[i][j] = dp[i-1][j-1]  // Characters are the same, no operation needed\r\n      } else {\r\n        dp[i][j] = Math.min(\r\n          dp[i-1][j] + 1,      // Delete\r\n          dp[i][j-1] + 1,      // Insert\r\n          dp[i-1][j-1] + 1     // Replace\r\n        )\r\n      }\r\n    }\r\n  }\r\n  \r\n  return dp[m][n]\r\n}\r\n```\r\n\r\n**Application in Spell Checking**:\r\n\r\nWhen a user inputs \"teh\", the system calculates the edit distance between it and all words in the dictionary:\r\n- \"teh\" vs \"the\": distance of 1 (swap e and h)\r\n- \"teh\" vs \"ten\": distance of 1 (replace h with n)\r\n- \"teh\" vs \"tea\": distance of 1 (replace h with a)\r\n\r\nThen the system recommends the word with the smallest edit distance as a spelling suggestion.\r\n\r\n**Algorithm Complexity**:\r\n- Time complexity: O(m × n), where m and n are the lengths of the two strings respectively\r\n- Space complexity: O(m × n), can be optimized to O(min(m, n))\r\n\r\n```javascript\r\n// Spelling suggestion generation\r\nconst getSpellingSuggestions = (word) =\u003e {\r\n  if (!spellChecker) {\r\n    return []\r\n  }\r\n  \r\n  try {\r\n    const cleanWord = word.toLowerCase().trim()\r\n    return spellChecker.suggest(cleanWord) || []\r\n  } catch (error) {\r\n    console.error('Error getting spelling suggestions:', error)\r\n    return []\r\n  }\r\n}\r\n```\r\n\r\n### Fault Tolerance Mechanism\r\n\r\nThe spell checking module adopts a \"lenient input, strict output\" design:\r\n\r\n- **Lenient Input**: Even if the spell checker initialization fails, the system can still work normally\r\n- **Strict Output**: Strict validation and feedback for user input\r\n\r\n```javascript\r\n// Implementation of fault tolerance mechanism\r\nconst processWord = async (word) =\u003e {\r\n  const cleanWord = word.toLowerCase().trim()\r\n  \r\n  // First checkpoint: spell checking\r\n  const isSpelledCorrectly = isWordSpelledCorrectly(cleanWord)\r\n  \r\n  if (!isSpelledCorrectly) {\r\n    const suggestions = getSpellingSuggestions(cleanWord)\r\n    return {\r\n      success: false,\r\n      error: 'SPELLING_ERROR',\r\n      suggestions,\r\n      word: cleanWord\r\n    }\r\n  }\r\n  \r\n  // Second checkpoint: part of speech analysis\r\n  const wordNetData = await getWordNetData(cleanWord)\r\n  \r\n  return {\r\n    success: true,\r\n    word: cleanWord,\r\n    ...wordNetData\r\n  }\r\n}\r\n```\r\n\r\n## WordNet Vocabulary Database Integration: Semantic Network\r\n\r\n### WordNet Data Structure\r\n\r\nWordNet is an English vocabulary database based on semantic relationships, which organizes vocabulary into synonym sets (synsets):\r\n\r\n```javascript\r\n// wordUtils.js - WordNet初始化\r\nconst wordnet = require('wordnet')\r\n\r\nlet wordnetInitialized = false\r\nconst initializeWordNet = async () =\u003e {\r\n  if (!wordnetInitialized) {\r\n    try {\r\n      await wordnet.init()\r\n      wordnetInitialized = true\r\n      console.log('WordNet initialized successfully')\r\n    } catch (error) {\r\n      console.error('Failed to initialize WordNet:', error)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Automated Part of Speech Recognition\r\n\r\nWordNet can automatically identify the part of speech of words through semantic network analysis:\r\n\r\n```javascript\r\n// Part of speech mapping function\r\nconst mapWordNetPoS = (wordnetPos) =\u003e {\r\n  if (!wordnetPos) return null\r\n  \r\n  const mapping = {\r\n    'noun': 'noun',\r\n    'verb': 'verb', \r\n    'adjective': 'adjective',\r\n    'adverb': 'adverb',\r\n    'n': 'noun',\r\n    'v': 'verb',\r\n    'a': 'adjective',\r\n    's': 'adjective', // adjective satellite\r\n    'r': 'adverb'\r\n  }\r\n  \r\n  return mapping[wordnetPos.toLowerCase()] || null\r\n}\r\n```\r\n\r\n### Asynchronous Initialization\r\n\r\nWordNet initialization is an asynchronous process that adopts a lazy loading strategy:\r\n\r\n```javascript\r\n// Complete implementation for getting WordNet data\r\nconst getWordNetData = async (word) =\u003e {\r\n  try {\r\n    // Ensure WordNet is initialized\r\n    await initializeWordNet()\r\n    \r\n    if (!wordnetInitialized) {\r\n      console.warn('WordNet not available')\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: false\r\n      }\r\n    }\r\n    \r\n    const cleanWord = word.toLowerCase().trim()\r\n    \r\n    try {\r\n      const definitions = await wordnet.lookup(cleanWord)\r\n      \r\n      if (!definitions || definitions.length === 0) {\r\n        console.log(`No WordNet data found for: ${cleanWord}`)\r\n        return {\r\n          definitions: [],\r\n          primaryDefinition: null,\r\n          primaryPartOfSpeech: null,\r\n          wordNetProcessed: true\r\n        }\r\n      }\r\n      \r\n      // Process WordNet definitions\r\n      const processedDefinitions = definitions.map(def =\u003e ({\r\n        text: def.glossary || def.gloss || '',\r\n        partOfSpeech: mapWordNetPoS(def.meta?.synsetType)\r\n      })).filter(def =\u003e def.text \u0026\u0026 def.partOfSpeech)\r\n      \r\n      // Get primary definition and part of speech\r\n      const primaryDefinition = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].text \r\n        : null\r\n      const primaryPartOfSpeech = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].partOfSpeech \r\n        : null\r\n      \r\n      return {\r\n        definitions: processedDefinitions.slice(0, 10), // Limit to 10 definitions\r\n        primaryDefinition,\r\n        primaryPartOfSpeech,\r\n        wordNetProcessed: true\r\n      }\r\n    } catch (lookupError) {\r\n      console.error('Error looking up word in WordNet:', lookupError)\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: true\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error in getWordNetData:', error)\r\n    return {\r\n      definitions: [],\r\n      primaryDefinition: null,\r\n      primaryPartOfSpeech: null,\r\n      wordNetProcessed: false\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Data Model and Storage Design: MongoDB Documents\r\n\r\n### Optimized Schema Design\r\n\r\nMongoDB document structure design is the foundation of the entire system:\r\n\r\n```javascript\r\n// models/Word.js - Complete Schema design\r\nconst wordSchema = new mongoose.Schema({\r\n  word: {\r\n    type: String,\r\n    required: true,\r\n    trim: true,\r\n    lowercase: true,\r\n    maxlength: 50\r\n  },\r\n  userIds: [{\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    ref: 'User',\r\n    required: true\r\n  }],\r\n  // WordNet retrieved data\r\n  definitions: [{\r\n    text: {\r\n      type: String,\r\n      trim: true,\r\n      maxlength: 1000\r\n    },\r\n    partOfSpeech: {\r\n      type: String,\r\n      enum: ['noun', 'verb', 'adjective', 'adverb', 'preposition', \r\n             'conjunction', 'interjection', 'pronoun', 'determiner', \r\n             'adjective satellite']\r\n    }\r\n  }],\r\n  // Primary part of speech (most common)\r\n  primaryPartOfSpeech: {\r\n    type: String,\r\n    enum: ['noun', 'verb', 'adjective', 'adverb', 'preposition', \r\n           'conjunction', 'interjection', 'pronoun', 'determiner', \r\n           'adjective satellite']\r\n  },\r\n  // Primary definition (first/most common)\r\n  primaryDefinition: {\r\n    type: String,\r\n    trim: true,\r\n    maxlength: 1000\r\n  },\r\n  usageCount: {\r\n    type: Number,\r\n    default: 0,\r\n    min: 0\r\n  },\r\n  // Track whether WordNet lookup was successful\r\n  wordNetProcessed: {\r\n    type: Boolean,\r\n    default: false\r\n  }\r\n}, {\r\n  timestamps: true\r\n})\r\n```\r\n\r\n### Performance Optimization with Compound Indexes\r\n\r\nIndex design is key to database performance:\r\n\r\n```javascript\r\n// Compound index prevents duplicate words uploaded by each user\r\nwordSchema.index({ word: 1, userIds: 1 }, { unique: true })\r\n\r\n// Indexes to improve query performance\r\nwordSchema.index({ userIds: 1, createdAt: -1 })\r\nwordSchema.index({ usageCount: -1 })\r\nwordSchema.index({ primaryPartOfSpeech: 1 })\r\n```\r\n\r\n**Index Performance Analysis**:\r\n\r\n- **Query without index**: O(n) time complexity\r\n- **Query with index**: O(log n) time complexity\r\n- **Compound index**: Supports multi-field query optimization\r\n\r\n### Multi-user Data Sharing Mechanism\r\n\r\nThe same word can be shared by multiple users:\r\n\r\n```javascript\r\n// Balance between user data isolation and sharing\r\nconst query = { userIds: req.user.id }\r\n\r\n// If word already exists, add user to sharing list\r\nif (existingWord) {\r\n  if (existingWord.userIds.includes(req.user.id)) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      message: req.t('words.wordAlreadyExists')\r\n    })\r\n  }\r\n  \r\n  // Add user to existing word\r\n  existingWord.userIds.push(req.user.id)\r\n  await existingWord.save()\r\n}\r\n```\r\n\r\n## Backend Controller Logic Deep Analysis: RESTful\r\n\r\n### Data Validation Schema Design\r\n\r\nJoi data validation:\r\n\r\n```javascript\r\n// Input validation schema\r\nconst addWordSchema = Joi.object({\r\n  word: Joi.string()\r\n    .min(1)\r\n    .max(50)\r\n    .pattern(/^[a-zA-Z\\-']+$/)\r\n    .required()\r\n})\r\n\r\n// Usage in controller\r\nconst { error } = addWordSchema.validate(req.body)\r\nif (error) {\r\n  return res.status(400).json({\r\n    success: false,\r\n    message: error.details[0].message\r\n  })\r\n}\r\n```\r\n\r\n### Pagination Query\r\n\r\n```javascript\r\n// getUserWords - Pagination query implementation\r\nconst { page = 1, limit = 50, sortBy = 'recent', search, partOfSpeech } = req.query\r\nconst skip = (page - 1) * limit\r\n\r\n// Build query conditions\r\nconst query = { userIds: req.user.id }\r\n\r\n// Search filtering\r\nif (search) {\r\n  query.word = { $regex: search.trim(), $options: 'i' }\r\n}\r\n\r\n// Part of speech filtering\r\nif (partOfSpeech \u0026\u0026 partOfSpeech !== 'all') {\r\n  query.primaryPartOfSpeech = partOfSpeech\r\n}\r\n\r\n// Sorting criteria\r\nlet sortCriteria\r\nswitch (sortBy) {\r\n  case 'alphabetical':\r\n    sortCriteria = { word: 1 }\r\n    break\r\n  case 'usage':\r\n    sortCriteria = { usageCount: -1, createdAt: -1 }\r\n    break\r\n  default:\r\n    sortCriteria = { createdAt: -1 }\r\n}\r\n\r\n// Pagination query\r\nconst words = await Word.find(query)\r\n  .sort(sortCriteria)\r\n  .skip(skip)\r\n  .limit(parseInt(limit))\r\n\r\n// Total count\r\nconst total = await Word.countDocuments(query)\r\n```\r\n\r\n### Standardized Error Handling Implementation\r\n\r\nUnified error handling mechanism:\r\n\r\n```javascript\r\n// Standardized error handling\r\ntry {\r\n  // Business logic\r\n} catch (error) {\r\n  if (error.code === 11000) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      message: req.t('words.wordAlreadyExists')\r\n    })\r\n  }\r\n  console.error('Add word error:', error)\r\n  res.status(500).json({\r\n    success: false,\r\n    message: req.t('words.serverErrorAddingWord')\r\n  })\r\n}\r\n```\r\n\r\n## Intelligent Recommendations: MongoDB Aggregation\r\n\r\n### Random Word Recommendation Algorithm\r\n\r\nUsing MongoDB's aggregation pipeline to implement intelligent word recommendation functionality:\r\n\r\n```javascript\r\n// getRandomWords - Implementation of intelligent recommendation\r\nconst { count, excludeUserWords, partOfSpeech } = value\r\n\r\n// Build an aggregation pipeline\r\nlet aggregationPipeline = []\r\n\r\n// Build matching conditions\r\nlet matchCriteria = {}\r\n\r\n// Exclude words the user already has\r\nif (excludeUserWords) {\r\n  matchCriteria.userIds = { $ne: req.user.id }\r\n}\r\n\r\n// Part of speech filtering\r\nif (partOfSpeech) {\r\n  matchCriteria.primaryPartOfSpeech = partOfSpeech\r\n}\r\n\r\n// Add a matching phase\r\nif (Object.keys(matchCriteria).length \u003e 0) {\r\n  aggregationPipeline.push({ $match: matchCriteria })\r\n}\r\n\r\n// Random sampling\r\naggregationPipeline.push({\r\n  $sample: { size: count * 2 } // 获取比需要更多的数据以应对过滤\r\n})\r\n\r\n// Project the required fields\r\naggregationPipeline.push({\r\n  $project: {\r\n    _id: 1,\r\n    word: 1,\r\n    primaryDefinition: 1,\r\n    primaryPartOfSpeech: 1,\r\n    usageCount: 1\r\n  }\r\n})\r\n\r\n// Execute aggregate query\r\nlet randomWords = await Word.aggregate(aggregationPipeline)\r\n```\r\n\r\n### Performance Optimization of Recommendation Algorithm\r\n\r\nMongoDB's `$sample` operator uses an efficient random sampling algorithm:\r\n\r\n**Algorithm Complexity Analysis**:\r\n- **Random Sampling**: O(1) time complexity\r\n- **Traditional Sorting**: O(n log n) time complexity\r\n- **Performance Improvement**: When n=1 million, improvement of approximately 3000x\r\n\r\n### Personalized Filtering Mechanism\r\n\r\nThe system supports multi-level personalized filtering:\r\n\r\n```javascript\r\n// Multi-layer filtering mechanism\r\nconst fallbackWords = await Word.aggregate(fallbackPipeline)\r\n\r\n// Merge results, avoid duplicates\r\nconst existingWordIds = new Set(randomWords.map(w =\u003e w._id.toString()))\r\nconst newWords = fallbackWords.filter(w =\u003e !existingWordIds.has(w._id.toString()))\r\n\r\nrandomWords = [...randomWords, ...newWords]\r\n```\r\n\r\n## Complete Data Flow Analysis: From Input to Storage\r\n\r\n### Complete Flow Diagram\r\n\r\n```mermaid\r\ngraph TD\r\n    A[User Input Word] --\u003e B[Frontend Validation]\r\n    B --\u003e C[Send API Request]\r\n    C --\u003e D[Backend Receive Request]\r\n    D --\u003e E[Joi Data Validation]\r\n    E --\u003e F[Spell Check Typo.js]\r\n    F --\u003e G{Spelling Correct?}\r\n    G --\u003e|No| H[Return Spelling Suggestions]\r\n    G --\u003e|Yes| I[WordNet Part of Speech Analysis]\r\n    I --\u003e J[Database Query]\r\n    J --\u003e K{Word Exists?}\r\n    K --\u003e|Yes| L[Add User to Sharing List]\r\n    K --\u003e|No| M[Create New Word Record]\r\n    L --\u003e N[Return Success Response]\r\n    M --\u003e N\r\n    N --\u003e O[Frontend Update State]\r\n    O --\u003e P[Interface Refresh Display]\r\n    H --\u003e Q[User Selects Suggestion]\r\n    Q --\u003e C\r\n```\r\n\r\n## Technology Library Toolchain\r\n\r\n### Typo.js\r\n\r\n**Technical Features**:\r\n\r\n- Based on Hunspell algorithm\r\n- Supports offline operation\r\n- Lightweight (approximately 100KB)\r\n- Multi-language support\r\n\r\n**Use Cases**:\r\n\r\n- Real-time spell verification\r\n- User input error correction\r\n- Batch text processing\r\n\r\n**Performance Characteristics**:\r\n- Initialization time: 50-100ms\r\n- Word checking: \u003c1ms\r\n- Suggestion generation: 1-5ms\r\n\r\n### WordNet: Digitalization of Semantic Networks\r\n\r\n**Data Structure**:\r\n- Nouns: approximately 117,000\r\n- Verbs: approximately 11,500\r\n- Adjectives: approximately 22,000\r\n- Adverbs: approximately 4,600\r\n\r\n**Semantic Relationships**:\r\n- Synonyms (synonyms)\r\n- Antonyms (antonyms)\r\n- Hypernym/hyponym relationships (hypernyms/hyponyms)\r\n- Part-whole relationships (meronyms/holonyms)\r\n\r\n**Usage Advantages**:\r\n- Accurate part of speech tagging\r\n- Rich semantic information\r\n- Standardized definitions\r\n\r\n### Joi: The Art of Data Validation\r\n\r\n**Design Philosophy**:\r\n- Declarative validation\r\n- Chainable API\r\n- Rich built-in rules\r\n\r\n**Performance Advantages**:\r\n- Validation speed: microsecond level\r\n- Memory usage: lightweight\r\n- Error messages: friendly and clear\r\n\r\n### Mongoose: MongoDB Query Builder\r\n\r\n**ORM Features**:\r\n- Type-safe model definitions\r\n- Middleware support\r\n- Query builder\r\n- Automatic type conversion\r\n\r\n**Performance Optimization**:\r\n- Connection pool management\r\n- Query optimization\r\n- Index recommendations\r\n\r\n## Backend Internationalization Response Implementation\r\n\r\n### Language Negotiation via Request Headers\r\n\r\nThe frontend implements language negotiation through HTTP request headers:\r\n\r\n```typescript\r\n// Complete implementation of language negotiation\r\nconst getCurrentLocale = () =\u003e {\r\n  return localStorage.getItem('locale') || \r\n         navigator.language.split('-')[0] || \r\n         'en'\r\n}\r\n\r\n// Language setting in request interceptor\r\nif (locale) {\r\n  config.headers['x-language'] = locale\r\n}\r\n```\r\n\r\n### Backend Middleware Internationalization Processing\r\n\r\n```javascript\r\n// Internationalization middleware\r\nconst i18nMiddleware = (req, res, next) =\u003e {\r\n  const locale = req.headers['x-language'] || 'en'\r\n  \r\n  // Set current request language environment\r\n  req.locale = locale\r\n  \r\n  // Create translation function\r\n  req.t = (key, options) =\u003e {\r\n    return i18n.t(key, { locale, ...options })\r\n  }\r\n  \r\n  next()\r\n}\r\n```\r\n\r\n### Real-time Language Switching Technical Solution\r\n\r\n```javascript\r\n// Real-time update of part of speech translation\r\nconst updateWordTranslations = (words, locale) =\u003e {\r\n  return words.map(word =\u003e {\r\n    if (word.primaryPartOfSpeech) {\r\n      word.primaryPartOfSpeechTranslated = \r\n        i18n.t(`words.${word.primaryPartOfSpeech}`, { locale })\r\n    }\r\n    return word\r\n  })\r\n}\r\n```\r\n\r\n## User Experience\r\n\r\n### Real-time Feedback Mechanism\r\n\r\n```javascript\r\n// Real-time user feedback\r\nconst addWord = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n  \r\n  // Clear previous error state\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  \r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim()\r\n  })\r\n  \r\n  if (result.success) {\r\n    // Success feedback\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n  } else if (result.suggestions) {\r\n    // Spelling error feedback\r\n    spellingError.value = true\r\n    spellingSuggestions.value = result.suggestions\r\n  }\r\n}\r\n```\r\n\r\n### Error Handling\r\n\r\n```javascript\r\n// Friendly error handling\r\ntry {\r\n  const response = await wordsAPI.addWord(newWord)\r\n  // ...\r\n} catch (error) {\r\n  const message = error.response?.data?.message || t('common.error')\r\n  \r\n  // Special error handling\r\n  if (error.response?.data?.error === 'SPELLING_ERROR') {\r\n    const suggestions = error.response.data.suggestions || []\r\n    const suggestionText = suggestions.length \u003e 0 \r\n      ? t('words.spellingErrorWithSuggestions', { \r\n          suggestions: suggestions.join(', ') \r\n        })\r\n      : t('words.spellingError')\r\n    \r\n    toast.error(suggestionText)\r\n    return { success: false, message: suggestionText, suggestions }\r\n  }\r\n  \r\n  toast.error(message)\r\n  return { success: false, message }\r\n}\r\n```\r\n\r\n## Complete Source Code Analysis\r\n\r\n### Backend Core Files\r\n\r\n#### 1. wordController.js - Word Controller\r\n\r\n```javascript\r\nconst Word = require('../models/Word');\r\nconst Joi = require('joi');\r\nconst { processWord } = require('../utils/wordUtils');\r\n\r\n// Data validation schema - add forceAdd parameter to support forced addition\r\nconst addWordSchema = Joi.object({\r\n  word: Joi.string().min(1).max(50).pattern(/^[a-zA-Z\\-']+$/).required(),\r\n  forceAdd: Joi.boolean().default(false) // New: force add flag\r\n});\r\n\r\n// @desc    Add new word\r\n// @route   POST /api/words\r\n// @access  Private\r\nexports.addWord = async (req, res) =\u003e {\r\n  try {\r\n    // Step 1: Validate input data\r\n    const { error } = addWordSchema.validate(req.body);\r\n    if (error) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: error.details[0].message\r\n      });\r\n    }\r\n\r\n    // Step 2: Extract parameters and clean input\r\n    const { word, forceAdd } = req.body;\r\n    const cleanWord = word.toLowerCase().trim();\r\n\r\n    // Step 3: Decide processing method based on forceAdd flag\r\n    let wordProcessing;\r\n    \r\n    if (forceAdd) {\r\n      // Force add mode: skip spell checking, directly get WordNet data\r\n      const wordNetData = await require('../utils/wordUtils').getWordNetData(cleanWord);\r\n      wordProcessing = {\r\n        success: true,\r\n        word: cleanWord,\r\n        ...wordNetData\r\n      };\r\n    } else {\r\n      // Normal mode: perform spell checking and WordNet query\r\n      wordProcessing = await processWord(cleanWord);\r\n      \r\n      if (!wordProcessing.success) {\r\n        // Return suggestions for spelling errors (200 status code, not error response)\r\n        return res.status(200).json({\r\n          success: false,\r\n          needsConfirmation: true,        // Requires user confirmation\r\n          spellingError: true,            // Mark as spelling error\r\n          message: req.t('words.spellingError'),\r\n          suggestions: wordProcessing.suggestions || [],\r\n          originalWord: wordProcessing.word,\r\n          suggestedCorrection: wordProcessing.suggestions \u0026\u0026 wordProcessing.suggestions.length \u003e 0 \r\n            ? wordProcessing.suggestions[0] : null\r\n        });\r\n      }\r\n    }\r\n\r\n    // Step 4: Check if word already exists in database\r\n    const existingWord = await Word.findOne({\r\n      word: cleanWord\r\n    });\r\n\r\n    if (existingWord) {\r\n      // Word exists, check if current user already owns it\r\n      if (existingWord.userIds.includes(req.user.id)) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          message: req.t('words.wordAlreadyExists')\r\n        });\r\n      }\r\n\r\n      // Add user to existing word's sharing list\r\n      existingWord.userIds.push(req.user.id);\r\n      await existingWord.save();\r\n\r\n      // Add translated part of speech information\r\n      const wordObj = existingWord.toObject();\r\n      if (wordObj.primaryPartOfSpeech) {\r\n        wordObj.primaryPartOfSpeechTranslated = req.t(`words.${wordObj.primaryPartOfSpeech}`);\r\n      }\r\n\r\n      res.status(201).json({\r\n        success: true,\r\n        word: wordObj\r\n      });\r\n    } else {\r\n      // Create new word record\r\n      const newWord = await Word.create({\r\n        word: cleanWord,\r\n        userIds: [req.user.id],\r\n        definitions: wordProcessing.definitions || [],\r\n        primaryDefinition: wordProcessing.primaryDefinition,\r\n        primaryPartOfSpeech: wordProcessing.primaryPartOfSpeech,\r\n        wordNetProcessed: wordProcessing.wordNetProcessed\r\n      });\r\n\r\n      // Add translated part of speech information\r\n      const wordObj = newWord.toObject();\r\n      if (wordObj.primaryPartOfSpeech) {\r\n        wordObj.primaryPartOfSpeechTranslated = req.t(`words.${wordObj.primaryPartOfSpeech}`);\r\n      }\r\n\r\n      res.status(201).json({\r\n        success: true,\r\n        word: wordObj\r\n      });\r\n    }\r\n  } catch (error) {\r\n    // Error handling: handle duplicate key and other database errors\r\n    if (error.code === 11000) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: req.t('words.wordAlreadyExists')\r\n      });\r\n    }\r\n    console.error('Add word error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: req.t('words.serverErrorAddingWord')\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n#### 2. wordUtils.js - Word Processing Tool\r\n\r\n```javascript\r\nconst Typo = require('typo-js');\r\nconst wordnet = require('wordnet');\r\n\r\n// Initialize spell checker\r\nlet spellChecker;\r\ntry {\r\n  spellChecker = new Typo('en_US');\r\n} catch (error) {\r\n  console.error('Failed to initialize spell checker:', error);\r\n}\r\n\r\n// Initialize WordNet\r\nlet wordnetInitialized = false;\r\nconst initializeWordNet = async () =\u003e {\r\n  if (!wordnetInitialized) {\r\n    try {\r\n      await wordnet.init();\r\n      wordnetInitialized = true;\r\n      console.log('WordNet initialized successfully');\r\n    } catch (error) {\r\n      console.error('Failed to initialize WordNet:', error);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Core spell checking function\r\n * @param {string} word - Word to be checked\r\n * @returns {boolean} - Whether spelling is correct\r\n */\r\nconst isWordSpelledCorrectly = (word) =\u003e {\r\n  // Defensive programming: check if spell checker is available\r\n  if (!spellChecker) {\r\n    console.warn('Spell checker not available, assuming word is correct');\r\n    return true;\r\n  }\r\n\r\n  try {\r\n    const cleanWord = word.toLowerCase().trim();\r\n    return spellChecker.check(cleanWord);\r\n  } catch (error) {\r\n    console.error('Error checking spelling:', error);\r\n    return true; // Default to correct, ensure system availability\r\n  }\r\n};\r\n\r\n/**\r\n * Get spelling suggestions\r\n * @param {string} word - Misspelled word\r\n * @returns {string[]} - Array of spelling suggestions\r\n */\r\nconst getSpellingSuggestions = (word) =\u003e {\r\n  if (!spellChecker) {\r\n    return [];\r\n  }\r\n\r\n  try {\r\n    const cleanWord = word.toLowerCase().trim();\r\n    return spellChecker.suggest(cleanWord) || [];\r\n  } catch (error) {\r\n    console.error('Error getting spelling suggestions:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * Get WordNet vocabulary data\r\n * @param {string} word - Word to be queried\r\n * @returns {Promise\u003cObject\u003e} - Object containing definitions and part of speech\r\n */\r\nconst getWordNetData = async (word) =\u003e {\r\n  try {\r\n    // Ensure WordNet is initialized\r\n    await initializeWordNet();\r\n    \r\n    if (!wordnetInitialized) {\r\n      console.warn('WordNet not available');\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: false\r\n      };\r\n    }\r\n\r\n    const cleanWord = word.toLowerCase().trim();\r\n    \r\n    try {\r\n      // Query word definitions from WordNet\r\n      const definitions = await wordnet.lookup(cleanWord);\r\n      \r\n      if (!definitions || definitions.length === 0) {\r\n        console.log(`No WordNet data found for: ${cleanWord}`);\r\n        return {\r\n          definitions: [],\r\n          primaryDefinition: null,\r\n          primaryPartOfSpeech: null,\r\n          wordNetProcessed: true\r\n        };\r\n      }\r\n\r\n      // Process WordNet returned definition data\r\n      const processedDefinitions = definitions.map(def =\u003e ({\r\n        text: def.glossary || def.gloss || '',\r\n        partOfSpeech: mapWordNetPoS(def.meta?.synsetType)\r\n      })).filter(def =\u003e def.text \u0026\u0026 def.partOfSpeech);\r\n\r\n      // Get primary definition (first/most common)\r\n      const primaryDefinition = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].text \r\n        : null;\r\n      const primaryPartOfSpeech = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].partOfSpeech \r\n        : null;\r\n\r\n      return {\r\n        definitions: processedDefinitions.slice(0, 10), // Limit to 10 definitions\r\n        primaryDefinition,\r\n        primaryPartOfSpeech,\r\n        wordNetProcessed: true\r\n      };\r\n    } catch (lookupError) {\r\n      console.error('Error looking up word in WordNet:', lookupError);\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: true\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error('Error in getWordNetData:', error);\r\n    return {\r\n      definitions: [],\r\n      primaryDefinition: null,\r\n      primaryPartOfSpeech: null,\r\n      wordNetProcessed: false\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * Map WordNet part of speech codes to system part of speech\r\n * @param {string} wordnetPos - WordNet part of speech code\r\n * @returns {string|null} - Mapped part of speech\r\n */\r\nconst mapWordNetPoS = (wordnetPos) =\u003e {\r\n  if (!wordnetPos) return null;\r\n  \r\n  const mapping = {\r\n    'noun': 'noun',\r\n    'verb': 'verb',\r\n    'adjective': 'adjective',\r\n    'adverb': 'adverb',\r\n    'n': 'noun',\r\n    'v': 'verb',\r\n    'a': 'adjective',\r\n    's': 'adjective', // adjective satellite\r\n    'r': 'adverb'\r\n  };\r\n\r\n  return mapping[wordnetPos.toLowerCase()] || null;\r\n};\r\n\r\n/**\r\n * Complete word processing workflow\r\n * @param {string} word - Word to be processed\r\n * @returns {Promise\u003cObject\u003e} - Processing result\r\n */\r\nconst processWord = async (word) =\u003e {\r\n  const cleanWord = word.toLowerCase().trim();\r\n  \r\n  // Step 1: Spell checking\r\n  const isSpelledCorrectly = isWordSpelledCorrectly(cleanWord);\r\n  \r\n  if (!isSpelledCorrectly) {\r\n    // Spelling error, return suggestions\r\n    const suggestions = getSpellingSuggestions(cleanWord);\r\n    return {\r\n      success: false,\r\n      error: 'SPELLING_ERROR',\r\n      suggestions,\r\n      word: cleanWord\r\n    };\r\n  }\r\n\r\n  // Step 2: Get WordNet data\r\n  const wordNetData = await getWordNetData(cleanWord);\r\n  \r\n  return {\r\n    success: true,\r\n    word: cleanWord,\r\n    ...wordNetData\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  isWordSpelledCorrectly,\r\n  getSpellingSuggestions,\r\n  getWordNetData,\r\n  processWord\r\n};\r\n```\r\n\r\n#### 3. words.js - Route Definition\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst {\r\n  getUserWords,\r\n  addWord,\r\n  deleteWord,\r\n  getRandomWords,\r\n  getWordStats,\r\n  getPartsOfSpeech\r\n} = require('../controllers/wordController');\r\nconst { auth } = require('../middleware/auth');\r\n\r\nconst router = express.Router();\r\n\r\n// Get random word recommendations\r\nrouter.get('/random', auth, getRandomWords);\r\n\r\n// Get user word statistics\r\nrouter.get('/stats', auth, getWordStats);\r\n\r\n// Get available parts of speech list\r\nrouter.get('/parts-of-speech', auth, getPartsOfSpeech);\r\n\r\n// Get user's word list\r\nrouter.get('/', auth, getUserWords);\r\n\r\n// Add new word (supports spelling suggestions)\r\nrouter.post('/', auth, addWord);\r\n\r\n// Delete word\r\nrouter.delete('/:id', auth, deleteWord);\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n### Frontend Core Files\r\n\r\n#### 4. Words.vue - Word Management View\r\n\r\n```vue\r\n\u003ctemplate\u003e\r\n  \u003cdiv class=\"space-y-6\"\u003e\r\n    \u003c!-- Add word form --\u003e\r\n    \u003cdiv v-if=\"showAddForm\" class=\"card\"\u003e\r\n      \u003cdiv class=\"card-header\"\u003e\r\n        \u003ch3 class=\"text-lg font-semibold\"\u003e{{ $t('words.add') }}\u003c/h3\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv class=\"card-body\"\u003e\r\n        \u003cform class=\"space-y-4\" @submit.prevent=\"addWord\"\u003e\r\n          \u003cdiv class=\"grid grid-cols-1 gap-4\"\u003e\r\n            \u003cdiv\u003e\r\n              \u003clabel class=\"block text-sm font-medium text-primary\" for=\"word\"\u003e\r\n                {{ $t('words.word') }} *\r\n              \u003c/label\u003e\r\n              \u003cinput\r\n                  id=\"word\"\r\n                  v-model=\"newWord.word\"\r\n                  :placeholder=\"$t('words.enterWord')\"\r\n                  class=\"input mt-1\"\r\n                  required\r\n                  type=\"text\"\r\n              /\u003e\r\n              \u003cp class=\"text-xs text-secondary mt-1\"\u003e\r\n                {{ $t('words.spellingWillBeChecked') }}\r\n              \u003c/p\u003e\r\n            \u003c/div\u003e\r\n\r\n            \u003cdiv class=\"flex items-end md:items-center\"\u003e\r\n              \u003cbutton\r\n                  :disabled=\"wordsStore.loading || !newWord.word.trim()\"\r\n                  class=\"btn btn-primary w-full\"\r\n                  type=\"submit\"\r\n              \u003e\r\n                \u003cdiv v-if=\"wordsStore.loading\" class=\"spinner mr-2\"\u003e\u003c/div\u003e\r\n                {{ $t('words.add') }}\r\n              \u003c/button\u003e\r\n            \u003c/div\u003e\r\n          \u003c/div\u003e\r\n\r\n          \u003c!-- Spelling suggestion UI --\u003e\r\n          \u003cdiv v-if=\"spellingError \u0026\u0026 spellingSuggestions.length \u003e 0\"\r\n               class=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4\"\u003e\r\n            \u003cdiv class=\"flex items-start space-x-2\"\u003e\r\n              \u003c!-- Information icon --\u003e\r\n              \u003cdiv class=\"flex-shrink-0 mt-0.5\"\u003e\r\n                \u003csvg class=\"w-5 h-5 text-blue-600 dark:text-blue-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"\u003e\r\n                  \u003cpath stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\u003e\u003c/path\u003e\r\n                \u003c/svg\u003e\r\n              \u003c/div\u003e\r\n              \u003cdiv class=\"flex-1\"\u003e\r\n                \u003c!-- Prompt text --\u003e\r\n                \u003cp class=\"text-sm font-medium text-blue-800 dark:text-blue-200 mb-2\"\u003e\r\n                  {{ $t('words.spellingNotRecognized') }}\r\n                \u003c/p\u003e\r\n                \u003cp class=\"text-sm text-blue-700 dark:text-blue-300 mb-3\"\u003e\r\n                  {{ $t('words.didYouMean') }}\r\n                \u003c/p\u003e\r\n                \r\n                \u003c!-- Spelling suggestion button group --\u003e\r\n                \u003cdiv class=\"flex flex-wrap gap-2\"\u003e\r\n                  \u003cbutton\r\n                      v-for=\"suggestion in spellingSuggestions\"\r\n                      :key=\"suggestion\"\r\n                      class=\"inline-flex items-center px-3 py-1.5 text-sm font-medium text-blue-700 dark:text-blue-200 bg-blue-100 dark:bg-blue-800 rounded-md hover:bg-blue-200 dark:hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\r\n                      @click=\"selectSuggestion(suggestion)\"\r\n                  \u003e\r\n                    {{ suggestion }}\r\n                  \u003c/button\u003e\r\n                \u003c/div\u003e\r\n                \r\n                \u003c!-- User action options --\u003e\r\n                \u003cdiv class=\"mt-3 flex items-center space-x-2\"\u003e\r\n                  \u003cbutton\r\n                      class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n                      @click=\"addWordAnyway\"\r\n                  \u003e\r\n                    {{ $t('words.addAnyway') }}\r\n                  \u003c/button\u003e\r\n                  \u003cspan class=\"text-xs text-blue-500 dark:text-blue-400\"\u003e{{ $t('words.or') }}\u003c/span\u003e\r\n                  \u003cbutton\r\n                      class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n                      @click=\"cancelSpelling\"\r\n                  \u003e\r\n                    {{ $t('words.tryAgain') }}\r\n                  \u003c/button\u003e\r\n                \u003c/div\u003e\r\n              \u003c/div\u003e\r\n            \u003c/div\u003e\r\n          \u003c/div\u003e\r\n        \u003c/form\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \r\n    \u003c!-- Other UI components... --\u003e\r\n  \u003c/div\u003e\r\n\u003c/template\u003e\r\n\r\n\u003cscript lang=\"ts\" setup\u003e\r\nimport { onMounted, reactive, ref } from 'vue'\r\nimport { useWordsStore } from '../stores/words.ts'\r\nimport { useI18n } from 'vue-i18n'\r\n\r\nconst wordsStore = useWordsStore()\r\nconst { t } = useI18n()\r\n\r\n// Reactive state\r\nconst showAddForm = ref(false)              // Whether to show add form\r\nconst spellingError = ref(false)            // Whether there is a spelling error\r\nconst spellingSuggestions = ref\u003cstring[]\u003e([]) // Spelling suggestions array\r\n\r\n// New word data\r\nconst newWord = reactive({\r\n  word: ''\r\n})\r\n\r\n// Initialize when component mounts\r\nonMounted(() =\u003e {\r\n  wordsStore.fetchWords()\r\n  wordsStore.fetchPartsOfSpeech()\r\n})\r\n\r\n/**\r\n * Main processing function for adding words\r\n */\r\nconst addWord = async () =\u003e {\r\n  // Validate input\r\n  if (!newWord.word.trim()) return\r\n\r\n  // Reset spelling error state\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n\r\n  // Call store to add word\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim()\r\n  })\r\n\r\n  if (result.success) {\r\n    // Success: reset form\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n    spellingError.value = false\r\n    spellingSuggestions.value = []\r\n  } else if (result.spellingError \u0026\u0026 result.suggestions?.length \u003e 0) {\r\n    // Spelling error: display suggestions\r\n    spellingError.value = true\r\n    spellingSuggestions.value = result.suggestions\r\n  }\r\n}\r\n\r\n/**\r\n * User selects spelling suggestion\r\n * @param {string} suggestion - Selected suggestion word\r\n */\r\nconst selectSuggestion = (suggestion: string) =\u003e {\r\n  newWord.word = suggestion\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n}\r\n\r\n/**\r\n * Force add word (skip spell checking)\r\n */\r\nconst addWordAnyway = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n  \r\n  // Reset error state\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  \r\n  // Force add through forceAdd parameter\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim(),\r\n    forceAdd: true\r\n  })\r\n  \r\n  if (result.success) {\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n  }\r\n}\r\n\r\n/**\r\n * Cancel spelling suggestions, re-enter\r\n */\r\nconst cancelSpelling = () =\u003e {\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  newWord.word = ''\r\n}\r\n\u003c/script\u003e\r\n```\r\n\r\n#### 5. words.ts - Pinia State Management\r\n\r\n```typescript\r\nimport { defineStore } from 'pinia'\r\nimport { ref, computed } from 'vue'\r\nimport { useToast } from 'vue-toastification'\r\nimport { useI18n } from 'vue-i18n'\r\nimport { wordsAPI } from '../services/api.ts'\r\n\r\n// Type definitions\r\ninterface NewWord {\r\n  word: string\r\n  forceAdd?: boolean  // Force add flag\r\n}\r\n\r\ninterface Word {\r\n  _id: string\r\n  word: string\r\n  userIds: string[]\r\n  definitions: Array\u003c{\r\n    text: string\r\n    partOfSpeech: string\r\n  }\u003e\r\n  primaryDefinition?: string\r\n  primaryPartOfSpeech?: string\r\n  primaryPartOfSpeechTranslated?: string\r\n  usageCount: number\r\n  wordNetProcessed: boolean\r\n  createdAt: string\r\n  updatedAt: string\r\n}\r\n\r\nexport const useWordsStore = defineStore('words', () =\u003e {\r\n  // Reactive state\r\n  const words = ref\u003cWord[]\u003e([])\r\n  const selectedWords = ref\u003cSet\u003cstring\u003e\u003e(new Set())\r\n  const loading = ref(false)\r\n  const currentFilter = ref\u003cstring\u003e('all')\r\n  const searchQuery = ref\u003cstring\u003e('')\r\n  \r\n  // Dependency injection\r\n  const toast = useToast()\r\n  const { t } = useI18n()\r\n\r\n  // Computed property: filtered word list\r\n  const filteredWords = computed(() =\u003e {\r\n    let filtered = words.value\r\n\r\n    // Part of speech filtering\r\n    if (currentFilter.value \u0026\u0026 currentFilter.value !== 'all') {\r\n      filtered = filtered.filter(word =\u003e \r\n        word.primaryPartOfSpeech === currentFilter.value\r\n      )\r\n    }\r\n\r\n    // Search filtering\r\n    if (searchQuery.value.trim()) {\r\n      const query = searchQuery.value.toLowerCase().trim()\r\n      filtered = filtered.filter(word =\u003e \r\n        word.word.toLowerCase().includes(query) ||\r\n        word.primaryDefinition?.toLowerCase().includes(query)\r\n      )\r\n    }\r\n\r\n    return filtered\r\n  })\r\n\r\n  // Computed property: sorted word list\r\n  const sortedWords = computed(() =\u003e {\r\n    return [...filteredWords.value].sort((a, b) =\u003e \r\n      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n    )\r\n  })\r\n\r\n  /**\r\n   * Core logic for adding words\r\n   * @param {NewWord} newWord - New word object\r\n   * @returns {Promise\u003cObject\u003e} Processing result\r\n   */\r\n  const addWord = async (newWord: NewWord) =\u003e {\r\n    // Check for duplicates\r\n    const existingWord = words.value.find(w =\u003e \r\n      w.word.toLowerCase() === newWord.word.toLowerCase()\r\n    )\r\n    if (existingWord) {\r\n      toast.error(t('words.wordExists'))\r\n      return { success: false, message: t('words.wordExists') }\r\n    }\r\n\r\n    loading.value = true\r\n    try {\r\n      // Call API to add word\r\n      const response = await wordsAPI.addWord(newWord)\r\n      \r\n      if (response.data.success) {\r\n        // Success: update local state\r\n        words.value.unshift(response.data.word)\r\n        toast.success(t('words.wordAdded'))\r\n        return { success: true, word: response.data.word }\r\n      } else {\r\n        // Check if it's a spelling error\r\n        if (response.data.spellingError \u0026\u0026 response.data.suggestions?.length \u003e 0) {\r\n          // Don't show error message, let UI component handle it\r\n          return { \r\n            success: false, \r\n            spellingError: true,\r\n            suggestions: response.data.suggestions,\r\n            originalWord: response.data.originalWord,\r\n            suggestedCorrection: response.data.suggestedCorrection,\r\n            message: response.data.message || t('words.spellingError')\r\n          }\r\n        }\r\n        \r\n        // Other errors\r\n        const message = response.data.message || t('common.error')\r\n        toast.error(message)\r\n        return { success: false, message }\r\n      }\r\n    } catch (error: any) {\r\n      // Exception handling\r\n      const message = error.response?.data?.message || t('common.error')\r\n      toast.error(message)\r\n      return { success: false, message }\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n\r\n  return {\r\n    // State\r\n    words: sortedWords,\r\n    selectedWords,\r\n    loading,\r\n    currentFilter,\r\n    searchQuery,\r\n    \r\n    // Methods\r\n    addWord,\r\n    // ... other methods\r\n  }\r\n})\r\n```\r\n\r\n#### 6. api.ts - API Service Layer\r\n\r\n```typescript\r\nimport axios from 'axios'\r\nimport { getCurrentLocale } from '../utils/i18n.js'\r\n\r\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL\r\n\r\n// Create axios instance\r\nconst api = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: 30000,\r\n  headers: {\r\n    'Content-Type': 'application/json'\r\n  }\r\n})\r\n\r\n// Request interceptor: add language and authentication headers\r\napi.interceptors.request.use(\r\n  (config) =\u003e {\r\n    // Add language header\r\n    const locale = getCurrentLocale()\r\n    if (locale) {\r\n      config.headers['x-language'] = locale\r\n    }\r\n\r\n    // Add authentication header\r\n    const token = localStorage.getItem('token')\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`\r\n    }\r\n\r\n    return config\r\n  },\r\n  (error) =\u003e {\r\n    return Promise.reject(error)\r\n  }\r\n)\r\n\r\n// Response interceptor: handle authentication failure\r\napi.interceptors.response.use(\r\n  (response) =\u003e response,\r\n  (error) =\u003e {\r\n    // Handle 401 error (unauthorized)\r\n    if (error.response?.status === 401) {\r\n      localStorage.removeItem('token')\r\n      delete api.defaults.headers.common['Authorization']\r\n      \r\n      if (window.location.pathname !== '/login') {\r\n        window.location.href = '/login'\r\n      }\r\n    }\r\n    \r\n    return Promise.reject(error)\r\n  }\r\n)\r\n\r\n// Export word-related APIs\r\nexport const wordsAPI = {\r\n  // Get word list\r\n  getWords: (params?: any) =\u003e api.get('/words', { params }),\r\n\r\n  // Add word (supports spelling suggestions and forced addition)\r\n  addWord: (word: any) =\u003e api.post('/words', word),\r\n\r\n  // Delete word\r\n  deleteWord: (id: string) =\u003e api.delete(`/words/${id}`),\r\n\r\n  // Get word statistics\r\n  getStats: () =\u003e api.get('/words/stats'),\r\n\r\n  // Get parts of speech list\r\n  getPartsOfSpeech: () =\u003e api.get('/words/parts-of-speech'),\r\n\r\n  // Get random words\r\n  getRandomWords: (params?: any) =\u003e api.get('/words/random', { params })\r\n}\r\n```\r\n\r\n## Final Thoughts\r\n\r\nWord checking was primarily implemented to solve the problem of \"vocabulary database pollution.\" Initially, my vision was to have various users gradually expand the Questions Party vocabulary database, creating a \"collaborative learning\" atmosphere. However, I then thought about the question: \"What if someone accidentally or intentionally inputs incorrect words, causing the vocabulary database to become polluted?\" After some investigation, I discovered Typo.js and WordNet.\r\n\r\n*May the knowledge networks built by all beings endure forever, may every word find its rightful place*. ✨\r\n"])</script><script>self.__next_f.push([1,"2a:T138fa,"])</script><script>self.__next_f.push([1,"\r\n# All-Chat-on-This 配置解析功能实现原理：从配置到消息的完整数据流\r\n\r\n处理各种AI服务商的API差异简直是个\"数据格式联合国\"的问题，而ACOT就是专门用来解决这个问题的。\r\n\r\n本篇文章将深度剖析从UserConfigDO配置类到sendMessage消息发送的每一个环节，全面解构这个让不同AI服务商API\"大一统\"的数据处理系统。\r\n\r\n## 配置类设计篇：UserConfigDO的灵活架构\r\n\r\n在处理多样化AI服务商API时，主要的问题不是调用API本身，而是如何设计一个足够灵活的配置系统来适配千差万别的认证方式和数据格式。\r\n\r\n### 灵活的API密钥放置策略\r\n\r\n```java\r\n// API密钥放置策略\r\nprivate String apiKeyPlacement; // 'header', 'body', 或 'custom_header'\r\nprivate String apiKeyHeader; // 当apiKeyPlacement='custom_header'时的自定义header名称\r\nprivate String apiKeyBodyPath; // 当apiKeyPlacement='body'时的JSON路径\r\n```\r\n\r\n**为什么需要三种策略**？\r\n\r\n让我们看看现实中AI服务商的多样性：\r\n\r\n**Header策略（最常见）**：\r\n```http\r\n# OpenAI风格\r\nAuthorization: Bearer sk-xxxxxxxxxxxx\r\n\r\n# Anthropic风格  \r\nx-api-key: sk-ant-xxxxxxxxxxxx\r\n\r\n# Google风格\r\nX-Goog-Api-Key: AIzaxxxxxxxxxxxx\r\n```\r\n\r\n**Body策略（嵌入式）**：\r\n```json\r\n{\r\n  \"api_key\": \"sk-xxxxxxxxxxxx\",\r\n  \"messages\": [...]\r\n}\r\n```\r\n\r\n**Custom Header策略（个性化）**：\r\n```http\r\nCustom-Auth-Token: xxxxxxxxxxxx\r\nX-Custom-Key: xxxxxxxxxxxx\r\n```\r\n\r\n这种设计的数学表达：\r\n$$API认证策略 = \\begin{cases}\r\nHeader \u0026 \\text{if placement = 'header'} \\\\\r\nBody \u0026 \\text{if placement = 'body'} \\\\\r\nCustomHeader \u0026 \\text{if placement = 'custom\\_header'}\r\n\\end{cases}$$\r\n\r\n### JSON模板化设计：统一处理\r\n\r\n```java\r\n// JSON模板\r\n@TableField(typeHandler = JacksonTypeHandler.class)\r\nprivate Map\u003cString, Object\u003e requestTemplate; // 请求的JSON模板\r\n\r\n@TableField(typeHandler = JacksonTypeHandler.class)\r\nprivate Map\u003cString, Object\u003e responseTemplate; // 响应处理的JSON模板\r\n```\r\n\r\n**为什么使用JacksonTypeHandler**？\r\n\r\n这是MyBatis Plus处理复杂对象的优雅方案：\r\n\r\n错误的做法：\r\n```java\r\n// ❌ 手动序列化，容易出错\r\nprivate String requestTemplateJson;\r\n\r\n// 使用时需要手动转换\r\nObjectMapper mapper = new ObjectMapper();\r\nMap\u003cString, Object\u003e template = mapper.readValue(requestTemplateJson, Map.class);\r\n```\r\n\r\n正确的做法：\r\n```java\r\n// ✅ 自动序列化，类型安全\r\n@TableField(typeHandler = JacksonTypeHandler.class)\r\nprivate Map\u003cString, Object\u003e requestTemplate;\r\n\r\n// 直接使用，无需转换\r\ntemplate.put(\"model\", \"gpt-4\");\r\n```\r\n\r\n**模板化兼容措施**：\r\n\r\n不同服务商的请求格式有可能差异巨大：\r\n\r\n```json\r\n// OpenAI格式\r\n{\r\n  \"model\": \"gpt-4\",\r\n  \"messages\": [...],\r\n  \"temperature\": 0.7\r\n}\r\n\r\n// Claude格式  \r\n{\r\n  \"model\": \"claude-3-sonnet-20240229\",\r\n  \"max_tokens\": 1024,\r\n  \"messages\": [...]\r\n}\r\n\r\n// 自定义API格式\r\n{\r\n  \"engine\": \"custom-model\",\r\n  \"prompt\": \"...\",\r\n  \"config\": {\r\n    \"temperature\": 0.7,\r\n    \"max_length\": 2048\r\n  }\r\n}\r\n```\r\n\r\n通过模板化，我们可以预设任意格式，然后动态填充消息内容。\r\n\r\n### 消息路径配置设计：支持复杂嵌套结构\r\n\r\n```java\r\n// 请求和响应处理策略  \r\nprivate String requestMessageGroupPath; // 消息组的JSON路径\r\nprivate String requestRolePathFromGroup; // 消息组中角色的JSON路径\r\nprivate String requestTextPathFromGroup; // 请求文本的JSON路径\r\nprivate String responseTextPath; // 响应文本的JSON路径\r\nprivate String responseThinkingTextPath; // 响应中思考文本的JSON路径\r\n```\r\n\r\n**路径系统如何工作**？\r\n\r\n以一个复杂的API格式为例：\r\n\r\n```json\r\n{\r\n  \"model\": \"gpt-4\",\r\n  \"parameters\": {\r\n    \"conversation\": {\r\n      \"messages\": [\r\n        {\r\n          \"role\": \"user\",\r\n          \"content\": \"Hello\"\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n对应的路径配置：\r\n- `requestMessageGroupPath`: `\"parameters.conversation.messages\"`\r\n- `requestRolePathFromGroup`: `\"role\"`  \r\n- `requestTextPathFromGroup`: `\"content\"`\r\n\r\n**JsonPath的数学表达**：\r\n\r\n路径解析算法可以表示为：\r\n$$JsonPath(object, path) = object[path_0][path_1]...[path_n]$$\r\n\r\n其中$path = path_0.path_1...path_n$\r\n\r\n### UserConfigDO完整结构图\r\n\r\n```mermaid\r\nclassDiagram\r\n    class UserConfigDO {\r\n        +Long id\r\n        +Boolean isAvailable\r\n        +String name\r\n        +String apiUrl\r\n        +String apiKey\r\n        \r\n        +String apiKeyPlacement\r\n        +String apiKeyHeader\r\n        +String apiKeyBodyPath\r\n        \r\n        +Map requestTemplate\r\n        +Map responseTemplate\r\n        +Map headers\r\n        \r\n        +String requestMessageGroupPath\r\n        +String requestRolePathFromGroup\r\n        +String requestTextPathFromGroup\r\n        +String responseTextPath\r\n        +String responseThinkingTextPath\r\n        \r\n        +String requestUserRoleField\r\n        +String requestAssistantField\r\n        +String requestSystemField\r\n        \r\n        +LocalDateTime lastUsedTime\r\n        +String secretKey\r\n    }\r\n```\r\n\r\n## 数据解析逻辑篇：prepareRequestData的双重奏\r\n\r\n数据准备是整个系统的核心，需要将用户配置转换为可发送的HTTP请求。ACOT提供了两个重载方法来处理不同的场景。\r\n\r\n### 测试版本：单消息处理的基础逻辑\r\n\r\n```java\r\npublic static Map\u003cString, Object\u003e prepareRequestData(UserConfigDO config, String messageText) {\r\n    // 准备请求头\r\n    Map\u003cString, String\u003e headers = new HashMap\u003c\u003e(config.getHeaders() != null ? config.getHeaders() : new HashMap\u003c\u003e());\r\n\r\n    // 检查API密钥是否加密，如有需要则解密\r\n    String apiKey = config.getApiKey();\r\n    if (apiKey != null \u0026\u0026 apiKey.startsWith(\"enc:\") \u0026\u0026 StringUtils.hasText(config.getSecretKey())) {\r\n        try {\r\n            apiKey = decryptApiKey(apiKey.substring(4), config.getSecretKey());\r\n        } catch (Exception e) {\r\n            log.error(\"Error decrypting API key\", e);\r\n            throw new ServiceException(CONFIG_NOT_EXISTS, \"Failed to decrypt API key: \" + e.getMessage());\r\n        }\r\n    }\r\n```\r\n\r\n### API密钥放置的三重分派\r\n\r\n```java\r\n// 根据放置策略将API密钥添加到请求头\r\nif (\"header\".equals(config.getApiKeyPlacement()) || config.getApiKeyPlacement() == null) {\r\n    headers.put(\"Authorization\", \"Bearer \" + apiKey);\r\n} else if (\"custom_header\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyHeader() != null) {\r\n    headers.put(config.getApiKeyHeader(), apiKey);\r\n}\r\n\r\n// 通过克隆模板来准备请求体\r\nMap\u003cString, Object\u003e requestBody = new HashMap\u003c\u003e(config.getRequestTemplate());\r\n\r\n// 如果需要，将API密钥添加到请求体中\r\nif (\"body\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyBodyPath() != null) {\r\n    JsonUtils.setValueByPath(requestBody, config.getApiKeyBodyPath(), apiKey);\r\n}\r\n```\r\n\r\n**策略模式**：\r\n\r\n每种放置方式都有其特定的处理逻辑：\r\n\r\n```typescript\r\n// 伪代码表示分派逻辑\r\nswitch(apiKeyPlacement) {\r\n    case 'header':\r\n        headers['Authorization'] = 'Bearer ' + apiKey;\r\n        break;\r\n    case 'custom_header':\r\n        headers[apiKeyHeader] = apiKey;\r\n        break;\r\n    case 'body':\r\n        setValueByPath(requestBody, apiKeyBodyPath, apiKey);\r\n        break;\r\n}\r\n```\r\n\r\n**JsonUtils.setValueByPath路径设置**：\r\n\r\n这个方法能处理复杂的嵌套路径：\r\n\r\n```java\r\n// 路径 \"auth.credentials.api_key\" 会被解析为：\r\n// requestBody.auth.credentials.api_key = apiKey\r\nJsonUtils.setValueByPath(requestBody, \"auth.credentials.api_key\", apiKey);\r\n```\r\n\r\n### 实用版本：对话历史处理\r\n\r\n```java\r\npublic static Map\u003cString, Object\u003e prepareRequestData(UserConfigDO config, String messageText, List\u003cConversationMessageDO\u003e conversationMessages) {\r\n    // ... 前面的逻辑相同\r\n    \r\n    // 创建消息组并添加对话历史\r\n    if (StringUtils.hasText(config.getRequestMessageGroupPath()) \u0026\u0026 (conversationMessages != null || messageText != null)) {\r\n        List\u003cMap\u003cString, Object\u003e\u003e messages = new ArrayList\u003c\u003e();\r\n\r\n        // 添加之前的消息\r\n        if (conversationMessages != null) {\r\n            for (ConversationMessageDO message : conversationMessages) {\r\n                // 跳过系统消息\r\n                if (\"system\".equals(message.getRole())) {\r\n                    continue;\r\n                }\r\n```\r\n\r\n**对话历史处理的核心算法**：\r\n\r\n```java\r\n// 角色映射策略\r\nString userRoleValue = StringUtils.hasText(config.getRequestUserRoleField()) ?\r\n        config.getRequestUserRoleField() : \"user\";\r\n\r\nString assistantRoleValue = StringUtils.hasText(config.getRequestAssistantField()) ?\r\n        config.getRequestAssistantField() : \"assistant\";\r\n```\r\n\r\n这种映射机制解决了不同服务商角色字段差异的问题：\r\n\r\n| 服务商 | User角色 | Assistant角色 |\r\n|--------|----------|---------------|\r\n| OpenAI | \"user\" | \"assistant\" |\r\n| Claude | \"user\" | \"assistant\" |\r\n| 自定义API | \"human\" | \"ai\" |\r\n| 某些API | \"customer\" | \"agent\" |\r\n\r\n**消息对象动态构建**：\r\n\r\n```java\r\nMap\u003cString, Object\u003e messageObj = new HashMap\u003c\u003e();\r\n// 动态设置角色字段名\r\nif (\"user\".equals(message.getRole())) {\r\n    messageObj.put(rolePath, userRoleValue);\r\n} else if (\"assistant\".equals(message.getRole())) {\r\n    messageObj.put(rolePath, assistantRoleValue);\r\n}\r\n// 动态设置内容字段名\r\nmessageObj.put(textPath, message.getContent());\r\n```\r\n\r\n倘若某些API的用户和AI的角色字段并非默认的`user`和`assistant`，那么该功能便可支持用户和AI的字段名自定义配置。\r\n\r\n## 消息生成与发送逻辑篇：sendMessage的完整业务流程\r\n\r\n消息发送是整个系统的最终目标，涉及权限验证、数据准备、HTTP调用、响应解析等多个环节。\r\n\r\n### 权限验证\r\n\r\n```java\r\n// 验证对话是否属于该用户\r\nConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\nif (conversation == null) {\r\n    throw new ServiceException(CONVERSATION_NOT_EXISTS.getCode(), CONVERSATION_NOT_EXISTS.getMsg());\r\n}\r\n\r\n// 获取配置\r\nUserConfigDO config = userConfigService.getConfig(configId, userId);\r\nif (config == null) {\r\n    throw new ServiceException(CONFIGURATION_NOT_EXISTS.getCode(), CONFIGURATION_NOT_EXISTS.getMsg());\r\n}\r\n```\r\n\r\n**双重权限验证机制**：\r\n\r\n1. **对话归属权验证**：确保用户只能操作自己的对话\r\n2. **配置归属权验证**：确保用户只能使用自己的配置\r\n\r\n这种设计防止了常见的安全问题：\r\n- **水平权限提升**：用户A不能访问用户B的对话\r\n- **配置泄露**：用户A不能使用用户B的API配置\r\n\r\n### 消息创建策略：先创建不保存\r\n\r\n```java\r\n// 创建用户消息（但暂时不保存）\r\nConversationMessageDO userMessageDO = new ConversationMessageDO()\r\n        .setConversationId(conversationId)\r\n        .setConfigId(configId)\r\n        .setRole(\"user\")\r\n        .setContent(userMessage);\r\n\r\n// 获取对话中的历史消息\r\nList\u003cConversationMessageDO\u003e previousMessages = list(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n        .eq(ConversationMessageDO::getConversationId, conversationId)\r\n        .orderByAsc(ConversationMessageDO::getCreateTime));\r\n\r\n// 生成助手回复\r\nConversationMessageDO assistantMessageDO = generateAssistantResponse(userMessage, config, conversationId, configId, previousMessages);\r\n\r\n// 如果执行到这里，说明API调用成功，现在保存用户消息\r\nsave(userMessageDO);\r\nsave(assistantMessageDO);\r\n```\r\n\r\n**为什么先创建用户消息但不保存**？\r\n\r\n这是一种事务性设计模式，遵循\"要么全成功，要么全失败\"的原则：\r\n\r\n错误的做法：\r\n```java\r\n// ❌ 先保存用户消息，如果API调用失败，数据不一致\r\nsave(userMessageDO);\r\ntry {\r\n    ConversationMessageDO response = callAPI(...);\r\n    save(response);\r\n} catch (Exception e) {\r\n    // 用户消息已保存，但没有回复 - 数据不一致！\r\n    throw e;\r\n}\r\n```\r\n\r\n正确的做法：\r\n```java\r\n// ✅ 先尝试API调用，成功后再批量保存\r\nConversationMessageDO userMessageDO = createUserMessage(...);\r\nConversationMessageDO assistantResponse = callAPI(...);\r\n// API成功，批量保存\r\nsave(userMessageDO);\r\nsave(assistantResponse);\r\n```\r\n\r\n### generateAssistantResponse：HTTP调用的核心引擎\r\n\r\n```java\r\nprivate ConversationMessageDO generateAssistantResponse(\r\n        String userMessage,\r\n        UserConfigDO config,\r\n        Long conversationId,\r\n        Long configId,\r\n        List\u003cConversationMessageDO\u003e conversationMessages) {\r\n\r\n    // 使用通用方法准备包含对话历史的请求数据\r\n    Map\u003cString, Object\u003e requestData = HttpUtils.prepareRequestData(config, userMessage, conversationMessages);\r\n    Map\u003cString, String\u003e headers = (Map\u003cString, String\u003e) requestData.get(\"headers\");\r\n    Map\u003cString, Object\u003e requestBody = (Map\u003cString, Object\u003e) requestData.get(\"requestBody\");\r\n\r\n    // 执行实际的HTTP请求\r\n    String requestBodyStr = JsonUtils.toJsonString(requestBody);\r\n    String responseStr = HttpUtils.post(config.getApiUrl(), headers, requestBodyStr);\r\n```\r\n\r\n**HTTP请求的完整数据流**：\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Service as ConversationService\r\n    participant Utils as HttpUtils\r\n    participant API as AI_API\r\n    participant Parser as JsonUtils\r\n\r\n    Service-\u003e\u003eUtils: prepareRequestData(config, message, history)\r\n    Utils-\u003e\u003eUtils: 解密API密钥\r\n    Utils-\u003e\u003eUtils: 构建请求头\r\n    Utils-\u003e\u003eUtils: 构建请求体\r\n    Utils--\u003e\u003eService: {headers, requestBody}\r\n    \r\n    Service-\u003e\u003eParser: toJsonString(requestBody)\r\n    Parser--\u003e\u003eService: requestBodyStr\r\n    \r\n    Service-\u003e\u003eUtils: post(url, headers, body)\r\n    Utils-\u003e\u003eAPI: HTTP POST\r\n    API--\u003e\u003eUtils: JSON Response\r\n    Utils--\u003e\u003eService: responseStr\r\n    \r\n    Service-\u003e\u003eParser: parseObject(responseStr)\r\n    Parser--\u003e\u003eService: responseMap\r\n    \r\n    Service-\u003e\u003eParser: extractValueFromPath(responseMap, textPath)\r\n    Parser--\u003e\u003eService: content\r\n```\r\n\r\n**响应解析的双路径设计**：\r\n\r\n```java\r\n// 使用指定路径从响应中提取内容和思考文本\r\nString content = null;\r\nString thinking = null;\r\n\r\nif (StringUtils.hasText(config.getResponseTextPath())) {\r\n    content = JsonUtils.extractValueFromPath(responseMap, config.getResponseTextPath());\r\n}\r\n\r\nif (StringUtils.hasText(config.getResponseThinkingTextPath())) {\r\n    thinking = JsonUtils.extractValueFromPath(responseMap, config.getResponseThinkingTextPath());\r\n}\r\n```\r\n\r\n这种设计支持不同服务商的响应格式：\r\n\r\n```json\r\n// OpenAI格式\r\n{\r\n  \"choices\": [\r\n    {\r\n      \"message\": {\r\n        \"content\": \"这是回复内容\"\r\n      }\r\n    }\r\n  ]\r\n}\r\n// 路径: \"choices.0.message.content\"\r\n\r\n// Claude格式  \r\n{\r\n  \"content\": [\r\n    {\r\n      \"text\": \"这是回复内容\"\r\n    }\r\n  ]\r\n}\r\n// 路径: \"content.0.text\"\r\n\r\n// 支持思考过程的格式\r\n{\r\n  \"response\": {\r\n    \"content\": \"这是回复内容\",\r\n    \"thinking\": \"这是思考过程\"\r\n  }\r\n}\r\n// 内容路径: \"response.content\"  \r\n// 思考路径: \"response.thinking\"\r\n```\r\n\r\n### 事务管理与缓存策略\r\n\r\n```java\r\n@Override\r\n@Transactional\r\n@Caching(evict = {\r\n        @CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n})\r\n```\r\n\r\n**@Transactional的回滚机制**：\r\n\r\nSpring的事务管理确保数据一致性：\r\n\r\n```java\r\n@Transactional\r\npublic ConversationMessageDO sendMessage(...) {\r\n    try {\r\n        // 1. 验证权限\r\n        validatePermissions();\r\n        \r\n        // 2. 调用API  \r\n        ConversationMessageDO response = callAPI();\r\n        \r\n        // 3. 保存消息\r\n        save(userMessage);\r\n        save(response);\r\n        \r\n        // 4. 更新对话时间\r\n        updateConversation();\r\n        \r\n        return response;\r\n    } catch (Exception e) {\r\n        // 任何异常都会触发回滚，保证数据一致性\r\n        throw e;\r\n    }\r\n}\r\n```\r\n\r\n**缓存失效策略的考虑**：\r\n\r\n```java\r\n@CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n```\r\n\r\n这个注解确保在新消息产生时，相关的缓存被清除。缓存键的设计考虑了：\r\n- **对话隔离**：不同对话的缓存独立\r\n- **用户隔离**：不同用户的缓存独立\r\n- **精确失效**：只清除相关缓存，不影响其他数据\r\n\r\n### 配置监控：markConfigurationAsAvailable\r\n\r\n```java\r\n// 标记配置为可用，因为已成功使用\r\nmarkConfigurationAsAvailable(configId, userId);\r\n\r\n@Override\r\npublic boolean markConfigurationAsAvailable(Long configId, Long userId) {\r\n    UserConfigDO config = userConfigService.getConfig(configId, userId);\r\n    if (config == null) {\r\n        return false;\r\n    }\r\n\r\n    // 将isAvailable设置为true并设置lastUsedTime为当前时间\r\n    userConfigService.setAvailableAndUpdateLastUsedTime(configId, true);\r\n\r\n    return true;\r\n}\r\n```\r\n\r\n**可用性标记的业务价值**：\r\n\r\n这个看似简单的操作实际上承载了重要的业务逻辑：\r\n\r\n1. **健康检查**：成功的API调用证明配置可用\r\n2. **使用统计**：记录最后使用时间，便于分析\r\n3. **自动修复**：将之前标记为不可用的配置重新激活\r\n4. **用户体验**：让用户知道哪些配置是可用的\r\n\r\n**lastUsedTime的统计价值**：\r\n\r\n```sql\r\n-- 可以分析用户的使用模式\r\nSELECT configId, COUNT(*) as usage_count, \r\n       MAX(lastUsedTime) as last_used,\r\n       AVG(TIMESTAMPDIFF(SECOND, createTime, lastUsedTime)) as avg_response_time\r\nFROM user_config \r\nWHERE userId = ? \r\nGROUP BY configId\r\nORDER BY usage_count DESC;\r\n```\r\n\r\n## JSON路径解析引擎篇：JsonUtils的深度算法解析\r\n\r\n~~最难的一集。~~\r\n\r\n### 路径解析的数学模型\r\n\r\nJSON路径解析本质上是一个**树遍历问题**，我们需要将字符串路径转换为对象访问序列。\r\n\r\n给定路径 `path = \"a.b[0].c.d[1].e\"`，解析算法可以表示为：\r\n\r\n$$PathTraversal(object, path) = \\prod_{i=0}^{n} Access(object_i, token_i)$$\r\n\r\n其中：\r\n- $token_i$ 是路径中的第i个访问标记\r\n- $Access$ 函数根据标记类型选择不同的访问策略\r\n\r\n### extractValueFromPath：路径提取的核心算法\r\n\r\n```java\r\npublic static String extractValueFromPath(Map\u003cString, Object\u003e data, String path) {\r\n    String[] parts = path.split(\"\\\\.\");  // 按点号分割路径\r\n    Object current = data;              // 当前遍历的对象\r\n\r\n    for (String part : parts) {\r\n        if (current == null) {\r\n            return null;  // 防御性检查：中途遇到null立即返回\r\n        }\r\n\r\n        // 处理数组表示法，如 choices[0]\r\n        if (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n            // 算法核心：解析数组名称和索引\r\n            String arrayName = part.substring(0, part.indexOf('['));\r\n            int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n```\r\n\r\n**数组索引解析的算法分析**：\r\n\r\n```java\r\n// 字符串解析的时间复杂度分析\r\n// part = \"choices[0]\"\r\nString arrayName = part.substring(0, part.indexOf('['));    // O(n)\r\nint index = Integer.parseInt(part.substring(...));          // O(1)\r\n```\r\n\r\n**类型安全的访问策略**：\r\n\r\n```java\r\nif (current instanceof Map) {\r\n    Map\u003cString, Object\u003e map = (Map\u003cString, Object\u003e) current;\r\n    if (map.containsKey(arrayName) \u0026\u0026 map.get(arrayName) instanceof List) {\r\n        List\u003cObject\u003e array = (List\u003cObject\u003e) map.get(arrayName);\r\n        if (index \u003c array.size()) {\r\n            current = array.get(index);  // 安全访问数组元素\r\n        } else {\r\n            return null;  // 索引越界，返回null\r\n        }\r\n    } else {\r\n        return null;  // 字段不存在或类型不匹配\r\n    }\r\n} else {\r\n    return null;  // 当前对象不是Map类型\r\n}\r\n```\r\n\r\n**为什么需要这么多类型检查**？\r\n\r\n在动态类型的JSON世界中，我们无法保证数据结构的一致性：\r\n\r\n错误的做法：\r\n```java\r\n// ❌ 危险的直接访问\r\nList\u003cObject\u003e array = (List\u003cObject\u003e) ((Map) current).get(arrayName);\r\ncurrent = array.get(index);  // 可能抛出NullPointerException、ClassCastException、IndexOutOfBoundsException\r\n```\r\n\r\n正确的做法：\r\n```java\r\n// ✅ 多重防护检查\r\nif (current instanceof Map) {                           // 类型检查\r\n    Map\u003cString, Object\u003e map = (Map\u003cString, Object\u003e) current;\r\n    if (map.containsKey(arrayName) \u0026\u0026                   // 存在性检查\r\n        map.get(arrayName) instanceof List) {            // 类型检查\r\n        List\u003cObject\u003e array = (List\u003cObject\u003e) map.get(arrayName);\r\n        if (index \u003c array.size()) {                      // 边界检查\r\n            current = array.get(index);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### setValueByPath：路径设置的智能构建\r\n\r\n相比于`extractValueFromPath`的只读访问，`setValueByPath`需要解决更复杂的问题：**如何在不完整的JSON结构中智能构建路径**。\r\n\r\n```java\r\npublic static void setValueByPath(Map\u003cString, Object\u003e data, String path, Object value) {\r\n    String[] parts = path.split(\"\\\\.\");\r\n    Map\u003cString, Object\u003e current = data;\r\n\r\n    // 步骤1：遍历路径，确保中间结构存在\r\n    for (int i = 0; i \u003c parts.length - 1; i++) {\r\n        String part = parts[i];\r\n\r\n        // 处理数组路径段\r\n        if (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n            String arrayName = part.substring(0, part.indexOf('['));\r\n            int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n```\r\n\r\n**智能数组构建算法**：\r\n\r\n```java\r\n// 如果数组不存在，创建新数组\r\nif (!current.containsKey(arrayName) || !(current.get(arrayName) instanceof List)) {\r\n    current.put(arrayName, new ArrayList\u003c\u003e());\r\n}\r\n\r\nList\u003cObject\u003e array = (List\u003cObject\u003e) current.get(arrayName);\r\n\r\n// 核心算法：数组扩容确保索引可访问\r\nwhile (array.size() \u003c= index) {\r\n    array.add(new HashMap\u003cString, Object\u003e());  // 用空对象填充\r\n}\r\n\r\n// 确保索引位置是Map对象（为下一级路径准备）\r\nif (!(array.get(index) instanceof Map)) {\r\n    array.set(index, new HashMap\u003cString, Object\u003e());\r\n}\r\n\r\ncurrent = (Map\u003cString, Object\u003e) array.get(index);\r\n```\r\n\r\n**数组扩容的数学分析**：\r\n\r\n假设当前数组长度为 $n$，目标索引为 $k$，则：\r\n\r\n$$扩容次数 = \\max(0, k - n + 1)$$\r\n\r\n**为什么用HashMap填充而不是null**？\r\n\r\n这是一个设计权衡：\r\n\r\n错误的做法：\r\n```java\r\n// ❌ 用null填充\r\nwhile (array.size() \u003c= index) {\r\n    array.add(null);\r\n}\r\n// 下一次访问时可能出现NullPointerException\r\n```\r\n\r\n正确的做法：\r\n```java\r\n// ✅ 用空对象填充\r\nwhile (array.size() \u003c= index) {\r\n    array.add(new HashMap\u003cString, Object\u003e());\r\n}\r\n// 确保后续路径可以继续构建\r\n```\r\n\r\n### 路径解析的实际应用场景\r\n\r\n**场景1：OpenAI响应解析**\r\n\r\n```json\r\n{\r\n  \"choices\": [\r\n    {\r\n      \"message\": {\r\n        \"content\": \"这是AI的回复\",\r\n        \"role\": \"assistant\"\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n```java\r\n// 提取回复内容\r\nString content = JsonUtils.extractValueFromPath(response, \"choices[0].message.content\");\r\n// 结果：\"这是AI的回复\"\r\n```\r\n\r\n**场景2：Claude响应解析**\r\n\r\n```json\r\n{\r\n  \"content\": [\r\n    {\r\n      \"text\": \"这是Claude的回复\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n```java\r\n// 提取回复内容\r\nString content = JsonUtils.extractValueFromPath(response, \"content[0].text\");\r\n// 结果：\"这是Claude的回复\"\r\n```\r\n\r\n**场景3：复杂请求体构建**\r\n\r\n```java\r\n// 构建复杂的请求体\r\nMap\u003cString, Object\u003e requestBody = new HashMap\u003c\u003e();\r\n\r\n// 设置模型信息\r\nJsonUtils.setValueByPath(requestBody, \"model\", \"gpt-4\");\r\n\r\n// 设置消息数组\r\nJsonUtils.setValueByPath(requestBody, \"messages[0].role\", \"user\");\r\nJsonUtils.setValueByPath(requestBody, \"messages[0].content\", \"Hello\");\r\n\r\n// 设置配置参数\r\nJsonUtils.setValueByPath(requestBody, \"config.temperature\", 0.7);\r\nJsonUtils.setValueByPath(requestBody, \"config.max_tokens\", 1000);\r\n\r\n// 结果：\r\n{\r\n  \"model\": \"gpt-4\",\r\n  \"messages\": [\r\n    {\r\n      \"role\": \"user\",\r\n      \"content\": \"Hello\"\r\n    }\r\n  ],\r\n  \"config\": {\r\n    \"temperature\": 0.7,\r\n    \"max_tokens\": 1000\r\n  }\r\n}\r\n```\r\n\r\n### 边界情况处理的防御性设计\r\n\r\n**情况1：路径不存在**\r\n\r\n```java\r\n// 输入：{\"user\": {\"name\": \"张三\"}}\r\n// 路径：user.age\r\nString age = JsonUtils.extractValueFromPath(data, \"user.age\");\r\n// 结果：null（不抛异常）\r\n```\r\n\r\n**情况2：类型不匹配**\r\n\r\n```java\r\n// 输入：{\"user\": \"张三\"}（user是字符串，不是对象）\r\n// 路径：user.name\r\nString name = JsonUtils.extractValueFromPath(data, \"user.name\");\r\n// 结果：null（不抛异常）\r\n```\r\n\r\n**情况3：数组索引越界**\r\n\r\n```java\r\n// 输入：{\"items\": [1, 2, 3]}\r\n// 路径：items[10]\r\nString item = JsonUtils.extractValueFromPath(data, \"items[10]\");\r\n// 结果：null（不抛异常）\r\n```\r\n\r\n### JsonUtils的完整方法架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    A[JsonUtils工具类] --\u003e B[基础序列化]\r\n    A --\u003e C[路径解析]\r\n    A --\u003e D[类型转换]\r\n    \r\n    B --\u003e B1[toJsonString]\r\n    B --\u003e B2[parseObject]\r\n    B --\u003e B3[parseArray]\r\n    \r\n    C --\u003e C1[extractValueFromPath]\r\n    C --\u003e C2[setValueByPath]\r\n    \r\n    D --\u003e D1[类型安全转换]\r\n    D --\u003e D2[静默解析]\r\n    \r\n    C1 --\u003e E[路径分割]\r\n    C1 --\u003e F[类型检查]\r\n    C1 --\u003e G[数组索引解析]\r\n    \r\n    C2 --\u003e H[智能构建]\r\n    C2 --\u003e I[数组扩容]\r\n    C2 --\u003e J[递归路径创建]\r\n    \r\n    E --\u003e E1[\"path.split('\\\\.')\"]\r\n    F --\u003e F1[instanceof检查]\r\n    G --\u003e G1[字符串substring]\r\n    \r\n    H --\u003e H1[防御性创建]\r\n    I --\u003e I2[while循环扩容]\r\n    J --\u003e J1[递归Map创建]\r\n```\r\n\r\n通过这种路径解析机制，ACOT实现了真正的**API格式无关性**，无论AI服务商如何变化响应格式，只需要修改路径配置就能适配。\r\n\r\n## 完整系统架构图\r\n\r\n```mermaid\r\ngraph TB\r\n    A[用户请求] --\u003e B[sendMessage方法]\r\n    B --\u003e C[权限验证]\r\n    C --\u003e D[配置获取]\r\n    D --\u003e E[消息历史查询]\r\n    E --\u003e F[prepareRequestData]\r\n    \r\n    F --\u003e G[API密钥解密]\r\n    G --\u003e H[请求头构建]\r\n    H --\u003e I[请求体构建]\r\n    I --\u003e J[消息组装配]\r\n    \r\n    J --\u003e K[HTTP POST调用]\r\n    K --\u003e L[响应解析]\r\n    L --\u003e M[JsonUtils路径提取]\r\n    M --\u003e N[消息保存]\r\n    N --\u003e O[缓存更新]\r\n    O --\u003e P[配置标记]\r\n    P --\u003e Q[返回结果]\r\n    \r\n    subgraph \"配置系统\"\r\n        D1[UserConfigDO]\r\n        D2[灵活密钥放置]\r\n        D3[JSON模板化]\r\n        D4[路径配置]\r\n    end\r\n    \r\n    subgraph \"加密系统\"  \r\n        G1[CryptoJS兼容]\r\n        G2[EVP_BytesToKey]\r\n        G3[AES/CBC解密]\r\n    end\r\n    \r\n    subgraph \"数据处理\"\r\n        F1[测试版prepareRequestData]\r\n        F2[实用版prepareRequestData]\r\n        F3[消息历史处理]\r\n        F4[角色映射]\r\n    end\r\n    \r\n    subgraph \"JSON解析引擎\"\r\n        M1[extractValueFromPath]\r\n        M2[setValueByPath]\r\n        M3[路径分割算法]\r\n        M4[类型安全检查]\r\n        M5[数组索引解析]\r\n        M6[智能结构构建]\r\n    end\r\n```\r\n\r\n## 性能优化\r\n\r\n### 缓存策略的层次设计\r\n\r\n```java\r\n@Cacheable(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\npublic List\u003cConversationMessageDO\u003e getMessages(Long conversationId, Long userId) {\r\n    // 缓存对话消息列表，减少数据库查询\r\n}\r\n\r\n@Cacheable(key = \"'id:' + #id + ':user:' + #userId\") \r\npublic ConversationMessageDO getMessage(Long id, Long userId) {\r\n    // 缓存单个消息，支持详情页快速加载\r\n}\r\n```\r\n\r\n**缓存键设计的考虑**：\r\n- **唯一性**：确保不同数据有不同的键\r\n- **可预测性**：便于手动清除特定缓存\r\n- **层次性**：支持批量清除相关缓存\r\n\r\n### 异常处理\r\n\r\n```java\r\ntry {\r\n    ConversationMessageDO assistantMessageDO = generateAssistantResponse(...);\r\n    save(userMessageDO);\r\n    save(assistantMessageDO);\r\n    return assistantMessageDO;\r\n} catch (Exception e) {\r\n    log.error(\"Error sending message\", e);\r\n    \r\n    // 不再创建错误消息，直接抛出异常\r\n    if (e instanceof ServiceException) {\r\n        throw e;\r\n    }\r\n    throw new ServiceException(MESSAGE_SEND_FAILED.getCode(), e.getMessage());\r\n}\r\n```\r\n\r\n**异常处理的原则**：\r\n1. **快速失败**：发现错误立即终止\r\n2. **信息保留**：记录详细的错误日志\r\n3. **类型保持**：保持ServiceException的类型\r\n4. **避免脏数据**：不保存不完整的对话\r\n\r\n## 完整代码全解析\r\n\r\n### JsonUtils：JSON解析工具类的完整实现\r\n\r\n```java\r\npackage com.chat.allchatonthis.common.util.json;\r\n\r\nimport cn.hutool.core.util.ArrayUtil;\r\nimport cn.hutool.core.util.StrUtil;\r\nimport cn.hutool.json.JSONUtil;\r\nimport com.fasterxml.jackson.annotation.JsonInclude;\r\nimport com.fasterxml.jackson.core.type.TypeReference;\r\nimport com.fasterxml.jackson.databind.DeserializationFeature;\r\nimport com.fasterxml.jackson.databind.JsonNode;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.SerializationFeature;\r\nimport com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\r\nimport lombok.SneakyThrows;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Type;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * JSON工具类 - ACOT的数据解析核心引擎\r\n */\r\n@Slf4j\r\npublic class JsonUtils {\r\n\r\n    // ==================== 核心配置 ====================\r\n    \r\n    /** 全局ObjectMapper实例 - 单例模式，线程安全 */\r\n    private static ObjectMapper objectMapper = new ObjectMapper();\r\n\r\n    static {\r\n        // 配置序列化行为：不因空Bean而失败\r\n        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\r\n        // 配置反序列化行为：忽略未知属性\r\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n        // 忽略null值，减少数据传输量\r\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n        // 支持Java 8时间类型\r\n        objectMapper.registerModules(new JavaTimeModule());\r\n    }\r\n\r\n    /**\r\n     * 初始化ObjectMapper - 支持Spring Boot自动配置\r\n     * \r\n     * @param objectMapper Spring管理的ObjectMapper Bean\r\n     */\r\n    public static void init(ObjectMapper objectMapper) {\r\n        JsonUtils.objectMapper = objectMapper;\r\n    }\r\n\r\n    // ==================== 基础序列化方法 ====================\r\n\r\n    /**\r\n     * 对象转JSON字符串 - 最常用的序列化方法\r\n     * \r\n     * @param object 要序列化的对象\r\n     * @return JSON字符串\r\n     */\r\n    @SneakyThrows\r\n    public static String toJsonString(Object object) {\r\n        return objectMapper.writeValueAsString(object);\r\n    }\r\n\r\n    /**\r\n     * 对象转JSON字节数组 - 适用于网络传输\r\n     * \r\n     * @param object 要序列化的对象\r\n     * @return JSON字节数组\r\n     */\r\n    @SneakyThrows\r\n    public static byte[] toJsonByte(Object object) {\r\n        return objectMapper.writeValueAsBytes(object);\r\n    }\r\n\r\n    /**\r\n     * 对象转格式化JSON字符串 - 适用于调试和日志\r\n     * \r\n     * @param object 要序列化的对象\r\n     * @return 格式化的JSON字符串\r\n     */\r\n    @SneakyThrows\r\n    public static String toJsonPrettyString(Object object) {\r\n        return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(object);\r\n    }\r\n\r\n    // ==================== 基础反序列化方法 ====================\r\n\r\n    /**\r\n     * JSON字符串转对象 - 核心反序列化方法\r\n     * \r\n     * @param text JSON字符串\r\n     * @param clazz 目标类型\r\n     * @return 反序列化后的对象\r\n     */\r\n    public static \u003cT\u003e T parseObject(String text, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return null;\r\n        }\r\n        try {\r\n            return objectMapper.readValue(text, clazz);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON解析失败, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 从JSON字符串的指定路径解析对象 - 支持嵌套提取\r\n     * \r\n     * @param text JSON字符串\r\n     * @param path 路径（如\"data.user\"）\r\n     * @param clazz 目标类型\r\n     * @return 解析后的对象\r\n     */\r\n    public static \u003cT\u003e T parseObject(String text, String path, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return null;\r\n        }\r\n        try {\r\n            JsonNode treeNode = objectMapper.readTree(text);\r\n            JsonNode pathNode = treeNode.path(path);\r\n            return objectMapper.readValue(pathNode.toString(), clazz);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON路径解析失败, json:{}, path:{}\", text, path, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 字节数组转对象 - 适用于网络传输数据\r\n     * \r\n     * @param bytes JSON字节数组\r\n     * @param clazz 目标类型\r\n     * @return 反序列化后的对象\r\n     */\r\n    public static \u003cT\u003e T parseObject(byte[] bytes, Class\u003cT\u003e clazz) {\r\n        if (ArrayUtil.isEmpty(bytes)) {\r\n            return null;\r\n        }\r\n        try {\r\n            return objectMapper.readValue(bytes, clazz);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON字节数组解析失败\", e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 使用TypeReference解析复杂类型 - 支持泛型\r\n     * \r\n     * @param text JSON字符串\r\n     * @param typeReference 类型引用\r\n     * @return 解析后的对象\r\n     */\r\n    public static \u003cT\u003e T parseObject(String text, TypeReference\u003cT\u003e typeReference) {\r\n        try {\r\n            return objectMapper.readValue(text, typeReference);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON TypeReference解析失败, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 静默解析 - 解析失败时返回null而不抛异常\r\n     * \r\n     * @param text JSON字符串\r\n     * @param typeReference 类型引用\r\n     * @return 解析后的对象或null\r\n     */\r\n    public static \u003cT\u003e T parseObjectQuietly(String text, TypeReference\u003cT\u003e typeReference) {\r\n        try {\r\n            return objectMapper.readValue(text, typeReference);\r\n        } catch (IOException e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // ==================== 数组解析方法 ====================\r\n\r\n    /**\r\n     * JSON字符串转List - 处理数组类型\r\n     * \r\n     * @param text JSON字符串\r\n     * @param clazz 数组元素类型\r\n     * @return List对象\r\n     */\r\n    public static \u003cT\u003e List\u003cT\u003e parseArray(String text, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return new ArrayList\u003c\u003e();\r\n        }\r\n        try {\r\n            return objectMapper.readValue(text, \r\n                objectMapper.getTypeFactory().constructCollectionType(List.class, clazz));\r\n        } catch (IOException e) {\r\n            log.error(\"JSON数组解析失败, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 从指定路径解析数组 - 支持嵌套数组提取\r\n     * \r\n     * @param text JSON字符串\r\n     * @param path 路径（如\"data.items\"）\r\n     * @param clazz 数组元素类型\r\n     * @return List对象\r\n     */\r\n    public static \u003cT\u003e List\u003cT\u003e parseArray(String text, String path, Class\u003cT\u003e clazz) {\r\n        if (StrUtil.isEmpty(text)) {\r\n            return null;\r\n        }\r\n        try {\r\n            JsonNode treeNode = objectMapper.readTree(text);\r\n            JsonNode pathNode = treeNode.path(path);\r\n            return objectMapper.readValue(pathNode.toString(), \r\n                objectMapper.getTypeFactory().constructCollectionType(List.class, clazz));\r\n        } catch (IOException e) {\r\n            log.error(\"JSON路径数组解析失败, json:{}, path:{}\", text, path, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    // ==================== 树结构解析方法 ====================\r\n\r\n    /**\r\n     * 解析为JsonNode树结构 - 支持动态访问\r\n     * \r\n     * @param text JSON字符串\r\n     * @return JsonNode树\r\n     */\r\n    public static JsonNode parseTree(String text) {\r\n        try {\r\n            return objectMapper.readTree(text);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON树解析失败, json:{}\", text, e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 字节数组解析为JsonNode树结构\r\n     * \r\n     * @param text JSON字节数组\r\n     * @return JsonNode树\r\n     */\r\n    public static JsonNode parseTree(byte[] text) {\r\n        try {\r\n            return objectMapper.readTree(text);\r\n        } catch (IOException e) {\r\n            log.error(\"JSON字节数组树解析失败\", e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    // ==================== 工具方法 ====================\r\n\r\n    /**\r\n     * 判断字符串是否为JSON格式\r\n     * \r\n     * @param text 待检测字符串\r\n     * @return 是否为JSON\r\n     */\r\n    public static boolean isJson(String text) {\r\n        return JSONUtil.isTypeJSON(text);\r\n    }\r\n\r\n    /**\r\n     * 判断字符串是否为JSON对象格式\r\n     * \r\n     * @param str 待检测字符串\r\n     * @return 是否为JSON对象\r\n     */\r\n    public static boolean isJsonObject(String str) {\r\n        return JSONUtil.isTypeJSONObject(str);\r\n    }\r\n\r\n    // ==================== 核心路径解析方法 ====================\r\n\r\n    /**\r\n     * 从嵌套JSON结构中提取值 - ACOT的核心功能\r\n     * \r\n     * 支持的路径格式：\r\n     * - 简单路径：user.name\r\n     * - 数组路径：choices[0].message.content\r\n     * - 混合路径：data.items[0].details.info\r\n     * \r\n     * @param data 数据结构\r\n     * @param path 点号分隔的路径（支持数组下标）\r\n     * @return 提取的值的字符串表示，找不到则返回null\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static String extractValueFromPath(Map\u003cString, Object\u003e data, String path) {\r\n        // 步骤1：路径分割\r\n        String[] parts = path.split(\"\\\\.\");\r\n        Object current = data;\r\n\r\n        // 步骤2：逐级遍历路径\r\n        for (String part : parts) {\r\n            // 防御性检查：中途遇到null立即返回\r\n            if (current == null) {\r\n                return null;\r\n            }\r\n\r\n            // 步骤3：解析当前路径段\r\n            if (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n                // 数组访问模式：choices[0]\r\n                String arrayName = part.substring(0, part.indexOf('['));\r\n                int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n\r\n                // 类型安全的数组访问\r\n                if (current instanceof Map) {\r\n                    Map\u003cString, Object\u003e map = (Map\u003cString, Object\u003e) current;\r\n                    if (map.containsKey(arrayName) \u0026\u0026 map.get(arrayName) instanceof List) {\r\n                        List\u003cObject\u003e array = (List\u003cObject\u003e) map.get(arrayName);\r\n                        if (index \u003c array.size()) {\r\n                            current = array.get(index);\r\n                        } else {\r\n                            return null;  // 数组越界\r\n                        }\r\n                    } else {\r\n                        return null;  // 字段不存在或类型不匹配\r\n                    }\r\n                } else {\r\n                    return null;  // 当前对象不是Map类型\r\n                }\r\n            } else {\r\n                // 普通属性访问模式：user.name\r\n                if (current instanceof Map) {\r\n                    current = ((Map\u003cString, Object\u003e) current).get(part);\r\n                } else {\r\n                    return null;  // 当前对象不是Map类型\r\n                }\r\n            }\r\n        }\r\n\r\n        // 步骤4：返回结果\r\n        return current != null ? current.toString() : null;\r\n    }\r\n\r\n    /**\r\n     * 在嵌套JSON结构中设置值 - ACOT的核心功能\r\n     * \r\n     * 特点：\r\n     * - 智能路径构建：自动创建不存在的中间路径\r\n     * - 数组自动扩容：确保数组索引可访问\r\n     * - 类型安全：防止类型冲突\r\n     * \r\n     * @param data 要修改的数据结构\r\n     * @param path 点号分隔的路径（支持数组下标）\r\n     * @param value 要设置的值\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static void setValueByPath(Map\u003cString, Object\u003e data, String path, Object value) {\r\n        // 步骤1：路径分割\r\n        String[] parts = path.split(\"\\\\.\");\r\n        Map\u003cString, Object\u003e current = data;\r\n\r\n        // 步骤2：遍历路径，确保中间结构存在\r\n        for (int i = 0; i \u003c parts.length - 1; i++) {\r\n            String part = parts[i];\r\n\r\n            if (part.contains(\"[\") \u0026\u0026 part.contains(\"]\")) {\r\n                // 数组路径处理\r\n                String arrayName = part.substring(0, part.indexOf('['));\r\n                int index = Integer.parseInt(part.substring(part.indexOf('[') + 1, part.indexOf(']')));\r\n\r\n                // 创建数组（如果不存在）\r\n                if (!current.containsKey(arrayName) || !(current.get(arrayName) instanceof List)) {\r\n                    current.put(arrayName, new ArrayList\u003c\u003e());\r\n                }\r\n\r\n                List\u003cObject\u003e array = (List\u003cObject\u003e) current.get(arrayName);\r\n\r\n                // 数组扩容：确保索引可访问\r\n                while (array.size() \u003c= index) {\r\n                    array.add(new HashMap\u003cString, Object\u003e());\r\n                }\r\n\r\n                // 确保数组元素是Map对象（为下一级路径做准备）\r\n                if (!(array.get(index) instanceof Map)) {\r\n                    array.set(index, new HashMap\u003cString, Object\u003e());\r\n                }\r\n\r\n                current = (Map\u003cString, Object\u003e) array.get(index);\r\n            } else {\r\n                // 普通属性路径处理\r\n                if (!current.containsKey(part) || !(current.get(part) instanceof Map)) {\r\n                    current.put(part, new HashMap\u003cString, Object\u003e());\r\n                }\r\n                current = (Map\u003cString, Object\u003e) current.get(part);\r\n            }\r\n        }\r\n\r\n        // 步骤3：设置最终值\r\n        String lastPart = parts[parts.length - 1];\r\n\r\n        if (lastPart.contains(\"[\") \u0026\u0026 lastPart.contains(\"]\")) {\r\n            // 最终路径是数组元素\r\n            String arrayName = lastPart.substring(0, lastPart.indexOf('['));\r\n            int index = Integer.parseInt(lastPart.substring(lastPart.indexOf('[') + 1, lastPart.indexOf(']')));\r\n\r\n            // 创建数组（如果不存在）\r\n            if (!current.containsKey(arrayName) || !(current.get(arrayName) instanceof List)) {\r\n                current.put(arrayName, new ArrayList\u003c\u003e());\r\n            }\r\n\r\n            List\u003cObject\u003e array = (List\u003cObject\u003e) current.get(arrayName);\r\n\r\n            // 数组扩容：确保索引可访问\r\n            while (array.size() \u003c= index) {\r\n                array.add(null);\r\n            }\r\n\r\n            // 设置数组元素值\r\n            array.set(index, value);\r\n        } else {\r\n            // 最终路径是普通属性\r\n            current.put(lastPart, value);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### UserConfigDO：配置类的完整实现\r\n\r\n```java\r\npackage com.chat.allchatonthis.entity.dataobject;\r\n\r\nimport com.baomidou.mybatisplus.annotation.*;\r\nimport com.baomidou.mybatisplus.extension.handlers.JacksonTypeHandler;\r\nimport com.chat.allchatonthis.config.mybatis.core.dataobject.BaseDO;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Data;\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.NoArgsConstructor;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.Map;\r\n\r\n/**\r\n * 用户配置数据对象 - 支持多样化AI服务商API配置\r\n * \r\n * 设计目标：\r\n * 1. 灵活适配不同AI服务商的认证方式\r\n * 2. 支持复杂嵌套的JSON请求/响应格式\r\n * 3. 提供完整的消息路径映射功能\r\n * 4. 确保配置的安全性和可用性监控\r\n */\r\n@EqualsAndHashCode(callSuper = true)\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Accessors(chain = true)  // 支持链式调用，提升代码可读性\r\n@TableName(value = \"user_config\", autoResultMap = true)\r\npublic class UserConfigDO extends BaseDO {\r\n    \r\n    // ==================== 基础配置字段 ====================\r\n    \r\n    @TableId(type = IdType.AUTO)\r\n    private Long id;\r\n    \r\n    /** 配置是否可用 - 用于健康检查和用户界面显示 */\r\n    private Boolean isAvailable;\r\n    \r\n    /** 外键：关联用户ID，实现多yonhg隔离 */\r\n    private Long userId;\r\n    \r\n    /** 配置名称 - 用户自定义，便于管理多个配置 */\r\n    private String name;\r\n    \r\n    /** API请求URL - 不同服务商的端点地址 */\r\n    private String apiUrl;\r\n    \r\n    /** API密钥 - 支持明文和加密存储（enc:前缀标识加密） */\r\n    private String apiKey;\r\n\r\n    // ==================== API密钥放置策略 ====================\r\n    \r\n    /** \r\n     * API密钥放置策略：\r\n     * - 'header': 放在Authorization header中（默认，适用于OpenAI等）\r\n     * - 'body': 嵌入请求体中（适用于某些自定义API）\r\n     * - 'custom_header': 放在自定义header中（适用于Anthropic等）\r\n     */\r\n    private String apiKeyPlacement;\r\n    \r\n    /** 自定义header名称 - 当apiKeyPlacement='custom_header'时使用 */\r\n    private String apiKeyHeader;\r\n    \r\n    /** JSON路径 - 当apiKeyPlacement='body'时，指定API密钥在请求体中的位置 */\r\n    private String apiKeyBodyPath;\r\n\r\n    // ==================== JSON模板系统 ====================\r\n    \r\n    /** \r\n     * 请求模板 - 预定义的JSON结构\r\n     * 使用JacksonTypeHandler自动处理Map\u003c-\u003eJSON转换\r\n     * 支持任意复杂的嵌套结构\r\n     */\r\n    @TableField(typeHandler = JacksonTypeHandler.class)\r\n    private Map\u003cString, Object\u003e requestTemplate;\r\n\r\n    /** \r\n     * 响应模板 - 用于响应格式验证和处理\r\n     * 目前主要用于文档化，未来可扩展为响应验证\r\n     */\r\n    @TableField(typeHandler = JacksonTypeHandler.class)\r\n    private Map\u003cString, Object\u003e responseTemplate;\r\n\r\n    /** \r\n     * 自定义HTTP头 - 支持添加额外的请求头\r\n     * 例如：User-Agent、Referer、自定义认证头等\r\n     */\r\n    @TableField(typeHandler = JacksonTypeHandler.class)\r\n    private Map\u003cString, String\u003e headers;\r\n\r\n    // ==================== 角色字段映射 ====================\r\n    \r\n    /** 用户角色字段名 - 不同API中用户角色的字段名（如user、human、customer） */\r\n    private String requestUserRoleField;\r\n    \r\n    /** 助手角色字段名 - 不同API中助手角色的字段名（如assistant、ai、agent） */\r\n    private String requestAssistantField;\r\n    \r\n    /** 系统角色字段名 - 系统消息的角色字段名（如system、instruction） */\r\n    private String requestSystemField;\r\n\r\n    // ==================== 消息路径配置系统 ====================\r\n    \r\n    /** \r\n     * 消息组路径 - 指定消息数组在请求JSON中的位置\r\n     * 例如：'messages' 或 'conversation.messages' 或 'data.chat.messages'\r\n     */\r\n    private String requestMessageGroupPath;\r\n    \r\n    /** \r\n     * 角色路径 - 指定单个消息对象中角色字段的名称\r\n     * 例如：'role' 或 'speaker' 或 'type'\r\n     */\r\n    private String requestRolePathFromGroup;\r\n    \r\n    /** \r\n     * 文本路径 - 指定单个消息对象中内容字段的名称\r\n     * 例如：'content' 或 'text' 或 'message'\r\n     */\r\n    private String requestTextPathFromGroup;\r\n    \r\n    /** \r\n     * 响应文本路径 - 指定如何从响应JSON中提取AI回复内容\r\n     * 例如：'choices.0.message.content' 或 'response.text'\r\n     */\r\n    private String responseTextPath;\r\n    \r\n    /** \r\n     * 思考文本路径 - 指定如何提取AI的思考过程（如果支持）\r\n     * 例如：'choices.0.message.thinking' 或 'response.reasoning'\r\n     */\r\n    private String responseThinkingTextPath;\r\n\r\n    // ==================== 监控和统计字段 ====================\r\n    \r\n    /** 最后使用时间 - 用于统计分析和健康检查 */\r\n    private LocalDateTime lastUsedTime;\r\n\r\n    // ==================== 临时字段 ====================\r\n    \r\n    /** \r\n     * 解密密钥 - 临时字段，不持久化到数据库\r\n     * 用于在运行时解密加密的API密钥\r\n     */\r\n    @TableField(exist = false)\r\n    private String secretKey;\r\n}\r\n```\r\n\r\n### HttpUtils：HTTP请求处理的完整实现\r\n\r\n```java\r\npackage com.chat.allchatonthis.common.util.http;\r\n\r\nimport cn.hutool.core.codec.Base64;\r\nimport cn.hutool.core.map.TableMap;\r\nimport cn.hutool.core.net.url.UrlBuilder;\r\nimport cn.hutool.core.util.ReflectUtil;\r\nimport cn.hutool.core.util.StrUtil;\r\nimport cn.hutool.http.HttpRequest;\r\nimport cn.hutool.http.HttpResponse;\r\nimport com.chat.allchatonthis.common.exception.ServiceException;\r\nimport com.chat.allchatonthis.common.util.json.JsonUtils;\r\nimport com.chat.allchatonthis.entity.dataobject.ConversationMessageDO;\r\nimport com.chat.allchatonthis.entity.dataobject.UserConfigDO;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.util.StringUtils;\r\n\r\nimport javax.crypto.Cipher;\r\nimport javax.crypto.spec.SecretKeySpec;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport static com.chat.allchatonthis.common.enums.ErrorCodeConstants.CONFIG_NOT_EXISTS;\r\n\r\n/**\r\n * HTTP工具类 - 处理API请求的核心逻辑\r\n */\r\n@Slf4j\r\npublic class HttpUtils {\r\n\r\n    /**\r\n     * 准备请求数据（简单版本）- 处理单个消息\r\n     * \r\n     * @param config 用户配置\r\n     * @param messageText 消息文本\r\n     * @return 包含headers和requestBody的Map\r\n     */\r\n    public static Map\u003cString, Object\u003e prepareRequestData(UserConfigDO config, String messageText) {\r\n        // ==================== 步骤1：构建请求头 ====================\r\n        \r\n        // 防御性拷贝：避免修改原始配置，确保线程安全\r\n        Map\u003cString, String\u003e headers = new HashMap\u003c\u003e(\r\n            config.getHeaders() != null ? config.getHeaders() : new HashMap\u003c\u003e()\r\n        );\r\n\r\n        // ==================== 步骤2：处理API密钥解密 ====================\r\n        \r\n        String apiKey = config.getApiKey();\r\n        \r\n        // 检查是否为加密密钥（enc:前缀）并且有解密密钥\r\n        if (apiKey != null \u0026\u0026 apiKey.startsWith(\"enc:\") \u0026\u0026 StringUtils.hasText(config.getSecretKey())) {\r\n            try {\r\n                // 去掉enc:前缀，调用解密方法\r\n                apiKey = decryptApiKey(apiKey.substring(4), config.getSecretKey());\r\n            } catch (Exception e) {\r\n                log.error(\"API密钥解密失败\", e);\r\n                throw new ServiceException(CONFIG_NOT_EXISTS, \"API密钥解密失败: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        // ==================== 步骤3：根据策略放置API密钥 ====================\r\n        \r\n        // 策略1：放在Authorization header中（默认策略）\r\n        if (\"header\".equals(config.getApiKeyPlacement()) || config.getApiKeyPlacement() == null) {\r\n            headers.put(\"Authorization\", \"Bearer \" + apiKey);\r\n        } \r\n        // 策略2：放在自定义header中（如x-api-key）\r\n        else if (\"custom_header\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyHeader() != null) {\r\n            headers.put(config.getApiKeyHeader(), apiKey);\r\n        }\r\n\r\n        // 确保Content-Type存在（默认为application/json）\r\n        if (!headers.containsKey(\"Content-Type\")) {\r\n            headers.put(\"Content-Type\", \"application/json\");\r\n        }\r\n\r\n        // ==================== 步骤4：构建请求体 ====================\r\n        \r\n        // 克隆请求模板，避免修改原始配置\r\n        Map\u003cString, Object\u003e requestBody = new HashMap\u003c\u003e(config.getRequestTemplate());\r\n\r\n        // 策略3：将API密钥放在请求体中\r\n        if (\"body\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyBodyPath() != null) {\r\n            JsonUtils.setValueByPath(requestBody, config.getApiKeyBodyPath(), apiKey);\r\n        }\r\n\r\n        // ==================== 步骤5：处理消息内容 ====================\r\n        \r\n        // 如果有消息文本和消息组路径，创建消息对象\r\n        if (StringUtils.hasText(messageText) \u0026\u0026 StringUtils.hasText(config.getRequestMessageGroupPath())) {\r\n            \r\n            // 获取字段名配置（带默认值）\r\n            String rolePath = StringUtils.hasText(config.getRequestRolePathFromGroup()) ?\r\n                    config.getRequestRolePathFromGroup() : \"role\";\r\n            String textPath = StringUtils.hasText(config.getRequestTextPathFromGroup()) ?\r\n                    config.getRequestTextPathFromGroup() : \"content\";\r\n            String roleValue = StringUtils.hasText(config.getRequestUserRoleField()) ?\r\n                    config.getRequestUserRoleField() : \"user\";\r\n\r\n            // 构建消息对象\r\n            Map\u003cString, Object\u003e messageObj = new HashMap\u003c\u003e();\r\n            messageObj.put(rolePath, roleValue);\r\n            messageObj.put(textPath, messageText);\r\n\r\n            // 创建消息数组并设置到请求体中\r\n            List\u003cMap\u003cString, Object\u003e\u003e messages = new ArrayList\u003c\u003e();\r\n            messages.add(messageObj);\r\n            JsonUtils.setValueByPath(requestBody, config.getRequestMessageGroupPath(), messages);\r\n        }\r\n\r\n        // ==================== 步骤6：返回结果 ====================\r\n        \r\n        Map\u003cString, Object\u003e result = new HashMap\u003c\u003e();\r\n        result.put(\"headers\", headers);\r\n        result.put(\"requestBody\", requestBody);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 准备请求数据（完整版本）- 处理对话历史\r\n     * \r\n     * @param config 用户配置\r\n     * @param messageText 新消息文本\r\n     * @param conversationMessages 对话历史\r\n     * @return 包含headers和requestBody的Map\r\n     */\r\n    public static Map\u003cString, Object\u003e prepareRequestData(UserConfigDO config, String messageText, \r\n                                                        List\u003cConversationMessageDO\u003e conversationMessages) {\r\n        // ==================== 步骤1-4：复用简单版本的逻辑 ====================\r\n        \r\n        // 构建请求头\r\n        Map\u003cString, String\u003e headers = new HashMap\u003c\u003e(\r\n            config.getHeaders() != null ? config.getHeaders() : new HashMap\u003c\u003e()\r\n        );\r\n\r\n        // 处理API密钥解密\r\n        String apiKey = config.getApiKey();\r\n        if (apiKey != null \u0026\u0026 apiKey.startsWith(\"enc:\") \u0026\u0026 StringUtils.hasText(config.getSecretKey())) {\r\n            try {\r\n                apiKey = decryptApiKey(apiKey.substring(4), config.getSecretKey());\r\n            } catch (Exception e) {\r\n                log.error(\"API密钥解密失败\", e);\r\n                throw new ServiceException(CONFIG_NOT_EXISTS, \"API密钥解密失败: \" + e.getMessage());\r\n            }\r\n        }\r\n\r\n        // 根据策略放置API密钥\r\n        if (\"header\".equals(config.getApiKeyPlacement()) || config.getApiKeyPlacement() == null) {\r\n            headers.put(\"Authorization\", \"Bearer \" + apiKey);\r\n        } else if (\"custom_header\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyHeader() != null) {\r\n            headers.put(config.getApiKeyHeader(), apiKey);\r\n        }\r\n\r\n        if (!headers.containsKey(\"Content-Type\")) {\r\n            headers.put(\"Content-Type\", \"application/json\");\r\n        }\r\n\r\n        // 构建请求体\r\n        Map\u003cString, Object\u003e requestBody = new HashMap\u003c\u003e(config.getRequestTemplate());\r\n\r\n        if (\"body\".equals(config.getApiKeyPlacement()) \u0026\u0026 config.getApiKeyBodyPath() != null) {\r\n            JsonUtils.setValueByPath(requestBody, config.getApiKeyBodyPath(), apiKey);\r\n        }\r\n\r\n        // ==================== 步骤5：处理对话历史（核心逻辑） ====================\r\n        \r\n        // 获取字段名配置\r\n        String rolePath = StringUtils.hasText(config.getRequestRolePathFromGroup()) ?\r\n                config.getRequestRolePathFromGroup() : \"role\";\r\n        String textPath = StringUtils.hasText(config.getRequestTextPathFromGroup()) ?\r\n                config.getRequestTextPathFromGroup() : \"content\";\r\n        String userRoleValue = StringUtils.hasText(config.getRequestUserRoleField()) ?\r\n                config.getRequestUserRoleField() : \"user\";\r\n        String assistantRoleValue = StringUtils.hasText(config.getRequestAssistantField()) ?\r\n                config.getRequestAssistantField() : \"assistant\";\r\n\r\n        // 构建完整的消息组\r\n        if (StringUtils.hasText(config.getRequestMessageGroupPath()) \u0026\u0026 \r\n            (conversationMessages != null || messageText != null)) {\r\n            \r\n            List\u003cMap\u003cString, Object\u003e\u003e messages = new ArrayList\u003c\u003e();\r\n\r\n            // 添加历史消息\r\n            if (conversationMessages != null) {\r\n                for (ConversationMessageDO message : conversationMessages) {\r\n                    // 跳过系统消息（系统消息通常不参与对话流）\r\n                    if (\"system\".equals(message.getRole())) {\r\n                        continue;\r\n                    }\r\n\r\n                    Map\u003cString, Object\u003e messageObj = new HashMap\u003c\u003e();\r\n                    \r\n                    // 角色映射：将数据库中的角色映射为API所需的角色\r\n                    if (\"user\".equals(message.getRole())) {\r\n                        messageObj.put(rolePath, userRoleValue);\r\n                    } else if (\"assistant\".equals(message.getRole())) {\r\n                        messageObj.put(rolePath, assistantRoleValue);\r\n                    } else {\r\n                        // 其他角色保持原样\r\n                        messageObj.put(rolePath, message.getRole());\r\n                    }\r\n                    \r\n                    // 设置消息内容\r\n                    messageObj.put(textPath, message.getContent());\r\n                    messages.add(messageObj);\r\n                }\r\n            }\r\n\r\n            // 添加新的用户消息\r\n            if (messageText != null) {\r\n                Map\u003cString, Object\u003e userMessage = new HashMap\u003c\u003e();\r\n                userMessage.put(rolePath, userRoleValue);\r\n                userMessage.put(textPath, messageText);\r\n                messages.add(userMessage);\r\n            }\r\n\r\n            // 将消息组设置到请求体中\r\n            JsonUtils.setValueByPath(requestBody, config.getRequestMessageGroupPath(), messages);\r\n        }\r\n        // 向后兼容：如果没有消息组路径，直接设置文本\r\n        else if (messageText != null \u0026\u0026 StringUtils.hasText(config.getRequestTextPathFromGroup())) {\r\n            JsonUtils.setValueByPath(requestBody, config.getRequestTextPathFromGroup(), messageText);\r\n        }\r\n\r\n        // ==================== 步骤6：返回结果 ====================\r\n        \r\n        Map\u003cString, Object\u003e result = new HashMap\u003c\u003e();\r\n        result.put(\"headers\", headers);\r\n        result.put(\"requestBody\", requestBody);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * 解密API密钥 - 兼容CryptoJS的AES解密\r\n     * \r\n     * @param encryptedApiKey 加密的API密钥（Base64格式）\r\n     * @param secretKey 解密密钥\r\n     * @return 解密后的API密钥\r\n     */\r\n    public static String decryptApiKey(String encryptedApiKey, String secretKey) {\r\n        try {\r\n            // ==================== 步骤1：Base64解码 ====================\r\n            \r\n            // CryptoJS使用Base64编码传输加密数据\r\n            byte[] cipherData = java.util.Base64.getDecoder().decode(encryptedApiKey);\r\n\r\n            // ==================== 步骤2：解析OpenSSL格式 ====================\r\n            \r\n            // CryptoJS默认使用OpenSSL格式: \"Salted__\" + 8字节盐 + 密文\r\n            // 总共16字节的前缀（8字节\"Salted__\" + 8字节盐值）\r\n            byte[] saltBytes = new byte[8];\r\n            byte[] cipherBytes = new byte[cipherData.length - 16];\r\n\r\n            // 提取盐值（跳过前8字节的\"Salted__\"）\r\n            System.arraycopy(cipherData, 8, saltBytes, 0, 8);\r\n            // 提取实际密文（跳过前16字节）\r\n            System.arraycopy(cipherData, 16, cipherBytes, 0, cipherData.length - 16);\r\n\r\n            // ==================== 步骤3：派生密钥和IV ====================\r\n            \r\n            // 使用EVP_BytesToKey算法生成密钥和初始化向量\r\n            byte[][] keyAndIV = EVP_BytesToKey(32, 16, secretKey.getBytes(StandardCharsets.UTF_8), saltBytes, 1);\r\n            byte[] key = keyAndIV[0];  // 32字节密钥（AES-256）\r\n            byte[] iv = keyAndIV[1];   // 16字节IV\r\n\r\n            // ==================== 步骤4：AES解密 ====================\r\n            \r\n            // 创建AES密钥规范\r\n            SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\r\n            // 创建IV参数规范\r\n            javax.crypto.spec.IvParameterSpec ivSpec = new javax.crypto.spec.IvParameterSpec(iv);\r\n\r\n            // 初始化解密器：AES/CBC/PKCS5Padding（与CryptoJS默认设置一致）\r\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\r\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\r\n\r\n            // 执行解密\r\n            byte[] decryptedBytes = cipher.doFinal(cipherBytes);\r\n            \r\n            // 转换为字符串并返回\r\n            return new String(decryptedBytes, StandardCharsets.UTF_8);\r\n            \r\n        } catch (Exception e) {\r\n            log.error(\"API密钥解密失败\", e);\r\n            throw new ServiceException(CONFIG_NOT_EXISTS, \"API密钥解密失败: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * EVP_BytesToKey算法实现 - 密钥派生函数\r\n     * \r\n     * 这是OpenSSL标准的密钥派生算法，用于从密码和盐值生成密钥和IV\r\n     * \r\n     * @param keyLen 密钥长度（字节）\r\n     * @param ivLen IV长度（字节）\r\n     * @param password 密码\r\n     * @param salt 盐值\r\n     * @param iterations 迭代次数\r\n     * @return [密钥, IV]\r\n     */\r\n    private static byte[][] EVP_BytesToKey(int keyLen, int ivLen, byte[] password, byte[] salt, int iterations) {\r\n        // ==================== 步骤1：初始化 ====================\r\n        \r\n        byte[] key = new byte[keyLen];\r\n        byte[] iv = new byte[ivLen];\r\n        byte[] concatenatedHashBytes = new byte[0];\r\n\r\n        // 初始化MD5消息摘要\r\n        MessageDigest md5;\r\n        try {\r\n            md5 = MessageDigest.getInstance(\"MD5\");\r\n        } catch (NoSuchAlgorithmException e) {\r\n            throw new RuntimeException(\"MD5算法不可用\", e);\r\n        }\r\n\r\n        // ==================== 步骤2：计算需要的哈希轮数 ====================\r\n        \r\n        int hashLen = 16; // MD5输出长度\r\n        int keyAndIvLen = keyLen + ivLen;\r\n        int numHashes = (keyAndIvLen + hashLen - 1) / hashLen; // 向上取整\r\n\r\n        // ==================== 步骤3：生成哈希链 ====================\r\n        \r\n        byte[] result = new byte[numHashes * hashLen];\r\n        int resultLen = 0;\r\n\r\n        for (int i = 1; i \u003c= numHashes; i++) {\r\n            // 第一轮：只使用密码和盐\r\n            // 后续轮：使用前一轮的结果 + 密码 + 盐\r\n            md5.reset();\r\n            if (i \u003e 1) {\r\n                md5.update(concatenatedHashBytes);\r\n            }\r\n            md5.update(password);\r\n            if (salt != null) {\r\n                md5.update(salt);\r\n            }\r\n            concatenatedHashBytes = md5.digest();\r\n\r\n            // 执行额外的迭代（通常为1，即不额外迭代）\r\n            for (int j = 1; j \u003c iterations; j++) {\r\n                md5.reset();\r\n                md5.update(concatenatedHashBytes);\r\n                concatenatedHashBytes = md5.digest();\r\n            }\r\n\r\n            // 将哈希结果拷贝到结果数组中\r\n            System.arraycopy(\r\n                concatenatedHashBytes, 0,\r\n                result, resultLen,\r\n                Math.min(concatenatedHashBytes.length, result.length - resultLen)\r\n            );\r\n            resultLen += concatenatedHashBytes.length;\r\n        }\r\n\r\n        // ==================== 步骤4：分离密钥和IV ====================\r\n        \r\n        // 从结果中提取密钥\r\n        System.arraycopy(result, 0, key, 0, keyLen);\r\n        // 从结果中提取IV\r\n        System.arraycopy(result, keyLen, iv, 0, ivLen);\r\n\r\n        return new byte[][]{key, iv};\r\n    }\r\n\r\n    /**\r\n     * HTTP POST请求 - 基于HuTool的封装\r\n     * \r\n     * @param url 请求URL\r\n     * @param headers 请求头\r\n     * @param requestBody 请求体\r\n     * @return 响应字符串\r\n     */\r\n    public static String post(String url, Map\u003cString, String\u003e headers, String requestBody) {\r\n        try (HttpResponse response = HttpRequest.post(url)\r\n                .addHeaders(headers)\r\n                .body(requestBody)\r\n                .execute()) {\r\n            return response.body();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * HTTP GET请求 - 基于HuTool的封装\r\n     * \r\n     * @param url 请求URL  \r\n     * @param headers 请求头\r\n     * @return 响应字符串\r\n     */\r\n    public static String get(String url, Map\u003cString, String\u003e headers) {\r\n        try (HttpResponse response = HttpRequest.get(url)\r\n                .addHeaders(headers)\r\n                .execute()) {\r\n            return response.body();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### ConversationMessageServiceImpl：消息服务的完整实现\r\n\r\n```java\r\npackage com.chat.allchatonthis.service.core.impl;\r\n\r\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\r\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\r\nimport com.chat.allchatonthis.common.exception.ServiceException;\r\nimport com.chat.allchatonthis.common.util.http.HttpUtils;\r\nimport com.chat.allchatonthis.common.util.json.JsonUtils;\r\nimport com.chat.allchatonthis.entity.dataobject.ConversationDO;\r\nimport com.chat.allchatonthis.entity.dataobject.ConversationMessageDO;\r\nimport com.chat.allchatonthis.entity.dataobject.UserConfigDO;\r\nimport com.chat.allchatonthis.mapper.ConversationMessageMapper;\r\nimport com.chat.allchatonthis.service.core.ConversationMessageService;\r\nimport com.chat.allchatonthis.service.core.ConversationService;\r\nimport com.chat.allchatonthis.service.core.UserConfigService;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.cache.annotation.CacheConfig;\r\nimport org.springframework.cache.annotation.CacheEvict;\r\nimport org.springframework.cache.annotation.Cacheable;\r\nimport org.springframework.cache.annotation.Caching;\r\nimport org.springframework.data.redis.core.RedisTemplate;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.util.StringUtils;\r\n\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport static com.chat.allchatonthis.common.enums.ErrorCodeConstants.*;\r\n\r\n/**\r\n * 对话消息服务实现类 - 消息处理的核心业务逻辑\r\n */\r\n@Service\r\n@AllArgsConstructor\r\n@Slf4j\r\n@CacheConfig(cacheNames = \"conversation_message\")\r\npublic class ConversationMessageServiceImpl extends ServiceImpl\u003cConversationMessageMapper, ConversationMessageDO\u003e \r\n        implements ConversationMessageService {\r\n\r\n    private final ConversationService conversationService;\r\n    private final UserConfigService userConfigService;\r\n    private final RedisTemplate\u003cString, Object\u003e redisTemplate;\r\n\r\n    /**\r\n     * 发送消息 - 系统的核心业务方法\r\n     * \r\n     * @param userMessage 用户消息内容\r\n     * @param configId 配置ID\r\n     * @param conversationId 对话ID\r\n     * @param userId 用户ID\r\n     * @param secretKey 解密密钥\r\n     * @return 助手回复消息\r\n     */\r\n    @Override\r\n    @Transactional  // 确保事务一致性\r\n    @Caching(evict = {\r\n            @CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n    })\r\n    public ConversationMessageDO sendMessage(String userMessage, Long configId, Long conversationId, \r\n                                           Long userId, String secretKey) {\r\n        // ==================== 步骤1：权限验证 ====================\r\n        \r\n        // 验证对话归属权：确保用户只能操作自己的对话\r\n        ConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\n        if (conversation == null) {\r\n            throw new ServiceException(CONVERSATION_NOT_EXISTS.getCode(), CONVERSATION_NOT_EXISTS.getMsg());\r\n        }\r\n\r\n        // 验证配置归属权：确保用户只能使用自己的配置\r\n        UserConfigDO config = userConfigService.getConfig(configId, userId);\r\n        if (config == null) {\r\n            throw new ServiceException(CONFIGURATION_NOT_EXISTS.getCode(), CONFIGURATION_NOT_EXISTS.getMsg());\r\n        }\r\n\r\n        // 设置临时解密密钥\r\n        if (StringUtils.hasText(secretKey)) {\r\n            config.setSecretKey(secretKey);\r\n        }\r\n\r\n        try {\r\n            // ==================== 步骤2：准备消息对象 ====================\r\n            \r\n            // 创建用户消息对象（注意：这里只是创建，不保存到数据库）\r\n            // 这是一种事务性设计：先确保API调用成功，再保存数据\r\n            ConversationMessageDO userMessageDO = new ConversationMessageDO()\r\n                    .setConversationId(conversationId)\r\n                    .setConfigId(configId)\r\n                    .setRole(\"user\")\r\n                    .setContent(userMessage);\r\n\r\n            // ==================== 步骤3：获取对话历史 ====================\r\n            \r\n            // 获取当前对话的所有历史消息，用于构建上下文\r\n            List\u003cConversationMessageDO\u003e previousMessages = list(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n                    .eq(ConversationMessageDO::getConversationId, conversationId)\r\n                    .orderByAsc(ConversationMessageDO::getCreateTime));\r\n\r\n            // ==================== 步骤4：调用AI API ====================\r\n            \r\n            // 调用AI API获取回复（这是关键步骤，可能失败）\r\n            ConversationMessageDO assistantMessageDO = generateAssistantResponse(\r\n                userMessage, config, conversationId, configId, previousMessages\r\n            );\r\n\r\n            // ==================== 步骤5：保存消息 ====================\r\n            \r\n            // 只有API调用成功才会执行到这里\r\n            // 批量保存用户消息和助手回复，确保数据一致性\r\n            save(userMessageDO);\r\n            save(assistantMessageDO);\r\n\r\n            // ==================== 步骤6：更新对话状态 ====================\r\n            \r\n            // 更新对话的最后更新时间\r\n            conversation.setUpdateTime(assistantMessageDO.getUpdateTime());\r\n            conversationService.updateById(conversation);\r\n\r\n            // 标记配置为可用（健康检查）\r\n            markConfigurationAsAvailable(configId, userId);\r\n\r\n            return assistantMessageDO;\r\n            \r\n        } catch (Exception e) {\r\n            log.error(\"消息发送失败\", e);\r\n\r\n            // 统一异常处理：不创建错误消息，直接抛出异常\r\n            if (e instanceof ServiceException) {\r\n                throw e;\r\n            }\r\n            throw new ServiceException(MESSAGE_SEND_FAILED.getCode(), e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 生成助手回复 - AI API调用的核心逻辑\r\n     * \r\n     * @param userMessage 用户消息\r\n     * @param config 配置信息\r\n     * @param conversationId 对话ID\r\n     * @param configId 配置ID\r\n     * @param conversationMessages 对话历史\r\n     * @return 助手回复消息\r\n     */\r\n    private ConversationMessageDO generateAssistantResponse(\r\n            String userMessage,\r\n            UserConfigDO config,\r\n            Long conversationId,\r\n            Long configId,\r\n            List\u003cConversationMessageDO\u003e conversationMessages) {\r\n\r\n        // ==================== 步骤1：准备请求数据 ====================\r\n        \r\n        // 使用HttpUtils准备完整的请求数据（包含对话历史）\r\n        Map\u003cString, Object\u003e requestData = HttpUtils.prepareRequestData(config, userMessage, conversationMessages);\r\n        \r\n        // 提取请求头和请求体\r\n        Map\u003cString, String\u003e headers = (Map\u003cString, String\u003e) requestData.get(\"headers\");\r\n        Map\u003cString, Object\u003e requestBody = (Map\u003cString, Object\u003e) requestData.get(\"requestBody\");\r\n\r\n        // ==================== 步骤2：发送HTTP请求 ====================\r\n        \r\n        // 序列化请求体为JSON字符串\r\n        String requestBodyStr = JsonUtils.toJsonString(requestBody);\r\n        \r\n        // 发送POST请求到AI API\r\n        String responseStr = HttpUtils.post(config.getApiUrl(), headers, requestBodyStr);\r\n\r\n        // 检查响应是否为空\r\n        if (responseStr == null) {\r\n            throw new ServiceException(API_CALL_FAILED.getCode(), \"API返回空响应\");\r\n        }\r\n\r\n        // ==================== 步骤3：解析响应 ====================\r\n        \r\n        // 解析响应JSON\r\n        Map\u003cString, Object\u003e responseMap = JsonUtils.parseObject(responseStr, Map.class);\r\n\r\n        // 提取AI回复内容\r\n        String content = null;\r\n        String thinking = null;\r\n\r\n        // 根据配置的路径提取回复内容\r\n        if (StringUtils.hasText(config.getResponseTextPath())) {\r\n            content = JsonUtils.extractValueFromPath(responseMap, config.getResponseTextPath());\r\n        }\r\n\r\n        // 根据配置的路径提取思考过程（如果支持）\r\n        if (StringUtils.hasText(config.getResponseThinkingTextPath())) {\r\n            thinking = JsonUtils.extractValueFromPath(responseMap, config.getResponseThinkingTextPath());\r\n        }\r\n\r\n        // 验证是否成功提取到内容\r\n        if (content == null) {\r\n            throw new ServiceException(API_CALL_FAILED.getCode(), \"无法从响应中提取内容\");\r\n        }\r\n\r\n        // ==================== 步骤4：构建回复消息 ====================\r\n        \r\n        // 创建助手回复消息对象\r\n        return new ConversationMessageDO()\r\n                .setConversationId(conversationId)\r\n                .setConfigId(configId)\r\n                .setRole(\"assistant\")\r\n                .setContent(content)\r\n                .setThinkingText(thinking);  // 思考过程（可选）\r\n    }\r\n\r\n    /**\r\n     * 标记配置为可用 - 健康检查和监控\r\n     * \r\n     * @param configId 配置ID\r\n     * @param userId 用户ID\r\n     * @return 是否成功\r\n     */\r\n    @Override\r\n    public boolean markConfigurationAsAvailable(Long configId, Long userId) {\r\n        // 获取配置信息\r\n        UserConfigDO config = userConfigService.getConfig(configId, userId);\r\n        if (config == null) {\r\n            return false;\r\n        }\r\n\r\n        // 更新配置状态：设置为可用，并记录最后使用时间\r\n        userConfigService.setAvailableAndUpdateLastUsedTime(configId, true);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 获取对话消息列表 - 带缓存\r\n     * \r\n     * @param conversationId 对话ID\r\n     * @param userId 用户ID\r\n     * @return 消息列表\r\n     */\r\n    @Override\r\n    @Cacheable(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n    public List\u003cConversationMessageDO\u003e getMessages(Long conversationId, Long userId) {\r\n        // 验证对话归属权\r\n        ConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\n        if (conversation == null) {\r\n            throw new ServiceException(CONVERSATION_NOT_EXISTS.getCode(), CONVERSATION_NOT_EXISTS.getMsg());\r\n        }\r\n\r\n        // 查询消息，按时间升序排列\r\n        return list(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n                .eq(ConversationMessageDO::getConversationId, conversationId)\r\n                .orderByAsc(ConversationMessageDO::getCreateTime)\r\n                .orderByAsc(ConversationMessageDO::getId)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 获取单个消息 - 带缓存\r\n     * \r\n     * @param id 消息ID\r\n     * @param userId 用户ID\r\n     * @return 消息对象\r\n     */\r\n    @Override\r\n    @Cacheable(key = \"'id:' + #id + ':user:' + #userId\")\r\n    public ConversationMessageDO getMessage(Long id, Long userId) {\r\n        ConversationMessageDO message = getById(id);\r\n        if (message == null) {\r\n            return null;\r\n        }\r\n\r\n        // 验证对话归属权\r\n        ConversationDO conversation = conversationService.getConversation(message.getConversationId(), userId);\r\n        if (conversation == null) {\r\n            return null;\r\n        }\r\n\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * 删除消息 - 清理缓存\r\n     * \r\n     * @param id 消息ID\r\n     * @param userId 用户ID\r\n     * @return 是否成功\r\n     */\r\n    @Override\r\n    @Transactional\r\n    @CacheEvict(key = \"'id:' + #id + ':user:' + #userId\")\r\n    public boolean deleteMessage(Long id, Long userId) {\r\n        ConversationMessageDO message = getMessage(id, userId);\r\n        if (message == null) {\r\n            return false;\r\n        }\r\n\r\n        // 手动清理相关缓存\r\n        Long conversationId = message.getConversationId();\r\n        String cacheKey = \"acot_conversation_message::conversation:\" + conversationId + \":user:\" + userId;\r\n        redisTemplate.delete(cacheKey);\r\n\r\n        return removeById(id);\r\n    }\r\n\r\n    /**\r\n     * 删除对话的所有消息 - 批量删除\r\n     * \r\n     * @param conversationId 对话ID\r\n     * @param userId 用户ID\r\n     * @return 是否成功\r\n     */\r\n    @Override\r\n    @Transactional\r\n    @CacheEvict(key = \"'conversation:' + #conversationId + ':user:' + #userId\")\r\n    public boolean deleteMessagesByConversationId(Long conversationId, Long userId) {\r\n        // 验证对话归属权\r\n        ConversationDO conversation = conversationService.getConversation(conversationId, userId);\r\n        if (conversation == null) {\r\n            return false;\r\n        }\r\n\r\n        // 批量删除消息\r\n        return remove(new LambdaQueryWrapper\u003cConversationMessageDO\u003e()\r\n                .eq(ConversationMessageDO::getConversationId, conversationId));\r\n    }\r\n}\r\n```\r\n\r\n## 写在最后\r\n\r\n消息的构建、提取和发送是ACOT项目中最复杂的环节，同时也是它的核心功能，借由该平台，用户理论上可以对接任何一个可供调用的大模型API（甚至都可以不是大模型的API）。通过将用户自定义的配置文件保存在平台，该平台可以成为用户的大模型自定义对接器。\r\n\r\n好，接下来又到了我最爱的许愿环节！💫\r\n\r\n*愿各API结构如细溪汇聚，宽广的河流包容源于五湖四海的样貌。容纳万物的算法能够让一切潜藏之物被人发掘。* ✨\r\n\r\n```java\r\n// 许愿（代码版）\r\nwhile (bugs.exist()) {\r\n    debug();\r\n    if (fixed) {\r\n        celebrate(); 🎉\r\n    }\r\n}\r\n```\r\n"])</script><script>self.__next_f.push([1,"2b:T68ed,"])</script><script>self.__next_f.push([1,"\r\n# All-Chat-on-This 端点监控与暴露功能实现原理：从AOP切面到Prometheus的完整监控生态\r\n\r\n“让我看看用户都在做什么” （让我访问！）\r\n\r\nACOT的监控系统设计比较简单，目前仅监控了接口调用次数和在线人数，不过我们可以从这简单的应用中窥见从数据收集到可视化展示的完整监控生态系统流程。\r\n\r\n## 监控架构篇：四层分离设计\r\n\r\n### 分层架构概述：数据流的生命周期\r\n\r\nACOT的监控系统采用了典型的**四层分离架构**，每一层都有其独特的职责和技术选型：\r\n\r\n```mermaid\r\ngraph TB\r\n    A[数据收集层] --\u003e B[指标存储层]\r\n    B --\u003e C[数据暴露层]\r\n    C --\u003e D[监控可视化层]\r\n    \r\n    A1[AOP切面拦截] --\u003e A\r\n    A2[Spring Security事件] --\u003e A\r\n    A3[HTTP Session监听] --\u003e A\r\n    \r\n    B1[Micrometer核心] --\u003e B\r\n    B2[Counter计数器] --\u003e B\r\n    B3[Gauge仪表盘] --\u003e B\r\n    \r\n    C1[Spring Boot Actuator] --\u003e C\r\n    C2[Actuator Prometheus] --\u003e C\r\n    C3[Actuator Metrics] --\u003e C\r\n    \r\n    D1[Prometheus时序数据库] --\u003e D\r\n    D2[Grafana可视化] --\u003e D\r\n    D3[告警系统] --\u003e D\r\n```\r\n\r\n**为什么要分层**？\r\n\r\n这种分层设计遵循了**关注点分离**的原则：\r\n\r\n$$监控系统 = 数据收集 \\oplus 指标存储 \\oplus 数据暴露 \\oplus 可视化展示$$\r\n\r\n每一层的技术选型都可以独立演进，比如：\r\n- 数据收集层：可以从AOP切换到Filter或者Interceptor\r\n- 指标存储层：可以从Micrometer切换到其他指标库\r\n- 数据暴露层：可以支持多种格式（Prometheus、JSON、XML等）\r\n- 可视化层：可以从Grafana切换到其他监控平台\r\n\r\n## 端点监控的核心原理篇：AOP\r\n\r\n### AOP切面编程：神秘下料男\r\n\r\n**什么是AOP？**\r\n\r\nAOP（Aspect-Oriented Programming）面向切面编程，简单来说就是在不修改原有代码的情况下，给方法\"加料\"。\r\n\r\n```java\r\n// 原来的业务方法\r\npublic String getUserInfo(Long userId) {\r\n    return userService.getUser(userId);\r\n}\r\n\r\n// AOP魔法后的实际执行流程\r\npublic String getUserInfo(Long userId) {\r\n    // ↓ AOP前置通知：记录调用统计\r\n    endpointMetrics.incrementEndpointCount(\"UserController\", \"getUserInfo\");\r\n    \r\n    // ↓ 原始业务逻辑\r\n    String result = userService.getUser(userId);\r\n    \r\n    // ↓ AOP后置通知：记录响应时间、异常处理等\r\n    return result;\r\n}\r\n```\r\n\r\n### EndpointMetricsAspect：切面拦截\r\n\r\n```java\r\n@Aspect\r\n@Component\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class EndpointMetricsAspect {\r\n\r\n    private final EndpointMetrics endpointMetrics;\r\n\r\n    /**\r\n     * 切点定义：只拦截@RestController标注的类\r\n     * \r\n     * @within vs @target 的区别：\r\n     * - @within：类级别匹配，编译时确定\r\n     * - @target：对象级别匹配，运行时确定\r\n     * \r\n     * 选择@within的原因：性能更好，编译时就能确定切入点\r\n     */\r\n    @Pointcut(\"@within(org.springframework.web.bind.annotation.RestController)\")\r\n    public void controllerPointcut() {\r\n        // 切点定义方法，无需实现体\r\n    }\r\n\r\n    /**\r\n     * 前置通知：在方法执行前统计调用次数\r\n     * \r\n     * 为什么选择@Before而不是@Around？\r\n     * - @Before：轻量级，只需要记录调用即可\r\n     * - @Around：重量级，需要控制方法执行流程\r\n     */\r\n    @Before(\"controllerPointcut()\")\r\n    public void beforeControllerMethod(JoinPoint joinPoint) {\r\n        try {\r\n            // 步骤1：获取方法签名信息\r\n            MethodSignature signature = (MethodSignature) joinPoint.getSignature();\r\n            Method method = signature.getMethod();\r\n            Class\u003c?\u003e controllerClass = method.getDeclaringClass();\r\n            \r\n            // 步骤2：提取类名和方法名\r\n            String controllerName = controllerClass.getSimpleName();  // UserController\r\n            String methodName = method.getName();                     // getUserInfo\r\n\r\n            // 步骤3：验证是否为HTTP端点（避免拦截内部方法）\r\n            if (isHttpEndpoint(method)) {\r\n                // 步骤4：记录端点调用统计\r\n                endpointMetrics.incrementEndpointCount(controllerName, methodName);\r\n                log.debug(\"端点调用: {}.{}\", controllerName, methodName);\r\n            }\r\n        } catch (Exception e) {\r\n            // 关键设计：异常隔离，监控失败不影响业务\r\n            log.error(\"端点指标记录失败\", e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * HTTP端点识别算法：支持所有Spring Web注解\r\n     * \r\n     * 为什么需要这个检查？\r\n     * - @RestController类中可能有非HTTP方法（如private helper方法）\r\n     * - 只有真正的HTTP端点才需要统计\r\n     */\r\n    private boolean isHttpEndpoint(Method method) {\r\n        return method.isAnnotationPresent(RequestMapping.class) ||      // 通用映射\r\n                method.isAnnotationPresent(GetMapping.class) ||         // GET请求\r\n                method.isAnnotationPresent(PostMapping.class) ||        // POST请求\r\n                method.isAnnotationPresent(PutMapping.class) ||         // PUT请求\r\n                method.isAnnotationPresent(DeleteMapping.class) ||      // DELETE请求\r\n                method.isAnnotationPresent(PatchMapping.class);         // PATCH请求\r\n    }\r\n}\r\n```\r\n\r\n**JoinPoint的信息提取链**：\r\n\r\n```java\r\n// JoinPoint信息提取的完整链路\r\nJoinPoint joinPoint = // AOP框架注入\r\n    ↓\r\nMethodSignature signature = (MethodSignature) joinPoint.getSignature();\r\n    ↓\r\nMethod method = signature.getMethod();  // 获取Method对象\r\n    ↓\r\nClass\u003c?\u003e clazz = method.getDeclaringClass();  // 获取声明类\r\n    ↓\r\nString className = clazz.getSimpleName();     // UserController\r\nString methodName = method.getName();         // getUserInfo\r\n```\r\n\r\n### 线程安全的计数器设计：EndpointMetrics并发\r\n\r\n在高并发环境下，如何确保计数器的准确性？请看VCR——（不是）\r\n\r\n```java\r\n@Component\r\npublic class EndpointMetrics {\r\n    \r\n    // 核心组件：Micrometer的度量注册表\r\n    private final MeterRegistry meterRegistry;\r\n    \r\n    // 线程安全的计数器缓存：避免重复创建Counter\r\n    private final Map\u003cString, Counter\u003e endpointCounters = new ConcurrentHashMap\u003c\u003e();\r\n    \r\n    // 原子操作的在线用户计数器\r\n    private final AtomicInteger onlineUsers = new AtomicInteger(0);\r\n\r\n    /**\r\n     * 构造函数：注册在线用户数的Gauge指标\r\n     * \r\n     * Gauge vs Counter 的区别：\r\n     * - Gauge：瞬时值指标，如当前在线用户数、内存使用量\r\n     * - Counter：累加指标，如API调用次数、错误数量\r\n     */\r\n    public EndpointMetrics(MeterRegistry meterRegistry) {\r\n        this.meterRegistry = meterRegistry;\r\n        \r\n        // 注册Gauge：实时反映在线用户数\r\n        Gauge.builder(\"acot.online.users\", onlineUsers::get)  // 引用原子类的get方法\r\n                .description(\"当前在线用户数\")\r\n                .register(meterRegistry);\r\n    }\r\n\r\n    /**\r\n     * 递增端点调用计数：核心的线程安全算法\r\n     * \r\n     * @param controllerName 控制器名称\r\n     * @param methodName 方法名称\r\n     */\r\n    public void incrementEndpointCount(String controllerName, String methodName) {\r\n        // 构造端点标识符\r\n        String endpoint = controllerName + \".\" + methodName;\r\n        \r\n        // 关键算法：computeIfAbsent的原子性保证\r\n        Counter counter = endpointCounters.computeIfAbsent(endpoint, k -\u003e\r\n                Counter.builder(\"acot.endpoint.calls\")\r\n                        // 多维度标签：支持Prometheus的复杂查询\r\n                        .tags(Arrays.asList(\r\n                                Tag.of(\"controller\", controllerName),  // 按控制器分组\r\n                                Tag.of(\"method\", methodName)))         // 按方法分组\r\n                        .description(\"端点调用次数统计\")\r\n                        .register(meterRegistry));  // 注册到Micrometer\r\n        \r\n        // 原子递增操作\r\n        counter.increment();\r\n    }\r\n\r\n    /**\r\n     * 用户登录：原子递增在线用户数\r\n     */\r\n    public void userLoggedIn() {\r\n        onlineUsers.incrementAndGet();  // 原子操作：current + 1\r\n    }\r\n\r\n    /**\r\n     * 用户登出：带边界检查的原子递减\r\n     */\r\n    public void userLoggedOut() {\r\n        // 防止负数的原子操作：max(0, current - 1)\r\n        onlineUsers.updateAndGet(current -\u003e Math.max(0, current - 1));\r\n    }\r\n}\r\n```\r\n\r\n**为什么选择ConcurrentHashMap + computeIfAbsent？**\r\n\r\n这种组合的优势在于：\r\n\r\n错误的做法：\r\n```java\r\n// ❌ 存在竞态条件的错误实现\r\nif (!endpointCounters.containsKey(endpoint)) {\r\n    // 问题：两个线程可能同时执行到这里\r\n    endpointCounters.put(endpoint, createNewCounter(endpoint));\r\n}\r\nCounter counter = endpointCounters.get(endpoint);\r\n```\r\n\r\n正确的做法：\r\n```java\r\n// ✅ 原子性操作，线程安全\r\nCounter counter = endpointCounters.computeIfAbsent(endpoint, k -\u003e createNewCounter(k));\r\n```\r\n\r\n**computeIfAbsent的时间复杂度分析**：\r\n\r\n在理想情况下：\r\n- 首次访问：$O(1)$ 创建 + $O(1)$ 插入 = $O(1)$\r\n- 后续访问：$O(1)$ 查找\r\n\r\n### 在线用户统计的双重保障机制\r\n\r\nACOT实现了一套\"双保险\"的用户统计系统：\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant User as 用户\r\n    participant Security as Spring Security\r\n    participant Session as HTTP Session\r\n    participant Listener1 as UserActivityMetricsConfig\r\n    participant Listener2 as SessionEventListener\r\n    participant Metrics as EndpointMetrics\r\n\r\n    User-\u003e\u003eSecurity: 登录\r\n    Security-\u003e\u003eListener1: AuthenticationSuccessEvent\r\n    Listener1-\u003e\u003eMetrics: userLoggedIn() [+1]\r\n    \r\n    User-\u003e\u003eSecurity: 正常登出\r\n    Security-\u003e\u003eListener1: LogoutSuccessEvent\r\n    Listener1-\u003e\u003eMetrics: userLoggedOut() [-1]\r\n    \r\n    Note over Session: 会话超时或异常断开\r\n    Session-\u003e\u003eListener2: sessionDestroyed\r\n    Listener2-\u003e\u003eMetrics: userLoggedOut() [-1]\r\n```\r\n\r\n### UserActivityMetricsConfig：Spring Security事件处理\r\n\r\n```java\r\n@Configuration\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class UserActivityMetricsConfig {\r\n\r\n    private final EndpointMetrics endpointMetrics;\r\n\r\n    /**\r\n     * 登录成功事件监听\r\n     * \r\n     * Spring事件机制的优势：\r\n     * - 松耦合：监听器和事件发布者无直接依赖\r\n     * - 异步支持：可配置为异步处理\r\n     * - 多监听器：同一事件可以有多个监听器\r\n     */\r\n    @EventListener\r\n    public void handleAuthenticationSuccess(AuthenticationSuccessEvent event) {\r\n        Authentication authentication = event.getAuthentication();\r\n        String username = authentication.getName();\r\n        \r\n        log.debug(\"用户登录: {}\", username);\r\n        \r\n        // 递增在线用户数\r\n        endpointMetrics.userLoggedIn();\r\n    }\r\n\r\n    /**\r\n     * 登出成功事件监听\r\n     * \r\n     * 注意：某些登出场景下authentication可能为null\r\n     * 例如：session超时后的主动登出\r\n     */\r\n    @EventListener\r\n    public void handleLogout(LogoutSuccessEvent event) {\r\n        Authentication authentication = event.getAuthentication();\r\n        \r\n        if (authentication != null) {\r\n            String username = authentication.getName();\r\n            log.debug(\"用户登出: {}\", username);\r\n        }\r\n        \r\n        // 递减在线用户数（无论authentication是否为null）\r\n        endpointMetrics.userLoggedOut();\r\n    }\r\n\r\n    /**\r\n     * 自定义认证成功处理器：避免重复统计\r\n     * \r\n     * 为什么需要这个Bean？\r\n     * - 某些情况下可能需要form-based登录\r\n     * - 这个handler只负责日志记录，不重复统计指标\r\n     */\r\n    @Bean\r\n    public AuthenticationSuccessHandler loggingAuthenticationSuccessHandler() {\r\n        return (request, response, authentication) -\u003e {\r\n            String username = authentication.getName();\r\n            log.debug(\"表单登录成功: {}\", username);\r\n            // 注意：这里不调用endpointMetrics.userLoggedIn()\r\n            // 因为@EventListener已经处理了统计\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 自定义登出成功处理器：避免重复统计\r\n     */\r\n    @Bean\r\n    public LogoutSuccessHandler loggingLogoutSuccessHandler() {\r\n        return (request, response, authentication) -\u003e {\r\n            if (authentication != null) {\r\n                String username = authentication.getName();\r\n                log.debug(\"表单登出成功: {}\", username);\r\n            }\r\n            // 注意：这里不调用endpointMetrics.userLoggedOut()\r\n            // 因为@EventListener已经处理了统计\r\n        };\r\n    }\r\n}\r\n```\r\n\r\n### SessionEventListener：会话生命周期的兜底机制\r\n\r\n```java\r\n@Component\r\n@Slf4j\r\n@RequiredArgsConstructor\r\npublic class SessionEventListener implements HttpSessionListener {\r\n\r\n    private final EndpointMetrics endpointMetrics;\r\n\r\n    /**\r\n     * 会话销毁监听：处理\"静默离开\"的用户\r\n     * \r\n     * 会话销毁的触发场景：\r\n     * 1. 会话超时（最常见）\r\n     * 2. 用户主动关闭浏览器\r\n     * 3. 调用session.invalidate()\r\n     * 4. 应用服务器关闭\r\n     */\r\n    @Override\r\n    public void sessionDestroyed(HttpSessionEvent se) {\r\n        String sessionId = se.getSession().getId();\r\n        log.debug(\"会话销毁: {}\", sessionId);\r\n        \r\n        // 兜底机制：确保用户数统计准确\r\n        endpointMetrics.userLoggedOut();\r\n    }\r\n\r\n    // 注意：这里没有实现sessionCreated方法\r\n    // 因为session创建不等于用户登录\r\n    // 匿名用户也会创建session\r\n}\r\n```\r\n\r\n**为什么需要SessionEventListener？**\r\n\r\nSpring Security事件监听有一个盲区：用户\"静默离开\"。\r\n\r\n| 离开方式 | Spring Security事件 | Session事件 | 统计准确性 |\r\n|----------|-------------------|-------------|------------|\r\n| 正常登出 | ✅ LogoutSuccessEvent | ✅ sessionDestroyed | ✅ 双重保障 |\r\n| 关闭浏览器 | ❌ 无事件 | ✅ sessionDestroyed (延迟) | ✅ 兜底机制 |\r\n| 网络断开 | ❌ 无事件 | ✅ sessionDestroyed (延迟) | ✅ 兜底机制 |\r\n| 会话超时 | ❌ 无事件 | ✅ sessionDestroyed | ✅ 兜底机制 |\r\n\r\n## Prometheus篇：时序数据库\r\n\r\n### 为什么选择Prometheus？\r\n\r\nPrometheus不仅仅是一个监控系统，它更像是一个\"时间魔法师\"，能够将瞬息万变的系统状态记录成可查询、可分析的时序数据。\r\n\r\n**Prometheus的核心优势**：\r\n\r\n1. **Pull模式的优雅性**：\r\n   ```mermaid\r\n   graph LR\r\n       A[Prometheus Server] --\u003e|Pull每15秒| B[ACOT应用1:8080/actuator/prometheus]\r\n       A --\u003e|Pull每15秒| C[ACOT应用2:8081/actuator/prometheus]\r\n       A --\u003e|Pull每15秒| D[其他服务:9090/metrics]\r\n   ```\r\n\r\n2. **多维度标签系统**：\r\n   ```promql\r\n   # 查询特定控制器的调用次数\r\n   acot_endpoint_calls_total{controller=\"UserController\"}\r\n   \r\n   # 查询特定方法的调用次数\r\n   acot_endpoint_calls_total{method=\"getUserInfo\"}\r\n   \r\n   # 查询特定控制器+方法的组合\r\n   acot_endpoint_calls_total{controller=\"UserController\", method=\"getUserInfo\"}\r\n   ```\r\n\r\n3. **强大的查询语言PromQL**：\r\n   \r\n   ```promql\r\n   # 查询过去5分钟的平均在线用户数\r\n   avg_over_time(acot_online_users[5m])\r\n   \r\n   # 查询API调用增长率\r\n   rate(acot_endpoint_calls_total[5m])\r\n   \r\n   # 查询最繁忙的端点\r\n   topk(10, rate(acot_endpoint_calls_total[1h]))\r\n   ```\r\n\r\n### 时序数据模型：时间戳设计根本\r\n\r\nPrometheus的数据模型可以用数学公式表示：\r\n\r\n$$Metric = MetricName\\{label_1=value_1, label_2=value_2, ...\\} \\rightarrow (timestamp, value)$$\r\n\r\n例如：\r\n```\r\nacot_endpoint_calls_total{controller=\"UserController\", method=\"getUserInfo\"} 42 @1234567890\r\n```\r\n\r\n**数据类型的选择策略**：\r\n\r\n| 指标类型 | 适用场景 | ACOT中的应用 | 数学特性 |\r\n|----------|----------|--------------|----------|\r\n| Counter | 单调递增 | API调用次数 | $f(t_2) \\geq f(t_1)$ 当 $t_2 \u003e t_1$ |\r\n| Gauge | 瞬时值 | 在线用户数 | $f(t)$ 可任意变化 |\r\n| Histogram | 分布统计 | 响应时间分布 | $\\sum_{i=1}^{n} bucket_i = total$ |\r\n| Summary | 分位数统计 | 响应时间百分位 | $P_{50}, P_{90}, P_{99}$ |\r\n\r\n### Spring Boot与Prometheus的集成\r\n\r\n**Maven依赖配置**：\r\n\r\n```xml\r\n\u003c!-- Spring Boot Actuator：生产级别的应用监控 --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\n    \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n\r\n\u003c!-- Micrometer Prometheus：度量指标的Prometheus导出器 --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\r\n    \u003cartifactId\u003emicrometer-registry-prometheus\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n\r\n\u003c!-- Spring AOP：切面编程支持 --\u003e\r\n\u003cdependency\u003e\r\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\r\n    \u003cartifactId\u003espring-boot-starter-aop\u003c/artifactId\u003e\r\n\u003c/dependency\u003e\r\n```\r\n\r\n**application.yaml配置**：\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        # 安全考虑：只暴露必要的端点\r\n        include: \"health,info,metrics,prometheus,env,threaddump,loggers\"\r\n        base-path: /actuator\r\n      cors:\r\n        # 开发环境配置，生产环境需要限制\r\n        allowed-origins: \"*\"\r\n        allowed-methods: GET,POST,PUT,DELETE,OPTIONS,HEAD\r\n        allowed-headers: \"*\"\r\n  \r\n  endpoint:\r\n    prometheus:\r\n      # 生产环境建议设置为 \"when_authorized\"\r\n      access: unrestricted\r\n    metrics:\r\n      access: unrestricted\r\n  \r\n  metrics:\r\n    distribution:\r\n      percentiles-histogram:\r\n        # 启用HTTP请求响应时间的直方图统计\r\n        http.server.requests: true\r\n    tags:\r\n      # 为所有指标添加应用标识标签\r\n      application: ${spring.application.name}\r\n    \r\n  prometheus:\r\n    metrics:\r\n      export:\r\n        enabled: true\r\n        # 可配置推送间隔，默认为拉取模式不需要\r\n        # step: 15s\r\n  \r\n  health:\r\n    diskspace:\r\n      enabled: true\r\n    db:\r\n      enabled: true\r\n\r\n# 开启调试日志查看指标注册过程\r\nlogging:\r\n  level:\r\n    com.chat.allchatonthis.config.metrics: debug\r\n```\r\n\r\n**Prometheus配置示例**：\r\n\r\n```yaml\r\n# prometheus.yml\r\nglobal:\r\n  scrape_interval: 15s\r\n  evaluation_interval: 15s\r\n\r\nscrape_configs:\r\n  - job_name: 'acot-backend'\r\n    metrics_path: '/actuator/prometheus'\r\n    static_configs:\r\n      - targets: ['localhost:8080']\r\n    scrape_interval: 10s\r\n    scrape_timeout: 5s\r\n```\r\n\r\n## Grafana篇：数据可视化\r\n\r\n### Grafana的核心价值\r\n\r\n如果说Prometheus是\"数据收集家\"，那么Grafana就是\"数据艺术家\"。它能够将冰冷的数字转化为直观的图表，让监控数据\"开口说话\"。\r\n\r\n**ACOT监控仪表板的构建思路**：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"ACOT Grafana仪表板\"\r\n        A[系统概览面板] --\u003e A1[在线用户数实时曲线]\r\n        A --\u003e A2[总API调用次数]\r\n        A --\u003e A3[系统健康状态]\r\n        \r\n        B[API调用统计面板] --\u003e B1[热门API排行榜]\r\n        B --\u003e B2[API调用趋势图]\r\n        B --\u003e B3[错误率统计]\r\n        \r\n        C[用户活动面板] --\u003e C1[用户登录/登出趋势]\r\n        C --\u003e C2[用户活跃时段分析]\r\n        C --\u003e C3[会话持续时间分布]\r\n        \r\n        D[性能指标面板] --\u003e D1[响应时间分布]\r\n        D --\u003e D2[JVM内存使用情况]\r\n        D --\u003e D3[数据库连接池状态]\r\n        \r\n        E[告警状态面板]\r\n    end\r\n```\r\n\r\n**关键PromQL查询语句**：\r\n\r\n```promql\r\n# 1. 当前在线用户数\r\nacot_online_users\r\n\r\n# 2. API调用速率 (每秒)\r\nrate(acot_endpoint_calls_total[5m])\r\n\r\n# 3. 最受欢迎的API端点 (Top 10)\r\ntopk(10, increase(acot_endpoint_calls_total[1h]))\r\n\r\n# 4. 用户登录速率\r\nrate(acot_online_users[5m]) \u003e 0\r\n\r\n# 5. 系统平均响应时间\r\nrate(http_server_requests_seconds_sum[5m]) / rate(http_server_requests_seconds_count[5m])\r\n\r\n# 6. 错误率统计\r\nrate(http_server_requests_seconds_count{status=~\"4..|5..\"}[5m]) / \r\nrate(http_server_requests_seconds_count[5m]) * 100\r\n```\r\n\r\n## 代码深度解析篇：逐行剖析监控的实现细节\r\n\r\n### MetricsController：监控数据的HTTP暴露接口\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/metrics\")\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class MetricsController {\r\n\r\n    private final MeterRegistry meterRegistry;\r\n\r\n    /**\r\n     * 获取当前在线用户数\r\n     * \r\n     * 实现原理：\r\n     * 1. 通过MeterRegistry查找名为\"acot.online.users\"的Gauge\r\n     * 2. 调用gauge().value()获取当前瞬时值\r\n     * 3. 转换为整数返回\r\n     */\r\n    @GetMapping(\"/online-users\")\r\n    public CommonResult\u003cInteger\u003e getOnlineUsers() {\r\n        // MeterRegistry.get()方法的查找链：\r\n        // 1. 按名称查找已注册的Meter\r\n        // 2. 返回第一个匹配的Meter\r\n        // 3. 如果找不到，抛出MeterNotFoundException\r\n        Integer onlineUsers = (int) meterRegistry.get(\"acot.online.users\").gauge().value();\r\n        \r\n        return CommonResult.success(onlineUsers);\r\n    }\r\n\r\n    /**\r\n     * 获取端点调用统计\r\n     * \r\n     * 这个方法展示了Micrometer Search API的强大功能\r\n     */\r\n    @GetMapping(\"/endpoints\")\r\n    public CommonResult\u003cMap\u003cString, Object\u003e\u003e getEndpointStats() {\r\n        Map\u003cString, Object\u003e stats = new HashMap\u003c\u003e();\r\n        \r\n        // Micrometer Search API的流式查询\r\n        Search.in(meterRegistry)\r\n            .name(\"acot.endpoint.calls\")  // 步骤1：按名称过滤\r\n            .counters()                   // 步骤2：只保留Counter类型\r\n            .forEach(counter -\u003e {         // 步骤3：遍历所有匹配的Counter\r\n                // 提取Counter的标签信息\r\n                Iterable\u003cTag\u003e tags = counter.getId().getTags();\r\n                \r\n                String controller = \"\";\r\n                String method = \"\";\r\n                \r\n                // 遍历标签，提取controller和method信息\r\n                for (Tag tag : tags) {\r\n                    if (\"controller\".equals(tag.getKey())) {\r\n                        controller = tag.getValue();\r\n                    } else if (\"method\".equals(tag.getKey())) {\r\n                        method = tag.getValue();\r\n                    }\r\n                }\r\n                \r\n                // 构造端点标识并记录计数值\r\n                String endpoint = controller + \".\" + method;\r\n                stats.put(endpoint, (int) counter.count());\r\n            });\r\n        \r\n        return CommonResult.success(stats);\r\n    }\r\n\r\n    /**\r\n     * 获取监控数据摘要\r\n     * \r\n     * 这个方法展示了如何聚合多个指标\r\n     */\r\n    @GetMapping(\"/summary\")\r\n    public CommonResult\u003cMap\u003cString, Object\u003e\u003e getMetricsSummary() {\r\n        Map\u003cString, Object\u003e summary = new HashMap\u003c\u003e();\r\n        \r\n        // 获取在线用户数\r\n        Integer onlineUsers = (int) meterRegistry.get(\"acot.online.users\").gauge().value();\r\n        summary.put(\"onlineUsers\", onlineUsers);\r\n        \r\n        // 计算总API调用次数（所有端点计数器的总和）\r\n        double totalApiCalls = Search.in(meterRegistry)\r\n            .name(\"acot.endpoint.calls\")\r\n            .counters()\r\n            .stream()\r\n            .mapToDouble(counter -\u003e counter.count())  // 提取每个计数器的值\r\n            .sum();                                   // 求和\r\n        summary.put(\"totalApiCalls\", (int) totalApiCalls);\r\n        \r\n        return CommonResult.success(summary);\r\n    }\r\n}\r\n```\r\n\r\n**MeterRegistry的内部工作机制**：\r\n\r\n```java\r\n// MeterRegistry的查找算法（简化版）\r\npublic Meter get(String name) {\r\n    for (Meter meter : this.meters) {\r\n        if (meter.getId().getName().equals(name)) {\r\n            return meter;\r\n        }\r\n    }\r\n    throw new MeterNotFoundException(\"找不到名为 \" + name + \" 的指标\");\r\n}\r\n```\r\n\r\n### 完整的指标数据流分析\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant Client as 客户端\r\n    participant Controller as RestController\r\n    participant Aspect as EndpointMetricsAspect\r\n    participant Metrics as EndpointMetrics\r\n    participant Registry as MeterRegistry\r\n    participant Prometheus as Prometheus端点\r\n\r\n    Client-\u003e\u003eController: HTTP请求\r\n    Controller-\u003e\u003eAspect: 方法调用 (AOP拦截)\r\n    Aspect-\u003e\u003eMetrics: incrementEndpointCount()\r\n    Metrics-\u003e\u003eRegistry: counter.increment()\r\n    Controller-\u003e\u003eClient: 返回响应\r\n    \r\n    Note over Registry: 指标数据持续累积\r\n    \r\n    Prometheus-\u003e\u003eController: GET /actuator/prometheus\r\n    Controller-\u003e\u003eRegistry: 获取所有指标\r\n    Registry-\u003e\u003ePrometheus: 返回Prometheus格式数据\r\n```\r\n\r\n### 配置文件的深层解析\r\n\r\n**为什么需要这些配置？**\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        # 为什么只暴露这些端点？\r\n        include: \"health,info,metrics,prometheus,env,threaddump,loggers\"\r\n        # 安全考虑：\r\n        # - health: 健康检查，负载均衡需要\r\n        # - metrics: 内部监控查询\r\n        # - prometheus: 外部监控系统拉取\r\n        # - 其他敏感端点不暴露，避免信息泄露\r\n```\r\n\r\n**生产环境的安全配置**：\r\n\r\n```yaml\r\nmanagement:\r\n  endpoints:\r\n    web:\r\n      exposure:\r\n        include: \"health,prometheus\"  # 最小暴露原则\r\n        base-path: /internal/actuator  # 内部路径，便于网关路由控制\r\n  endpoint:\r\n    prometheus:\r\n      access: when_authorized  # 需要认证\r\n    health:\r\n      show-details: when_authorized  # 详细信息需要认证\r\n  server:\r\n    port: 9090  # 独立的管理端口，便于防火墙策略\r\n```\r\n\r\n## 写在最后\r\n\r\n相比起使用监控系统来关注系统运行的健康程度，其实我更喜欢使用监控系统来进行用户行为分析。诚然，安全比个性更重要，但安全的目的不就是为了之后更多的可能性吗？\r\n\r\nACOT的监控系统设计是相对简单的，但它展现出了一个系统的长期可持续发展能力——对于用户需求的敏锐嗅觉。毕竟，能解决用户需求的系统才是好系统。\r\n\r\n*愿未来的系统形如灵智的精灵，倾心聆听来访者的声音，化身他们手中披荆斩棘的利刃，担任成为未来的算子，让人类的智慧在宇宙中闪烁。* ✨\r\n\r\n```java\r\n// 许愿（监控版）\r\nwhile (system.isRunning()) {\r\n    monitor.collect();\r\n    if (anomaly.detected()) {\r\n        alert.send(); 🚨\r\n        engineer.fix();\r\n    }\r\n    dashboard.update(); 📊\r\n}\r\n```\r\n"])</script><script>self.__next_f.push([1,"2c:T2de1,"])</script><script>self.__next_f.push([1,"\r\n# 专精时间减半计算器 - 算法详解\r\n\r\n## 前言\r\n\r\n专精时间减半计算器是一个专门为明日方舟玩家设计的工具，用来计算什么时候换艾丽妮或逻各斯这些减半干员最合适，能够恰好触发专精时间减半效果。本篇将详细拆解其核心算法的实现逻辑。\r\n\r\n这个算法看起来挺复杂的，但其实核心思想很简单：**算出在什么时候换减半干员，能让剩余时间刚好被减半**。\r\n\r\n## 核心算法解析\r\n\r\n### 数据结构设计\r\n\r\n首先，让我们看看这个计算器用到的主要数据：\r\n\r\n```javascript\r\nconst halfOperatorParams = reactive({\r\n  efficiency: null,        // 当前专精助手干员提供的效率\r\n  isFit: false,           // 是否享受职业专精效率加成\r\n  halfOperatorAddition: 0.3, // 减半干员专精效率加成（默认30%）\r\n  hasAscalon: false,      // 控制中枢是否入驻阿斯卡纶/烛煌\r\n  remainder: null,        // 当前显示的剩余时间\r\n  leadTime: 5,           // 默认提前5分钟提醒\r\n})\r\n```\r\n\r\n### 算法核心逻辑\r\n\r\n`calculateTime()` 函数分析：\r\n\r\n```javascript\r\nfunction calculateTime() {\r\n  // 第一步：计算额外效率\r\n  extraEfficiency = 0.05 + (halfOperatorParams.hasAscalon ? 0.05 : 0)\r\n```\r\n\r\n代码解析：\r\n- 训练室基础效率是 5%（0.05）\r\n- 如果控制中枢有阿斯卡纶或烛煌，再加 5%\r\n- 所以 `extraEfficiency` 要么是 0.05，要么是 0.1\r\n\r\n```javascript\r\n  // 第二步：计算当前总效率\r\n  nowEfficiency.value = 1 + halfOperatorParams.efficiency + extraEfficiency\r\n```\r\n\r\n公式理解：\r\n- 基础效率是 1（也就是 100%）\r\n- 加上专精助手干员的效率（比如 0.6 就是 60%）\r\n- 再加上刚才算出的额外效率\r\n- 比如：1 + 0.6 + 0.05 = 1.65（也就是 165% 效率）\r\n\r\n```javascript\r\n  // 第三步：计算减半干员的效率\r\n  halfOperatorEfficiency.value = halfOperatorParams.isFit ? \r\n    1 + halfOperatorParams.halfOperatorAddition + extraEfficiency : \r\n    1 + extraEfficiency;\r\n```\r\n\r\n这里有个判断：\r\n- 如果减半干员有职业加成（比如艾丽妮对近卫/狙击有加成），就加上 `halfOperatorAddition`\r\n- 如果没有职业加成，就只加基础的额外效率\r\n- 比如艾丽妮对近卫职业：1 + 0.3 + 0.05 = 1.35（135% 效率）\r\n\r\n### 时间计算的精髓\r\n\r\n接下来是算法的核心部分：\r\n\r\n```javascript\r\n  if (halfOperatorParams.efficiency != null \u0026\u0026 halfOperatorParams.remainder != null) {\r\n    // 第四步：将显示时间转为总秒数\r\n    remainSeconds = convertToSeconds(halfOperatorParams.remainder)\r\n```\r\n\r\n这个函数把用户输入的时间（比如 \"04:30:15\"）转换成秒数，方便后续计算。\r\n\r\n```javascript\r\n    // 第五步：计算零效率下的实际剩余时间\r\n    zeroEffRemainSeconds.value = remainSeconds * nowEfficiency.value\r\n```\r\n\r\n这一步很关键！为什么要乘以当前效率呢？\r\n\r\n举个例子：\r\n- 显示剩余时间 1 小时（3600 秒）\r\n- 当前效率 165%（1.65）\r\n- 在零效率下实际需要：3600 × 1.65 = 5940 秒\r\n\r\n这样做是为了统一计算基准。\r\n\r\n```javascript\r\n    // 第六步：计算减半干员需要的时间\r\n    zeroEffNeedTime = halfOperatorEfficiency.value * 5 * 60 * 60\r\n```\r\n\r\n这里的逻辑是：\r\n- 减半干员的减半效果需要剩余时间 ≥ 5 小时才能触发\r\n- 5 小时 = 5 × 60 × 60 = 18000 秒\r\n- 但考虑到减半干员的效率，实际需要的零效率时间是：18000 × 减半干员效率\r\n\r\n```javascript\r\n    // 第七步：计算时间差\r\n    timeDifference = zeroEffRemainSeconds.value - zeroEffNeedTime\r\n    timeDifference /= nowEfficiency.value\r\n```\r\n\r\n这是算法的核心：\r\n- 先算出零效率下的时间差\r\n- 再除以当前效率，得到实际显示时间下的差值\r\n- 这个差值就是\"还有多久需要换减半干员\"\r\n\r\n### 状态判断逻辑\r\n\r\n最后是状态判断：\r\n\r\n```javascript\r\n    // 第八步：计算余裕时间\r\n    ampleTime = timeDifference - halfOperatorParams.leadTime * 60\r\n    \r\n    if (ampleTime \u003e 0) {\r\n      // 情况1：还有余裕时间\r\n      state.value = \"success\"\r\n      // 计算提醒时间...\r\n    } else if (timeDifference \u003e 0) {\r\n      // 情况2：已经很紧急了\r\n      state.value = \"warning\"\r\n    } else {\r\n      // 情况3：已经来不及了\r\n      state.value = \"danger\"\r\n    }\r\n```\r\n\r\n这里设计了三种状态：\r\n1. **成功**（绿色）：还有时间，可以定闹钟\r\n2. **警告**（黄色）：赶紧换干员！\r\n3. **危险**（红色）：已经触发不了减半效果了\r\n\r\n## UI 数据显示逻辑\r\n\r\n### 效率显示\r\n\r\n```javascript\r\n// 显示百分比形式的效率\r\n{{ ((nowEfficiency - 1) * 100).toFixed(0) }}%\r\n{{ ((halfOperatorEfficiency - 1) * 100).toFixed(0) }}%\r\n```\r\n\r\n这里把效率转换成百分比显示，比如 1.65 显示为 65%。\r\n\r\n### 剩余时间格式化\r\n\r\n```javascript\r\nconst formattedRemainingTime = computed(() =\u003e {\r\n  if (!zeroEffRemainSeconds.value) return '00:00:00'\r\n  const hours = Math.floor(zeroEffRemainSeconds.value / 3600)\r\n  const minutes = Math.floor((zeroEffRemainSeconds.value % 3600) / 60).toString().padStart(2, '0')\r\n  const seconds = Math.floor(zeroEffRemainSeconds.value % 60).toString().padStart(2, '0')\r\n  return `${hours}:${minutes}:${seconds}`\r\n})\r\n```\r\n\r\n这个函数把秒数转换成好看的时间格式，比如 \"5:30:45\"。\r\n\r\n### 提醒时间计算\r\n\r\n```javascript\r\nremindTime = secondsToTimeString(getSecondsSinceMidnight() + ampleTime \u003e 86400 ?\r\n  Math.floor(getSecondsSinceMidnight() + ampleTime - 86400) :\r\n  Math.floor(getSecondsSinceMidnight() + ampleTime))\r\n```\r\n\r\n这部分处理跨天的情况：\r\n- 如果提醒时间超过了当天 24 点，就算成第二天的时间\r\n- 比如现在是 23:30，还需要 2 小时提醒，那就是明天 01:30\r\n\r\n## 实际应用场景\r\n\r\n假设你现在有个近卫干员在专精，显示剩余时间 6 小时：\r\n\r\n1. **输入数据**：\r\n- 剩余时间：06:00:00\r\n- 当前效率：60%（0.6）\r\n- 有阿斯卡纶/烛煌：是\r\n- 艾丽妮有近卫加成：是\r\n\r\n2. **计算过程**：\r\n- 当前总效率：1 + 0.6 + 0.1 = 1.7（170%）\r\n- 艾丽妮效率：1 + 0.3 + 0.1 = 1.4（140%）\r\n- 零效率下实际剩余：6×3600×1.7 = 36720 秒\r\n- 艾丽妮需要的时间：5×3600×1.4 = 25200 秒\r\n- 时间差：(36720 - 25200) / 1.7 ≈ 6776 秒 ≈ 1小时52分钟（向下取整）\r\n\r\n3. **结果**：大约1小时52分钟后换艾丽妮，能恰好触发减半效果！（当然，实际使用时别卡那么极限）\r\n\r\n## 算法全代码解析\r\n\r\n下面是完整的 `calculateTime()` 函数：\r\n\r\n```javascript\r\nfunction calculateTime() {\r\n  // ==================== 第一阶段：计算基础效率 ====================\r\n  \r\n  // 计算额外效率加成\r\n  // 训练室基础效率固定为5%，如果控制中枢有阿斯卡纶/烛煌再额外加5%\r\n  extraEfficiency = 0.05 + (halfOperatorParams.hasAscalon ? 0.05 : 0)\r\n  \r\n  // 计算当前总效率（未换减半干员时的效率）\r\n  // 公式：基础100% + 专精助手干员效率 + 额外效率\r\n  nowEfficiency.value = 1 + halfOperatorParams.efficiency + extraEfficiency\r\n  \r\n  // 计算减半干员的总效率（换了减半干员后的效率）\r\n  // 如果减半干员有职业加成，就加上对应的加成值，否则只加基础额外效率\r\n  halfOperatorEfficiency.value = halfOperatorParams.isFit ? \r\n    1 + halfOperatorParams.halfOperatorAddition + extraEfficiency : \r\n    1 + extraEfficiency;\r\n\r\n  // ==================== 第二阶段：检查输入数据完整性 ====================\r\n  \r\n  // 只有当效率和剩余时间都有值时才进行计算\r\n  if (halfOperatorParams.efficiency != null \u0026\u0026 halfOperatorParams.remainder != null) {\r\n    \r\n    // ==================== 第三阶段：时间换算核心逻辑 ====================\r\n    \r\n    // 将用户输入的时间格式（如\"04:30:15\"）转换为总秒数\r\n    remainSeconds = convertToSeconds(halfOperatorParams.remainder)\r\n    \r\n    // 【核心算法1】计算零效率下的实际剩余时间\r\n    // 为什么要乘以当前效率？因为要把\"有效率加成下的显示时间\"换算成\"零效率下的真实时间\"\r\n    // 举例：显示1小时，当前170%效率，那么零效率下实际需要1×1.7=1.7小时\r\n    zeroEffRemainSeconds.value = remainSeconds * nowEfficiency.value\r\n    \r\n    // 【核心算法2】计算减半干员在零效率下需要的时间\r\n    // 减半效果触发条件：剩余时间≥5小时\r\n    // 但这个5小时是在减半干员效率下的，所以零效率下需要：5小时×减半干员效率\r\n    zeroEffNeedTime = halfOperatorEfficiency.value * 5 * 60 * 60\r\n    \r\n    // 【核心算法3】计算零效率下的时间差\r\n    // 这个差值表示：当前剩余时间 - 减半干员需要的最少时间\r\n    // 正数表示还有余量，负数表示已经不够了\r\n    timeDifference = zeroEffRemainSeconds.value - zeroEffNeedTime\r\n    \r\n    // 【核心算法4】将零效率下的时间差转换回当前效率下的时间差\r\n    // 因为最终要告诉用户\"还有X分钟需要换干员\"，这个X是在当前效率下的时间\r\n    timeDifference /= nowEfficiency.value\r\n    \r\n    // ==================== 第四阶段：状态判断和用户提醒 ====================\r\n    \r\n    // 计算余裕时间：时间差减去用户设置的提前提醒时间\r\n    // 比如时间差还有10分钟，用户设置提前5分钟提醒，那么余裕时间就是5分钟\r\n    ampleTime = timeDifference - halfOperatorParams.leadTime * 60\r\n    \r\n    if (ampleTime \u003e 0) {\r\n      // 【状态1：成功】还有充足的余裕时间\r\n      state.value = \"success\"\r\n      \r\n      // 计算具体的提醒时间点\r\n      // 获取当前时间距离午夜的秒数，加上余裕时间，就是提醒的时间点\r\n      // 如果超过24小时（86400秒），就减去86400，表示第二天的时间\r\n      remindTime = secondsToTimeString(\r\n        getSecondsSinceMidnight() + ampleTime \u003e 86400 ?\r\n          Math.floor(getSecondsSinceMidnight() + ampleTime - 86400) :\r\n          Math.floor(getSecondsSinceMidnight() + ampleTime)\r\n      )\r\n      \r\n      // 生成提醒文本\r\n      remindText.value = `减半干员的专精减半效果将在${Math.floor(timeDifference / 60)}分钟后迎来临界触发点，可以制定${remindTime}时间点的闹钟(〃'▽'〃)`\r\n      \r\n    } else if (timeDifference \u003e 0) {\r\n      // 【状态2：警告】余裕时间不足，但还能触发减半效果\r\n      state.value = \"warning\"\r\n      remindText.value = \"立，刻，换，减，半，干，员！！！(╬◣д◢)\"\r\n      \r\n    } else {\r\n      // 【状态3：危险】已经错过了最佳时机，无法触发减半效果\r\n      state.value = \"danger\"\r\n      remindText.value = \"已经...已经触发不了了...o(╥﹏╥)o\"\r\n    }\r\n    \r\n  } else {\r\n    // ==================== 数据不完整时的默认状态 ====================\r\n    state.value = \"info\"\r\n    remindText.value = \"得先输入数据才会有结果哦(￣▽￣)\"\r\n  }\r\n}\r\n```\r\n\r\n### 算法的数学原理\r\n\r\n这个算法的核心数学思想是**时间等价换算**：\r\n\r\n1. **统一基准**：所有时间计算都换算到\"零效率基准\"下进行比较\r\n2. **效率换算公式**：\r\n- 显示时间 → 零效率时间：`显示时间 × 当前效率`\r\n- 零效率时间 → 显示时间：`零效率时间 ÷ 当前效率`\r\n\r\n3. **临界点判断**：\r\n```\r\n零效率下剩余时间 ≥ 零效率下减半干员需要时间\r\n即：remainSeconds × nowEfficiency ≥ 5小时 × halfOperatorEfficiency\r\n   ```\r\n\r\n4. **时间差计算**：\r\n```\r\n实际可用时间 = (剩余时间 - 最少需要时间) ÷ 当前效率\r\n   ```\r\n\r\n"])</script><script>self.__next_f.push([1,"2d:T1805,"])</script><script>self.__next_f.push([1,"\r\n`MutationObserver` 是浏览器提供的原生 API，用于监听 DOM 树的变化。它可以异步观察指定元素及其子元素的变化，是现代 Web 开发中处理 DOM 变化的推荐方式。\r\n\r\n\r\n### **基本作用**\r\n`MutationObserver` 用于监听以下类型的 DOM 变化：\r\n- 子节点的添加或删除\r\n- 元素属性的变化\r\n- 文本内容的变化\r\n- 元素子树的变化\r\n\r\n```javascript\r\nconst observer = new MutationObserver((mutations) =\u003e {\r\n  mutations.forEach((mutation) =\u003e {\r\n    console.log('DOM 发生变化:', mutation);\r\n  });\r\n});\r\n```\r\n\r\n\r\n### **基本用法**\r\n创建 MutationObserver 需要三个步骤：\r\n\r\n```javascript\r\n// 1. 创建观察器实例\r\nconst observer = new MutationObserver((mutations, observer) =\u003e {\r\n  // 处理变化\r\n  mutations.forEach((mutation) =\u003e {\r\n    console.log('变化类型:', mutation.type);\r\n    console.log('目标元素:', mutation.target);\r\n  });\r\n});\r\n\r\n// 2. 配置观察选项\r\nconst config = {\r\n  childList: true,        // 观察子节点变化\r\n  attributes: true,       // 观察属性变化\r\n  attributeOldValue: true,// 记录属性旧值\r\n  characterData: true,    // 观察文本内容变化\r\n  subtree: true          // 观察整个子树\r\n};\r\n\r\n// 3. 开始观察\r\nconst targetNode = document.getElementById('myDiv');\r\nobserver.observe(targetNode, config);\r\n```\r\n\r\n\r\n### **配置选项详解**\r\n```javascript\r\nconst config = {\r\n  childList: true,          // 监听子节点的添加/删除\r\n  attributes: true,         // 监听属性变化\r\n  attributeOldValue: true,  // 记录属性变化前的值\r\n  attributeFilter: ['class', 'style'], // 只监听指定属性\r\n  characterData: true,      // 监听文本节点内容变化\r\n  characterDataOldValue: true, // 记录文本变化前的值\r\n  subtree: true            // 监听整个子树的变化\r\n};\r\n```\r\n\r\n\r\n### **实用示例**\r\n\r\n#### **监听元素类名变化**\r\n```javascript\r\nconst observer = new MutationObserver((mutations) =\u003e {\r\n  mutations.forEach((mutation) =\u003e {\r\n    if (mutation.type === 'attributes' \u0026\u0026 mutation.attributeName === 'class') {\r\n      console.log('类名从', mutation.oldValue, '变为', mutation.target.className);\r\n    }\r\n  });\r\n});\r\n\r\nobserver.observe(document.body, {\r\n  attributes: true,\r\n  attributeOldValue: true,\r\n  attributeFilter: ['class']\r\n});\r\n```\r\n\r\n#### **监听子元素添加**\r\n```javascript\r\nconst listObserver = new MutationObserver((mutations) =\u003e {\r\n  mutations.forEach((mutation) =\u003e {\r\n    if (mutation.type === 'childList') {\r\n      mutation.addedNodes.forEach((node) =\u003e {\r\n        if (node.nodeType === Node.ELEMENT_NODE) {\r\n          console.log('添加了新元素:', node);\r\n        }\r\n      });\r\n    }\r\n  });\r\n});\r\n\r\nconst todoList = document.getElementById('todoList');\r\nlistObserver.observe(todoList, { childList: true });\r\n```\r\n\r\n\r\n### **与传统事件监听的对比**\r\n```javascript\r\n// 传统方式：使用 DOMNodeInserted（已废弃）\r\nelement.addEventListener('DOMNodeInserted', handler, false);\r\n\r\n// 现代方式：使用 MutationObserver\r\nconst observer = new MutationObserver(handler);\r\nobserver.observe(element, { childList: true, subtree: true });\r\n```\r\n\r\n\r\n### **性能优势**\r\n1. **异步执行**：不会阻塞主线程\r\n2. **批量处理**：将多个变化合并为一次回调\r\n3. **精确控制**：可以选择性监听特定类型的变化\r\n\r\n\r\n### **实际应用场景**\r\n- **无限滚动列表**：监听容器高度变化\r\n- **动态内容加载**：监听新内容的插入\r\n- **主题切换**：监听 class 或 data 属性变化\r\n- **表单验证**：监听输入框内容变化\r\n- **组件库开发**：监听 DOM 结构变化\r\n\r\n\r\n### **React 中的使用**\r\n```jsx\r\nimport React, { useEffect, useRef } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const containerRef = useRef(null);\r\n\r\n  useEffect(() =\u003e {\r\n    const observer = new MutationObserver((mutations) =\u003e {\r\n      mutations.forEach((mutation) =\u003e {\r\n        if (mutation.type === 'childList') {\r\n          console.log('子元素发生变化');\r\n        }\r\n      });\r\n    });\r\n\r\n    if (containerRef.current) {\r\n      observer.observe(containerRef.current, {\r\n        childList: true,\r\n        subtree: true\r\n      });\r\n    }\r\n\r\n    // 清理函数\r\n    return () =\u003e {\r\n      observer.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  return \u003cdiv ref={containerRef}\u003e监听的容器\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **注意事项**\r\n1. **及时断开连接**：使用 `observer.disconnect()` 避免内存泄漏\r\n2. **避免无限循环**：回调函数中修改 DOM 可能触发新的变化\r\n3. **性能考虑**：避免监听过大的 DOM 树\r\n4. **浏览器兼容性**：现代浏览器都支持，IE11+ 可用\r\n\r\n\r\n### **完整示例**\r\n```javascript\r\nclass DOMWatcher {\r\n  constructor(target, options = {}) {\r\n    this.target = target;\r\n    this.options = {\r\n      childList: true,\r\n      attributes: true,\r\n      subtree: true,\r\n      ...options\r\n    };\r\n    this.observer = new MutationObserver(this.handleMutations.bind(this));\r\n  }\r\n\r\n  handleMutations(mutations) {\r\n    mutations.forEach((mutation) =\u003e {\r\n      switch (mutation.type) {\r\n        case 'childList':\r\n          this.handleChildListChange(mutation);\r\n          break;\r\n        case 'attributes':\r\n          this.handleAttributeChange(mutation);\r\n          break;\r\n        case 'characterData':\r\n          this.handleTextChange(mutation);\r\n          break;\r\n      }\r\n    });\r\n  }\r\n\r\n  handleChildListChange(mutation) {\r\n    console.log('子元素变化:', mutation.addedNodes, mutation.removedNodes);\r\n  }\r\n\r\n  handleAttributeChange(mutation) {\r\n    console.log('属性变化:', mutation.attributeName, mutation.oldValue);\r\n  }\r\n\r\n  handleTextChange(mutation) {\r\n    console.log('文本变化:', mutation.oldValue, mutation.target.textContent);\r\n  }\r\n\r\n  start() {\r\n    this.observer.observe(this.target, this.options);\r\n  }\r\n\r\n  stop() {\r\n    this.observer.disconnect();\r\n  }\r\n}\r\n\r\n// 使用示例\r\nconst watcher = new DOMWatcher(document.body);\r\nwatcher.start();\r\n```\r\n\r\nMutationObserver 是现代 Web 开发中监听 DOM 变化的标准方案，提供了强大的功能和优秀的性能表现。\r\n"])</script><script>self.__next_f.push([1,"2e:T2b7a,"])</script><script>self.__next_f.push([1,"\r\n`requestAnimationFrame` 是浏览器提供的原生 API，用于创建平滑的动画效果。它会在下一次重绘之前调用指定的回调函数，确保动画与浏览器的刷新率保持同步。\r\n\r\n\r\n### **基本作用**\r\n`requestAnimationFrame` 的主要作用是：\r\n- 在浏览器下一次重绘前执行动画函数\r\n- 与显示器刷新率同步（通常是 60fps）\r\n- 当页面不可见时自动暂停，节省性能\r\n- 提供更流畅的动画体验\r\n\r\n```javascript\r\nfunction animate() {\r\n  // 动画逻辑\r\n  console.log('执行动画帧');\r\n  \r\n  // 请求下一帧\r\n  requestAnimationFrame(animate);\r\n}\r\n\r\n// 开始动画\r\nrequestAnimationFrame(animate);\r\n```\r\n\r\n\r\n### **基本用法**\r\n```javascript\r\nfunction animate(timestamp) {\r\n  // timestamp: 当前时间戳（毫秒）\r\n  console.log('当前时间:', timestamp);\r\n  \r\n  // 执行动画逻辑\r\n  element.style.left = Math.sin(timestamp / 1000) * 100 + 'px';\r\n  \r\n  // 请求下一帧\r\n  requestAnimationFrame(animate);\r\n}\r\n\r\n// 启动动画\r\nconst animationId = requestAnimationFrame(animate);\r\n\r\n// 取消动画\r\ncancelAnimationFrame(animationId);\r\n```\r\n\r\n### 工作原理与常见问题 \r\n#### 为什么一般在使用requestAnimationFrame函数的时候，都是递归调用？\r\n\r\n`requestAnimationFrame`采用递归调用是因为它本质上是一次性的：每次调用只会在下一次重绘前执行一次回调函数。为了创建连续的动画效果，需要在每次回调结束时再次请求下一帧，形成递归调用的模式。这种方式能确保动画帧与浏览器重绘节奏精确同步。\r\n\r\n#### 持续性递归调用requestAnimationFrame难道不会导致栈溢出吗？\r\n\r\n不会导致栈溢出。因为`requestAnimationFrame`的回调函数是在当前执行栈为空时，由浏览器的事件循环机制调度执行的，属于异步执行模式。每次调用后，回调函数会在浏览器下一次重绘前被触发，而触发时上一次的函数调用栈已经执行完毕并释放，因此调用栈不会无限增长。\r\n\r\n#### 什么是浏览器的重绘任务队列？\r\n\r\n浏览器的重绘任务队列是用于管理视觉更新操作的任务队列。当DOM或CSS发生变化需要更新屏幕时，这些更新操作会被加入重绘队列。浏览器会定期（通常与显示器刷新率同步）从队列中取出任务执行，以确保视觉更新的流畅性。\r\n\r\n#### requestAnimationFrame是如何确保与浏览器刷新率同步的？\r\n\r\n浏览器会以自身的刷新率（通常是 60Hz，即每秒 60 次）定期触发重绘，以更新页面显示。`requestAnimationFrame` 的回调函数会被加入浏览器的**重绘任务队列**，在下一次重绘前执行，因此天然与重绘频率对齐。\r\n\r\n同时，浏览器会根据设备性能或页面状态（如切换到后台时）调整刷新率（例如降为 30Hz），`requestAnimationFrame` 会自动适配这种变化，回调触发频率会随浏览器实际重绘频率同步改变，无需手动干预。\r\n\r\n### **与传统方案的对比**\r\n\r\n#### **setTimeout/setInterval 的问题**\r\n```javascript\r\n// 传统方式：使用 setTimeout（不推荐）\r\nfunction animateWithTimeout() {\r\n  element.style.left = parseInt(element.style.left || 0) + 1 + 'px';\r\n  setTimeout(animateWithTimeout, 16); // 约 60fps\r\n}\r\n\r\n// 问题：\r\n// 1. 不与浏览器刷新率同步\r\n// 2. 页面不可见时仍然执行\r\n// 3. 可能导致丢帧或卡顿\r\n```\r\n\r\n#### **requestAnimationFrame 的优势**\r\n```javascript\r\n// 现代方式：使用 requestAnimationFrame（推荐）\r\nfunction animateWithRAF(timestamp) {\r\n  element.style.left = parseInt(element.style.left || 0) + 1 + 'px';\r\n  requestAnimationFrame(animateWithRAF);\r\n}\r\n\r\n// 优势：\r\n// 1. 与浏览器刷新率同步\r\n// 2. 页面不可见时自动暂停\r\n// 3. 更好的性能和电池续航\r\n```\r\n\r\n\r\n### **实用示例**\r\n\r\n#### **简单的移动动画**\r\n```javascript\r\nclass Animator {\r\n  constructor(element) {\r\n    this.element = element;\r\n    this.isRunning = false;\r\n    this.animationId = null;\r\n  }\r\n\r\n  start() {\r\n    if (this.isRunning) return;\r\n    \r\n    this.isRunning = true;\r\n    this.animate();\r\n  }\r\n\r\n  stop() {\r\n    this.isRunning = false;\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n    }\r\n  }\r\n\r\n  animate = (timestamp) =\u003e {\r\n    if (!this.isRunning) return;\r\n\r\n    // 动画逻辑\r\n    const x = Math.sin(timestamp / 1000) * 200;\r\n    this.element.style.transform = `translateX(${x}px)`;\r\n\r\n    // 请求下一帧\r\n    this.animationId = requestAnimationFrame(this.animate);\r\n  }\r\n}\r\n\r\n// 使用示例\r\nconst element = document.getElementById('myElement');\r\nconst animator = new Animator(element);\r\nanimator.start();\r\n```\r\n\r\n#### **时间控制的动画**\r\n```javascript\r\nclass TimedAnimation {\r\n  constructor(element, duration = 2000) {\r\n    this.element = element;\r\n    this.duration = duration;\r\n    this.startTime = null;\r\n  }\r\n\r\n  start() {\r\n    this.startTime = null;\r\n    this.animate();\r\n  }\r\n\r\n  animate = (timestamp) =\u003e {\r\n    if (!this.startTime) {\r\n      this.startTime = timestamp;\r\n    }\r\n\r\n    const elapsed = timestamp - this.startTime;\r\n    const progress = Math.min(elapsed / this.duration, 1);\r\n\r\n    // 使用缓动函数\r\n    const easeProgress = this.easeInOutQuad(progress);\r\n    \r\n    // 应用动画\r\n    this.element.style.transform = `translateX(${easeProgress * 300}px)`;\r\n\r\n    // 继续动画或结束\r\n    if (progress \u003c 1) {\r\n      requestAnimationFrame(this.animate);\r\n    } else {\r\n      console.log('动画完成');\r\n    }\r\n  }\r\n\r\n  easeInOutQuad(t) {\r\n    return t \u003c 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **性能优化技巧**\r\n\r\n#### **避免强制重排（Forced Reflow）**\r\n```javascript\r\n// 不好的做法：多次读取/写入样式\r\nfunction badAnimate() {\r\n  element1.style.left = element1.offsetLeft + 1 + 'px'; // 读取触发重排\r\n  element2.style.left = element2.offsetLeft + 1 + 'px'; // 再次触发重排\r\n}\r\n\r\n// 好的做法：批量处理样式操作\r\nfunction goodAnimate() {\r\n  // 先读取所有需要的值\r\n  const left1 = element1.offsetLeft;\r\n  const left2 = element2.offsetLeft;\r\n  \r\n  // 再批量写入\r\n  element1.style.left = left1 + 1 + 'px';\r\n  element2.style.left = left2 + 1 + 'px';\r\n}\r\n```\r\n\r\n#### **使用 CSS 变换代替位置改变**\r\n```javascript\r\n// 性能较差：改变 left/top\r\nfunction slowAnimate(timestamp) {\r\n  element.style.left = Math.sin(timestamp / 1000) * 100 + 'px';\r\n}\r\n\r\n// 性能更好：使用 transform\r\nfunction fastAnimate(timestamp) {\r\n  const x = Math.sin(timestamp / 1000) * 100;\r\n  element.style.transform = `translateX(${x}px)`;\r\n}\r\n```\r\n\r\n\r\n### **React 中的使用**\r\n```jsx\r\nimport React, { useEffect, useRef, useState } from 'react';\r\n\r\nfunction AnimatedComponent() {\r\n  const elementRef = useRef(null);\r\n  const animationRef = useRef(null);\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n\r\n  const animate = (timestamp) =\u003e {\r\n    if (!elementRef.current || !isAnimating) return;\r\n\r\n    const x = Math.sin(timestamp / 1000) * 100;\r\n    elementRef.current.style.transform = `translateX(${x}px)`;\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n  };\r\n\r\n  const startAnimation = () =\u003e {\r\n    setIsAnimating(true);\r\n  };\r\n\r\n  const stopAnimation = () =\u003e {\r\n    setIsAnimating(false);\r\n    if (animationRef.current) {\r\n      cancelAnimationFrame(animationRef.current);\r\n    }\r\n  };\r\n\r\n  useEffect(() =\u003e {\r\n    if (isAnimating) {\r\n      animationRef.current = requestAnimationFrame(animate);\r\n    }\r\n\r\n    return () =\u003e {\r\n      if (animationRef.current) {\r\n        cancelAnimationFrame(animationRef.current);\r\n      }\r\n    };\r\n  }, [isAnimating]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv ref={elementRef} style={{ width: 50, height: 50, backgroundColor: 'blue' }}\u003e\r\n        动画元素\r\n      \u003c/div\u003e\r\n      \u003cbutton onClick={isAnimating ? stopAnimation : startAnimation}\u003e\r\n        {isAnimating ? '停止' : '开始'}动画\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **自定义动画 Hook**\r\n```jsx\r\nimport { useEffect, useRef, useCallback } from 'react';\r\n\r\nfunction useAnimationFrame(callback, isRunning = true) {\r\n  const requestRef = useRef();\r\n\r\n  const animate = useCallback((timestamp) =\u003e {\r\n    callback(timestamp);\r\n    if (isRunning) {\r\n      requestRef.current = requestAnimationFrame(animate);\r\n    }\r\n  }, [callback, isRunning]);\r\n\r\n  useEffect(() =\u003e {\r\n    if (isRunning) {\r\n      requestRef.current = requestAnimationFrame(animate);\r\n    } else {\r\n      if (requestRef.current) {\r\n        cancelAnimationFrame(requestRef.current);\r\n      }\r\n    }\r\n\r\n    return () =\u003e {\r\n      if (requestRef.current) {\r\n        cancelAnimationFrame(requestRef.current);\r\n      }\r\n    };\r\n  }, [animate, isRunning]);\r\n}\r\n\r\n// 使用示例\r\nfunction MyAnimatedComponent() {\r\n  const [position, setPosition] = useState(0);\r\n\r\n  useAnimationFrame((timestamp) =\u003e {\r\n    setPosition(Math.sin(timestamp / 1000) * 100);\r\n  });\r\n\r\n  return (\r\n    \u003cdiv style={{ transform: `translateX(${position}px)` }}\u003e\r\n      动画内容\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **实际应用场景**\r\n- **平滑滚动**：页面滚动到指定位置\r\n- **粒子系统**：创建粒子动画效果\r\n- **数据可视化**：图表动画和过渡\r\n- **游戏开发**：游戏循环和角色动画\r\n- **UI 动效**：按钮点击、页面切换动画\r\n- **性能监控**：FPS 计算和性能分析\r\n\r\n\r\n### **注意事项**\r\n1. **内存管理**：始终使用 `cancelAnimationFrame` 清理动画\r\n2. **条件检查**：在回调中检查动画是否应该继续\r\n3. **性能考虑**：避免在动画中进行复杂计算\r\n4. **浏览器兼容性**：现代浏览器都支持，需要时使用 polyfill\r\n\r\n\r\n### **完整的动画管理器示例**\r\n```javascript\r\nclass AnimationManager {\r\n  constructor() {\r\n    this.animations = new Map();\r\n    this.isRunning = false;\r\n    this.animationId = null;\r\n  }\r\n\r\n  add(key, animationFn) {\r\n    this.animations.set(key, {\r\n      fn: animationFn,\r\n      active: true\r\n    });\r\n    \r\n    if (!this.isRunning) {\r\n      this.start();\r\n    }\r\n  }\r\n\r\n  remove(key) {\r\n    this.animations.delete(key);\r\n    \r\n    if (this.animations.size === 0) {\r\n      this.stop();\r\n    }\r\n  }\r\n\r\n  start() {\r\n    if (this.isRunning) return;\r\n    \r\n    this.isRunning = true;\r\n    this.tick();\r\n  }\r\n\r\n  stop() {\r\n    this.isRunning = false;\r\n    if (this.animationId) {\r\n      cancelAnimationFrame(this.animationId);\r\n    }\r\n  }\r\n\r\n  tick = (timestamp) =\u003e {\r\n    if (!this.isRunning) return;\r\n\r\n    // 执行所有活跃的动画\r\n    for (const [key, animation] of this.animations) {\r\n      if (animation.active) {\r\n        animation.fn(timestamp);\r\n      }\r\n    }\r\n\r\n    // 请求下一帧\r\n    this.animationId = requestAnimationFrame(this.tick);\r\n  }\r\n}\r\n\r\n// 全局动画管理器\r\nconst animationManager = new AnimationManager();\r\n\r\n// 使用示例\r\nanimationManager.add('myAnimation', (timestamp) =\u003e {\r\n  // 动画逻辑\r\n});\r\n```\r\n\r\n`requestAnimationFrame` 是现代 Web 动画的核心 API，提供了流畅、高效的动画解决方案。\r\n"])</script><script>self.__next_f.push([1,"2f:T3e5f,"])</script><script>self.__next_f.push([1,"\r\n`AnimatePresence` 是 Framer Motion 提供的核心组件，用于处理组件的退出动画。它通过检测 React 组件树中直接子组件的移除，使组件在卸载前能够执行完整的退出动画。\r\n\r\n\r\n### **基本作用**\r\n`AnimatePresence` 主要用于以下场景：\r\n- **组件退出动画**：在组件卸载前执行动画\r\n- **条件渲染动画**：处理基于状态的组件显示/隐藏\r\n- **列表项动画**：列表项添加/删除时的过渡效果\r\n- **路由切换动画**：页面或视图切换的动画效果\r\n\r\n```jsx\r\nimport { AnimatePresence, motion } from \"framer-motion\";\r\n\r\nfunction App() {\r\n  const [show, setShow] = useState(true);\r\n\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {show \u0026\u0026 (\r\n        \u003cmotion.div\r\n          key=\"modal\"\r\n          initial={{ opacity: 0 }}\r\n          animate={{ opacity: 1 }}\r\n          exit={{ opacity: 0 }}\r\n        \u003e\r\n          内容\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **基本用法**\r\n\r\n#### **条件渲染动画**\r\n```jsx\r\nimport { AnimatePresence, motion } from \"framer-motion\";\r\n\r\nfunction Modal({ isOpen, onClose }) {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {isOpen \u0026\u0026 (\r\n        \u003cmotion.div\r\n          key=\"modal\"\r\n          initial={{ opacity: 0, scale: 0.8 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          exit={{ opacity: 0, scale: 0.8 }}\r\n          className=\"modal-overlay\"\r\n        \u003e\r\n          \u003cmotion.div\r\n            initial={{ y: -50 }}\r\n            animate={{ y: 0 }}\r\n            exit={{ y: -50 }}\r\n            className=\"modal-content\"\r\n          \u003e\r\n            \u003ch2\u003e模态框标题\u003c/h2\u003e\r\n            \u003cp\u003e模态框内容\u003c/p\u003e\r\n            \u003cbutton onClick={onClose}\u003e关闭\u003c/button\u003e\r\n          \u003c/motion.div\u003e\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **列表动画**\r\n```jsx\r\nfunction TodoList() {\r\n  const [todos, setTodos] = useState([\r\n    { id: 1, text: \"学习 React\" },\r\n    { id: 2, text: \"学习 Framer Motion\" }\r\n  ]);\r\n\r\n  const removeTodo = (id) =\u003e {\r\n    setTodos(prev =\u003e prev.filter(todo =\u003e todo.id !== id));\r\n  };\r\n\r\n  return (\r\n    \u003cul\u003e\r\n      \u003cAnimatePresence\u003e\r\n        {todos.map(todo =\u003e (\r\n          \u003cmotion.li\r\n            key={todo.id} // 关键：每个子元素必须有唯一的 key\r\n            initial={{ opacity: 0, x: -100 }}\r\n            animate={{ opacity: 1, x: 0 }}\r\n            exit={{ opacity: 0, x: 100 }}\r\n            layout // 自动处理布局动画\r\n          \u003e\r\n            {todo.text}\r\n            \u003cbutton onClick={() =\u003e removeTodo(todo.id)}\u003e删除\u003c/button\u003e\r\n          \u003c/motion.li\u003e\r\n        ))}\r\n      \u003c/AnimatePresence\u003e\r\n    \u003c/ul\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **变体（Variants）的使用**\r\n```jsx\r\nconst modalVariants = {\r\n  hidden: { \r\n    opacity: 0, \r\n    scale: 0.8,\r\n    transition: { \r\n      when: \"afterChildren\" // 先执行子组件动画\r\n    }\r\n  },\r\n  visible: { \r\n    opacity: 1, \r\n    scale: 1,\r\n    transition: { \r\n      when: \"beforeChildren\", // 先执行父组件动画\r\n      staggerChildren: 0.1 // 子组件依次动画\r\n    }\r\n  }\r\n};\r\n\r\nconst itemVariants = {\r\n  hidden: { opacity: 0, y: 20 },\r\n  visible: { opacity: 1, y: 0 }\r\n};\r\n\r\nfunction AnimatedModal({ isOpen }) {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {isOpen \u0026\u0026 (\r\n        \u003cmotion.div\r\n          variants={modalVariants}\r\n          initial=\"hidden\"\r\n          animate=\"visible\"\r\n          exit=\"hidden\"\r\n          className=\"modal\"\r\n        \u003e\r\n          \u003cmotion.h2 variants={itemVariants}\u003e标题\u003c/motion.h2\u003e\r\n          \u003cmotion.p variants={itemVariants}\u003e内容\u003c/motion.p\u003e\r\n          \u003cmotion.button variants={itemVariants}\u003e按钮\u003c/motion.button\u003e\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **key 属性的重要性**\r\n\r\n#### **通过改变 key 触发动画**\r\n```jsx\r\nfunction Slideshow() {\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  const images = [\r\n    { id: 1, src: \"image1.jpg\", alt: \"图片1\" },\r\n    { id: 2, src: \"image2.jpg\", alt: \"图片2\" },\r\n    { id: 3, src: \"image3.jpg\", alt: \"图片3\" }\r\n  ];\r\n\r\n  const currentImage = images[currentIndex];\r\n\r\n  return (\r\n    \u003cdiv className=\"slideshow\"\u003e\r\n      \u003cAnimatePresence mode=\"wait\"\u003e\r\n        \u003cmotion.img\r\n          key={currentImage.id} // 改变 key 会触发组件重新挂载\r\n          src={currentImage.src}\r\n          alt={currentImage.alt}\r\n          initial={{ x: 300, opacity: 0 }}\r\n          animate={{ x: 0, opacity: 1 }}\r\n          exit={{ x: -300, opacity: 0 }}\r\n          transition={{ duration: 0.5 }}\r\n        /\u003e\r\n      \u003c/AnimatePresence\u003e\r\n      \r\n      \u003cbutton onClick={() =\u003e setCurrentIndex(prev =\u003e (prev + 1) % images.length)}\u003e\r\n        下一张\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **mode 属性详解**\r\n\r\n#### **sync 模式（默认）**\r\n```jsx\r\n// 组件同时进入和退出\r\n\u003cAnimatePresence mode=\"sync\"\u003e\r\n  {show \u0026\u0026 \u003cComponent key=\"item\" /\u003e}\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n#### **wait 模式**\r\n```jsx\r\n// 等待退出动画完成后再开始进入动画\r\n\u003cAnimatePresence mode=\"wait\"\u003e\r\n  \u003cComponent key={activeTab} /\u003e\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n#### **popLayout 模式**\r\n```jsx\r\n// 退出的元素从布局中\"弹出\"，其他元素立即调整位置\r\n\u003cAnimatePresence mode=\"popLayout\"\u003e\r\n  {items.map(item =\u003e (\r\n    \u003cmotion.div key={item.id} layout\u003e\r\n      {item.content}\r\n    \u003c/motion.div\u003e\r\n  ))}\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n\r\n### **高级功能**\r\n\r\n#### **访问组件存在状态**\r\n```jsx\r\nimport { useIsPresent } from \"framer-motion\";\r\n\r\nfunction Component() {\r\n  const isPresent = useIsPresent();\r\n\r\n  return (\r\n    \u003cmotion.div\r\n      style={{ \r\n        backgroundColor: isPresent ? \"green\" : \"red\" \r\n      }}\r\n    \u003e\r\n      {isPresent ? \"组件存在\" : \"组件正在退出\"}\r\n    \u003c/motion.div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **传递自定义数据**\r\n```jsx\r\nfunction Slideshow() {\r\n  const [direction, setDirection] = useState(1); // 1: 前进, -1: 后退\r\n\r\n  const slideVariants = {\r\n    enter: (direction) =\u003e ({\r\n      x: direction \u003e 0 ? 1000 : -1000,\r\n      opacity: 0\r\n    }),\r\n    center: {\r\n      zIndex: 1,\r\n      x: 0,\r\n      opacity: 1\r\n    },\r\n    exit: (direction) =\u003e ({\r\n      zIndex: 0,\r\n      x: direction \u003c 0 ? 1000 : -1000,\r\n      opacity: 0\r\n    })\r\n  };\r\n\r\n  return (\r\n    \u003cAnimatePresence custom={direction}\u003e\r\n      \u003cmotion.div\r\n        key={currentSlide}\r\n        custom={direction}\r\n        variants={slideVariants}\r\n        initial=\"enter\"\r\n        animate=\"center\"\r\n        exit=\"exit\"\r\n        transition={{ duration: 0.5 }}\r\n      \u003e\r\n        幻灯片内容\r\n      \u003c/motion.div\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **手动控制移除时机**\r\n```jsx\r\nimport { usePresence } from \"framer-motion\";\r\n\r\nfunction Component() {\r\n  const [isPresent, safeToRemove] = usePresence();\r\n\r\n  useEffect(() =\u003e {\r\n    if (!isPresent) {\r\n      // 执行自定义清理逻辑\r\n      setTimeout(() =\u003e {\r\n        console.log(\"执行清理操作\");\r\n        safeToRemove(); // 告诉 AnimatePresence 可以安全移除组件\r\n      }, 1000);\r\n    }\r\n  }, [isPresent, safeToRemove]);\r\n\r\n  return \u003cdiv\u003e自定义退出逻辑的组件\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **实际应用场景**\r\n\r\n#### **路由切换动画**\r\n```jsx\r\nimport { useLocation } from \"react-router-dom\";\r\n\r\nfunction AnimatedRoutes() {\r\n  const location = useLocation();\r\n\r\n  return (\r\n    \u003cAnimatePresence mode=\"wait\"\u003e\r\n      \u003cmotion.div\r\n        key={location.pathname}\r\n        initial={{ opacity: 0, x: 100 }}\r\n        animate={{ opacity: 1, x: 0 }}\r\n        exit={{ opacity: 0, x: -100 }}\r\n        transition={{ duration: 0.3 }}\r\n      \u003e\r\n        \u003cRoutes location={location}\u003e\r\n          \u003cRoute path=\"/\" component={Home} /\u003e\r\n          \u003cRoute path=\"/about\" component={About} /\u003e\r\n          \u003cRoute path=\"/contact\" component={Contact} /\u003e\r\n        \u003c/Routes\u003e\r\n      \u003c/motion.div\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **通知系统**\r\n```jsx\r\nfunction NotificationCenter() {\r\n  const [notifications, setNotifications] = useState([]);\r\n\r\n  const removeNotification = (id) =\u003e {\r\n    setNotifications(prev =\u003e prev.filter(n =\u003e n.id !== id));\r\n  };\r\n\r\n  return (\r\n    \u003cdiv className=\"notification-center\"\u003e\r\n      \u003cAnimatePresence\u003e\r\n        {notifications.map(notification =\u003e (\r\n          \u003cmotion.div\r\n            key={notification.id}\r\n            initial={{ opacity: 0, y: -50, scale: 0.3 }}\r\n            animate={{ opacity: 1, y: 0, scale: 1 }}\r\n            exit={{ \r\n              opacity: 0, \r\n              scale: 0.5, \r\n              transition: { duration: 0.2 } \r\n            }}\r\n            layout\r\n            className=\"notification\"\r\n          \u003e\r\n            \u003cp\u003e{notification.message}\u003c/p\u003e\r\n            \u003cbutton onClick={() =\u003e removeNotification(notification.id)}\u003e\r\n              ×\r\n            \u003c/button\u003e\r\n          \u003c/motion.div\u003e\r\n        ))}\r\n      \u003c/AnimatePresence\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **搜索结果动画**\r\n```jsx\r\nfunction SearchResults({ results, query }) {\r\n  return (\r\n    \u003cdiv className=\"search-results\"\u003e\r\n      \u003cAnimatePresence\u003e\r\n        {results.map((result, index) =\u003e (\r\n          \u003cmotion.div\r\n            key={result.id}\r\n            initial={{ opacity: 0, y: 20 }}\r\n            animate={{ opacity: 1, y: 0 }}\r\n            exit={{ opacity: 0, y: -20 }}\r\n            transition={{ delay: index * 0.05 }}\r\n            layout\r\n            className=\"search-result-item\"\r\n          \u003e\r\n            \u003ch3\u003e{result.title}\u003c/h3\u003e\r\n            \u003cp\u003e{result.description}\u003c/p\u003e\r\n          \u003c/motion.div\u003e\r\n        ))}\r\n      \u003c/AnimatePresence\u003e\r\n      \r\n      {results.length === 0 \u0026\u0026 query \u0026\u0026 (\r\n        \u003cmotion.div\r\n          initial={{ opacity: 0 }}\r\n          animate={{ opacity: 1 }}\r\n          className=\"no-results\"\r\n        \u003e\r\n          没有找到相关结果\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **性能优化**\r\n\r\n#### **避免不必要的重新渲染**\r\n```jsx\r\n// 问题：每次渲染都创建新的 variants 对象\r\nfunction BadComponent() {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      \u003cmotion.div\r\n        variants={{\r\n          initial: { opacity: 0 },\r\n          animate: { opacity: 1 },\r\n          exit: { opacity: 0 }\r\n        }}\r\n      /\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n\r\n// 解决方案：将 variants 提取到组件外部\r\nconst variants = {\r\n  initial: { opacity: 0 },\r\n  animate: { opacity: 1 },\r\n  exit: { opacity: 0 }\r\n};\r\n\r\nfunction GoodComponent() {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      \u003cmotion.div variants={variants} /\u003e\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **使用 layout 属性优化列表动画**\r\n```jsx\r\nfunction OptimizedList({ items }) {\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {items.map(item =\u003e (\r\n        \u003cmotion.div\r\n          key={item.id}\r\n          layout // 自动处理位置变化的动画\r\n          initial={{ opacity: 0, scale: 0.8 }}\r\n          animate={{ opacity: 1, scale: 1 }}\r\n          exit={{ opacity: 0, scale: 0.8 }}\r\n          transition={{ \r\n            layout: { duration: 0.3 }, // 布局动画配置\r\n            opacity: { duration: 0.2 }  // 透明度动画配置\r\n          }}\r\n        \u003e\r\n          {item.content}\r\n        \u003c/motion.div\u003e\r\n      ))}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **最佳实践**\r\n\r\n1. **始终为直接子组件提供唯一的 key**\r\n   ```jsx\r\n   // ✅ 正确\r\n   \u003cAnimatePresence\u003e\r\n     {items.map(item =\u003e (\r\n       \u003cmotion.div key={item.id}\u003e\r\n         {item.content}\r\n       \u003c/motion.div\u003e\r\n     ))}\r\n   \u003c/AnimatePresence\u003e\r\n\r\n   // ❌ 错误：使用 index 作为 key\r\n   \u003cAnimatePresence\u003e\r\n     {items.map((item, index) =\u003e (\r\n       \u003cmotion.div key={index}\u003e\r\n         {item.content}\r\n       \u003c/motion.div\u003e\r\n     ))}\r\n   \u003c/AnimatePresence\u003e\r\n   ```\r\n\r\n2. **确保 AnimatePresence 在条件渲染之外**\r\n   ```jsx\r\n   // ✅ 正确\r\n   \u003cAnimatePresence\u003e\r\n     {isVisible \u0026\u0026 \u003cComponent /\u003e}\r\n   \u003c/AnimatePresence\u003e\r\n\r\n   // ❌ 错误：AnimatePresence 被条件渲染\r\n   {isVisible \u0026\u0026 (\r\n     \u003cAnimatePresence\u003e\r\n       \u003cComponent /\u003e\r\n     \u003c/AnimatePresence\u003e\r\n   )}\r\n   ```\r\n\r\n3. **合理使用 mode 属性**\r\n   - `sync`：适用于大多数场景\r\n   - `wait`：适用于页面切换、单个元素替换\r\n   - `popLayout`：适用于列表项删除时的布局调整\r\n\r\n4. **性能考虑**\r\n   - 将 variants 对象提取到组件外部\r\n   - 使用 `layout` 属性处理位置变化\r\n   - 避免在动画过程中进行复杂计算\r\n\r\n\r\n### **常见问题和解决方案**\r\n\r\n#### **退出动画不工作**\r\n```jsx\r\n// 问题：key 不唯一或没有 key\r\n\u003cAnimatePresence\u003e\r\n  {show \u0026\u0026 \u003cmotion.div\u003e内容\u003c/motion.div\u003e} {/* 缺少 key */}\r\n\u003c/AnimatePresence\u003e\r\n\r\n// 解决方案：添加唯一 key\r\n\u003cAnimatePresence\u003e\r\n  {show \u0026\u0026 \u003cmotion.div key=\"unique-id\"\u003e内容\u003c/motion.div\u003e}\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n#### **布局动画与 popLayout 冲突**\r\n```jsx\r\n// 解决方案：为父容器设置相对定位\r\n\u003cmotion.ul style={{ position: \"relative\" }} layout\u003e\r\n  \u003cAnimatePresence mode=\"popLayout\"\u003e\r\n    {items.map(item =\u003e (\r\n      \u003cmotion.li key={item.id} layout /\u003e\r\n    ))}\r\n  \u003c/AnimatePresence\u003e\r\n\u003c/motion.ul\u003e\r\n```\r\n\r\n#### **与 LayoutGroup 结合使用**\r\n```jsx\r\nimport { LayoutGroup } from \"framer-motion\";\r\n\r\n\u003cLayoutGroup\u003e\r\n  \u003cmotion.ul layout\u003e\r\n    \u003cAnimatePresence\u003e\r\n      {items.map(item =\u003e (\r\n        \u003cmotion.li key={item.id} layout /\u003e\r\n      ))}\r\n    \u003c/AnimatePresence\u003e\r\n  \u003c/motion.ul\u003e\r\n\u003c/LayoutGroup\u003e\r\n```\r\n\r\n\r\n### **完整示例**\r\n```jsx\r\nimport React, { useState } from 'react';\r\nimport { AnimatePresence, motion } from 'framer-motion';\r\n\r\nconst cardVariants = {\r\n  initial: { \r\n    opacity: 0, \r\n    scale: 0.8, \r\n    rotate: -10 \r\n  },\r\n  animate: { \r\n    opacity: 1, \r\n    scale: 1, \r\n    rotate: 0,\r\n    transition: {\r\n      duration: 0.3,\r\n      ease: \"easeOut\"\r\n    }\r\n  },\r\n  exit: { \r\n    opacity: 0, \r\n    scale: 0.8, \r\n    rotate: 10,\r\n    transition: {\r\n      duration: 0.2,\r\n      ease: \"easeIn\"\r\n    }\r\n  }\r\n};\r\n\r\nfunction CardManager() {\r\n  const [cards, setCards] = useState([\r\n    { id: 1, title: \"卡片 1\", content: \"这是第一张卡片\" },\r\n    { id: 2, title: \"卡片 2\", content: \"这是第二张卡片\" },\r\n    { id: 3, title: \"卡片 3\", content: \"这是第三张卡片\" }\r\n  ]);\r\n\r\n  const addCard = () =\u003e {\r\n    const newCard = {\r\n      id: Date.now(),\r\n      title: `卡片 ${cards.length + 1}`,\r\n      content: `这是第 ${cards.length + 1} 张卡片`\r\n    };\r\n    setCards(prev =\u003e [...prev, newCard]);\r\n  };\r\n\r\n  const removeCard = (id) =\u003e {\r\n    setCards(prev =\u003e prev.filter(card =\u003e card.id !== id));\r\n  };\r\n\r\n  return (\r\n    \u003cdiv className=\"card-manager\"\u003e\r\n      \u003cbutton onClick={addCard} className=\"add-button\"\u003e\r\n        添加卡片\r\n      \u003c/button\u003e\r\n      \r\n      \u003cdiv className=\"cards-container\"\u003e\r\n        \u003cAnimatePresence\u003e\r\n          {cards.map(card =\u003e (\r\n            \u003cmotion.div\r\n              key={card.id}\r\n              variants={cardVariants}\r\n              initial=\"initial\"\r\n              animate=\"animate\"\r\n              exit=\"exit\"\r\n              layout\r\n              className=\"card\"\r\n            \u003e\r\n              \u003ch3\u003e{card.title}\u003c/h3\u003e\r\n              \u003cp\u003e{card.content}\u003c/p\u003e\r\n              \u003cbutton \r\n                onClick={() =\u003e removeCard(card.id)}\r\n                className=\"remove-button\"\r\n              \u003e\r\n                删除\r\n              \u003c/button\u003e\r\n            \u003c/motion.div\u003e\r\n          ))}\r\n        \u003c/AnimatePresence\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nexport default CardManager;\r\n```\r\n\r\n\r\n### **注意事项**\r\n\r\n- **key 的重要性**：直接子组件必须有唯一且稳定的 key\r\n- **组件层级**：AnimatePresence 只检测直接子组件的变化\r\n- **性能影响**：复杂的退出动画可能影响性能，特别是在移动设备上\r\n- **浏览器兼容性**：需要现代浏览器支持，老版本浏览器可能需要 polyfill\r\n- **内存管理**：确保动画完成后正确清理组件和事件监听器\r\n\r\n`AnimatePresence` 是创建流畅用户界面的强大工具，通过合理使用可以大大提升应用的交互体验和视觉效果。\r\n"])</script><script>self.__next_f.push([1,"30:T410a,"])</script><script>self.__next_f.push([1,"\n`React.createContext` 是 React 提供的 Context API 的核心函数，用于创建一个 Context 对象，解决组件间跨层级数据传递的问题，避免 \"props drilling\"（属性钻取）。\n\n\n### **基本作用**\nContext 提供了一种在组件树中共享数据的方式，无需通过每层组件手动传递 props：\n\n- **解决 props drilling 问题**：避免在多层嵌套组件中逐层传递 props\n- **全局状态管理**：在组件树中共享主题、用户信息、语言设置等全局数据\n- **跨组件通信**：让任意层级的组件都能访问共享数据\n\n```jsx\nimport React, { createContext } from 'react';\n\n// 创建 Context\nconst ThemeContext = createContext();\n```\n\n\n### **基本语法**\n```jsx\nconst MyContext = createContext(defaultValue);\n```\n\n- **defaultValue**：当组件树中没有匹配的 Provider 时使用的默认值\n\n\n### **完整使用流程**\n\n#### **1. 创建 Context 和自定义 Hook**\n```jsx\nimport React, { createContext, useContext, useState, useMemo } from 'react';\n\n// 创建主题 Context（保持私有，不导出）\nconst ThemeContext = createContext();\n\n// 自定义 Hook\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  \n  if (!context) {\n    throw new Error('useTheme 必须在 ThemeProvider 内部使用');\n  }\n  \n  return context;\n}\n```\n\n#### **2. 创建 Provider 组件**\n```jsx\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n\n  const toggleTheme = () =\u003e {\n    setTheme(prev =\u003e prev === 'light' ? 'dark' : 'light');\n  };\n\n  // 使用 useMemo 优化性能\n  const value = useMemo(() =\u003e ({\n    theme,\n    toggleTheme\n  }), [theme]);\n\n  return (\n    \u003cThemeContext.Provider value={value}\u003e\n      {children}\n    \u003c/ThemeContext.Provider\u003e\n  );\n}\n```\n\n#### **3. 使用自定义 Hook 获取数据**\n```jsx\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    \u003cheader style={{ \n      background: theme === 'light' ? '#fff' : '#333',\n      color: theme === 'light' ? '#333' : '#fff'\n    }}\u003e\n      \u003ch1\u003e我的应用\u003c/h1\u003e\n      \u003cbutton onClick={toggleTheme}\u003e\n        切换到 {theme === 'light' ? '暗色' : '亮色'} 主题\n      \u003c/button\u003e\n    \u003c/header\u003e\n  );\n}\n```\n\n#### **4. 完整应用示例**\n```jsx\nfunction App() {\n  return (\n    \u003cThemeProvider\u003e\n      \u003cdiv\u003e\n        \u003cHeader /\u003e\n        \u003cContent /\u003e\n      \u003c/div\u003e\n    \u003c/ThemeProvider\u003e\n  );\n}\n\nfunction Content() {\n  const { theme } = useTheme();\n  \n  return (\n    \u003cmain style={{\n      background: theme === 'light' ? '#f5f5f5' : '#222',\n      color: theme === 'light' ? '#333' : '#fff',\n      padding: '20px'\n    }}\u003e\n      \u003cp\u003e这是主要内容区域\u003c/p\u003e\n      \u003cSidebar /\u003e\n    \u003c/main\u003e\n  );\n}\n\nfunction Sidebar() {\n  const { theme } = useTheme();\n  \n  return (\n    \u003caside style={{\n      background: theme === 'light' ? '#e0e0e0' : '#444',\n      padding: '10px'\n    }}\u003e\n      \u003cp\u003e侧边栏内容\u003c/p\u003e\n    \u003c/aside\u003e\n  );\n}\n```\n\n\n### **多个 Context 的使用**\n```jsx\n// 用户信息 Context\nconst UserContext = createContext();\n\n// 语言 Context  \nconst LanguageContext = createContext();\n\n// 组合多个 Provider\nfunction AppProviders({ children }) {\n  const [user, setUser] = useState(null);\n  const [language, setLanguage] = useState('zh');\n\n  return (\n    \u003cUserContext.Provider value={{ user, setUser }}\u003e\n      \u003cLanguageContext.Provider value={{ language, setLanguage }}\u003e\n        \u003cThemeContext.Provider value={{ theme: 'light' }}\u003e\n          {children}\n        \u003c/ThemeContext.Provider\u003e\n      \u003c/LanguageContext.Provider\u003e\n    \u003c/UserContext.Provider\u003e\n  );\n}\n\n// 使用多个 Context\nfunction UserProfile() {\n  const { user } = useContext(UserContext);\n  const { language } = useContext(LanguageContext);\n  const { theme } = useTheme(); // ThemeContext已有自定义Hook\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e用户: {user?.name}\u003c/p\u003e\n      \u003cp\u003e语言: {language}\u003c/p\u003e\n      \u003cp\u003e主题: {theme}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **为其他 Context 创建自定义 Hook**\n```jsx\n// 为用户 Context 创建自定义 Hook\nfunction useUser() {\n  const context = useContext(UserContext);\n  \n  if (!context) {\n    throw new Error('useUser 必须在 UserProvider 内部使用');\n  }\n  \n  return context;\n}\n\n// 为语言 Context 创建自定义 Hook\nfunction useLanguage() {\n  const context = useContext(LanguageContext);\n  \n  if (!context) {\n    throw new Error('useLanguage 必须在 LanguageProvider 内部使用');\n  }\n  \n  return context;\n}\n\n// 使用多个自定义 Hook\nfunction MyComponent() {\n  const { theme, toggleTheme } = useTheme();\n  const { user, setUser } = useUser();\n  const { language, setLanguage } = useLanguage();\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003e当前主题: {theme}\u003c/p\u003e\n      \u003cp\u003e当前用户: {user?.name || '未登录'}\u003c/p\u003e\n      \u003cp\u003e当前语言: {language}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **复杂状态管理示例**\n```jsx\n// 购物车 Context\nconst CartContext = createContext();\n\nfunction CartProvider({ children }) {\n  const [items, setItems] = useState([]);\n\n  const addItem = (product) =\u003e {\n    setItems(prev =\u003e {\n      const existingItem = prev.find(item =\u003e item.id === product.id);\n      if (existingItem) {\n        return prev.map(item =\u003e\n          item.id === product.id\n            ? { ...item, quantity: item.quantity + 1 }\n            : item\n        );\n      }\n      return [...prev, { ...product, quantity: 1 }];\n    });\n  };\n\n  const removeItem = (productId) =\u003e {\n    setItems(prev =\u003e prev.filter(item =\u003e item.id !== productId));\n  };\n\n  const updateQuantity = (productId, quantity) =\u003e {\n    if (quantity \u003c= 0) {\n      removeItem(productId);\n      return;\n    }\n    \n    setItems(prev =\u003e\n      prev.map(item =\u003e\n        item.id === productId\n          ? { ...item, quantity }\n          : item\n      )\n    );\n  };\n\n  const getTotalPrice = () =\u003e {\n    return items.reduce((total, item) =\u003e total + item.price * item.quantity, 0);\n  };\n\n  const getTotalItems = () =\u003e {\n    return items.reduce((total, item) =\u003e total + item.quantity, 0);\n  };\n\n  const clearCart = () =\u003e {\n    setItems([]);\n  };\n\n  const value = {\n    items,\n    addItem,\n    removeItem,\n    updateQuantity,\n    getTotalPrice,\n    getTotalItems,\n    clearCart\n  };\n\n  return (\n    \u003cCartContext.Provider value={value}\u003e\n      {children}\n    \u003c/CartContext.Provider\u003e\n  );\n}\n\n// 购物车 Hook\nfunction useCart() {\n  const context = useContext(CartContext);\n  if (!context) {\n    throw new Error('useCart 必须在 CartProvider 内部使用');\n  }\n  return context;\n}\n\n// 商品组件\nfunction ProductCard({ product }) {\n  const { addItem } = useCart();\n\n  return (\n    \u003cdiv className=\"product-card\"\u003e\n      \u003ch3\u003e{product.name}\u003c/h3\u003e\n      \u003cp\u003e价格: ¥{product.price}\u003c/p\u003e\n      \u003cbutton onClick={() =\u003e addItem(product)}\u003e\n        加入购物车\n      \u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n\n// 购物车组件\nfunction Cart() {\n  const { items, updateQuantity, removeItem, getTotalPrice, clearCart } = useCart();\n\n  return (\n    \u003cdiv className=\"cart\"\u003e\n      \u003ch2\u003e购物车\u003c/h2\u003e\n      {items.length === 0 ? (\n        \u003cp\u003e购物车为空\u003c/p\u003e\n      ) : (\n        \u003c\u003e\n          {items.map(item =\u003e (\n            \u003cdiv key={item.id} className=\"cart-item\"\u003e\n              \u003cspan\u003e{item.name}\u003c/span\u003e\n              \u003cspan\u003e¥{item.price}\u003c/span\u003e\n              \u003cinput\n                type=\"number\"\n                value={item.quantity}\n                onChange={(e) =\u003e updateQuantity(item.id, parseInt(e.target.value))}\n                min=\"1\"\n              /\u003e\n              \u003cbutton onClick={() =\u003e removeItem(item.id)}\u003e删除\u003c/button\u003e\n            \u003c/div\u003e\n          ))}\n          \u003cdiv className=\"cart-total\"\u003e\n            \u003cp\u003e总计: ¥{getTotalPrice()}\u003c/p\u003e\n            \u003cbutton onClick={clearCart}\u003e清空购物车\u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **与 useReducer 结合使用**\n```jsx\nimport React, { createContext, useContext, useReducer } from 'react';\n\n// 定义 actions\nconst ACTIONS = {\n  SET_LOADING: 'SET_LOADING',\n  SET_USER: 'SET_USER',\n  SET_ERROR: 'SET_ERROR',\n  LOGOUT: 'LOGOUT'\n};\n\n// 定义 reducer\nfunction authReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.SET_LOADING:\n      return { ...state, loading: action.payload };\n    case ACTIONS.SET_USER:\n      return { ...state, user: action.payload, loading: false, error: null };\n    case ACTIONS.SET_ERROR:\n      return { ...state, error: action.payload, loading: false };\n    case ACTIONS.LOGOUT:\n      return { user: null, loading: false, error: null };\n    default:\n      return state;\n  }\n}\n\n// 初始状态\nconst initialState = {\n  user: null,\n  loading: false,\n  error: null\n};\n\n// 创建 Context\nconst AuthContext = createContext();\n\n// AuthProvider 组件\nfunction AuthProvider({ children }) {\n  const [state, dispatch] = useReducer(authReducer, initialState);\n\n  const login = async (email, password) =\u003e {\n    dispatch({ type: ACTIONS.SET_LOADING, payload: true });\n    \n    try {\n      // 模拟 API 调用\n      const response = await fetch('/api/login', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email, password })\n      });\n      \n      if (!response.ok) {\n        throw new Error('登录失败');\n      }\n      \n      const user = await response.json();\n      dispatch({ type: ACTIONS.SET_USER, payload: user });\n    } catch (error) {\n      dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\n    }\n  };\n\n  const logout = () =\u003e {\n    dispatch({ type: ACTIONS.LOGOUT });\n  };\n\n  const value = {\n    ...state,\n    login,\n    logout\n  };\n\n  return (\n    \u003cAuthContext.Provider value={value}\u003e\n      {children}\n    \u003c/AuthContext.Provider\u003e\n  );\n}\n\n// 自定义 Hook\nfunction useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth 必须在 AuthProvider 内部使用');\n  }\n  return context;\n}\n\n// 登录组件\nfunction LoginForm() {\n  const { login, loading, error } = useAuth();\n  const [email, setEmail] = useState('');\n  const [password, setPassword] = useState('');\n\n  const handleSubmit = (e) =\u003e {\n    e.preventDefault();\n    login(email, password);\n  };\n\n  return (\n    \u003cform onSubmit={handleSubmit}\u003e\n      \u003cdiv\u003e\n        \u003cinput\n          type=\"email\"\n          placeholder=\"邮箱\"\n          value={email}\n          onChange={(e) =\u003e setEmail(e.target.value)}\n        /\u003e\n      \u003c/div\u003e\n      \u003cdiv\u003e\n        \u003cinput\n          type=\"password\"\n          placeholder=\"密码\"\n          value={password}\n          onChange={(e) =\u003e setPassword(e.target.value)}\n        /\u003e\n      \u003c/div\u003e\n      {error \u0026\u0026 \u003cp style={{ color: 'red' }}\u003e{error}\u003c/p\u003e}\n      \u003cbutton type=\"submit\" disabled={loading}\u003e\n        {loading ? '登录中...' : '登录'}\n      \u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n```\n\n\n### **性能优化**\n\n#### **避免不必要的重新渲染**\n```jsx\n// 问题：value 对象每次都会重新创建\nfunction BadProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  return (\n    \u003cUserContext.Provider value={{ user, setUser }}\u003e\n      {children}\n    \u003c/UserContext.Provider\u003e\n  );\n}\n\n// 解决方案：使用 useMemo 缓存 value\nfunction GoodProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  const value = useMemo(() =\u003e ({\n    user,\n    setUser\n  }), [user]);\n  \n  return (\n    \u003cUserContext.Provider value={value}\u003e\n      {children}\n    \u003c/UserContext.Provider\u003e\n  );\n}\n```\n\n#### **拆分 Context**\n```jsx\n// 拆分频繁变化和不常变化的数据\nconst UserDataContext = createContext(); // 用户信息（不常变）\nconst UserActionsContext = createContext(); // 用户操作（不变）\n\nfunction UserProvider({ children }) {\n  const [user, setUser] = useState(null);\n  \n  // 操作函数不会变化\n  const actions = useMemo(() =\u003e ({\n    login: (userData) =\u003e setUser(userData),\n    logout: () =\u003e setUser(null),\n    updateProfile: (updates) =\u003e setUser(prev =\u003e ({ ...prev, ...updates }))\n  }), []);\n\n  return (\n    \u003cUserActionsContext.Provider value={actions}\u003e\n      \u003cUserDataContext.Provider value={user}\u003e\n        {children}\n      \u003c/UserDataContext.Provider\u003e\n    \u003c/UserActionsContext.Provider\u003e\n  );\n}\n\n// 分别获取数据和操作\nfunction useUserData() {\n  return useContext(UserDataContext);\n}\n\nfunction useUserActions() {\n  return useContext(UserActionsContext);\n}\n```\n\n\n### **类组件中的使用**\n\n#### **Consumer 组件**\n```jsx\n// 注意：Consumer 仍需要直接使用 Context\n// 因为类组件无法使用 Hook，需要导出 Context\nexport const ThemeContext = createContext(); // 需要导出供 Consumer 使用\n\nfunction MyClassComponent() {\n  return (\n    \u003cThemeContext.Consumer\u003e\n      {({ theme, toggleTheme }) =\u003e (\n        \u003cdiv style={{ background: theme === 'light' ? '#fff' : '#333' }}\u003e\n          \u003cbutton onClick={toggleTheme}\u003e切换主题\u003c/button\u003e\n        \u003c/div\u003e\n      )}\n    \u003c/ThemeContext.Consumer\u003e\n  );\n}\n```\n\n#### **contextType**\n```jsx\nclass MyClassComponent extends React.Component {\n  static contextType = ThemeContext; // 需要直接引用 Context\n\n  render() {\n    const { theme, toggleTheme } = this.context;\n    \n    return (\n      \u003cdiv style={{ background: theme === 'light' ? '#fff' : '#333' }}\u003e\n        \u003cbutton onClick={toggleTheme}\u003e切换主题\u003c/button\u003e\n      \u003c/div\u003e\n    );\n  }\n}\n\n// 推荐：将类组件改为函数组件，使用自定义 Hook\nfunction MyFunctionComponent() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    \u003cdiv style={{ background: theme === 'light' ? '#fff' : '#333' }}\u003e\n      \u003cbutton onClick={toggleTheme}\u003e切换主题\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n### **完整的自定义 Hook 最佳实践示例**\n```jsx\n// contexts/ThemeContext.js\nimport React, { createContext, useContext, useState, useMemo } from 'react';\n\n// Context 保持私有\nconst ThemeContext = createContext();\n\n// Provider 组件\nexport function ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () =\u003e {\n    setTheme(prev =\u003e prev === 'light' ? 'dark' : 'light');\n  };\n\n  // 性能优化：缓存 Context value\n  const value = useMemo(() =\u003e ({\n    theme,\n    toggleTheme\n  }), [theme]);\n\n  return (\n    \u003cThemeContext.Provider value={value}\u003e\n      {children}\n    \u003c/ThemeContext.Provider\u003e\n  );\n}\n\n// 自定义 Hook（包含错误检查）\nexport function useTheme() {\n  const context = useContext(ThemeContext);\n  \n  if (!context) {\n    throw new Error('useTheme 必须在 ThemeProvider 内部使用');\n  }\n  \n  return context;\n}\n\n// 可选：为 TypeScript 提供类型\nexport type Theme = 'light' | 'dark';\nexport interface ThemeContextType {\n  theme: Theme;\n  toggleTheme: () =\u003e void;\n}\n```\n\n```jsx\n// components/App.js\nimport React from 'react';\nimport { ThemeProvider } from '../contexts/ThemeContext';\nimport Header from './Header';\nimport Content from './Content';\n\nfunction App() {\n  return (\n    \u003cThemeProvider\u003e\n      \u003cHeader /\u003e\n      \u003cContent /\u003e\n    \u003c/ThemeProvider\u003e\n  );\n}\n\nexport default App;\n```\n\n```jsx\n// components/Header.js\nimport React from 'react';\nimport { useTheme } from '../contexts/ThemeContext';\n\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n\n  return (\n    \u003cheader style={{\n      background: theme === 'light' ? '#fff' : '#333',\n      color: theme === 'light' ? '#333' : '#fff'\n    }}\u003e\n      \u003ch1\u003e我的应用\u003c/h1\u003e\n      \u003cbutton onClick={toggleTheme}\u003e\n        切换主题\n      \u003c/button\u003e\n    \u003c/header\u003e\n  );\n}\n\nexport default Header;\n```\n\n\n### **最佳实践**\n\n1. **使用自定义 Hook 而非直接使用 Context**\n   - 提供更好的封装性和错误检查\n   - 让 Context 保持私有，不暴露实现细节\n\n2. **合理使用 Context**\n   - 只在真正需要跨多层组件传递数据时使用\n   - 避免将所有状态都放入 Context\n\n3. **创建专用的 Provider 组件**\n   - 封装 Context 的创建和状态管理逻辑\n   - 提供清晰的 API\n\n4. **性能优化**\n   - 使用 useMemo 缓存 Context value\n   - 拆分频繁变化和不常变化的数据\n\n5. **错误处理**\n   - 在自定义 Hook 中检查 Context 是否存在\n   - 提供有意义的错误信息\n\n6. **文件组织**\n   - 将每个 Context 放在单独的文件中\n   - 导出 Provider 和自定义 Hook，不导出 Context 本身\n\n\n### **注意事项**\n\n- **性能影响**：Context 值改变会导致所有消费组件重新渲染\n- **不要过度使用**：简单的 props 传递可能比 Context 更合适\n- **默认值限制**：defaultValue 只在没有 Provider 时生效\n- **嵌套 Provider**：同一 Context 的多个 Provider 会形成嵌套关系\n- **测试复杂性**：Context 可能增加组件测试的复杂度\n\n`React.createContext` 是管理跨组件状态的强大工具，但应该在合适的场景下使用，避免过度设计导致应用复杂性增加。"])</script><script>self.__next_f.push([1,"31:T1377,"])</script><script>self.__next_f.push([1,"\r\n`React.memo` 是 React 提供的一个高阶组件，用于优化函数组件的性能，避免不必要的重新渲染。\r\n\r\n\r\n### **基本作用**\r\n`React.memo` 会对组件的**前后 props** 进行浅比较（Shallow Comparison）。如果 props 没有变化，React 会复用之前的渲染结果，跳过组件的重新渲染，从而提升性能。\r\n\r\n```jsx\r\nconst MyComponent = React.memo(function MyComponent(props) {\r\n  // 组件逻辑\r\n});\r\n```\r\n\r\n\r\n### **浅比较（Shallow Comparison）**\r\n浅比较只检查对象或数组的引用是否相同，不比较其内部属性。例如：\r\n\r\n```jsx\r\n// 示例1：props 引用未变，不会重新渲染\r\n\u003cMyComponent data={someData} /\u003e // 第一次渲染\r\n\u003cMyComponent data={someData} /\u003e // 第二次渲染，data 引用相同，跳过渲染\r\n\r\n// 示例2：props 引用改变，会重新渲染\r\n\u003cMyComponent data={[1, 2, 3]} /\u003e // 第一次渲染\r\n\u003cMyComponent data={[1, 2, 3]} /\u003e // 第二次渲染，data 是新数组，触发渲染\r\n```\r\n\r\n\r\n### **自定义比较函数**\r\n你可以通过第二个参数传入自定义比较函数，控制是否跳过渲染：\r\n\r\n```jsx\r\nconst MyComponent = React.memo(\r\n  function MyComponent(props) {\r\n    // 组件逻辑\r\n  },\r\n  (prevProps, nextProps) =\u003e {\r\n    // 如果返回 true，跳过渲染；返回 false，触发渲染\r\n    return prevProps.someProp === nextProps.someProp;\r\n  }\r\n);\r\n```\r\n\r\n\r\n### **与 `shouldComponentUpdate` 的区别**\r\n- `React.memo` 用于**函数组件**，只比较 props。\r\n- `shouldComponentUpdate` 用于**类组件**，可以比较 props 和 state。\r\n\r\n\r\n### **与 `useMemo` 的区别**\r\n虽然都用于性能优化，但 `React.memo` 和 `useMemo` 的作用范围和使用场景完全不同：\r\n\r\n| 特性 | React.memo | useMemo |\r\n|------|------------|---------|\r\n| **用途** | 优化组件渲染 | 优化计算结果 |\r\n| **对象** | 整个组件 | 计算值/对象 |\r\n| **比较内容** | props | 依赖数组 |\r\n| **返回值** | 组件 | 计算结果 |\r\n| **使用位置** | 组件定义外部 | 组件内部 |\r\n\r\n```jsx\r\n// React.memo：防止组件重新渲染\r\nconst ExpensiveComponent = React.memo(({ data }) =\u003e {\r\n  return \u003cdiv\u003e{data.map(item =\u003e \u003cspan key={item.id}\u003e{item.name}\u003c/span\u003e)}\u003c/div\u003e;\r\n});\r\n\r\nfunction ParentComponent() {\r\n  const [count, setCount] = useState(0);\r\n  const [items] = useState([{ id: 1, name: 'Item 1' }]);\r\n\r\n  // useMemo：缓存计算结果\r\n  const processedItems = useMemo(() =\u003e {\r\n    return items.map(item =\u003e ({ ...item, processed: true }));\r\n  }, [items]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eCount: {count}\u003c/button\u003e\r\n      {/* React.memo 防止 ExpensiveComponent 因 count 变化而重新渲染 */}\r\n      \u003cExpensiveComponent data={processedItems} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n**配合使用**：\r\n```jsx\r\n// 使用 useMemo 提供稳定的 props 引用\r\nconst ParentComponent = () =\u003e {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  // useMemo 确保 config 对象引用稳定\r\n  const config = useMemo(() =\u003e ({\r\n    theme: 'dark',\r\n    pageSize: 10\r\n  }), []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eCount: {count}\u003c/button\u003e\r\n      {/* React.memo 防止不必要的重新渲染 */}\r\n      \u003cMemoizedChild config={config} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n};\r\n\r\nconst MemoizedChild = React.memo(({ config }) =\u003e {\r\n  return \u003cdiv\u003e配置主题: {config.theme}\u003c/div\u003e;\r\n});\r\n```\r\n\r\n\r\n### **注意事项**\r\n1. **仅用于纯组件**：确保组件在相同 props 下返回相同结果。\r\n2. **避免内联函数/对象**：\r\n```jsx\r\n// 每次渲染都会创建新的 onClick 函数，导致 memo 失效\r\n\u003cMyComponent onClick={() =\u003e console.log('Click')} /\u003e\r\n\r\n// 改进：将函数提取到组件外部或使用 useCallback\r\nconst handleClick = useCallback(() =\u003e console.log('Click'), []);\r\n\u003cMyComponent onClick={handleClick} /\u003e\r\n   ```\r\n3. **不比较 state 变化**：`React.memo` 只关注 props，组件内部 state 变化仍会触发重新渲染。\r\n\r\n\r\n### **适用场景**\r\n- 组件频繁渲染，但 props 变化较少。\r\n- 组件树较大，优化渲染性能。\r\n- 静态展示组件（如列表项、卡片）。\r\n\r\n\r\n### **示例代码**\r\n以下是一个使用 `React.memo` 的简单示例：\r\n\r\n```jsx\r\nimport React from 'react';\r\n\r\n// 使用 React.memo 包装组件\r\nconst UserCard = React.memo(({ name, age }) =\u003e {\r\n  console.log('UserCard 渲染');\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003e{name}\u003c/h3\u003e\r\n      \u003cp\u003e年龄: {age}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// 父组件\r\nfunction App() {\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e\r\n        点击: {count}\r\n      \u003c/button\u003e\r\n      {/* 即使 count 变化，UserCard 也不会重新渲染 */}\r\n      \u003cUserCard name=\"张三\" age={25} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n在这个例子中，点击按钮会更新 `count`，但 `UserCard` 的 props 没有变化，因此不会触发重新渲染。"])</script><script>self.__next_f.push([1,"32:T2bbb,"])</script><script>self.__next_f.push([1,"\r\n`useCallback` 是 React 提供的性能优化 Hook，用于缓存函数定义，避免子组件因为函数引用变化而不必要的重新渲染。它返回一个记忆化的回调函数，只有当依赖项改变时才会更新。\r\n\r\n\r\n### **基本作用**\r\n`useCallback` 的主要作用是：\r\n- 缓存函数定义，避免每次渲染时创建新的函数实例\r\n- 与 `React.memo` 配合使用，优化子组件性能\r\n- 在依赖项不变的情况下，返回相同的函数引用\r\n\r\n```jsx\r\nimport React, { useCallback, useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [count, setCount] = useState(0);\r\n  \r\n  // 使用 useCallback 缓存函数\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log('按钮被点击');\r\n  }, []); // 空依赖数组，函数永不更新\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={handleClick}\u003e点击\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **基本语法**\r\n```jsx\r\nconst memoizedCallback = useCallback(\r\n  () =\u003e {\r\n    // 函数体\r\n    doSomething(a, b);\r\n  },\r\n  [a, b] // 依赖数组\r\n);\r\n```\r\n\r\n- **第一个参数**：要缓存的函数\r\n- **第二个参数**：依赖数组，当数组中的值改变时，函数会重新创建\r\n\r\n\r\n### **与普通函数的对比**\r\n\r\n#### **不使用 useCallback（问题示例）**\r\n```jsx\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('张三');\r\n\r\n  // 每次渲染都会创建新的函数\r\n  const handleNameChange = (newName) =\u003e {\r\n    setName(newName);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n      {/* 即使 name 没变，Child 也会重新渲染 */}\r\n      \u003cChild onNameChange={handleNameChange} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst Child = React.memo(({ onNameChange }) =\u003e {\r\n  console.log('Child 组件重新渲染');\r\n  return \u003cbutton onClick={() =\u003e onNameChange('李四')}\u003e改名\u003c/button\u003e;\r\n});\r\n```\r\n\r\n#### **使用 useCallback（优化后）**\r\n```jsx\r\nfunction Parent() {\r\n  const [count, setCount] = useState(0);\r\n  const [name, setName] = useState('张三');\r\n\r\n  // 使用 useCallback 缓存函数\r\n  const handleNameChange = useCallback((newName) =\u003e {\r\n    setName(newName);\r\n  }, []); // name 更新通过参数传入，不需要依赖\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n      {/* count 变化时，Child 不会重新渲染 */}\r\n      \u003cChild onNameChange={handleNameChange} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **依赖数组的使用**\r\n\r\n#### **空依赖数组**\r\n```jsx\r\n// 函数永远不会重新创建\r\nconst handleClick = useCallback(() =\u003e {\r\n  console.log('这个函数永远不变');\r\n}, []);\r\n```\r\n\r\n#### **有依赖的情况**\r\n```jsx\r\nfunction SearchComponent() {\r\n  const [query, setQuery] = useState('');\r\n  const [filter, setFilter] = useState('all');\r\n\r\n  // 当 query 或 filter 改变时，函数会重新创建\r\n  const handleSearch = useCallback(() =\u003e {\r\n    console.log(`搜索: ${query}, 过滤: ${filter}`);\r\n  }, [query, filter]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput value={query} onChange={(e) =\u003e setQuery(e.target.value)} /\u003e\r\n      \u003cSearchButton onSearch={handleSearch} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **实际应用场景**\r\n\r\n#### **优化列表渲染**\r\n```jsx\r\nfunction TodoList() {\r\n  const [todos, setTodos] = useState([]);\r\n\r\n  // 删除项目的函数\r\n  const handleDelete = useCallback((id) =\u003e {\r\n    setTodos(prev =\u003e prev.filter(todo =\u003e todo.id !== id));\r\n  }, []); // 使用函数式更新，不需要依赖 todos\r\n\r\n  // 切换完成状态\r\n  const handleToggle = useCallback((id) =\u003e {\r\n    setTodos(prev =\u003e \r\n      prev.map(todo =\u003e \r\n        todo.id === id ? { ...todo, done: !todo.done } : todo\r\n      )\r\n    );\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {todos.map(todo =\u003e (\r\n        \u003cTodoItem\r\n          key={todo.id}\r\n          todo={todo}\r\n          onDelete={handleDelete}\r\n          onToggle={handleToggle}\r\n        /\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst TodoItem = React.memo(({ todo, onDelete, onToggle }) =\u003e {\r\n  console.log(`TodoItem ${todo.id} 渲染`);\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cspan\u003e{todo.text}\u003c/span\u003e\r\n      \u003cbutton onClick={() =\u003e onToggle(todo.id)}\u003e\r\n        {todo.done ? '未完成' : '完成'}\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e onDelete(todo.id)}\u003e删除\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n#### **表单处理优化**\r\n```jsx\r\nfunction UserForm() {\r\n  const [formData, setFormData] = useState({\r\n    name: '',\r\n    email: '',\r\n    age: ''\r\n  });\r\n\r\n  // 通用的字段更新函数\r\n  const handleFieldChange = useCallback((field) =\u003e {\r\n    return (value) =\u003e {\r\n      setFormData(prev =\u003e ({\r\n        ...prev,\r\n        [field]: value\r\n      }));\r\n    };\r\n  }, []);\r\n\r\n  // 提交函数\r\n  const handleSubmit = useCallback(() =\u003e {\r\n    console.log('提交表单:', formData);\r\n  }, [formData]);\r\n\r\n  return (\r\n    \u003cform\u003e\r\n      \u003cFormField\r\n        label=\"姓名\"\r\n        value={formData.name}\r\n        onChange={handleFieldChange('name')}\r\n      /\u003e\r\n      \u003cFormField\r\n        label=\"邮箱\"\r\n        value={formData.email}\r\n        onChange={handleFieldChange('email')}\r\n      /\u003e\r\n      \u003cbutton type=\"button\" onClick={handleSubmit}\u003e\r\n        提交\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n\r\nconst FormField = React.memo(({ label, value, onChange }) =\u003e {\r\n  console.log(`FormField ${label} 渲染`);\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003clabel\u003e{label}\u003c/label\u003e\r\n      \u003cinput\r\n        value={value}\r\n        onChange={(e) =\u003e onChange(e.target.value)}\r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n\r\n### **与其他 Hook 的配合使用**\r\n\r\n#### **与 useMemo 的区别**\r\n```jsx\r\nfunction MyComponent({ items }) {\r\n  // useMemo 缓存计算结果\r\n  const expensiveValue = useMemo(() =\u003e {\r\n    return items.reduce((sum, item) =\u003e sum + item.value, 0);\r\n  }, [items]);\r\n\r\n  // useCallback 缓存函数定义\r\n  const handleSort = useCallback(() =\u003e {\r\n    return items.sort((a, b) =\u003e a.value - b.value);\r\n  }, [items]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e总计: {expensiveValue}\u003c/p\u003e\r\n      \u003cbutton onClick={handleSort}\u003e排序\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **与 useEffect 结合**\r\n```jsx\r\nfunction DataFetcher({ userId }) {\r\n  const [data, setData] = useState(null);\r\n\r\n  // 缓存获取数据的函数\r\n  const fetchData = useCallback(async () =\u003e {\r\n    try {\r\n      const response = await fetch(`/api/users/${userId}`);\r\n      const userData = await response.json();\r\n      setData(userData);\r\n    } catch (error) {\r\n      console.error('获取数据失败:', error);\r\n    }\r\n  }, [userId]);\r\n\r\n  useEffect(() =\u003e {\r\n    fetchData();\r\n  }, [fetchData]); // fetchData 作为依赖\r\n\r\n  return \u003cdiv\u003e{data ? data.name : '加载中...'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **常见陷阱和解决方案**\r\n\r\n#### **忘记添加依赖项**\r\n```jsx\r\nfunction BadExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 错误：缺少 count 依赖\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log(count); // 这里总是打印初始值 0\r\n  }, []); // 应该是 [count]\r\n\r\n  return \u003cbutton onClick={handleClick}\u003e点击\u003c/button\u003e;\r\n}\r\n\r\nfunction GoodExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 正确：包含所有依赖\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log(count);\r\n  }, [count]);\r\n\r\n  return \u003cbutton onClick={handleClick}\u003e点击\u003c/button\u003e;\r\n}\r\n```\r\n\r\n#### **避免过度优化**\r\n```jsx\r\n// 不必要的优化\r\nfunction OverOptimized() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 这个组件很简单，不需要 useCallback\r\n  const handleClick = useCallback(() =\u003e {\r\n    setCount(prev =\u003e prev + 1);\r\n  }, []);\r\n\r\n  return \u003cbutton onClick={handleClick}\u003e{count}\u003c/button\u003e;\r\n}\r\n\r\n// 简单直接的写法\r\nfunction Simple() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    \u003cbutton onClick={() =\u003e setCount(prev =\u003e prev + 1)}\u003e\r\n      {count}\r\n    \u003c/button\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **性能测试示例**\r\n```jsx\r\nimport React, { useCallback, useState, useRef } from 'react';\r\n\r\nfunction PerformanceTest() {\r\n  const [count, setCount] = useState(0);\r\n  const renderCountRef = useRef(0);\r\n\r\n  // 有 useCallback 的版本\r\n  const optimizedHandler = useCallback(() =\u003e {\r\n    console.log('优化版本被调用');\r\n  }, []);\r\n\r\n  // 没有 useCallback 的版本\r\n  const unoptimizedHandler = () =\u003e {\r\n    console.log('未优化版本被调用');\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e父组件渲染次数: {++renderCountRef.current}\u003c/p\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加计数\u003c/button\u003e\r\n      \r\n      \u003cOptimizedChild handler={optimizedHandler} /\u003e\r\n      \u003cUnoptimizedChild handler={unoptimizedHandler} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst OptimizedChild = React.memo(({ handler }) =\u003e {\r\n  const renderCount = useRef(0);\r\n  console.log('OptimizedChild 渲染次数:', ++renderCount.current);\r\n  \r\n  return \u003cbutton onClick={handler}\u003e优化版本\u003c/button\u003e;\r\n});\r\n\r\nconst UnoptimizedChild = React.memo(({ handler }) =\u003e {\r\n  const renderCount = useRef(0);\r\n  console.log('UnoptimizedChild 渲染次数:', ++renderCount.current);\r\n  \r\n  return \u003cbutton onClick={handler}\u003e未优化版本\u003c/button\u003e;\r\n});\r\n```\r\n\r\n\r\n### **自定义 Hook 中的使用**\r\n```jsx\r\nfunction useAPI(url) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const fetchData = useCallback(async () =\u003e {\r\n    setLoading(true);\r\n    try {\r\n      const response = await fetch(url);\r\n      const result = await response.json();\r\n      setData(result);\r\n    } catch (error) {\r\n      console.error('API 调用失败:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [url]);\r\n\r\n  const refresh = useCallback(() =\u003e {\r\n    fetchData();\r\n  }, [fetchData]);\r\n\r\n  useEffect(() =\u003e {\r\n    fetchData();\r\n  }, [fetchData]);\r\n\r\n  return { data, loading, refresh };\r\n}\r\n\r\n// 使用自定义 Hook\r\nfunction UserProfile({ userId }) {\r\n  const { data, loading, refresh } = useAPI(`/api/users/${userId}`);\r\n\r\n  if (loading) return \u003cdiv\u003e加载中...\u003c/div\u003e;\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch1\u003e{data?.name}\u003c/h1\u003e\r\n      \u003cbutton onClick={refresh}\u003e刷新\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **最佳实践**\r\n1. **与 React.memo 配合使用**：useCallback 的主要价值在于防止子组件不必要的重新渲染\r\n2. **正确设置依赖项**：包含回调函数中使用的所有变量\r\n3. **避免过度优化**：不是所有函数都需要用 useCallback 包装\r\n4. **使用函数式更新**：减少对状态的依赖，提高函数的稳定性\r\n5. **考虑替代方案**：有时重构组件结构比使用 useCallback 更好\r\n\r\n\r\n### **注意事项**\r\n- **内存开销**：缓存函数会占用额外内存\r\n- **依赖追踪**：确保 ESLint 规则 `exhaustive-deps` 开启\r\n- **浅比较**：依赖数组使用浅比较，注意对象和数组的引用\r\n- **调试困难**：过度使用可能使代码难以理解和调试\r\n\r\n`useCallback` 是 React 性能优化的重要工具，但应该在合适的场景下使用，避免过度优化导致代码复杂性增加。\r\n"])</script><script>self.__next_f.push([1,"33:T32e8,"])</script><script>self.__next_f.push([1,"\r\n`useEffect` 是 React 最重要的 Hook 之一，用于处理副作用操作。它结合了类组件中 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount` 的功能，让函数组件能够执行数据获取、订阅设置、DOM 操作等副作用。\r\n\r\n\r\n### **基本作用**\r\n`useEffect` 的主要作用是：\r\n- 执行副作用操作（数据获取、订阅、DOM 操作等）\r\n- 在组件渲染后执行代码\r\n- 处理组件的生命周期事件\r\n- 清理资源，防止内存泄漏\r\n\r\n```jsx\r\nimport React, { useEffect, useState } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 基本的 useEffect\r\n  useEffect(() =\u003e {\r\n    document.title = `计数: ${count}`;\r\n  });\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e当前计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **基本语法**\r\n```jsx\r\nuseEffect(() =\u003e {\r\n  // 副作用代码\r\n  \r\n  return () =\u003e {\r\n    // 清理代码（可选）\r\n  };\r\n}, [dependencies]); // 依赖数组（可选）\r\n```\r\n\r\n- **第一个参数**：副作用函数\r\n- **第二个参数**：依赖数组（可选）\r\n- **返回值**：清理函数（可选）\r\n\r\n\r\n### **不同的使用模式**\r\n\r\n#### **每次渲染后执行**\r\n```jsx\r\nfunction Component() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 没有依赖数组，每次渲染后都会执行\r\n  useEffect(() =\u003e {\r\n    console.log('组件渲染了');\r\n  });\r\n\r\n  return \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e{count}\u003c/button\u003e;\r\n}\r\n```\r\n\r\n#### **仅在挂载时执行**\r\n```jsx\r\nfunction Component() {\r\n  const [data, setData] = useState(null);\r\n\r\n  // 空依赖数组，只在组件挂载时执行一次\r\n  useEffect(() =\u003e {\r\n    console.log('组件挂载了');\r\n    \r\n    // 获取数据\r\n    fetch('/api/data')\r\n      .then(response =\u003e response.json())\r\n      .then(data =\u003e setData(data));\r\n  }, []); // 空依赖数组\r\n\r\n  return \u003cdiv\u003e{data ? JSON.stringify(data) : '加载中...'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **依赖特定值的变化**\r\n```jsx\r\nfunction Component({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n\r\n  // 当 userId 变化时执行\r\n  useEffect(() =\u003e {\r\n    console.log('userId 变化了:', userId);\r\n    \r\n    fetch(`/api/users/${userId}`)\r\n      .then(response =\u003e response.json())\r\n      .then(userData =\u003e setUser(userData));\r\n  }, [userId]); // 依赖 userId\r\n\r\n  return \u003cdiv\u003e{user ? user.name : '加载中...'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **清理副作用**\r\n\r\n#### **清理定时器**\r\n```jsx\r\nfunction Timer() {\r\n  const [seconds, setSeconds] = useState(0);\r\n\r\n  useEffect(() =\u003e {\r\n    const interval = setInterval(() =\u003e {\r\n      setSeconds(prev =\u003e prev + 1);\r\n    }, 1000);\r\n\r\n    // 清理函数：组件卸载时清除定时器\r\n    return () =\u003e {\r\n      clearInterval(interval);\r\n    };\r\n  }, []); // 空依赖，只设置一次\r\n\r\n  return \u003cdiv\u003e已运行 {seconds} 秒\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **清理事件监听器**\r\n```jsx\r\nfunction WindowSize() {\r\n  const [windowSize, setWindowSize] = useState({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight\r\n  });\r\n\r\n  useEffect(() =\u003e {\r\n    const handleResize = () =\u003e {\r\n      setWindowSize({\r\n        width: window.innerWidth,\r\n        height: window.innerHeight\r\n      });\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n\r\n    // 清理事件监听器\r\n    return () =\u003e {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, []);\r\n\r\n  return \u003cdiv\u003e窗口大小: {windowSize.width} x {windowSize.height}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **取消网络请求**\r\n```jsx\r\nfunction DataFetcher({ url }) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n\r\n  useEffect(() =\u003e {\r\n    const abortController = new AbortController();\r\n\r\n    const fetchData = async () =\u003e {\r\n      try {\r\n        setLoading(true);\r\n        const response = await fetch(url, {\r\n          signal: abortController.signal\r\n        });\r\n        const result = await response.json();\r\n        setData(result);\r\n      } catch (error) {\r\n        if (error.name !== 'AbortError') {\r\n          console.error('获取数据失败:', error);\r\n        }\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n\r\n    // 清理：取消请求\r\n    return () =\u003e {\r\n      abortController.abort();\r\n    };\r\n  }, [url]);\r\n\r\n  if (loading) return \u003cdiv\u003e加载中...\u003c/div\u003e;\r\n  return \u003cdiv\u003e{JSON.stringify(data)}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **常见应用场景**\r\n\r\n#### **数据获取**\r\n```jsx\r\nfunction UserList() {\r\n  const [users, setUsers] = useState([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() =\u003e {\r\n    const fetchUsers = async () =\u003e {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n        const response = await fetch('/api/users');\r\n        \r\n        if (!response.ok) {\r\n          throw new Error('获取用户列表失败');\r\n        }\r\n        \r\n        const userData = await response.json();\r\n        setUsers(userData);\r\n      } catch (err) {\r\n        setError(err.message);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchUsers();\r\n  }, []);\r\n\r\n  if (loading) return \u003cdiv\u003e加载中...\u003c/div\u003e;\r\n  if (error) return \u003cdiv\u003e错误: {error}\u003c/div\u003e;\r\n\r\n  return (\r\n    \u003cul\u003e\r\n      {users.map(user =\u003e (\r\n        \u003cli key={user.id}\u003e{user.name}\u003c/li\u003e\r\n      ))}\r\n    \u003c/ul\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **订阅外部数据源**\r\n```jsx\r\nfunction ChatRoom({ roomId }) {\r\n  const [messages, setMessages] = useState([]);\r\n\r\n  useEffect(() =\u003e {\r\n    const socket = new WebSocket(`ws://localhost:8080/chat/${roomId}`);\r\n\r\n    socket.onmessage = (event) =\u003e {\r\n      const message = JSON.parse(event.data);\r\n      setMessages(prev =\u003e [...prev, message]);\r\n    };\r\n\r\n    socket.onerror = (error) =\u003e {\r\n      console.error('WebSocket 错误:', error);\r\n    };\r\n\r\n    // 清理：关闭连接\r\n    return () =\u003e {\r\n      socket.close();\r\n    };\r\n  }, [roomId]); // roomId 变化时重新连接\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003e聊天室 {roomId}\u003c/h3\u003e\r\n      {messages.map((msg, index) =\u003e (\r\n        \u003cp key={index}\u003e{msg.text}\u003c/p\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **DOM 操作**\r\n```jsx\r\nfunction FocusInput() {\r\n  const [inputValue, setInputValue] = useState('');\r\n  const inputRef = useRef(null);\r\n\r\n  // 组件挂载后聚焦输入框\r\n  useEffect(() =\u003e {\r\n    if (inputRef.current) {\r\n      inputRef.current.focus();\r\n    }\r\n  }, []);\r\n\r\n  // 输入值变化时更新文档标题\r\n  useEffect(() =\u003e {\r\n    document.title = inputValue || '请输入内容';\r\n  }, [inputValue]);\r\n\r\n  return (\r\n    \u003cinput\r\n      ref={inputRef}\r\n      value={inputValue}\r\n      onChange={(e) =\u003e setInputValue(e.target.value)}\r\n      placeholder=\"输入内容\"\r\n    /\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **多个 useEffect 的使用**\r\n```jsx\r\nfunction UserProfile({ userId }) {\r\n  const [user, setUser] = useState(null);\r\n  const [posts, setPosts] = useState([]);\r\n  const [onlineStatus, setOnlineStatus] = useState(false);\r\n\r\n  // Effect 1: 获取用户信息\r\n  useEffect(() =\u003e {\r\n    fetch(`/api/users/${userId}`)\r\n      .then(response =\u003e response.json())\r\n      .then(userData =\u003e setUser(userData));\r\n  }, [userId]);\r\n\r\n  // Effect 2: 获取用户文章\r\n  useEffect(() =\u003e {\r\n    fetch(`/api/users/${userId}/posts`)\r\n      .then(response =\u003e response.json())\r\n      .then(postsData =\u003e setPosts(postsData));\r\n  }, [userId]);\r\n\r\n  // Effect 3: 订阅在线状态\r\n  useEffect(() =\u003e {\r\n    const subscription = subscribeToUserOnlineStatus(\r\n      userId,\r\n      setOnlineStatus\r\n    );\r\n\r\n    return () =\u003e {\r\n      subscription.unsubscribe();\r\n    };\r\n  }, [userId]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {user \u0026\u0026 (\r\n        \u003c\u003e\r\n          \u003ch1\u003e{user.name} {onlineStatus ? '🟢' : '🔴'}\u003c/h1\u003e\r\n          \u003cp\u003e文章数量: {posts.length}\u003c/p\u003e\r\n        \u003c/\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **条件执行 Effect**\r\n```jsx\r\nfunction ConditionalEffect({ shouldFetch, url }) {\r\n  const [data, setData] = useState(null);\r\n\r\n  useEffect(() =\u003e {\r\n    // 只有当 shouldFetch 为 true 时才执行\r\n    if (!shouldFetch) return;\r\n\r\n    fetch(url)\r\n      .then(response =\u003e response.json())\r\n      .then(result =\u003e setData(result));\r\n  }, [shouldFetch, url]);\r\n\r\n  return \u003cdiv\u003e{data ? JSON.stringify(data) : '暂无数据'}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **自定义 Hook 中的 useEffect**\r\n```jsx\r\n// 自定义 Hook：获取数据\r\nfunction useApi(url) {\r\n  const [data, setData] = useState(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() =\u003e {\r\n    let cancelled = false;\r\n\r\n    const fetchData = async () =\u003e {\r\n      try {\r\n        setLoading(true);\r\n        setError(null);\r\n        const response = await fetch(url);\r\n        const result = await response.json();\r\n        \r\n        if (!cancelled) {\r\n          setData(result);\r\n        }\r\n      } catch (err) {\r\n        if (!cancelled) {\r\n          setError(err.message);\r\n        }\r\n      } finally {\r\n        if (!cancelled) {\r\n          setLoading(false);\r\n        }\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n\r\n    return () =\u003e {\r\n      cancelled = true;\r\n    };\r\n  }, [url]);\r\n\r\n  return { data, loading, error };\r\n}\r\n\r\n// 使用自定义 Hook\r\nfunction UserComponent({ userId }) {\r\n  const { data: user, loading, error } = useApi(`/api/users/${userId}`);\r\n\r\n  if (loading) return \u003cdiv\u003e加载中...\u003c/div\u003e;\r\n  if (error) return \u003cdiv\u003e错误: {error}\u003c/div\u003e;\r\n  if (!user) return \u003cdiv\u003e用户不存在\u003c/div\u003e;\r\n\r\n  return \u003ch1\u003e{user.name}\u003c/h1\u003e;\r\n}\r\n```\r\n\r\n\r\n### **常见陷阱和解决方案**\r\n\r\n#### **无限循环**\r\n```jsx\r\n// 错误：会导致无限循环\r\nfunction BadExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() =\u003e {\r\n    setCount(count + 1); // 每次渲染都会增加 count\r\n  }); // 没有依赖数组\r\n\r\n  return \u003cdiv\u003e{count}\u003c/div\u003e;\r\n}\r\n\r\n// 正确：添加适当的依赖数组\r\nfunction GoodExample() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  useEffect(() =\u003e {\r\n    const timer = setTimeout(() =\u003e {\r\n      setCount(count + 1);\r\n    }, 1000);\r\n\r\n    return () =\u003e clearTimeout(timer);\r\n  }, [count]); // 依赖 count\r\n\r\n  return \u003cdiv\u003e{count}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **缺少依赖项**\r\n```jsx\r\nfunction SearchComponent() {\r\n  const [query, setQuery] = useState('');\r\n  const [results, setResults] = useState([]);\r\n\r\n  // 错误：缺少 query 依赖\r\n  useEffect(() =\u003e {\r\n    if (query) {\r\n      fetch(`/api/search?q=${query}`)\r\n        .then(response =\u003e response.json())\r\n        .then(data =\u003e setResults(data));\r\n    }\r\n  }, []); // 应该包含 [query]\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        value={query} \r\n        onChange={(e) =\u003e setQuery(e.target.value)} \r\n      /\u003e\r\n      {/* results 不会更新 */}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **性能优化技巧**\r\n\r\n#### **防抖搜索**\r\n```jsx\r\nfunction SearchWithDebounce() {\r\n  const [query, setQuery] = useState('');\r\n  const [results, setResults] = useState([]);\r\n\r\n  useEffect(() =\u003e {\r\n    if (!query) {\r\n      setResults([]);\r\n      return;\r\n    }\r\n\r\n    const timeoutId = setTimeout(() =\u003e {\r\n      fetch(`/api/search?q=${query}`)\r\n        .then(response =\u003e response.json())\r\n        .then(data =\u003e setResults(data));\r\n    }, 500); // 500ms 防抖\r\n\r\n    return () =\u003e clearTimeout(timeoutId);\r\n  }, [query]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        value={query}\r\n        onChange={(e) =\u003e setQuery(e.target.value)}\r\n        placeholder=\"搜索...\"\r\n      /\u003e\r\n      \u003cul\u003e\r\n        {results.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e{item.title}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **减少 Effect 执行**\r\n```jsx\r\nfunction OptimizedComponent({ user }) {\r\n  const [profile, setProfile] = useState(null);\r\n\r\n  // 使用 useMemo 避免不必要的依赖变化\r\n  const userId = useMemo(() =\u003e user?.id, [user?.id]);\r\n\r\n  useEffect(() =\u003e {\r\n    if (!userId) return;\r\n\r\n    fetch(`/api/profiles/${userId}`)\r\n      .then(response =\u003e response.json())\r\n      .then(data =\u003e setProfile(data));\r\n  }, [userId]); // 只有 userId 真正变化时才执行\r\n\r\n  return \u003cdiv\u003e{profile?.bio}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **最佳实践**\r\n1. **合理使用依赖数组**：包含 Effect 中使用的所有变量\r\n2. **分离关注点**：不同的副作用使用不同的 useEffect\r\n3. **及时清理**：返回清理函数防止内存泄漏\r\n4. **避免过度触发**：使用合适的依赖项减少不必要的执行\r\n5. **错误处理**：在异步操作中妥善处理错误\r\n\r\n\r\n### **注意事项**\r\n- **依赖项检查**：使用 ESLint 插件 `exhaustive-deps` 检查依赖\r\n- **异步操作**：Effect 函数本身不能是 async，需要在内部定义异步函数\r\n- **清理时机**：清理函数在组件卸载或依赖变化前执行\r\n- **执行时机**：Effect 在 DOM 更新后异步执行\r\n\r\n`useEffect` 是处理副作用的强大工具，正确使用能够让函数组件具备完整的生命周期能力。\r\n"])</script><script>self.__next_f.push([1,"34:T4be0,"])</script><script>self.__next_f.push([1,"\r\n`useMemo` 是 React 提供的性能优化 Hook，用于缓存计算结果，避免在每次渲染时重复执行昂贵的计算。它会返回一个记忆化的值，只有当依赖项改变时才会重新计算。\r\n\r\n\r\n### **基本作用**\r\n`useMemo` 的主要作用是：\r\n- 缓存计算结果，避免重复的昂贵计算\r\n- 优化组件性能，减少不必要的重新渲染\r\n- 在依赖项不变的情况下，返回相同的引用值\r\n- 与 `React.memo` 配合使用，优化子组件传值\r\n\r\n```jsx\r\nimport React, { useMemo, useState } from 'react';\r\n\r\nfunction MyComponent({ items }) {\r\n  const [filter, setFilter] = useState('');\r\n\r\n  // 使用 useMemo 缓存过滤结果\r\n  const filteredItems = useMemo(() =\u003e {\r\n    console.log('执行过滤计算');\r\n    return items.filter(item =\u003e \r\n      item.name.toLowerCase().includes(filter.toLowerCase())\r\n    );\r\n  }, [items, filter]); // 依赖 items 和 filter\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        value={filter}\r\n        onChange={(e) =\u003e setFilter(e.target.value)}\r\n        placeholder=\"搜索...\"\r\n      /\u003e\r\n      \u003cul\u003e\r\n        {filteredItems.map(item =\u003e (\r\n          \u003cli key={item.id}\u003e{item.name}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **基本语法**\r\n```jsx\r\nconst memoizedValue = useMemo(() =\u003e {\r\n  // 计算逻辑\r\n  return expensiveCalculation(a, b);\r\n}, [a, b]); // 依赖数组\r\n```\r\n\r\n- **第一个参数**：计算函数，返回要缓存的值\r\n- **第二个参数**：依赖数组，当数组中的值改变时，重新计算\r\n\r\n\r\n### **与普通计算的对比**\r\n\r\n#### **不使用 useMemo（问题示例）**\r\n```jsx\r\nfunction ExpensiveComponent({ data, threshold }) {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 每次渲染都会执行这个昂贵的计算\r\n  const expensiveValue = data\r\n    .filter(item =\u003e item.value \u003e threshold)\r\n    .reduce((sum, item) =\u003e sum + item.value, 0);\r\n\r\n  console.log('计算执行了'); // 每次渲染都会打印\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e昂贵计算结果: {expensiveValue}\u003c/p\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加计数\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **使用 useMemo（优化后）**\r\n```jsx\r\nfunction OptimizedComponent({ data, threshold }) {\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 只有当 data 或 threshold 变化时才重新计算\r\n  const expensiveValue = useMemo(() =\u003e {\r\n    console.log('计算执行了'); // 只在依赖变化时打印\r\n    return data\r\n      .filter(item =\u003e item.value \u003e threshold)\r\n      .reduce((sum, item) =\u003e sum + item.value, 0);\r\n  }, [data, threshold]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e昂贵计算结果: {expensiveValue}\u003c/p\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加计数\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **实际应用场景**\r\n\r\n#### **复杂数据处理**\r\n```jsx\r\nfunction DataAnalytics({ salesData, dateRange, category }) {\r\n  // 数据过滤和聚合\r\n  const processedData = useMemo(() =\u003e {\r\n    console.log('处理数据...');\r\n    \r\n    return salesData\r\n      .filter(sale =\u003e {\r\n        const saleDate = new Date(sale.date);\r\n        return saleDate \u003e= dateRange.start \u0026\u0026 \r\n               saleDate \u003c= dateRange.end \u0026\u0026\r\n               sale.category === category;\r\n      })\r\n      .reduce((acc, sale) =\u003e {\r\n        const month = sale.date.substr(0, 7);\r\n        acc[month] = (acc[month] || 0) + sale.amount;\r\n        return acc;\r\n      }, {});\r\n  }, [salesData, dateRange, category]);\r\n\r\n  // 计算统计数据\r\n  const statistics = useMemo(() =\u003e {\r\n    const values = Object.values(processedData);\r\n    return {\r\n      total: values.reduce((sum, val) =\u003e sum + val, 0),\r\n      average: values.length ? values.reduce((sum, val) =\u003e sum + val, 0) / values.length : 0,\r\n      max: Math.max(...values),\r\n      min: Math.min(...values)\r\n    };\r\n  }, [processedData]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003e销售分析\u003c/h3\u003e\r\n      \u003cp\u003e总计: {statistics.total}\u003c/p\u003e\r\n      \u003cp\u003e平均: {statistics.average.toFixed(2)}\u003c/p\u003e\r\n      \u003cp\u003e最高: {statistics.max}\u003c/p\u003e\r\n      \u003cp\u003e最低: {statistics.min}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **搜索和排序**\r\n```jsx\r\nfunction ProductList({ products, searchTerm, sortBy, sortOrder }) {\r\n  // 搜索过滤\r\n  const filteredProducts = useMemo(() =\u003e {\r\n    if (!searchTerm) return products;\r\n    \r\n    return products.filter(product =\u003e\r\n      product.name.toLowerCase().includes(searchTerm.toLowerCase()) ||\r\n      product.description.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }, [products, searchTerm]);\r\n\r\n  // 排序\r\n  const sortedProducts = useMemo(() =\u003e {\r\n    const sorted = [...filteredProducts].sort((a, b) =\u003e {\r\n      let aValue = a[sortBy];\r\n      let bValue = b[sortBy];\r\n\r\n      if (typeof aValue === 'string') {\r\n        aValue = aValue.toLowerCase();\r\n        bValue = bValue.toLowerCase();\r\n      }\r\n\r\n      if (aValue \u003c bValue) return sortOrder === 'asc' ? -1 : 1;\r\n      if (aValue \u003e bValue) return sortOrder === 'asc' ? 1 : -1;\r\n      return 0;\r\n    });\r\n\r\n    return sorted;\r\n  }, [filteredProducts, sortBy, sortOrder]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e找到 {sortedProducts.length} 个产品\u003c/p\u003e\r\n      {sortedProducts.map(product =\u003e (\r\n        \u003cdiv key={product.id}\u003e\r\n          \u003ch4\u003e{product.name}\u003c/h4\u003e\r\n          \u003cp\u003e{product.description}\u003c/p\u003e\r\n          \u003cp\u003e价格: ¥{product.price}\u003c/p\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **避免子组件重新渲染**\r\n```jsx\r\nfunction ParentComponent() {\r\n  const [count, setCount] = useState(0);\r\n  const [users, setUsers] = useState([]);\r\n\r\n  // 没有 useMemo：每次渲染都创建新的配置对象\r\n  const badConfig = {\r\n    pageSize: 10,\r\n    sortBy: 'name'\r\n  };\r\n\r\n  // 使用 useMemo：配置对象引用稳定\r\n  const config = useMemo(() =\u003e ({\r\n    pageSize: 10,\r\n    sortBy: 'name'\r\n  }), []); // 空依赖，配置永不变化\r\n\r\n  // 用户列表的计算逻辑\r\n  const processedUsers = useMemo(() =\u003e {\r\n    return users.map(user =\u003e ({\r\n      ...user,\r\n      displayName: `${user.firstName} ${user.lastName}`,\r\n      isActive: user.lastLogin \u003e Date.now() - 30 * 24 * 60 * 60 * 1000\r\n    }));\r\n  }, [users]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n      \r\n      {/* 使用 badConfig 会导致 UserList 每次都重新渲染 */}\r\n      \u003cUserList users={processedUsers} config={config} /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nconst UserList = React.memo(({ users, config }) =\u003e {\r\n  console.log('UserList 渲染');\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      {users.slice(0, config.pageSize).map(user =\u003e (\r\n        \u003cdiv key={user.id}\u003e\r\n          {user.displayName} {user.isActive ? '🟢' : '🔴'}\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n\r\n### **与 useCallback 的对比**\r\n\r\n#### **useMemo vs useCallback**\r\n```jsx\r\nfunction ComparisonExample({ items }) {\r\n  // useMemo：缓存计算结果（值）\r\n  const expensiveValue = useMemo(() =\u003e {\r\n    return items.reduce((sum, item) =\u003e sum + item.value, 0);\r\n  }, [items]);\r\n\r\n  // useCallback：缓存函数定义\r\n  const handleClick = useCallback(() =\u003e {\r\n    console.log('按钮被点击');\r\n  }, []);\r\n\r\n  // 等价写法\r\n  const memoizedCallback = useMemo(() =\u003e {\r\n    return () =\u003e console.log('按钮被点击');\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e总计: {expensiveValue}\u003c/p\u003e\r\n      \u003cbutton onClick={handleClick}\u003e点击\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **与 `React.memo` 的区别**\r\n`useMemo` 和 `React.memo` 都是性能优化工具，但它们解决的问题和使用方式完全不同：\r\n\r\n| 特性 | useMemo | React.memo |\r\n|------|---------|------------|\r\n| **优化目标** | 计算过程 | 组件渲染 |\r\n| **作用范围** | 组件内部的值 | 整个组件 |\r\n| **使用位置** | 组件内部（Hook） | 组件定义外部（HOC） |\r\n| **触发条件** | 依赖数组变化 | props 变化 |\r\n| **返回类型** | 任意值 | React 组件 |\r\n\r\n```jsx\r\n// React.memo：组件级别的优化\r\nconst ProductCard = React.memo(({ product, onAddToCart }) =\u003e {\r\n  console.log('ProductCard 渲染');\r\n  \r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch3\u003e{product.name}\u003c/h3\u003e\r\n      \u003cp\u003e价格: ¥{product.price}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e onAddToCart(product.id)}\u003e\r\n        加入购物车\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// useMemo：值级别的优化\r\nfunction ProductList({ products, category, searchTerm }) {\r\n  console.log('ProductList 渲染');\r\n\r\n  // useMemo 缓存过滤结果\r\n  const filteredProducts = useMemo(() =\u003e {\r\n    console.log('执行过滤计算');\r\n    return products\r\n      .filter(p =\u003e p.category === category)\r\n      .filter(p =\u003e p.name.includes(searchTerm));\r\n  }, [products, category, searchTerm]);\r\n\r\n  // useMemo 缓存回调函数，配合 React.memo 使用\r\n  const handleAddToCart = useMemo(() =\u003e {\r\n    return (productId) =\u003e {\r\n      console.log('添加到购物车:', productId);\r\n    };\r\n  }, []); // 或者使用 useCallback\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e找到 {filteredProducts.length} 个产品\u003c/p\u003e\r\n      {filteredProducts.map(product =\u003e (\r\n        \u003cProductCard\r\n          key={product.id}\r\n          product={product}\r\n          onAddToCart={handleAddToCart}\r\n        /\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n**组合使用的最佳实践**：\r\n```jsx\r\nfunction ShoppingApp() {\r\n  const [cart, setCart] = useState([]);\r\n  const [searchTerm, setSearchTerm] = useState('');\r\n  const [products] = useState([\r\n    { id: 1, name: 'iPhone', category: 'electronics', price: 999 },\r\n    { id: 2, name: 'T-Shirt', category: 'clothing', price: 29 }\r\n  ]);\r\n\r\n  // useMemo：缓存搜索结果\r\n  const searchResults = useMemo(() =\u003e {\r\n    if (!searchTerm) return products;\r\n    return products.filter(p =\u003e \r\n      p.name.toLowerCase().includes(searchTerm.toLowerCase())\r\n    );\r\n  }, [products, searchTerm]);\r\n\r\n  // useMemo：缓存购物车统计\r\n  const cartStats = useMemo(() =\u003e {\r\n    return {\r\n      itemCount: cart.length,\r\n      total: cart.reduce((sum, item) =\u003e sum + item.price, 0)\r\n    };\r\n  }, [cart]);\r\n\r\n  // useCallback：稳定的事件处理函数\r\n  const addToCart = useCallback((productId) =\u003e {\r\n    const product = products.find(p =\u003e p.id === productId);\r\n    setCart(prev =\u003e [...prev, product]);\r\n  }, [products]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        value={searchTerm}\r\n        onChange={(e) =\u003e setSearchTerm(e.target.value)}\r\n        placeholder=\"搜索产品...\"\r\n      /\u003e\r\n      \r\n      {/* CartSummary 使用 React.memo 优化 */}\r\n      \u003cCartSummary stats={cartStats} /\u003e\r\n      \r\n      {/* ProductGrid 使用 React.memo 优化 */}\r\n      \u003cProductGrid \r\n        products={searchResults} \r\n        onAddToCart={addToCart} \r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\n// React.memo 优化的组件\r\nconst CartSummary = React.memo(({ stats }) =\u003e {\r\n  console.log('CartSummary 渲染');\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e购物车: {stats.itemCount} 件商品\u003c/p\u003e\r\n      \u003cp\u003e总计: ¥{stats.total}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\nconst ProductGrid = React.memo(({ products, onAddToCart }) =\u003e {\r\n  console.log('ProductGrid 渲染');\r\n  return (\r\n    \u003cdiv\u003e\r\n      {products.map(product =\u003e (\r\n        \u003cProductItem\r\n          key={product.id}\r\n          product={product}\r\n          onAddToCart={onAddToCart}\r\n        /\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\nconst ProductItem = React.memo(({ product, onAddToCart }) =\u003e {\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch4\u003e{product.name}\u003c/h4\u003e\r\n      \u003cp\u003e¥{product.price}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e onAddToCart(product.id)}\u003e\r\n        加入购物车\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n```\r\n\r\n**何时使用哪个**：\r\n- **使用 `useMemo`**：\r\n  - 昂贵的计算需要缓存结果\r\n  - 需要为子组件提供稳定的 props 引用\r\n  - 避免在每次渲染时重新创建对象/数组\r\n\r\n- **使用 `React.memo`**：\r\n  - 组件经常接收相同的 props\r\n  - 组件渲染成本较高\r\n  - 父组件频繁重新渲染，但子组件 props 变化较少\r\n\r\n- **配合使用**：\r\n  - 用 `useMemo` 创建稳定的 props\r\n  - 用 `React.memo` 防止子组件不必要的重新渲染\r\n\r\n\r\n### **条件计算**\r\n```jsx\r\nfunction ConditionalMemo({ data, shouldProcess, processingType }) {\r\n  const processedData = useMemo(() =\u003e {\r\n    // 只有在需要处理时才进行计算\r\n    if (!shouldProcess) return data;\r\n\r\n    console.log('执行数据处理...');\r\n    \r\n    switch (processingType) {\r\n      case 'sort':\r\n        return [...data].sort((a, b) =\u003e a.value - b.value);\r\n      case 'filter':\r\n        return data.filter(item =\u003e item.active);\r\n      case 'transform':\r\n        return data.map(item =\u003e ({ ...item, processed: true }));\r\n      default:\r\n        return data;\r\n    }\r\n  }, [data, shouldProcess, processingType]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e数据项数量: {processedData.length}\u003c/p\u003e\r\n      {processedData.map(item =\u003e (\r\n        \u003cdiv key={item.id}\u003e{item.name}\u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **复杂对象的记忆化**\r\n```jsx\r\nfunction FormValidator({ formData, validationRules }) {\r\n  // 验证结果的计算\r\n  const validationResults = useMemo(() =\u003e {\r\n    const results = {};\r\n    \r\n    Object.keys(validationRules).forEach(field =\u003e {\r\n      const value = formData[field];\r\n      const rules = validationRules[field];\r\n      \r\n      results[field] = {\r\n        isValid: true,\r\n        errors: []\r\n      };\r\n\r\n      rules.forEach(rule =\u003e {\r\n        if (!rule.validator(value)) {\r\n          results[field].isValid = false;\r\n          results[field].errors.push(rule.message);\r\n        }\r\n      });\r\n    });\r\n\r\n    return results;\r\n  }, [formData, validationRules]);\r\n\r\n  // 整体表单状态\r\n  const formStatus = useMemo(() =\u003e {\r\n    const allFields = Object.values(validationResults);\r\n    const hasErrors = allFields.some(field =\u003e !field.isValid);\r\n    const totalErrors = allFields.reduce((sum, field) =\u003e sum + field.errors.length, 0);\r\n\r\n    return {\r\n      isValid: !hasErrors,\r\n      errorCount: totalErrors,\r\n      canSubmit: !hasErrors \u0026\u0026 Object.keys(formData).length \u003e 0\r\n    };\r\n  }, [validationResults, formData]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e表单状态: {formStatus.isValid ? '有效' : '无效'}\u003c/p\u003e\r\n      \u003cp\u003e错误数量: {formStatus.errorCount}\u003c/p\u003e\r\n      \u003cbutton disabled={!formStatus.canSubmit}\u003e\r\n        提交表单\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **常见陷阱和解决方案**\r\n\r\n#### **依赖数组不正确**\r\n```jsx\r\nfunction BadExample({ items, filter }) {\r\n  const [multiplier, setMultiplier] = useState(1);\r\n\r\n  // 错误：缺少 multiplier 依赖\r\n  const processedItems = useMemo(() =\u003e {\r\n    return items\r\n      .filter(item =\u003e item.category === filter)\r\n      .map(item =\u003e ({ ...item, value: item.value * multiplier }));\r\n  }, [items, filter]); // 应该包含 [items, filter, multiplier]\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput \r\n        type=\"number\" \r\n        value={multiplier}\r\n        onChange={(e) =\u003e setMultiplier(Number(e.target.value))}\r\n      /\u003e\r\n      {/* multiplier 变化时，processedItems 不会更新 */}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **过度使用 useMemo**\r\n```jsx\r\n// 不必要的优化\r\nfunction OverOptimized() {\r\n  const [name, setName] = useState('');\r\n\r\n  // 简单的字符串操作不需要 useMemo\r\n  const uppercaseName = useMemo(() =\u003e {\r\n    return name.toUpperCase();\r\n  }, [name]);\r\n\r\n  return \u003cdiv\u003e{uppercaseName}\u003c/div\u003e;\r\n}\r\n\r\n// 简单直接的写法\r\nfunction Simple() {\r\n  const [name, setName] = useState('');\r\n\r\n  return \u003cdiv\u003e{name.toUpperCase()}\u003c/div\u003e;\r\n}\r\n```\r\n\r\n#### **引用类型的陷阱**\r\n```jsx\r\nfunction ReferenceTypeExample({ config }) {\r\n  // 错误：config 是对象，每次都被认为是新的\r\n  const processedConfig = useMemo(() =\u003e {\r\n    return {\r\n      ...config,\r\n      processed: true\r\n    };\r\n  }, [config]); // config 对象引用可能每次都不同\r\n\r\n  // 正确：使用对象的具体属性作为依赖\r\n  const processedConfigCorrect = useMemo(() =\u003e {\r\n    return {\r\n      ...config,\r\n      processed: true\r\n    };\r\n  }, [config.apiUrl, config.timeout, config.retries]); // 具体属性\r\n\r\n  return \u003cdiv\u003e配置已处理\u003c/div\u003e;\r\n}\r\n```\r\n\r\n\r\n### **性能测试示例**\r\n```jsx\r\nfunction PerformanceTest({ data }) {\r\n  const [rerenderCount, setRerenderCount] = useState(0);\r\n\r\n  // 昂贵的计算（模拟）\r\n  const expensiveCalculation = (items) =\u003e {\r\n    console.log('执行昂贵计算...');\r\n    let result = 0;\r\n    for (let i = 0; i \u003c 1000000; i++) {\r\n      result += Math.random();\r\n    }\r\n    return items.length + result;\r\n  };\r\n\r\n  // 没有缓存的版本\r\n  const unoptimizedValue = expensiveCalculation(data);\r\n\r\n  // 有缓存的版本\r\n  const optimizedValue = useMemo(() =\u003e {\r\n    return expensiveCalculation(data);\r\n  }, [data]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e重新渲染次数: {rerenderCount}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setRerenderCount(prev =\u003e prev + 1)}\u003e\r\n        触发重新渲染\r\n      \u003c/button\u003e\r\n      \u003cp\u003e未优化的值: {unoptimizedValue.toFixed(2)}\u003c/p\u003e\r\n      \u003cp\u003e优化后的值: {optimizedValue.toFixed(2)}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **自定义 Hook 中的使用**\r\n```jsx\r\nfunction useFilteredData(data, filters) {\r\n  const filteredData = useMemo(() =\u003e {\r\n    let result = data;\r\n\r\n    if (filters.search) {\r\n      result = result.filter(item =\u003e\r\n        item.name.toLowerCase().includes(filters.search.toLowerCase())\r\n      );\r\n    }\r\n\r\n    if (filters.category) {\r\n      result = result.filter(item =\u003e item.category === filters.category);\r\n    }\r\n\r\n    if (filters.priceRange) {\r\n      result = result.filter(item =\u003e\r\n        item.price \u003e= filters.priceRange.min \u0026\u0026\r\n        item.price \u003c= filters.priceRange.max\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }, [data, filters.search, filters.category, filters.priceRange]);\r\n\r\n  const statistics = useMemo(() =\u003e {\r\n    return {\r\n      count: filteredData.length,\r\n      averagePrice: filteredData.length\r\n        ? filteredData.reduce((sum, item) =\u003e sum + item.price, 0) / filteredData.length\r\n        : 0\r\n    };\r\n  }, [filteredData]);\r\n\r\n  return { filteredData, statistics };\r\n}\r\n\r\n// 使用自定义 Hook\r\nfunction ProductCatalog({ products }) {\r\n  const [filters, setFilters] = useState({\r\n    search: '',\r\n    category: '',\r\n    priceRange: { min: 0, max: 1000 }\r\n  });\r\n\r\n  const { filteredData, statistics } = useFilteredData(products, filters);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e找到 {statistics.count} 个产品\u003c/p\u003e\r\n      \u003cp\u003e平均价格: ¥{statistics.averagePrice.toFixed(2)}\u003c/p\u003e\r\n      {/* 渲染产品列表 */}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **最佳实践**\r\n1. **识别昂贵计算**：只对真正昂贵的计算使用 useMemo\r\n2. **正确设置依赖**：包含计算中使用的所有变量\r\n3. **避免过度优化**：简单计算不需要记忆化\r\n4. **稳定的引用**：为子组件提供稳定的 props 引用\r\n5. **测量性能**：使用开发者工具验证优化效果\r\n\r\n\r\n### **注意事项**\r\n- **内存开销**：缓存值会占用额外内存\r\n- **计算成本**：记忆化本身也有成本，确保收益大于成本\r\n- **依赖比较**：使用浅比较，注意对象和数组的引用\r\n- **调试困难**：过度使用可能使代码难以理解\r\n\r\n`useMemo` 是优化 React 应用性能的重要工具，但应该在合适的场景下使用，避免过度优化导致代码复杂性增加。\r\n"])</script><script>self.__next_f.push([1,"35:T6e5b,"])</script><script>self.__next_f.push([1,"\r\n`useReducer` 是 React 提供的状态管理 Hook，适用于管理复杂的状态逻辑。它类似于 Redux 的工作方式，通过 reducer 函数来处理状态更新，特别适合处理多个相关状态值或复杂的状态转换逻辑。\r\n\r\n\r\n### **基本作用**\r\n`useReducer` 的主要作用是：\r\n- 管理复杂的组件状态逻辑\r\n- 处理多个相关的状态值\r\n- 提供可预测的状态更新方式\r\n- 替代多个 useState 的复杂场景\r\n- 与 useContext 结合实现全局状态管理\r\n\r\n```jsx\r\nimport React, { useReducer } from 'react';\r\n\r\n// 定义 reducer 函数\r\nfunction counterReducer(state, action) {\r\n  switch (action.type) {\r\n    case 'increment':\r\n      return { count: state.count + 1 };\r\n    case 'decrement':\r\n      return { count: state.count - 1 };\r\n    case 'reset':\r\n      return { count: 0 };\r\n    default:\r\n      throw new Error(`未知的 action 类型: ${action.type}`);\r\n  }\r\n}\r\n\r\nfunction Counter() {\r\n  const [state, dispatch] = useReducer(counterReducer, { count: 0 });\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {state.count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e+1\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e-1\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'reset' })}\u003e重置\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **基本语法**\r\n```jsx\r\nconst [state, dispatch] = useReducer(reducer, initialState, init);\r\n```\r\n\r\n- **reducer**：reducer 函数 `(state, action) =\u003e newState`\r\n- **initialState**：初始状态值\r\n- **init**：可选的初始化函数，用于延迟初始化\r\n- **返回值**：`[state, dispatch]` 数组\r\n\r\n\r\n### **与 useState 的对比**\r\n\r\n#### **使用 useState（简单状态）**\r\n```jsx\r\nfunction SimpleCounter() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {count}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count - 1)}\u003e减少\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(0)}\u003e重置\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **使用 useReducer（复杂状态）**\r\n```jsx\r\nfunction ComplexCounter() {\r\n  const initialState = {\r\n    count: 0,\r\n    step: 1,\r\n    history: []\r\n  };\r\n\r\n  function reducer(state, action) {\r\n    switch (action.type) {\r\n      case 'increment':\r\n        return {\r\n          ...state,\r\n          count: state.count + state.step,\r\n          history: [...state.history, { action: 'increment', value: state.step }]\r\n        };\r\n      case 'decrement':\r\n        return {\r\n          ...state,\r\n          count: state.count - state.step,\r\n          history: [...state.history, { action: 'decrement', value: state.step }]\r\n        };\r\n      case 'setStep':\r\n        return {\r\n          ...state,\r\n          step: action.payload\r\n        };\r\n      case 'reset':\r\n        return {\r\n          ...initialState\r\n        };\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e计数: {state.count}\u003c/p\u003e\r\n      \u003cp\u003e步长: {state.step}\u003c/p\u003e\r\n      \u003cinput\r\n        type=\"number\"\r\n        value={state.step}\r\n        onChange={(e) =\u003e dispatch({ \r\n          type: 'setStep', \r\n          payload: parseInt(e.target.value) || 1 \r\n        })}\r\n      /\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'increment' })}\u003e\r\n        增加 {state.step}\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'decrement' })}\u003e\r\n        减少 {state.step}\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e dispatch({ type: 'reset' })}\u003e重置\u003c/button\u003e\r\n      \r\n      \u003ch3\u003e操作历史:\u003c/h3\u003e\r\n      \u003cul\u003e\r\n        {state.history.map((item, index) =\u003e (\r\n          \u003cli key={index}\u003e\r\n            {item.action} {item.value}\r\n          \u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **表单状态管理**\r\n\r\n#### **复杂表单处理**\r\n```jsx\r\nfunction FormWithReducer() {\r\n  const initialState = {\r\n    values: {\r\n      name: '',\r\n      email: '',\r\n      age: '',\r\n      preferences: []\r\n    },\r\n    errors: {},\r\n    isSubmitting: false,\r\n    isValid: false\r\n  };\r\n\r\n  function formReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'SET_FIELD':\r\n        return {\r\n          ...state,\r\n          values: {\r\n            ...state.values,\r\n            [action.field]: action.value\r\n          }\r\n        };\r\n      \r\n      case 'SET_ERROR':\r\n        return {\r\n          ...state,\r\n          errors: {\r\n            ...state.errors,\r\n            [action.field]: action.error\r\n          }\r\n        };\r\n      \r\n      case 'CLEAR_ERROR':\r\n        const newErrors = { ...state.errors };\r\n        delete newErrors[action.field];\r\n        return {\r\n          ...state,\r\n          errors: newErrors\r\n        };\r\n      \r\n      case 'ADD_PREFERENCE':\r\n        return {\r\n          ...state,\r\n          values: {\r\n            ...state.values,\r\n            preferences: [...state.values.preferences, action.preference]\r\n          }\r\n        };\r\n      \r\n      case 'REMOVE_PREFERENCE':\r\n        return {\r\n          ...state,\r\n          values: {\r\n            ...state.values,\r\n            preferences: state.values.preferences.filter(p =\u003e p !== action.preference)\r\n          }\r\n        };\r\n      \r\n      case 'SET_SUBMITTING':\r\n        return {\r\n          ...state,\r\n          isSubmitting: action.isSubmitting\r\n        };\r\n      \r\n      case 'RESET_FORM':\r\n        return initialState;\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(formReducer, initialState);\r\n\r\n  const handleFieldChange = (field, value) =\u003e {\r\n    dispatch({ type: 'SET_FIELD', field, value });\r\n    \r\n    // 实时验证\r\n    if (field === 'email' \u0026\u0026 value \u0026\u0026 !value.includes('@')) {\r\n      dispatch({ type: 'SET_ERROR', field, error: '请输入有效的邮箱地址' });\r\n    } else {\r\n      dispatch({ type: 'CLEAR_ERROR', field });\r\n    }\r\n  };\r\n\r\n  const handleSubmit = async (e) =\u003e {\r\n    e.preventDefault();\r\n    dispatch({ type: 'SET_SUBMITTING', isSubmitting: true });\r\n    \r\n    try {\r\n      // 模拟API调用\r\n      await new Promise(resolve =\u003e setTimeout(resolve, 2000));\r\n      console.log('表单提交成功:', state.values);\r\n      dispatch({ type: 'RESET_FORM' });\r\n    } catch (error) {\r\n      console.error('提交失败:', error);\r\n    } finally {\r\n      dispatch({ type: 'SET_SUBMITTING', isSubmitting: false });\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cform onSubmit={handleSubmit}\u003e\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e姓名:\u003c/label\u003e\r\n        \u003cinput\r\n          value={state.values.name}\r\n          onChange={(e) =\u003e handleFieldChange('name', e.target.value)}\r\n        /\u003e\r\n        {state.errors.name \u0026\u0026 \u003cspan style={{color: 'red'}}\u003e{state.errors.name}\u003c/span\u003e}\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e邮箱:\u003c/label\u003e\r\n        \u003cinput\r\n          value={state.values.email}\r\n          onChange={(e) =\u003e handleFieldChange('email', e.target.value)}\r\n        /\u003e\r\n        {state.errors.email \u0026\u0026 \u003cspan style={{color: 'red'}}\u003e{state.errors.email}\u003c/span\u003e}\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e年龄:\u003c/label\u003e\r\n        \u003cinput\r\n          type=\"number\"\r\n          value={state.values.age}\r\n          onChange={(e) =\u003e handleFieldChange('age', e.target.value)}\r\n        /\u003e\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e偏好:\u003c/label\u003e\r\n        {['技术', '设计', '管理'].map(pref =\u003e (\r\n          \u003clabel key={pref}\u003e\r\n            \u003cinput\r\n              type=\"checkbox\"\r\n              checked={state.values.preferences.includes(pref)}\r\n              onChange={(e) =\u003e {\r\n                if (e.target.checked) {\r\n                  dispatch({ type: 'ADD_PREFERENCE', preference: pref });\r\n                } else {\r\n                  dispatch({ type: 'REMOVE_PREFERENCE', preference: pref });\r\n                }\r\n              }}\r\n            /\u003e\r\n            {pref}\r\n          \u003c/label\u003e\r\n        ))}\r\n      \u003c/div\u003e\r\n\r\n      \u003cbutton type=\"submit\" disabled={state.isSubmitting}\u003e\r\n        {state.isSubmitting ? '提交中...' : '提交'}\r\n      \u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **购物车状态管理**\r\n\r\n#### **电商购物车示例**\r\n```jsx\r\nfunction ShoppingCart() {\r\n  const initialState = {\r\n    items: [],\r\n    total: 0,\r\n    discount: 0,\r\n    couponCode: '',\r\n    isLoading: false\r\n  };\r\n\r\n  function cartReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'ADD_ITEM':\r\n        const existingItem = state.items.find(item =\u003e item.id === action.item.id);\r\n        let newItems;\r\n        \r\n        if (existingItem) {\r\n          newItems = state.items.map(item =\u003e\r\n            item.id === action.item.id\r\n              ? { ...item, quantity: item.quantity + 1 }\r\n              : item\r\n          );\r\n        } else {\r\n          newItems = [...state.items, { ...action.item, quantity: 1 }];\r\n        }\r\n\r\n        return {\r\n          ...state,\r\n          items: newItems,\r\n          total: calculateTotal(newItems, state.discount)\r\n        };\r\n\r\n      case 'REMOVE_ITEM':\r\n        const filteredItems = state.items.filter(item =\u003e item.id !== action.itemId);\r\n        return {\r\n          ...state,\r\n          items: filteredItems,\r\n          total: calculateTotal(filteredItems, state.discount)\r\n        };\r\n\r\n      case 'UPDATE_QUANTITY':\r\n        const updatedItems = state.items.map(item =\u003e\r\n          item.id === action.itemId\r\n            ? { ...item, quantity: Math.max(0, action.quantity) }\r\n            : item\r\n        ).filter(item =\u003e item.quantity \u003e 0);\r\n\r\n        return {\r\n          ...state,\r\n          items: updatedItems,\r\n          total: calculateTotal(updatedItems, state.discount)\r\n        };\r\n\r\n      case 'APPLY_COUPON':\r\n        const discount = calculateDiscount(action.couponCode, state.items);\r\n        return {\r\n          ...state,\r\n          couponCode: action.couponCode,\r\n          discount,\r\n          total: calculateTotal(state.items, discount)\r\n        };\r\n\r\n      case 'CLEAR_CART':\r\n        return initialState;\r\n\r\n      case 'SET_LOADING':\r\n        return {\r\n          ...state,\r\n          isLoading: action.isLoading\r\n        };\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  // 辅助函数\r\n  const calculateTotal = (items, discount = 0) =\u003e {\r\n    const subtotal = items.reduce((sum, item) =\u003e sum + item.price * item.quantity, 0);\r\n    return subtotal - discount;\r\n  };\r\n\r\n  const calculateDiscount = (couponCode, items) =\u003e {\r\n    const subtotal = items.reduce((sum, item) =\u003e sum + item.price * item.quantity, 0);\r\n    switch (couponCode) {\r\n      case 'SAVE10':\r\n        return subtotal * 0.1;\r\n      case 'SAVE20':\r\n        return subtotal * 0.2;\r\n      default:\r\n        return 0;\r\n    }\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(cartReducer, initialState);\r\n\r\n  // 商品数据\r\n  const products = [\r\n    { id: 1, name: 'iPhone 15', price: 5999 },\r\n    { id: 2, name: 'MacBook Pro', price: 15999 },\r\n    { id: 3, name: 'AirPods', price: 1299 }\r\n  ];\r\n\r\n  const addToCart = (product) =\u003e {\r\n    dispatch({ type: 'ADD_ITEM', item: product });\r\n  };\r\n\r\n  const removeFromCart = (itemId) =\u003e {\r\n    dispatch({ type: 'REMOVE_ITEM', itemId });\r\n  };\r\n\r\n  const updateQuantity = (itemId, quantity) =\u003e {\r\n    dispatch({ type: 'UPDATE_QUANTITY', itemId, quantity });\r\n  };\r\n\r\n  const applyCoupon = (couponCode) =\u003e {\r\n    dispatch({ type: 'APPLY_COUPON', couponCode });\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch2\u003e产品列表\u003c/h2\u003e\r\n      {products.map(product =\u003e (\r\n        \u003cdiv key={product.id} style={{ border: '1px solid #ccc', margin: '10px', padding: '10px' }}\u003e\r\n          \u003ch3\u003e{product.name}\u003c/h3\u003e\r\n          \u003cp\u003e价格: ¥{product.price}\u003c/p\u003e\r\n          \u003cbutton onClick={() =\u003e addToCart(product)}\u003e加入购物车\u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n\r\n      \u003ch2\u003e购物车\u003c/h2\u003e\r\n      {state.items.length === 0 ? (\r\n        \u003cp\u003e购物车为空\u003c/p\u003e\r\n      ) : (\r\n        \u003c\u003e\r\n          {state.items.map(item =\u003e (\r\n            \u003cdiv key={item.id} style={{ border: '1px solid #eee', margin: '5px', padding: '10px' }}\u003e\r\n              \u003ch4\u003e{item.name}\u003c/h4\u003e\r\n              \u003cp\u003e单价: ¥{item.price}\u003c/p\u003e\r\n              \u003cdiv\u003e\r\n                数量: \r\n                \u003cbutton onClick={() =\u003e updateQuantity(item.id, item.quantity - 1)}\u003e-\u003c/button\u003e\r\n                \u003cspan style={{ margin: '0 10px' }}\u003e{item.quantity}\u003c/span\u003e\r\n                \u003cbutton onClick={() =\u003e updateQuantity(item.id, item.quantity + 1)}\u003e+\u003c/button\u003e\r\n              \u003c/div\u003e\r\n              \u003cp\u003e小计: ¥{item.price * item.quantity}\u003c/p\u003e\r\n              \u003cbutton onClick={() =\u003e removeFromCart(item.id)}\u003e移除\u003c/button\u003e\r\n            \u003c/div\u003e\r\n          ))}\r\n\r\n          \u003cdiv\u003e\r\n            \u003cinput\r\n              placeholder=\"输入优惠券代码\"\r\n              onChange={(e) =\u003e applyCoupon(e.target.value)}\r\n            /\u003e\r\n            \u003cp\u003e折扣: ¥{state.discount}\u003c/p\u003e\r\n            \u003ch3\u003e总计: ¥{state.total}\u003c/h3\u003e\r\n            \u003cbutton onClick={() =\u003e dispatch({ type: 'CLEAR_CART' })}\u003e清空购物车\u003c/button\u003e\r\n          \u003c/div\u003e\r\n        \u003c/\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **与 useContext 结合使用**\r\n\r\n#### **全局状态管理**\r\n```jsx\r\n// 创建 Context\r\nconst AppContext = React.createContext();\r\n\r\n// 初始状态\r\nconst initialState = {\r\n  user: null,\r\n  theme: 'light',\r\n  notifications: [],\r\n  isLoading: false\r\n};\r\n\r\n// Reducer 函数\r\nfunction appReducer(state, action) {\r\n  switch (action.type) {\r\n    case 'SET_USER':\r\n      return {\r\n        ...state,\r\n        user: action.user\r\n      };\r\n    \r\n    case 'LOGOUT':\r\n      return {\r\n        ...state,\r\n        user: null\r\n      };\r\n    \r\n    case 'TOGGLE_THEME':\r\n      return {\r\n        ...state,\r\n        theme: state.theme === 'light' ? 'dark' : 'light'\r\n      };\r\n    \r\n    case 'ADD_NOTIFICATION':\r\n      return {\r\n        ...state,\r\n        notifications: [...state.notifications, {\r\n          id: Date.now(),\r\n          message: action.message,\r\n          type: action.notificationType || 'info'\r\n        }]\r\n      };\r\n    \r\n    case 'REMOVE_NOTIFICATION':\r\n      return {\r\n        ...state,\r\n        notifications: state.notifications.filter(n =\u003e n.id !== action.id)\r\n      };\r\n    \r\n    case 'SET_LOADING':\r\n      return {\r\n        ...state,\r\n        isLoading: action.isLoading\r\n      };\r\n    \r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Provider 组件\r\nfunction AppProvider({ children }) {\r\n  const [state, dispatch] = useReducer(appReducer, initialState);\r\n\r\n  const actions = {\r\n    login: (user) =\u003e {\r\n      dispatch({ type: 'SET_USER', user });\r\n      dispatch({ type: 'ADD_NOTIFICATION', message: '登录成功', notificationType: 'success' });\r\n    },\r\n    \r\n    logout: () =\u003e {\r\n      dispatch({ type: 'LOGOUT' });\r\n      dispatch({ type: 'ADD_NOTIFICATION', message: '已退出登录', notificationType: 'info' });\r\n    },\r\n    \r\n    toggleTheme: () =\u003e {\r\n      dispatch({ type: 'TOGGLE_THEME' });\r\n    },\r\n    \r\n    addNotification: (message, type) =\u003e {\r\n      dispatch({ type: 'ADD_NOTIFICATION', message, notificationType: type });\r\n    },\r\n    \r\n    removeNotification: (id) =\u003e {\r\n      dispatch({ type: 'REMOVE_NOTIFICATION', id });\r\n    },\r\n    \r\n    setLoading: (isLoading) =\u003e {\r\n      dispatch({ type: 'SET_LOADING', isLoading });\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cAppContext.Provider value={{ state, actions }}\u003e\r\n      {children}\r\n    \u003c/AppContext.Provider\u003e\r\n  );\r\n}\r\n\r\n// 自定义 Hook\r\nfunction useAppContext() {\r\n  const context = useContext(AppContext);\r\n  if (!context) {\r\n    throw new Error('useAppContext 必须在 AppProvider 内部使用');\r\n  }\r\n  return context;\r\n}\r\n\r\n// 使用示例组件\r\nfunction Header() {\r\n  const { state, actions } = useAppContext();\r\n\r\n  return (\r\n    \u003cheader style={{ \r\n      background: state.theme === 'light' ? '#fff' : '#333',\r\n      color: state.theme === 'light' ? '#333' : '#fff',\r\n      padding: '1rem'\r\n    }}\u003e\r\n      \u003ch1\u003e我的应用\u003c/h1\u003e\r\n      \u003cdiv\u003e\r\n        {state.user ? (\r\n          \u003cdiv\u003e\r\n            \u003cspan\u003e欢迎, {state.user.name}\u003c/span\u003e\r\n            \u003cbutton onClick={actions.logout}\u003e退出\u003c/button\u003e\r\n          \u003c/div\u003e\r\n        ) : (\r\n          \u003cbutton onClick={() =\u003e actions.login({ name: '用户', id: 1 })}\u003e\r\n            登录\r\n          \u003c/button\u003e\r\n        )}\r\n        \u003cbutton onClick={actions.toggleTheme}\u003e\r\n          切换到 {state.theme === 'light' ? '暗色' : '亮色'} 主题\r\n        \u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/header\u003e\r\n  );\r\n}\r\n\r\nfunction NotificationList() {\r\n  const { state, actions } = useAppContext();\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {state.notifications.map(notification =\u003e (\r\n        \u003cdiv \r\n          key={notification.id}\r\n          style={{\r\n            padding: '10px',\r\n            margin: '5px',\r\n            background: notification.type === 'success' ? 'green' : \r\n                       notification.type === 'error' ? 'red' : 'blue',\r\n            color: 'white'\r\n          }}\r\n        \u003e\r\n          {notification.message}\r\n          \u003cbutton onClick={() =\u003e actions.removeNotification(notification.id)}\u003e\r\n            ×\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ))}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\n// 主应用\r\nfunction App() {\r\n  return (\r\n    \u003cAppProvider\u003e\r\n      \u003cHeader /\u003e\r\n      \u003cNotificationList /\u003e\r\n    \u003c/AppProvider\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **异步操作处理**\r\n\r\n#### **数据获取状态管理**\r\n```jsx\r\nfunction DataFetcher() {\r\n  const initialState = {\r\n    data: null,\r\n    loading: false,\r\n    error: null,\r\n    lastFetch: null\r\n  };\r\n\r\n  function dataReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'FETCH_START':\r\n        return {\r\n          ...state,\r\n          loading: true,\r\n          error: null\r\n        };\r\n      \r\n      case 'FETCH_SUCCESS':\r\n        return {\r\n          ...state,\r\n          loading: false,\r\n          data: action.data,\r\n          lastFetch: new Date(),\r\n          error: null\r\n        };\r\n      \r\n      case 'FETCH_ERROR':\r\n        return {\r\n          ...state,\r\n          loading: false,\r\n          error: action.error,\r\n          data: null\r\n        };\r\n      \r\n      case 'CLEAR_DATA':\r\n        return initialState;\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(dataReducer, initialState);\r\n\r\n  const fetchData = async (url) =\u003e {\r\n    dispatch({ type: 'FETCH_START' });\r\n    \r\n    try {\r\n      const response = await fetch(url);\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      const data = await response.json();\r\n      dispatch({ type: 'FETCH_SUCCESS', data });\r\n    } catch (error) {\r\n      dispatch({ type: 'FETCH_ERROR', error: error.message });\r\n    }\r\n  };\r\n\r\n  const clearData = () =\u003e {\r\n    dispatch({ type: 'CLEAR_DATA' });\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={() =\u003e fetchData('/api/users')}\u003e获取用户数据\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e fetchData('/api/posts')}\u003e获取文章数据\u003c/button\u003e\r\n      \u003cbutton onClick={clearData}\u003e清空数据\u003c/button\u003e\r\n\r\n      {state.loading \u0026\u0026 \u003cp\u003e加载中...\u003c/p\u003e}\r\n      {state.error \u0026\u0026 \u003cp style={{color: 'red'}}\u003e错误: {state.error}\u003c/p\u003e}\r\n      {state.data \u0026\u0026 (\r\n        \u003cdiv\u003e\r\n          \u003cp\u003e数据获取时间: {state.lastFetch?.toLocaleString()}\u003c/p\u003e\r\n          \u003cpre\u003e{JSON.stringify(state.data, null, 2)}\u003c/pre\u003e\r\n        \u003c/div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **游戏状态管理**\r\n\r\n#### **井字游戏示例**\r\n```jsx\r\nfunction TicTacToe() {\r\n  const initialState = {\r\n    board: Array(9).fill(null),\r\n    isXNext: true,\r\n    winner: null,\r\n    gameOver: false,\r\n    moves: 0\r\n  };\r\n\r\n  function gameReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'MAKE_MOVE':\r\n        if (state.board[action.index] || state.winner) {\r\n          return state;\r\n        }\r\n\r\n        const newBoard = [...state.board];\r\n        newBoard[action.index] = state.isXNext ? 'X' : 'O';\r\n        \r\n        const winner = calculateWinner(newBoard);\r\n        const gameOver = winner || newBoard.every(cell =\u003e cell !== null);\r\n\r\n        return {\r\n          ...state,\r\n          board: newBoard,\r\n          isXNext: !state.isXNext,\r\n          winner,\r\n          gameOver,\r\n          moves: state.moves + 1\r\n        };\r\n\r\n      case 'RESET_GAME':\r\n        return initialState;\r\n\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const calculateWinner = (board) =\u003e {\r\n    const lines = [\r\n      [0, 1, 2], [3, 4, 5], [6, 7, 8], // 行\r\n      [0, 3, 6], [1, 4, 7], [2, 5, 8], // 列\r\n      [0, 4, 8], [2, 4, 6] // 对角线\r\n    ];\r\n\r\n    for (let line of lines) {\r\n      const [a, b, c] = line;\r\n      if (board[a] \u0026\u0026 board[a] === board[b] \u0026\u0026 board[a] === board[c]) {\r\n        return board[a];\r\n      }\r\n    }\r\n    return null;\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(gameReducer, initialState);\r\n\r\n  const makeMove = (index) =\u003e {\r\n    dispatch({ type: 'MAKE_MOVE', index });\r\n  };\r\n\r\n  const resetGame = () =\u003e {\r\n    dispatch({ type: 'RESET_GAME' });\r\n  };\r\n\r\n  const renderSquare = (index) =\u003e (\r\n    \u003cbutton\r\n      style={{\r\n        width: '60px',\r\n        height: '60px',\r\n        fontSize: '20px',\r\n        fontWeight: 'bold'\r\n      }}\r\n      onClick={() =\u003e makeMove(index)}\r\n    \u003e\r\n      {state.board[index]}\r\n    \u003c/button\u003e\r\n  );\r\n\r\n  let status;\r\n  if (state.winner) {\r\n    status = `获胜者: ${state.winner}`;\r\n  } else if (state.gameOver) {\r\n    status = '平局!';\r\n  } else {\r\n    status = `下一个玩家: ${state.isXNext ? 'X' : 'O'}`;\r\n  }\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003e{status}\u003c/div\u003e\r\n      \u003cp\u003e步数: {state.moves}\u003c/p\u003e\r\n      \u003cdiv\u003e\r\n        \u003cdiv\u003e\r\n          {renderSquare(0)}\r\n          {renderSquare(1)}\r\n          {renderSquare(2)}\r\n        \u003c/div\u003e\r\n        \u003cdiv\u003e\r\n          {renderSquare(3)}\r\n          {renderSquare(4)}\r\n          {renderSquare(5)}\r\n        \u003c/div\u003e\r\n        \u003cdiv\u003e\r\n          {renderSquare(6)}\r\n          {renderSquare(7)}\r\n          {renderSquare(8)}\r\n        \u003c/div\u003e\r\n      \u003c/div\u003e\r\n      \u003cbutton onClick={resetGame}\u003e重新开始\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **自定义 Hook 封装**\r\n\r\n#### **通用状态管理 Hook**\r\n```jsx\r\nfunction useStateWithReducer(initialState) {\r\n  function stateReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'SET':\r\n        return { ...state, ...action.payload };\r\n      case 'RESET':\r\n        return initialState;\r\n      case 'UPDATE_FIELD':\r\n        return { ...state, [action.field]: action.value };\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(stateReducer, initialState);\r\n\r\n  const setState = (payload) =\u003e {\r\n    dispatch({ type: 'SET', payload });\r\n  };\r\n\r\n  const resetState = () =\u003e {\r\n    dispatch({ type: 'RESET' });\r\n  };\r\n\r\n  const updateField = (field, value) =\u003e {\r\n    dispatch({ type: 'UPDATE_FIELD', field, value });\r\n  };\r\n\r\n  return [state, { setState, resetState, updateField }];\r\n}\r\n\r\n// 使用示例\r\nfunction UserProfile() {\r\n  const [userState, userActions] = useStateWithReducer({\r\n    name: '',\r\n    email: '',\r\n    age: '',\r\n    isEditing: false\r\n  });\r\n\r\n  const handleSave = () =\u003e {\r\n    console.log('保存用户信息:', userState);\r\n    userActions.updateField('isEditing', false);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      {userState.isEditing ? (\r\n        \u003cdiv\u003e\r\n          \u003cinput\r\n            value={userState.name}\r\n            onChange={(e) =\u003e userActions.updateField('name', e.target.value)}\r\n            placeholder=\"姓名\"\r\n          /\u003e\r\n          \u003cinput\r\n            value={userState.email}\r\n            onChange={(e) =\u003e userActions.updateField('email', e.target.value)}\r\n            placeholder=\"邮箱\"\r\n          /\u003e\r\n          \u003cinput\r\n            value={userState.age}\r\n            onChange={(e) =\u003e userActions.updateField('age', e.target.value)}\r\n            placeholder=\"年龄\"\r\n          /\u003e\r\n          \u003cbutton onClick={handleSave}\u003e保存\u003c/button\u003e\r\n          \u003cbutton onClick={() =\u003e userActions.updateField('isEditing', false)}\u003e\r\n            取消\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      ) : (\r\n        \u003cdiv\u003e\r\n          \u003cp\u003e姓名: {userState.name}\u003c/p\u003e\r\n          \u003cp\u003e邮箱: {userState.email}\u003c/p\u003e\r\n          \u003cp\u003e年龄: {userState.age}\u003c/p\u003e\r\n          \u003cbutton onClick={() =\u003e userActions.updateField('isEditing', true)}\u003e\r\n            编辑\r\n          \u003c/button\u003e\r\n        \u003c/div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **常见陷阱和解决方案**\r\n\r\n#### **状态更新不当**\r\n```jsx\r\nfunction BadExample() {\r\n  function badReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'ADD_ITEM':\r\n        // 错误：直接修改原状态对象\r\n        state.items.push(action.item);\r\n        return state;\r\n      \r\n      case 'UPDATE_USER':\r\n        // 错误：直接修改嵌套对象\r\n        state.user.name = action.name;\r\n        return state;\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n}\r\n\r\nfunction GoodExample() {\r\n  function goodReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'ADD_ITEM':\r\n        // 正确：创建新的状态对象\r\n        return {\r\n          ...state,\r\n          items: [...state.items, action.item]\r\n        };\r\n      \r\n      case 'UPDATE_USER':\r\n        // 正确：使用扩展运算符创建新对象\r\n        return {\r\n          ...state,\r\n          user: {\r\n            ...state.user,\r\n            name: action.name\r\n          }\r\n        };\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **复杂状态的深层更新**\r\n```jsx\r\nfunction DeepUpdateExample() {\r\n  const initialState = {\r\n    user: {\r\n      profile: {\r\n        personal: {\r\n          name: '',\r\n          age: 0\r\n        },\r\n        contact: {\r\n          email: '',\r\n          phone: ''\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  function deepUpdateReducer(state, action) {\r\n    switch (action.type) {\r\n      case 'UPDATE_PERSONAL_INFO':\r\n        return {\r\n          ...state,\r\n          user: {\r\n            ...state.user,\r\n            profile: {\r\n              ...state.user.profile,\r\n              personal: {\r\n                ...state.user.profile.personal,\r\n                [action.field]: action.value\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n      case 'UPDATE_CONTACT_INFO':\r\n        return {\r\n          ...state,\r\n          user: {\r\n            ...state.user,\r\n            profile: {\r\n              ...state.user.profile,\r\n              contact: {\r\n                ...state.user.profile.contact,\r\n                [action.field]: action.value\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  const [state, dispatch] = useReducer(deepUpdateReducer, initialState);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        placeholder=\"姓名\"\r\n        onChange={(e) =\u003e dispatch({\r\n          type: 'UPDATE_PERSONAL_INFO',\r\n          field: 'name',\r\n          value: e.target.value\r\n        })}\r\n      /\u003e\r\n      \u003cinput\r\n        placeholder=\"邮箱\"\r\n        onChange={(e) =\u003e dispatch({\r\n          type: 'UPDATE_CONTACT_INFO',\r\n          field: 'email',\r\n          value: e.target.value\r\n        })}\r\n      /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **最佳实践**\r\n1. **纯函数**：Reducer 必须是纯函数，不能有副作用\r\n2. **不可变更新**：始终返回新的状态对象，不要修改原状态\r\n3. **action 类型**：使用常量定义 action 类型，避免拼写错误\r\n4. **状态结构**：保持状态结构扁平化，避免过深的嵌套\r\n5. **默认情况**：在 reducer 中处理默认情况，通常返回原状态\r\n6. **错误处理**：对未知的 action 类型抛出错误或给出警告\r\n\r\n\r\n### **何时使用 useReducer**\r\n- **复杂状态逻辑**：多个相关状态值需要一起更新\r\n- **状态转换复杂**：状态的下一个值依赖于前一个值\r\n- **多个组件共享状态**：结合 useContext 实现全局状态管理\r\n- **可预测的状态更新**：需要清晰的状态变更历史和调试\r\n\r\n\r\n### **注意事项**\r\n- **性能考虑**：每次 dispatch 都会触发重新渲染\r\n- **初始化成本**：useReducer 的初始化比 useState 稍重\r\n- **学习曲线**：相比 useState 有一定的学习成本\r\n- **调试复杂**：状态变更逻辑集中在 reducer 中，需要良好的调试工具\r\n\r\n`useReducer` 是管理复杂状态的强大工具，特别适合处理具有多个子值或复杂状态转换逻辑的场景。\r\n"])</script><script>self.__next_f.push([1,"36:T5bf6,"])</script><script>self.__next_f.push([1,"\r\n`useRef` 是 React 提供的一个重要 Hook，用于在函数组件中创建可变的引用对象。它返回一个可变的 ref 对象，其 `.current` 属性可以保存任何值，并且在组件的整个生命周期内保持不变。\r\n\r\n\r\n### **基本作用**\r\n`useRef` 的主要作用是：\r\n- 访问和操作 DOM 元素\r\n- 保存可变值，不触发重新渲染\r\n- 在渲染之间保持数据的持久性\r\n- 存储定时器、间隔器等引用\r\n- 缓存昂贵的计算结果\r\n\r\n```jsx\r\nimport React, { useRef, useEffect } from 'react';\r\n\r\nfunction MyComponent() {\r\n  const inputRef = useRef(null);\r\n\r\n  useEffect(() =\u003e {\r\n    // 组件挂载后自动聚焦输入框\r\n    inputRef.current.focus();\r\n  }, []);\r\n\r\n  const handleClick = () =\u003e {\r\n    // 程序化聚焦输入框\r\n    inputRef.current.focus();\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput ref={inputRef} type=\"text\" /\u003e\r\n      \u003cbutton onClick={handleClick}\u003e聚焦输入框\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **基本语法**\r\n```jsx\r\nconst refContainer = useRef(initialValue);\r\n\r\n// 访问当前值\r\nconst currentValue = refContainer.current;\r\n\r\n// 设置新值\r\nrefContainer.current = newValue;\r\n```\r\n\r\n- **参数**：初始值（可选）\r\n- **返回值**：一个具有 `current` 属性的可变 ref 对象\r\n\r\n\r\n### **访问 DOM 元素**\r\n\r\n#### **基本 DOM 操作**\r\n```jsx\r\nfunction DOMExample() {\r\n  const titleRef = useRef(null);\r\n  const inputRef = useRef(null);\r\n\r\n  const handleStyleChange = () =\u003e {\r\n    titleRef.current.style.color = 'red';\r\n    titleRef.current.style.fontSize = '24px';\r\n  };\r\n\r\n  const handleInputFocus = () =\u003e {\r\n    inputRef.current.focus();\r\n    inputRef.current.select(); // 选中所有文本\r\n  };\r\n\r\n  const handleGetValue = () =\u003e {\r\n    console.log('输入框的值:', inputRef.current.value);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch1 ref={titleRef}\u003e标题\u003c/h1\u003e\r\n      \u003cinput ref={inputRef} type=\"text\" defaultValue=\"默认文本\" /\u003e\r\n      \u003cbutton onClick={handleStyleChange}\u003e改变标题样式\u003c/button\u003e\r\n      \u003cbutton onClick={handleInputFocus}\u003e聚焦并选中\u003c/button\u003e\r\n      \u003cbutton onClick={handleGetValue}\u003e获取输入值\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **滚动控制**\r\n```jsx\r\nfunction ScrollExample() {\r\n  const containerRef = useRef(null);\r\n  const topRef = useRef(null);\r\n  const bottomRef = useRef(null);\r\n\r\n  const scrollToTop = () =\u003e {\r\n    topRef.current?.scrollIntoView({ \r\n      behavior: 'smooth' \r\n    });\r\n  };\r\n\r\n  const scrollToBottom = () =\u003e {\r\n    bottomRef.current?.scrollIntoView({ \r\n      behavior: 'smooth' \r\n    });\r\n  };\r\n\r\n  const scrollToPosition = (position) =\u003e {\r\n    containerRef.current?.scrollTo({\r\n      top: position,\r\n      behavior: 'smooth'\r\n    });\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cbutton onClick={scrollToTop}\u003e滚动到顶部\u003c/button\u003e\r\n      \u003cbutton onClick={scrollToBottom}\u003e滚动到底部\u003c/button\u003e\r\n      \u003cbutton onClick={() =\u003e scrollToPosition(500)}\u003e滚动到500px位置\u003c/button\u003e\r\n      \r\n      \u003cdiv ref={containerRef} style={{ height: 300, overflow: 'auto' }}\u003e\r\n        \u003cdiv ref={topRef}\u003e顶部内容\u003c/div\u003e\r\n        \u003cdiv style={{ height: 1000 }}\u003e中间内容...\u003c/div\u003e\r\n        \u003cdiv ref={bottomRef}\u003e底部内容\u003c/div\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **保存可变值**\r\n\r\n#### **不触发重新渲染的计数器**\r\n```jsx\r\nfunction MutableCounter() {\r\n  const [count, setCount] = useState(0);\r\n  const renderCount = useRef(0);\r\n  const previousCount = useRef(0);\r\n\r\n  // 每次渲染时增加渲染计数\r\n  renderCount.current += 1;\r\n\r\n  // 保存上一次的 count 值\r\n  useEffect(() =\u003e {\r\n    previousCount.current = count;\r\n  });\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e当前计数: {count}\u003c/p\u003e\r\n      \u003cp\u003e上一次计数: {previousCount.current}\u003c/p\u003e\r\n      \u003cp\u003e组件渲染次数: {renderCount.current}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **存储定时器引用**\r\n```jsx\r\nfunction Timer() {\r\n  const [seconds, setSeconds] = useState(0);\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const intervalRef = useRef(null);\r\n\r\n  const startTimer = () =\u003e {\r\n    if (!isRunning) {\r\n      setIsRunning(true);\r\n      intervalRef.current = setInterval(() =\u003e {\r\n        setSeconds(prev =\u003e prev + 1);\r\n      }, 1000);\r\n    }\r\n  };\r\n\r\n  const stopTimer = () =\u003e {\r\n    if (isRunning) {\r\n      setIsRunning(false);\r\n      clearInterval(intervalRef.current);\r\n    }\r\n  };\r\n\r\n  const resetTimer = () =\u003e {\r\n    setSeconds(0);\r\n    setIsRunning(false);\r\n    clearInterval(intervalRef.current);\r\n  };\r\n\r\n  // 组件卸载时清理定时器\r\n  useEffect(() =\u003e {\r\n    return () =\u003e {\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch2\u003e计时器: {seconds}秒\u003c/h2\u003e\r\n      \u003cbutton onClick={startTimer} disabled={isRunning}\u003e\r\n        开始\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={stopTimer} disabled={!isRunning}\u003e\r\n        停止\r\n      \u003c/button\u003e\r\n      \u003cbutton onClick={resetTimer}\u003e重置\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **表单处理**\r\n\r\n#### **非受控组件**\r\n```jsx\r\nfunction UncontrolledForm() {\r\n  const nameRef = useRef(null);\r\n  const emailRef = useRef(null);\r\n  const passwordRef = useRef(null);\r\n\r\n  const handleSubmit = (e) =\u003e {\r\n    e.preventDefault();\r\n    \r\n    const formData = {\r\n      name: nameRef.current.value,\r\n      email: emailRef.current.value,\r\n      password: passwordRef.current.value\r\n    };\r\n\r\n    console.log('表单数据:', formData);\r\n  };\r\n\r\n  const clearForm = () =\u003e {\r\n    nameRef.current.value = '';\r\n    emailRef.current.value = '';\r\n    passwordRef.current.value = '';\r\n    nameRef.current.focus();\r\n  };\r\n\r\n  return (\r\n    \u003cform onSubmit={handleSubmit}\u003e\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e姓名:\u003c/label\u003e\r\n        \u003cinput ref={nameRef} type=\"text\" required /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e邮箱:\u003c/label\u003e\r\n        \u003cinput ref={emailRef} type=\"email\" required /\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv\u003e\r\n        \u003clabel\u003e密码:\u003c/label\u003e\r\n        \u003cinput ref={passwordRef} type=\"password\" required /\u003e\r\n      \u003c/div\u003e\r\n      \u003cbutton type=\"submit\"\u003e提交\u003c/button\u003e\r\n      \u003cbutton type=\"button\" onClick={clearForm}\u003e清空\u003c/button\u003e\r\n    \u003c/form\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **文件上传**\r\n```jsx\r\nfunction FileUpload() {\r\n  const fileInputRef = useRef(null);\r\n  const [selectedFiles, setSelectedFiles] = useState([]);\r\n\r\n  const handleFileSelect = () =\u003e {\r\n    fileInputRef.current?.click();\r\n  };\r\n\r\n  const handleFileChange = (e) =\u003e {\r\n    const files = Array.from(e.target.files);\r\n    setSelectedFiles(files);\r\n  };\r\n\r\n  const clearFiles = () =\u003e {\r\n    fileInputRef.current.value = '';\r\n    setSelectedFiles([]);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        ref={fileInputRef}\r\n        type=\"file\"\r\n        multiple\r\n        onChange={handleFileChange}\r\n        style={{ display: 'none' }}\r\n      /\u003e\r\n      \u003cbutton onClick={handleFileSelect}\u003e选择文件\u003c/button\u003e\r\n      \u003cbutton onClick={clearFiles}\u003e清空选择\u003c/button\u003e\r\n      \r\n      {selectedFiles.length \u003e 0 \u0026\u0026 (\r\n        \u003cdiv\u003e\r\n          \u003ch3\u003e已选择的文件:\u003c/h3\u003e\r\n          \u003cul\u003e\r\n            {selectedFiles.map((file, index) =\u003e (\r\n              \u003cli key={index}\u003e\r\n                {file.name} ({(file.size / 1024).toFixed(2)} KB)\r\n              \u003c/li\u003e\r\n            ))}\r\n          \u003c/ul\u003e\r\n        \u003c/div\u003e\r\n      )}\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **缓存和性能优化**\r\n\r\n#### **缓存昂贵计算的结果**\r\n```jsx\r\nfunction ExpensiveCalculation({ data }) {\r\n  const [filter, setFilter] = useState('');\r\n  const cacheRef = useRef(new Map());\r\n\r\n  const getProcessedData = useMemo(() =\u003e {\r\n    const cacheKey = `${JSON.stringify(data)}-${filter}`;\r\n    \r\n    if (cacheRef.current.has(cacheKey)) {\r\n      console.log('从缓存获取结果');\r\n      return cacheRef.current.get(cacheKey);\r\n    }\r\n\r\n    console.log('执行昂贵计算');\r\n    const result = data\r\n      .filter(item =\u003e item.name.includes(filter))\r\n      .map(item =\u003e ({\r\n        ...item,\r\n        processed: true,\r\n        timestamp: Date.now()\r\n      }));\r\n\r\n    cacheRef.current.set(cacheKey, result);\r\n    \r\n    // 限制缓存大小\r\n    if (cacheRef.current.size \u003e 10) {\r\n      const firstKey = cacheRef.current.keys().next().value;\r\n      cacheRef.current.delete(firstKey);\r\n    }\r\n\r\n    return result;\r\n  }, [data, filter]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        value={filter}\r\n        onChange={(e) =\u003e setFilter(e.target.value)}\r\n        placeholder=\"搜索...\"\r\n      /\u003e\r\n      \u003cp\u003e结果数量: {getProcessedData.length}\u003c/p\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **防抖处理**\r\n```jsx\r\nfunction SearchWithDebounce() {\r\n  const [query, setQuery] = useState('');\r\n  const [results, setResults] = useState([]);\r\n  const debounceTimeoutRef = useRef(null);\r\n\r\n  const handleSearch = (searchQuery) =\u003e {\r\n    // 清除之前的定时器\r\n    if (debounceTimeoutRef.current) {\r\n      clearTimeout(debounceTimeoutRef.current);\r\n    }\r\n\r\n    // 设置新的定时器\r\n    debounceTimeoutRef.current = setTimeout(() =\u003e {\r\n      if (searchQuery) {\r\n        // 模拟API调用\r\n        console.log('搜索:', searchQuery);\r\n        setResults([\r\n          `结果1: ${searchQuery}`,\r\n          `结果2: ${searchQuery}`,\r\n          `结果3: ${searchQuery}`\r\n        ]);\r\n      } else {\r\n        setResults([]);\r\n      }\r\n    }, 500); // 500ms防抖\r\n  };\r\n\r\n  const handleInputChange = (e) =\u003e {\r\n    const value = e.target.value;\r\n    setQuery(value);\r\n    handleSearch(value);\r\n  };\r\n\r\n  // 清理定时器\r\n  useEffect(() =\u003e {\r\n    return () =\u003e {\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        value={query}\r\n        onChange={handleInputChange}\r\n        placeholder=\"输入搜索关键词...\"\r\n      /\u003e\r\n      \u003cul\u003e\r\n        {results.map((result, index) =\u003e (\r\n          \u003cli key={index}\u003e{result}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **组件间通信**\r\n\r\n#### **转发 ref**\r\n```jsx\r\n// 子组件使用 forwardRef\r\nconst CustomInput = React.forwardRef((props, ref) =\u003e {\r\n  return (\r\n    \u003cinput\r\n      ref={ref}\r\n      style={{\r\n        padding: '8px',\r\n        border: '2px solid #ccc',\r\n        borderRadius: '4px'\r\n      }}\r\n      {...props}\r\n    /\u003e\r\n  );\r\n});\r\n\r\n// 父组件\r\nfunction ParentComponent() {\r\n  const inputRef = useRef(null);\r\n\r\n  const focusInput = () =\u003e {\r\n    inputRef.current?.focus();\r\n  };\r\n\r\n  const getInputValue = () =\u003e {\r\n    console.log('输入值:', inputRef.current?.value);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cCustomInput ref={inputRef} placeholder=\"自定义输入框\" /\u003e\r\n      \u003cbutton onClick={focusInput}\u003e聚焦\u003c/button\u003e\r\n      \u003cbutton onClick={getInputValue}\u003e获取值\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **暴露方法给父组件**\r\n```jsx\r\n// 子组件\r\nconst ChildComponent = React.forwardRef((props, ref) =\u003e {\r\n  const [count, setCount] = useState(0);\r\n  const internalRef = useRef(null);\r\n\r\n  // 使用 useImperativeHandle 暴露方法\r\n  useImperativeHandle(ref, () =\u003e ({\r\n    focus: () =\u003e {\r\n      internalRef.current?.focus();\r\n    },\r\n    reset: () =\u003e {\r\n      setCount(0);\r\n    },\r\n    increment: () =\u003e {\r\n      setCount(prev =\u003e prev + 1);\r\n    },\r\n    getCount: () =\u003e count\r\n  }));\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput ref={internalRef} value={count} readOnly /\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e内部增加\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n});\r\n\r\n// 父组件\r\nfunction ImperativeParent() {\r\n  const childRef = useRef(null);\r\n\r\n  const handleFocus = () =\u003e {\r\n    childRef.current?.focus();\r\n  };\r\n\r\n  const handleReset = () =\u003e {\r\n    childRef.current?.reset();\r\n  };\r\n\r\n  const handleIncrement = () =\u003e {\r\n    childRef.current?.increment();\r\n  };\r\n\r\n  const handleGetCount = () =\u003e {\r\n    const count = childRef.current?.getCount();\r\n    console.log('当前计数:', count);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cChildComponent ref={childRef} /\u003e\r\n      \u003cbutton onClick={handleFocus}\u003e聚焦子组件\u003c/button\u003e\r\n      \u003cbutton onClick={handleReset}\u003e重置计数\u003c/button\u003e\r\n      \u003cbutton onClick={handleIncrement}\u003e外部增加\u003c/button\u003e\r\n      \u003cbutton onClick={handleGetCount}\u003e获取计数\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **常见陷阱和解决方案**\r\n\r\n#### **ref 的初始值问题**\r\n```jsx\r\nfunction RefInitializationExample() {\r\n  const divRef = useRef(null);\r\n  \r\n  // 错误：组件首次渲染时 ref.current 为 null\r\n  const badExample = () =\u003e {\r\n    console.log(divRef.current.scrollHeight); // 可能报错\r\n  };\r\n\r\n  // 正确：检查 ref.current 是否存在\r\n  const goodExample = () =\u003e {\r\n    if (divRef.current) {\r\n      console.log(divRef.current.scrollHeight);\r\n    }\r\n  };\r\n\r\n  // 更安全的写法：使用可选链\r\n  const safestExample = () =\u003e {\r\n    console.log(divRef.current?.scrollHeight);\r\n  };\r\n\r\n  return (\r\n    \u003cdiv ref={divRef}\u003e\r\n      \u003cbutton onClick={badExample}\u003e错误示例\u003c/button\u003e\r\n      \u003cbutton onClick={goodExample}\u003e正确示例\u003c/button\u003e\r\n      \u003cbutton onClick={safestExample}\u003e最安全示例\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **在依赖数组中使用 ref**\r\n```jsx\r\nfunction EffectWithRef() {\r\n  const divRef = useRef(null);\r\n  const [count, setCount] = useState(0);\r\n\r\n  // 错误：ref 对象不应该在依赖数组中\r\n  useEffect(() =\u003e {\r\n    if (divRef.current) {\r\n      divRef.current.textContent = `计数: ${count}`;\r\n    }\r\n  }, [count, divRef]); // divRef 不应该在这里\r\n\r\n  // 正确：只依赖实际需要的值\r\n  useEffect(() =\u003e {\r\n    if (divRef.current) {\r\n      divRef.current.textContent = `计数: ${count}`;\r\n    }\r\n  }, [count]); // 只依赖 count\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv ref={divRef}\u003e\u003c/div\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **自定义 Hook 中的使用**\r\n\r\n#### **自定义的防抖 Hook**\r\n```jsx\r\nfunction useDebounce(callback, delay) {\r\n  const timeoutRef = useRef(null);\r\n  const callbackRef = useRef(callback);\r\n\r\n  // 保持最新的回调函数引用\r\n  useEffect(() =\u003e {\r\n    callbackRef.current = callback;\r\n  });\r\n\r\n  const debouncedCallback = useCallback((...args) =\u003e {\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n    }\r\n\r\n    timeoutRef.current = setTimeout(() =\u003e {\r\n      callbackRef.current(...args);\r\n    }, delay);\r\n  }, [delay]);\r\n\r\n  // 清理定时器\r\n  useEffect(() =\u003e {\r\n    return () =\u003e {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return debouncedCallback;\r\n}\r\n\r\n// 使用自定义 Hook\r\nfunction SearchComponent() {\r\n  const [query, setQuery] = useState('');\r\n  const [results, setResults] = useState([]);\r\n\r\n  const searchAPI = async (searchTerm) =\u003e {\r\n    console.log('搜索:', searchTerm);\r\n    // 模拟API调用\r\n    setResults([`搜索结果: ${searchTerm}`]);\r\n  };\r\n\r\n  const debouncedSearch = useDebounce(searchAPI, 500);\r\n\r\n  const handleInputChange = (e) =\u003e {\r\n    const value = e.target.value;\r\n    setQuery(value);\r\n    if (value) {\r\n      debouncedSearch(value);\r\n    } else {\r\n      setResults([]);\r\n    }\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        value={query}\r\n        onChange={handleInputChange}\r\n        placeholder=\"搜索...\"\r\n      /\u003e\r\n      \u003cul\u003e\r\n        {results.map((result, index) =\u003e (\r\n          \u003cli key={index}\u003e{result}\u003c/li\u003e\r\n        ))}\r\n      \u003c/ul\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **自定义的前一个值 Hook**\r\n```jsx\r\nfunction usePrevious(value) {\r\n  const ref = useRef();\r\n  \r\n  useEffect(() =\u003e {\r\n    ref.current = value;\r\n  });\r\n  \r\n  return ref.current;\r\n}\r\n\r\n// 使用示例\r\nfunction PreviousValueExample() {\r\n  const [count, setCount] = useState(0);\r\n  const previousCount = usePrevious(count);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e当前值: {count}\u003c/p\u003e\r\n      \u003cp\u003e前一个值: {previousCount}\u003c/p\u003e\r\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e增加\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n\r\n### **ref 的同步更新特性**\r\n\r\n与 state 的异步更新不同，ref 的更新是同步的。这意味着当你修改 `ref.current` 时，新值会立即生效，而不需要等待下一次渲染。这在某些需要立即检测状态变化的场景中非常有用。\r\n\r\n#### **state 异步 vs ref 同步的对比**\r\n```jsx\r\nfunction SyncVsAsyncExample() {\r\n  const [count, setCount] = useState(0);\r\n  const countRef = useRef(0);\r\n\r\n  const handleStateClick = () =\u003e {\r\n    console.log('点击前 state:', count); // 显示旧值\r\n    setCount(count + 1);\r\n    console.log('点击后 state:', count); // 仍然显示旧值（异步更新）\r\n  };\r\n\r\n  const handleRefClick = () =\u003e {\r\n    console.log('点击前 ref:', countRef.current); // 显示当前值\r\n    countRef.current += 1;\r\n    console.log('点击后 ref:', countRef.current); // 立即显示新值（同步更新）\r\n  };\r\n\r\n  // 使用 useEffect 观察 state 的实际更新时机\r\n  useEffect(() =\u003e {\r\n    console.log('state 实际更新为:', count);\r\n  }, [count]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003eState 计数: {count}\u003c/p\u003e\r\n      \u003cp\u003eRef 计数: {countRef.current}\u003c/p\u003e\r\n      \u003cbutton onClick={handleStateClick}\u003eState +1\u003c/button\u003e\r\n      \u003cbutton onClick={handleRefClick}\u003eRef +1\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **连续快速操作的场景**\r\n```jsx\r\nfunction RapidClickExample() {\r\n  const [stateClicks, setStateClicks] = useState(0);\r\n  const refClicks = useRef(0);\r\n  const [log, setLog] = useState([]);\r\n\r\n  const handleRapidStateClicks = () =\u003e {\r\n    // 连续的 state 更新可能会被批处理\r\n    setStateClicks(prev =\u003e prev + 1);\r\n    setStateClicks(prev =\u003e prev + 1);\r\n    setStateClicks(prev =\u003e prev + 1);\r\n    \r\n    // 在同一个事件中，stateClicks 的值不会立即更新\r\n    setLog(prev =\u003e [...prev, `State 批量更新，当前显示: ${stateClicks}`]);\r\n  };\r\n\r\n  const handleRapidRefClicks = () =\u003e {\r\n    // ref 的更新是立即的\r\n    refClicks.current += 1;\r\n    refClicks.current += 1;\r\n    refClicks.current += 1;\r\n    \r\n    // 可以立即获取到最新值\r\n    setLog(prev =\u003e [...prev, `Ref 立即更新，当前值: ${refClicks.current}`]);\r\n  };\r\n\r\n  const clearLog = () =\u003e setLog([]);\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003eState 点击次数: {stateClicks}\u003c/p\u003e\r\n        \u003cp\u003eRef 点击次数: {refClicks.current}\u003c/p\u003e\r\n      \u003c/div\u003e\r\n      \r\n      \u003cdiv\u003e\r\n        \u003cbutton onClick={handleRapidStateClicks}\u003eState 连续+3\u003c/button\u003e\r\n        \u003cbutton onClick={handleRapidRefClicks}\u003eRef 连续+3\u003c/button\u003e\r\n        \u003cbutton onClick={clearLog}\u003e清空日志\u003c/button\u003e\r\n      \u003c/div\u003e\r\n\r\n      \u003cdiv\u003e\r\n        \u003ch4\u003e操作日志:\u003c/h4\u003e\r\n        \u003cul\u003e\r\n          {log.map((entry, index) =\u003e (\r\n            \u003cli key={index}\u003e{entry}\u003c/li\u003e\r\n          ))}\r\n        \u003c/ul\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **实时计算场景**\r\n```jsx\r\nfunction RealTimeCalculation() {\r\n  const [inputValue, setInputValue] = useState('');\r\n  const calculationCountRef = useRef(0);\r\n  const lastCalculationRef = useRef(null);\r\n\r\n  const performExpensiveCalculation = (value) =\u003e {\r\n    // 增加计算次数（同步更新）\r\n    calculationCountRef.current += 1;\r\n    \r\n    // 立即记录计算时间\r\n    lastCalculationRef.current = new Date().toLocaleTimeString();\r\n    \r\n    // 模拟昂贵计算\r\n    const result = value.split('').reverse().join('') + calculationCountRef.current;\r\n    \r\n    console.log(`第 ${calculationCountRef.current} 次计算在 ${lastCalculationRef.current} 完成`);\r\n    return result;\r\n  };\r\n\r\n  const handleInputChange = (e) =\u003e {\r\n    const value = e.target.value;\r\n    setInputValue(value);\r\n    \r\n    if (value) {\r\n      // 因为 ref 是同步更新的，我们可以立即获取准确的计算次数\r\n      const result = performExpensiveCalculation(value);\r\n      console.log('计算结果:', result);\r\n    }\r\n  };\r\n\r\n  const resetCalculations = () =\u003e {\r\n    calculationCountRef.current = 0;\r\n    lastCalculationRef.current = null;\r\n    setInputValue('');\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cinput\r\n        value={inputValue}\r\n        onChange={handleInputChange}\r\n        placeholder=\"输入文本触发计算...\"\r\n      /\u003e\r\n      \u003cdiv\u003e\r\n        \u003cp\u003e计算次数: {calculationCountRef.current}\u003c/p\u003e\r\n        \u003cp\u003e最后计算时间: {lastCalculationRef.current || '未开始'}\u003c/p\u003e\r\n      \u003c/div\u003e\r\n      \u003cbutton onClick={resetCalculations}\u003e重置\u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n#### **事件处理中的即时状态检查**\r\n```jsx\r\nfunction EventHandlingExample() {\r\n  const [isProcessing, setIsProcessing] = useState(false);\r\n  const processingCountRef = useRef(0);\r\n  const isProcessingRef = useRef(false);\r\n\r\n  const simulateAsyncOperation = async () =\u003e {\r\n    // 使用 state（异步更新）\r\n    setIsProcessing(true);\r\n    \r\n    // 使用 ref（同步更新）\r\n    isProcessingRef.current = true;\r\n    processingCountRef.current += 1;\r\n\r\n    console.log('开始处理时:');\r\n    console.log('- state isProcessing:', isProcessing); // 可能还是 false\r\n    console.log('- ref isProcessingRef:', isProcessingRef.current); // 立即是 true\r\n    console.log('- ref processingCount:', processingCountRef.current); // 立即更新的计数\r\n\r\n    // 模拟异步操作\r\n    await new Promise(resolve =\u003e setTimeout(resolve, 2000));\r\n\r\n    setIsProcessing(false);\r\n    isProcessingRef.current = false;\r\n    \r\n    console.log('处理完成');\r\n  };\r\n\r\n  const handleClick = () =\u003e {\r\n    // 防止重复点击：使用 ref 可以立即检查状态\r\n    if (isProcessingRef.current) {\r\n      console.log('操作正在进行中，忽略点击');\r\n      return;\r\n    }\r\n\r\n    // 如果使用 state 检查，可能无法立即防止重复点击\r\n    // if (isProcessing) { ... } // 这可能不准确\r\n\r\n    simulateAsyncOperation();\r\n  };\r\n\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003cp\u003e处理状态 (state): {isProcessing ? '进行中' : '空闲'}\u003c/p\u003e\r\n      \u003cp\u003e处理状态 (ref): {isProcessingRef.current ? '进行中' : '空闲'}\u003c/p\u003e\r\n      \u003cp\u003e处理次数: {processingCountRef.current}\u003c/p\u003e\r\n      \u003cbutton onClick={handleClick} disabled={isProcessing}\u003e\r\n        {isProcessing ? '处理中...' : '开始处理'}\r\n      \u003c/button\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n这种同步更新的特性使得 ref 在以下场景中特别有用：\r\n- **防止重复操作**：立即标记操作状态\r\n- **实时计数**：需要准确跟踪操作次数\r\n- **性能监控**：立即记录时间戳或计数\r\n- **复杂事件处理**：需要在同一个事件处理函数中获取最新状态\r\n\r\n\r\n### **最佳实践**\r\n1. **DOM 操作**：优先使用 ref 而不是 document.querySelector\r\n2. **避免过度使用**：不要用 ref 替代 state，只在必要时使用\r\n3. **null 检查**：访问 ref.current 前要检查是否为 null\r\n4. **清理资源**：及时清理定时器、事件监听器等\r\n5. **转发 ref**：在可复用组件中正确使用 forwardRef\r\n6. **同步特性**：利用 ref 的同步更新特性处理需要立即响应的场景\r\n\r\n\r\n### **注意事项**\r\n- **不触发重新渲染**：修改 ref.current 不会导致组件重新渲染\r\n- **同步更新**：ref.current 的修改是同步的，与 state 的异步更新不同\r\n- **初始值为 null**：DOM ref 在首次渲染时为 null\r\n- **避免在渲染期间读取**：不要在渲染过程中读取或写入 ref.current\r\n- **函数组件专用**：useRef 只能在函数组件中使用\r\n\r\n`useRef` 是 React 中处理 DOM 操作和保存可变值的重要工具，正确使用能够提升应用的交互性和性能。\r\n"])</script><script>self.__next_f.push([1,"37:T3b22,"])</script><script>self.__next_f.push([1,"\r\nTailwindCSS 主题系统是一个强大的定制化工具，允许开发者完全控制设计系统的每个方面，包括颜色、字体、间距、断点等。通过主题配置，可以创建统一且可维护的设计语言。\r\n\r\n\r\n### **基本概念**\r\nTailwindCSS 主题配置通过 `tailwind.config.js` 文件中的 `theme` 对象来定义。主题系统提供了两种配置方式：\r\n- **覆盖（Override）**：完全替换默认值\r\n- **扩展（Extend）**：在默认值基础上添加新值\r\n\r\n```javascript\r\n// tailwind.config.js\r\nmodule.exports = {\r\n  theme: {\r\n    // 覆盖默认配置\r\n    colors: {\r\n      blue: '#1e40af',\r\n      red: '#dc2626'\r\n    },\r\n    extend: {\r\n      // 扩展默认配置\r\n      colors: {\r\n        brand: '#8b5cf6'\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **颜色系统配置**\r\n\r\n#### **基础颜色配置**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    colors: {\r\n      // 单一颜色\r\n      primary: '#3b82f6',\r\n      secondary: '#64748b',\r\n      \r\n      // 颜色调色板\r\n      gray: {\r\n        50: '#f9fafb',\r\n        100: '#f3f4f6',\r\n        200: '#e5e7eb',\r\n        // ... 更多层级\r\n        900: '#111827'\r\n      },\r\n      \r\n      // 使用内置颜色\r\n      ...require('tailwindcss/colors')\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **语义化颜色**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        // 语义化命名\r\n        success: '#10b981',\r\n        warning: '#f59e0b',\r\n        error: '#ef4444',\r\n        info: '#3b82f6',\r\n        \r\n        // 品牌色系\r\n        brand: {\r\n          primary: '#8b5cf6',\r\n          secondary: '#06b6d4',\r\n          accent: '#f59e0b'\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **深色模式配置**\r\n\r\n#### **基础深色模式**\r\n```javascript\r\nmodule.exports = {\r\n  darkMode: 'class', // 或 'media'\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        background: {\r\n          light: '#ffffff',\r\n          dark: '#1a1a1a'\r\n        },\r\n        text: {\r\n          light: '#1f2937',\r\n          dark: '#f9fafb'\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **复杂深色模式配置**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        primary: {\r\n          50: '#eff6ff',\r\n          500: '#3b82f6',\r\n          900: '#1e3a8a'\r\n        }\r\n      },\r\n      backgroundColor: {\r\n        'dark-card': '#1f2937',\r\n        'dark-surface': '#111827'\r\n      },\r\n      textColor: {\r\n        'dark-primary': '#f9fafb',\r\n        'dark-secondary': '#d1d5db'\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **排版系统配置**\r\n\r\n#### **字体配置**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      fontFamily: {\r\n        'sans': ['Inter', 'system-ui', 'sans-serif'],\r\n        'serif': ['Merriweather', 'serif'],\r\n        'mono': ['JetBrains Mono', 'monospace'],\r\n        'brand': ['Poppins', 'sans-serif']\r\n      },\r\n      fontSize: {\r\n        'xs': '0.75rem',\r\n        'sm': '0.875rem',\r\n        'base': '1rem',\r\n        'lg': '1.125rem',\r\n        'xl': '1.25rem',\r\n        '2xl': '1.5rem',\r\n        '3xl': '1.875rem',\r\n        '4xl': '2.25rem',\r\n        '5xl': '3rem',\r\n        // 自定义尺寸\r\n        'display': ['4rem', { lineHeight: '1.1' }],\r\n        'hero': ['3.5rem', { lineHeight: '1.2', letterSpacing: '-0.02em' }]\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### **间距系统**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      spacing: {\r\n        '18': '4.5rem',\r\n        '88': '22rem',\r\n        '128': '32rem',\r\n        // 自定义间距\r\n        'nav': '4.5rem',\r\n        'sidebar': '16rem'\r\n      },\r\n      padding: {\r\n        'safe': 'env(safe-area-inset-bottom)'\r\n      },\r\n      margin: {\r\n        'auto-safe': 'auto env(safe-area-inset-right) auto env(safe-area-inset-left)'\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **响应式断点配置**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    screens: {\r\n      'xs': '475px',\r\n      'sm': '640px',\r\n      'md': '768px',\r\n      'lg': '1024px',\r\n      'xl': '1280px',\r\n      '2xl': '1536px',\r\n      // 自定义断点\r\n      'tablet': '640px',\r\n      'laptop': '1024px',\r\n      'desktop': '1280px',\r\n      // 最大宽度断点\r\n      'max-sm': {'max': '639px'},\r\n      'max-md': {'max': '767px'}\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **动画和过渡配置**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      animation: {\r\n        'fade-in': 'fadeIn 0.5s ease-in-out',\r\n        'slide-up': 'slideUp 0.3s ease-out',\r\n        'bounce-gentle': 'bounceGentle 2s infinite',\r\n        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite'\r\n      },\r\n      keyframes: {\r\n        fadeIn: {\r\n          '0%': { opacity: '0' },\r\n          '100%': { opacity: '1' }\r\n        },\r\n        slideUp: {\r\n          '0%': { transform: 'translateY(100%)', opacity: '0' },\r\n          '100%': { transform: 'translateY(0)', opacity: '1' }\r\n        },\r\n        bounceGentle: {\r\n          '0%, 100%': { transform: 'translateY(-5%)' },\r\n          '50%': { transform: 'translateY(0)' }\r\n        }\r\n      },\r\n      transitionDuration: {\r\n        '250': '250ms',\r\n        '350': '350ms',\r\n        '400': '400ms'\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **组件样式配置**\r\n\r\n#### **自定义组件类**\r\n```javascript\r\nmodule.exports = {\r\n  theme: {\r\n    extend: {\r\n      // 自定义工具类\r\n      borderRadius: {\r\n        'card': '0.75rem',\r\n        'button': '0.5rem'\r\n      },\r\n      boxShadow: {\r\n        'card': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',\r\n        'card-hover': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',\r\n        'inner-light': 'inset 0 1px 2px 0 rgba(255, 255, 255, 0.06)'\r\n      }\r\n    }\r\n  },\r\n  plugins: [\r\n    function({ addComponents }) {\r\n      addComponents({\r\n        '.btn': {\r\n          padding: '0.5rem 1rem',\r\n          borderRadius: '0.5rem',\r\n          fontWeight: '500',\r\n          transition: 'all 0.2s'\r\n        },\r\n        '.btn-primary': {\r\n          backgroundColor: '#3b82f6',\r\n          color: '#ffffff',\r\n          '\u0026:hover': {\r\n            backgroundColor: '#2563eb'\r\n          }\r\n        }\r\n      })\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n\r\n### **实用配置示例**\r\n\r\n#### **完整的设计系统配置**\r\n```javascript\r\nconst colors = require('tailwindcss/colors')\r\n\r\nmodule.exports = {\r\n  darkMode: 'class',\r\n  theme: {\r\n    extend: {\r\n      colors: {\r\n        // 品牌色系\r\n        primary: {\r\n          50: '#eff6ff',\r\n          100: '#dbeafe',\r\n          200: '#bfdbfe',\r\n          300: '#93c5fd',\r\n          400: '#60a5fa',\r\n          500: '#3b82f6',\r\n          600: '#2563eb',\r\n          700: '#1d4ed8',\r\n          800: '#1e40af',\r\n          900: '#1e3a8a'\r\n        },\r\n        // 语义色彩\r\n        success: colors.emerald,\r\n        warning: colors.amber,\r\n        error: colors.red,\r\n        info: colors.blue,\r\n        // 中性色\r\n        gray: colors.slate\r\n      },\r\n      fontFamily: {\r\n        sans: ['Inter var', 'Inter', 'system-ui', 'sans-serif'],\r\n        mono: ['JetBrains Mono', 'Consolas', 'monospace']\r\n      },\r\n      fontSize: {\r\n        'hero': ['clamp(2.5rem, 8vw, 4rem)', { lineHeight: '1.1' }],\r\n        'title': ['clamp(1.5rem, 4vw, 2.5rem)', { lineHeight: '1.2' }]\r\n      },\r\n      spacing: {\r\n        'header': '4rem',\r\n        'section': '6rem'\r\n      },\r\n      animation: {\r\n        'fade-in-up': 'fadeInUp 0.6s ease-out',\r\n        'scale-in': 'scaleIn 0.3s ease-out'\r\n      },\r\n      keyframes: {\r\n        fadeInUp: {\r\n          '0%': {\r\n            opacity: '0',\r\n            transform: 'translateY(30px)'\r\n          },\r\n          '100%': {\r\n            opacity: '1',\r\n            transform: 'translateY(0)'\r\n          }\r\n        },\r\n        scaleIn: {\r\n          '0%': {\r\n            opacity: '0',\r\n            transform: 'scale(0.9)'\r\n          },\r\n          '100%': {\r\n            opacity: '1',\r\n            transform: 'scale(1)'\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n\r\n### **主题切换实现**\r\n\r\n#### **React 中的主题切换**\r\n```jsx\r\nimport { createContext, useContext, useEffect, useState } from 'react'\r\n\r\nconst ThemeContext = createContext()\r\n\r\nexport function ThemeProvider({ children }) {\r\n  const [theme, setTheme] = useState('light')\r\n\r\n  useEffect(() =\u003e {\r\n    const savedTheme = localStorage.getItem('theme')\r\n    if (savedTheme) {\r\n      setTheme(savedTheme)\r\n    } else {\r\n      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches\r\n      setTheme(prefersDark ? 'dark' : 'light')\r\n    }\r\n  }, [])\r\n\r\n  useEffect(() =\u003e {\r\n    localStorage.setItem('theme', theme)\r\n    document.documentElement.classList.toggle('dark', theme === 'dark')\r\n  }, [theme])\r\n\r\n  const toggleTheme = () =\u003e {\r\n    setTheme(prev =\u003e prev === 'light' ? 'dark' : 'light')\r\n  }\r\n\r\n  return (\r\n    \u003cThemeContext.Provider value={{ theme, toggleTheme }}\u003e\r\n      {children}\r\n    \u003c/ThemeContext.Provider\u003e\r\n  )\r\n}\r\n\r\nexport const useTheme = () =\u003e {\r\n  const context = useContext(ThemeContext)\r\n  if (!context) {\r\n    throw new Error('useTheme must be used within ThemeProvider')\r\n  }\r\n  return context\r\n}\r\n```\r\n\r\n#### **子组件使用示例**\r\n\r\n##### **主题切换按钮组件**\r\n```jsx\r\nimport { useTheme } from './ThemeProvider'\r\n\r\nfunction ThemeToggleButton() {\r\n  const { theme, toggleTheme } = useTheme()\r\n\r\n  return (\r\n    \u003cbutton\r\n      onClick={toggleTheme}\r\n      className=\"\r\n        p-3 rounded-lg\r\n        bg-white dark:bg-gray-800\r\n        border border-gray-200 dark:border-gray-700\r\n        text-gray-900 dark:text-gray-100\r\n        hover:bg-gray-50 dark:hover:bg-gray-700\r\n        transition-colors duration-200\r\n        shadow-sm hover:shadow-md\r\n      \"\r\n      aria-label={`切换到${theme === 'light' ? '深色' : '浅色'}模式`}\r\n    \u003e\r\n      {theme === 'light' ? (\r\n        \u003csvg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n          \u003cpath d=\"M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z\" /\u003e\r\n        \u003c/svg\u003e\r\n      ) : (\r\n        \u003csvg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n          \u003cpath fillRule=\"evenodd\" d=\"M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z\" clipRule=\"evenodd\" /\u003e\r\n        \u003c/svg\u003e\r\n      )}\r\n    \u003c/button\u003e\r\n  )\r\n}\r\n```\r\n\r\n##### **主题感知的卡片组件**\r\n```jsx\r\nimport { useTheme } from './ThemeProvider'\r\n\r\nfunction ThemeCard({ title, children }) {\r\n  const { theme } = useTheme()\r\n\r\n  return (\r\n    \u003cdiv className={`\r\n      p-6 rounded-xl\r\n      ${theme === 'light' \r\n        ? 'bg-white shadow-md border border-gray-100' \r\n        : 'bg-gray-800 shadow-xl border border-gray-700'\r\n      }\r\n      transition-all duration-300 ease-in-out\r\n      hover:shadow-lg hover:scale-102\r\n    `}\u003e\r\n      \u003ch3 className=\"\r\n        text-xl font-semibold mb-4\r\n        text-gray-900 dark:text-gray-100\r\n      \"\u003e\r\n        {title}\r\n      \u003c/h3\u003e\r\n      \u003cdiv className=\"\r\n        text-gray-600 dark:text-gray-300\r\n        leading-relaxed\r\n      \"\u003e\r\n        {children}\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  )\r\n}\r\n```\r\n\r\n##### **动态主题样式组件**\r\n```jsx\r\nimport { useTheme } from './ThemeProvider'\r\n\r\nfunction DynamicHeader() {\r\n  const { theme } = useTheme()\r\n\r\n  // 根据主题动态设置样式\r\n  const headerStyles = {\r\n    light: {\r\n      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\r\n      color: 'white'\r\n    },\r\n    dark: {\r\n      background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',\r\n      color: '#e2e8f0'\r\n    }\r\n  }\r\n\r\n  return (\r\n    \u003cheader \r\n      style={headerStyles[theme]}\r\n      className=\"\r\n        px-8 py-16 text-center\r\n        transition-all duration-500 ease-in-out\r\n      \"\r\n    \u003e\r\n      \u003ch1 className=\"\r\n        text-4xl md:text-6xl font-bold mb-6\r\n        animate-fade-in-up\r\n      \"\u003e\r\n        {theme === 'light' ? '☀️ 明亮模式' : '🌙 深色模式'}\r\n      \u003c/h1\u003e\r\n      \u003cp className=\"\r\n        text-lg md:text-xl opacity-90\r\n        max-w-2xl mx-auto\r\n      \"\u003e\r\n        当前使用的是 {theme === 'light' ? '浅色' : '深色'} 主题\r\n      \u003c/p\u003e\r\n    \u003c/header\u003e\r\n  )\r\n}\r\n```\r\n\r\n##### **主题状态指示器**\r\n```jsx\r\nimport { useTheme } from './ThemeProvider'\r\n\r\nfunction ThemeIndicator() {\r\n  const { theme } = useTheme()\r\n\r\n  return (\r\n    \u003cdiv className=\"\r\n      fixed top-4 right-4 z-50\r\n      px-3 py-2 rounded-full\r\n      bg-black/20 dark:bg-white/20\r\n      backdrop-blur-sm\r\n      text-white dark:text-black\r\n      text-sm font-medium\r\n      transition-all duration-300\r\n    \"\u003e\r\n      \u003cspan className=\"flex items-center gap-2\"\u003e\r\n        \u003cdiv className={`\r\n          w-2 h-2 rounded-full\r\n          ${theme === 'light' ? 'bg-yellow-400' : 'bg-blue-400'}\r\n        `} /\u003e\r\n        {theme === 'light' ? 'Light' : 'Dark'}\r\n      \u003c/span\u003e\r\n    \u003c/div\u003e\r\n  )\r\n}\r\n```\r\n\r\n##### **应用入口组件示例**\r\n```jsx\r\nimport { ThemeProvider } from './ThemeProvider'\r\n\r\nfunction App() {\r\n  return (\r\n    \u003cThemeProvider\u003e\r\n      \u003cdiv className=\"\r\n        min-h-screen\r\n        bg-gray-50 dark:bg-gray-900\r\n        transition-colors duration-300\r\n      \"\u003e\r\n        \u003cThemeIndicator /\u003e\r\n        \u003cDynamicHeader /\u003e\r\n        \r\n        \u003cmain className=\"container mx-auto px-4 py-8\"\u003e\r\n          \u003cdiv className=\"flex justify-between items-center mb-8\"\u003e\r\n            \u003ch2 className=\"\r\n              text-2xl font-bold\r\n              text-gray-900 dark:text-gray-100\r\n            \"\u003e\r\n              主题演示\r\n            \u003c/h2\u003e\r\n            \u003cThemeToggleButton /\u003e\r\n          \u003c/div\u003e\r\n\r\n          \u003cdiv className=\"grid md:grid-cols-2 gap-6\"\u003e\r\n            \u003cThemeCard title=\"功能特性\"\u003e\r\n              自动适应系统主题偏好，支持手动切换\r\n            \u003c/ThemeCard\u003e\r\n            \u003cThemeCard title=\"持久化存储\"\u003e\r\n              主题选择会保存到 localStorage\r\n            \u003c/ThemeCard\u003e\r\n          \u003c/div\u003e\r\n        \u003c/main\u003e\r\n      \u003c/div\u003e\r\n    \u003c/ThemeProvider\u003e\r\n  )\r\n}\r\n```\r\n\r\n\r\n### **最佳实践**\r\n1. **保持一致性**：使用统一的命名规范和数值规律\r\n2. **语义化命名**：使用描述性的颜色名而非具体的颜色值\r\n3. **渐进增强**：优先使用 extend 而不是完全覆盖\r\n4. **性能考虑**：避免定义过多不使用的样式\r\n5. **可维护性**：将复杂配置拆分为独立的模块文件\r\n\r\n\r\n### **注意事项**\r\n- **CSS 变量集成**：可以结合 CSS 自定义属性实现更灵活的主题\r\n- **构建优化**：使用 purge 配置移除未使用的样式\r\n- **团队协作**：建立清晰的设计 token 文档\r\n- **向后兼容**：升级 TailwindCSS 时注意配置变更\r\n\r\nTailwindCSS 主题系统为构建一致、可维护的设计系统提供了强大的基础，合理配置能够显著提升开发效率和用户体验。\r\n"])</script><script>self.__next_f.push([1,"38:T4b5e,"])</script><script>self.__next_f.push([1,"\r\n# 二进制雨幕：向机器运算界的一瞥\r\n\r\n做背景的时候莫名想到《黑客帝国》导致的。\r\n\r\n本篇文章会剖析从字符网格到径向遮罩的每一行代码，全面解构这个让鼠标光标拥有\"照明术\"的视觉效果。\r\n\r\n## Canvas初始化：搭建数字舞台\r\n\r\nCanvas在前端绘图领域的重要性不言而喻，它所饰演的画布承载了整个背景。\r\n\r\n### 响应式画布的精确适配\r\n\r\n```12:25:src/components/ui/background/BinaryRainBackground.tsx\r\nconst resizeCanvas = useCallback(() =\u003e {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    canvas.width = rect.width;\r\n    canvas.height = rect.height;\r\n\r\n    // Generate particles grid\r\n    const binaryChars = ['0', '1'];\r\n    const gridSize = 20;\r\n    particlesRef.current = [];\r\n}, []);\r\n```\r\n\r\n**getBoundingClientRect精确定位**：\r\n\r\n这个看似简单的方法实际上是Web API中的精密仪器，它返回的不仅仅是元素的位置，而是一个包含了所有空间信息的完整报告：\r\n- **绝对位置**：相对于视口的精确坐标\r\n- **实际尺寸**：经过CSS变换后的真实大小\r\n- **边界信息**：包含border、padding等所有影响布局的因素\r\n\r\n**为什么直接设置canvas.width而不是CSS样式**？\r\n\r\n```typescript\r\ncanvas.width = rect.width;   // 设置画布的实际分辨率\r\n// 而不是：\r\n// canvas.style.width = rect.width + 'px';  // 只是视觉缩放\r\n```\r\n\r\n这是Canvas开发中的一个经典陷阱！CSS尺寸只是视觉上的缩放，而canvas.width设置的是实际的像素分辨率。如果只设置CSS尺寸，你会得到一个糊成马赛克的模糊画面——类似于用放大镜看像素游戏。\r\n\r\n### 网格生成：20像素的数学艺术\r\n\r\n```26:39:src/components/ui/background/BinaryRainBackground.tsx\r\n// Generate particles grid\r\nconst binaryChars = ['0', '1'];\r\nconst gridSize = 20;\r\nparticlesRef.current = [];\r\n\r\nfor (let y = 0; y \u003c canvas.height; y += gridSize) {\r\n    for (let x = 0; x \u003c canvas.width; x += gridSize) {\r\n        particlesRef.current.push({\r\n            x,\r\n            y,\r\n            char: binaryChars[Math.floor(Math.random() * 2)]\r\n        });\r\n    }\r\n}\r\n```\r\n\r\n**为什么选择20像素的网格**？~~（主要是其他像素值看起来视觉效果都不太好）~~\r\n\r\n- **太小（如10px）**：字符密度过高，GPU哭泣，帧率跳水💔\r\n- **太大（如40px）**：字符稀疏，看起来像散布的星星而不是矩阵雨\r\n- **20px刚好**：既保证了足够的视觉密度，又不会出现明显卡顿\r\n\r\n**字符数量的数学估算**：\r\n\r\n对于一个1920×1080的全屏画面：\r\n$$字符数量 = \\frac{1920}{20} \\times \\frac{1080}{20} = 96 \\times 54 = 5184个$$\r\n\r\n每个字符对象包含3个属性（x, y, char），在JavaScript中大约占用24字节，总内存占用约124KB——完全在可控范围内！\r\n\r\n### 字符对象的极简设计\r\n\r\n```typescript\r\ninterface ParticleData {\r\n    x: number;\r\n    y: number;\r\n    char: string;\r\n}\r\n```\r\n\r\n这个接口设计体现了\"Less is More\"的哲学：\r\n- **x, y**: 字符在网格中的绝对位置\r\n- **char**: 当前显示的字符（'0'或'1'）\r\n- **没有颜色**：统一使用主题色，减少内存占用\r\n- **没有速度**：位置固定，无需速度属性\r\n- **没有生命周期**：字符永存，只是内容变化\r\n\r\n### 随机性的持续注入随机\r\n\r\n```93:96:src/components/ui/background/BinaryRainBackground.tsx\r\nconst updateCharacters = useCallback(() =\u003e {\r\n    particlesRef.current.forEach(p =\u003e {\r\n        p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n    });\r\n}, []);\r\n```\r\n\r\n每秒尝试重新设置每个字符对象的显示字符。\r\n\r\n## 动画渲染：光影交织的视觉盛宴\r\n\r\nCanvas动画的核心在于渲染循环，而我们的二进制雨幕用了一些巧妙的技巧来创造独特的视觉效果。\r\n\r\n## 鼠标跟踪与径向遮罩\r\n\r\n《鼠标探照灯与字符矩阵》\r\n\r\n### 坐标转换\r\n\r\n```45:51:src/components/ui/background/BinaryRainBackground.tsx\r\n// 鼠标移动事件：更新鼠标坐标\r\nthis.canvas.addEventListener('mousemove', (e) =\u003e {\r\n    const rect = this.canvas.getBoundingClientRect();\r\n    // 将屏幕坐标转换为Canvas坐标\r\n    this.mouseX = e.clientX - rect.left;\r\n    this.mouseY = e.clientY - rect.top;\r\n});\r\n```\r\n\r\n**坐标系统的数学变换**：\r\n\r\n浏览器中存在多个坐标系统：\r\n- **屏幕坐标系**：`e.clientX, e.clientY`（相对于视口）\r\n- **页面坐标系**：`e.pageX, e.pageY`（相对于整个页面）\r\n- **Canvas坐标系**：`mouseX, mouseY`（相对于画布）\r\n\r\n变换公式：\r\n$$Canvas_{x} = Screen_{x} - Canvas_{offsetX}$$\r\n$$Canvas_{y} = Screen_{y} - Canvas_{offsetY}$$\r\n\r\n其中`rect.left`和`rect.top`就是Canvas相对于视口的偏移量。\r\n\r\n### 径向渐变\r\n\r\n```78:85:src/components/ui/background/BinaryRainBackground.tsx\r\n// Create mask\r\nctx.globalCompositeOperation = 'destination-in';\r\nconst gradient = ctx.createRadialGradient(\r\n    mousePosRef.current.x, mousePosRef.current.y, 0,\r\n    mousePosRef.current.x, mousePosRef.current.y, 200\r\n);\r\ngradient.addColorStop(0, 'rgba(255, 255, 255, 1)');\r\ngradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\r\n```\r\n\r\n**径向渐变的几何原理**：\r\n\r\n`createRadialGradient`创建的是从内圆到外圆的渐变：\r\n- **内圆**：半径0，位置(mouseX, mouseY)，完全不透明\r\n- **外圆**：半径200，位置(mouseX, mouseY)，完全透明\r\n\r\n数学表达式：\r\n$$透明度(r) = \\begin{cases}\r\n1 \u0026 \\text{if } r = 0 \\\\\r\n1 - \\frac{r}{200} \u0026 \\text{if } 0 \u003c r \u003c 200 \\\\\r\n0 \u0026 \\text{if } r \\geq 200\r\n\\end{cases}$$\r\n\r\n其中$r = \\sqrt{(x-mouseX)^2 + (y-mouseY)^2}$是像素到鼠标的距离。\r\n\r\n### destination-in混合模式\r\n\r\n```typescript\r\nctx.globalCompositeOperation = 'destination-in';\r\n```\r\n\r\n**工作原理**：\r\n1. **destination**：已经画在画布上的内容（我们的字符）\r\n2. **source**：新绘制的内容（径向渐变遮罩）\r\n3. **destination-in**：只保留destination中与source重叠且source不透明的部分\r\n\r\n**destination-in混合模式算法具体解释：**\r\n\r\n```typescript\r\n// 伪代码\r\nfor (每个像素(x, y)) {\r\n    const 字符透明度 = destination[x][y].alpha;    // 字符的原始透明度\r\n    const 渐变透明度 = source[x][y].alpha;         // 径向渐变的透明度\r\n    \r\n    // destination-in 的混合公式\r\n    最终透明度 = 字符透明度 * 渐变透明度;\r\n    \r\n    // 如果渐变在该位置是透明的(alpha=0)，字符也变透明\r\n    // 如果渐变在该位置是不透明的(alpha=1)，字符保持原样\r\n}\r\n```\r\n\r\n**视觉效果**：\r\n\r\n- 渐变中心（不透明）：字符完全可见\r\n- 渐变边缘（透明）：字符完全隐藏\r\n- 渐变中间（半透明）：字符部分可见\r\n\r\n## 字符更新：双管齐下\r\n\r\n二进制雨幕使用了双时间线系统，分别担任更新与渲染的职责。\r\n\r\n### 定时器与动画帧的分工协作\r\n\r\n```98:102:src/components/ui/background/BinaryRainBackground.tsx\r\n// Character update interval\r\nintervalIdRef.current = setInterval(updateCharacters, 1000);\r\n```\r\n\r\n```107:115:src/components/ui/background/BinaryRainBackground.tsx\r\nconst animate = useCallback(() =\u003e {\r\n    // ... 渲染逻辑\r\n    animationIdRef.current = requestAnimationFrame(animate);\r\n}, [color]);\r\n```\r\n\r\n**为什么用两套定时系统**？\r\n\r\n这是性能优化的经典分离策略：\r\n\r\n**setInterval（1000ms）- 内容更新**：\r\n- 更新字符内容\r\n- 频率相对较低\r\n- 不需要与屏幕刷新同步\r\n\r\n**requestAnimationFrame（~16.67ms）- 视觉渲染**：\r\n- 绘制当前帧\r\n- 与屏幕刷新率同步\r\n- 页面不可见时自动暂停\r\n\r\n### 内存友好的字符更新\r\n\r\n```93:96:src/components/ui/background/BinaryRainBackground.tsx\r\nconst updateCharacters = useCallback(() =\u003e {\r\n    particlesRef.current.forEach(p =\u003e {\r\n        p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n    });\r\n}, []);\r\n```\r\n\r\n**为什么不重新创建对象**？\r\n\r\n错误的做法：\r\n```typescript\r\n// ❌ 会创建大量垃圾对象\r\nparticlesRef.current = particlesRef.current.map(p =\u003e ({\r\n    ...p,\r\n    char: ['0', '1'][Math.floor(Math.random() * 2)]\r\n}));\r\n```\r\n\r\n正确的做法：\r\n```typescript\r\n// ✅ 直接修改属性，零垃圾生成\r\nparticlesRef.current.forEach(p =\u003e {\r\n    p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n});\r\n```\r\n\r\n这种方式的优势：\r\n- **零内存分配**：不创建新对象\r\n- **垃圾回收友好**：减少GC压力\r\n- **性能稳定**：避免帧率波动\r\n\r\n## 性能优化\r\n\r\n老三样优化方案，还是写着吧。\r\n\r\n### useCallback缓存\r\n\r\n```12:40:src/components/ui/background/BinaryRainBackground.tsx\r\nconst resizeCanvas = useCallback(() =\u003e {\r\n    // ... 尺寸调整逻辑\r\n}, []);\r\n\r\nconst updateMousePos = useCallback((e: MouseEvent) =\u003e {\r\n    // ... 鼠标位置更新\r\n}, []);\r\n\r\nconst animate = useCallback(() =\u003e {\r\n    // ... 动画循环\r\n}, [color]);\r\n\r\nconst updateCharacters = useCallback(() =\u003e {\r\n    // ... 字符更新\r\n}, []);\r\n```\r\n\r\n**未使用useCallback的问题**：\r\n```typescript\r\n// ❌ 每次渲染都创建新函数\r\nuseEffect(() =\u003e {\r\n    const animate = () =\u003e { /* ... */ };  // 新函数引用\r\n    requestAnimationFrame(animate);\r\n}, [color]);  // color变化时会重复创建animate\r\n```\r\n\r\n**使用useCallback的优势**：\r\n```typescript\r\n// ✅ 函数引用稳定，避免重复创建\r\nconst animate = useCallback(() =\u003e { /* ... */ }, [color]);\r\nuseEffect(() =\u003e {\r\n    requestAnimationFrame(animate);  // 使用缓存的函数\r\n}, [animate]);\r\n```\r\n\r\n### 事件监听器的生命周期管理\r\n\r\n```104:112:src/components/ui/background/BinaryRainBackground.tsx\r\n// Set up event listeners\r\nwindow.addEventListener('resize', resizeCanvas);\r\ndocument.addEventListener('mousemove', updateMousePos);\r\n\r\n// Cleanup\r\nreturn () =\u003e {\r\n    window.removeEventListener('resize', resizeCanvas);\r\n    document.removeEventListener('mousemove', updateMousePos);\r\n};\r\n```\r\n\r\n**为什么清理如此重要**？\r\n\r\n事件监听器是内存泄漏的常见源头：\r\n\r\n**内存泄漏场景**：\r\n1. 组件卸载但事件监听器仍然存在\r\n2. 监听器引用了已销毁的DOM元素\r\n3. 闭包持有大量内存引用\r\n\r\n**清理函数的保护机制**：\r\n- 确保组件卸载时立即清理\r\n- 避免\"僵尸监听器\"继续运行\r\n- 释放闭包中的内存引用\r\n\r\n### Canvas渲染的GPU加速技巧\r\n\r\n```60:76:src/components/ui/background/BinaryRainBackground.tsx\r\n// Clear canvas\r\nctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n// Draw background\r\nctx.fillStyle = 'rgba(10, 10, 10, 0.1)';\r\nctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n// Text styling\r\nctx.fillStyle = color;\r\nctx.font = '14px monospace';\r\nctx.textAlign = 'left';\r\nctx.textBaseline = 'top';\r\n\r\n// Draw characters\r\nparticlesRef.current.forEach(p =\u003e {\r\n    ctx.fillText(p.char, p.x, p.y);\r\n});\r\n```\r\n\r\n**渲染状态的批量设置**：\r\n\r\n优化前的低效做法：\r\n```typescript\r\n// ❌ 每个字符都设置一次样式\r\nparticlesRef.current.forEach(p =\u003e {\r\n    ctx.fillStyle = color;          // 重复设置\r\n    ctx.font = '14px monospace';    // 重复设置\r\n    ctx.fillText(p.char, p.x, p.y);\r\n});\r\n```\r\n\r\n优化后的高效做法：\r\n```typescript\r\n// ✅ 批量设置样式，然后批量绘制\r\nctx.fillStyle = color;\r\nctx.font = '14px monospace';\r\nparticlesRef.current.forEach(p =\u003e {\r\n    ctx.fillText(p.char, p.x, p.y);  // 只专注绘制\r\n});\r\n```\r\n\r\n## 完整源码全解析\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport {useEffect, useRef, memo, useCallback} from 'react';\r\n\r\n// ==================== 类型定义 ====================\r\ninterface BinaryRainBackgroundProps {\r\n    className?: string;    // 自定义样式类名\r\n    opacity?: number;      // 整体透明度 [0-1]\r\n    color?: string;        // 字符颜色（RGBA格式）\r\n}\r\n\r\n// ==================== 主组件：二进制雨幕背景 ====================\r\nexport const BinaryRainBackground = memo(function BinaryRainBackground({\r\n                                         className = '',\r\n                                         opacity = 0.6,              // 默认60%透明度\r\n                                         color = 'rgba(0, 255, 255, 1)'  // 默认青色\r\n                                     }: BinaryRainBackgroundProps) {\r\n    \r\n    // ==================== Refs管理 ====================\r\n    const canvasRef = useRef\u003cHTMLCanvasElement\u003e(null);                              // Canvas DOM引用\r\n    const animationIdRef = useRef\u003cnumber | null\u003e(null);                             // RAF动画ID\r\n    const particlesRef = useRef\u003cArray\u003c{ x: number; y: number; char: string }\u003e\u003e([]);  // 字符网格数组\r\n    const mousePosRef = useRef({x: 0, y: 0});                                       // 鼠标位置缓存\r\n    const intervalIdRef = useRef\u003cNodeJS.Timeout | null\u003e(null);                      // 字符更新定时器\r\n\r\n    // ==================== Canvas尺寸管理 ====================\r\n    const resizeCanvas = useCallback(() =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        // 获取Canvas的实际显示尺寸\r\n        const rect = canvas.getBoundingClientRect();\r\n        canvas.width = rect.width;   // 设置实际分辨率\r\n        canvas.height = rect.height; // 避免模糊问题\r\n\r\n        // 生成字符网格：20px间距的规则网格\r\n        const binaryChars = ['0', '1'];\r\n        const gridSize = 20;  // 网格大小\r\n        particlesRef.current = [];\r\n\r\n        // 双重循环生成网格点\r\n        for (let y = 0; y \u003c canvas.height; y += gridSize) {\r\n            for (let x = 0; x \u003c canvas.width; x += gridSize) {\r\n                particlesRef.current.push({\r\n                    x,\r\n                    y,\r\n                    char: binaryChars[Math.floor(Math.random() * 2)]  // 随机0或1\r\n                });\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    // ==================== 鼠标位置跟踪 ====================\r\n    const updateMousePos = useCallback((e: MouseEvent) =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        // 坐标系转换：屏幕坐标 → Canvas坐标\r\n        const rect = canvas.getBoundingClientRect();\r\n        mousePosRef.current.x = e.clientX - rect.left;\r\n        mousePosRef.current.y = e.clientY - rect.top;\r\n    }, []);\r\n\r\n    // ==================== 核心动画循环 ====================\r\n    const animate = useCallback(() =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        // 注册下一帧\r\n        animationIdRef.current = requestAnimationFrame(animate);\r\n\r\n        // 步骤1：清除画布（准备新帧）\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // 步骤2：设置文字样式（批量设置提升性能）\r\n        ctx.fillStyle = color;\r\n        ctx.font = '14px monospace';    // 等宽字体确保对齐\r\n        ctx.textAlign = 'left';\r\n        ctx.textBaseline = 'top';\r\n\r\n        // 步骤3：绘制所有字符\r\n        particlesRef.current.forEach(p =\u003e {\r\n            ctx.fillText(p.char, p.x, p.y);\r\n        });\r\n\r\n        // 步骤4：创建径向遮罩\r\n        ctx.globalCompositeOperation = 'destination-in';  // 遮罩混合模式\r\n        \r\n        // 创建以鼠标为中心的径向渐变\r\n        const gradient = ctx.createRadialGradient(\r\n            mousePosRef.current.x, mousePosRef.current.y, 0,      // 内圆：鼠标位置，半径0\r\n            mousePosRef.current.x, mousePosRef.current.y, 200     // 外圆：鼠标位置，半径200px\r\n        );\r\n        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');      // 中心：完全不透明\r\n        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');      // 边缘：完全透明\r\n        \r\n        // 应用渐变遮罩\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // 步骤6：重置混合模式\r\n        ctx.globalCompositeOperation = 'source-over';\r\n    }, [color]);\r\n\r\n    // ==================== 字符内容更新 ====================\r\n    const updateCharacters = useCallback(() =\u003e {\r\n        // 遍历所有字符，随机更新内容\r\n        particlesRef.current.forEach(p =\u003e {\r\n            p.char = ['0', '1'][Math.floor(Math.random() * 2)];\r\n        });\r\n    }, []);\r\n\r\n    // ==================== 组件生命周期管理 ====================\r\n    useEffect(() =\u003e {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        // 启动字符更新定时器（1秒间隔）\r\n        intervalIdRef.current = setInterval(updateCharacters, 1000);\r\n\r\n        // 注册事件监听器\r\n        window.addEventListener('resize', resizeCanvas);          // 窗口大小变化\r\n        document.addEventListener('mousemove', updateMousePos);   // 鼠标移动\r\n\r\n        // 初始化设置\r\n        resizeCanvas();  // 计算初始网格\r\n        animate();       // 启动动画循环\r\n\r\n        // 清理函数：组件卸载时执行\r\n        return () =\u003e {\r\n            // 清理动画循环\r\n            if (animationIdRef.current) {\r\n                cancelAnimationFrame(animationIdRef.current);\r\n            }\r\n            // 清理定时器\r\n            if (intervalIdRef.current) {\r\n                clearInterval(intervalIdRef.current);\r\n            }\r\n            // 清理事件监听器\r\n            window.removeEventListener('resize', resizeCanvas);\r\n            document.removeEventListener('mousemove', updateMousePos);\r\n        };\r\n    }, [color, resizeCanvas, updateMousePos, animate, updateCharacters]);\r\n\r\n    // ==================== 组件渲染 ====================\r\n    return (\r\n        \u003ccanvas\r\n            ref={canvasRef}\r\n            className={`absolute inset-0 w-full h-full pointer-events-none ${className}`}\r\n            style={{\r\n                opacity,      // 应用透明度\r\n                zIndex: 0     // 确保在背景层\r\n            }}\r\n        /\u003e\r\n    );\r\n}); \r\n```\r\n\r\n### 核心算法流程图\r\n\r\n```\r\n初始化 → 网格生成 → 动画循环 → 字符更新 → 清理资源\r\n  ↓         ↓         ↓         ↓         ↓\r\nCanvas    20px网格   RAF循环   1秒定时    useEffect清理\r\n尺寸适配    字符分布   渲染优化   随机更新   内存释放\r\n  ↓         ↓         ↓         ↓         ↓\r\n响应式     二进制字符  鼠标跟踪   视觉刷新   生命周期\r\n设计       随机分布   径向遮罩   保持活力   完整管理\r\n```\r\n\r\n### 关键技术要点总结\r\n\r\n**1. 径向遮罩的数学实现**\r\n\r\n- 鼠标位置实时跟踪，坐标精确转换\r\n- 径向渐变创建探照灯效果\r\n- destination-in混合模式实现遮罩\r\n\r\n**2. 双时间线设计**\r\n\r\n- requestAnimationFrame：60fps视觉渲染\r\n- setInterval：1s字符内容更新\r\n- 分离关注点，各司其职\r\n\r\n## 写在最后\r\n\r\n我认真思考了一会儿，发现好像没什么想写的......\r\n\r\n不管了，又到了我最喜欢的许愿环节！mua！\r\n\r\n*愿你的代码如Matrix中的数字雨，在用户的视线中编织出最美的数字诗篇。* ✨\r\n"])</script><script>self.__next_f.push([1,"39:T4459,"])</script><script>self.__next_f.push([1,"\r\n# 自定义光标图案\r\n\r\n## 基本概念\r\n\r\n光标图案自定义主要涉及三个核心状态：\r\n- **默认状态**：鼠标悬停时的基础样式\r\n- **悬停状态**：鼠标悬停在可交互元素上时的样式\r\n- **拖拽状态**：正在进行拖拽操作时的样式\r\n\r\n## 为什么能覆盖默认光标\r\n\r\n你可能会好奇，为什么我们的自定义图案能够\"覆盖\"浏览器的默认光标？实际上，这是通过隐藏系统光标并用自定义元素替代来实现的：\r\n\r\n### 光标隐藏与替换原理\r\n\r\n核心实现分为两个步骤：**隐藏系统光标** + **自定义光标跟随**\r\n\r\n```tsx\r\n// 步骤1：隐藏系统默认光标\r\n\u003cdiv className=\"cursor-none\"\u003e\r\n  {/* 容器内容 */}\r\n\u003c/div\u003e\r\n\r\n// 步骤2：创建跟随鼠标的自定义光标\r\n\u003cmotion.div\r\n  className=\"fixed pointer-events-none z-50\"\r\n  style={{\r\n    left: position.x - 32,  // 实时跟随鼠标X坐标\r\n    top: position.y - 32,   // 实时跟随鼠标Y坐标\r\n  }}\r\n\u003e\r\n```\r\n\r\n### 技术实现机制\r\n\r\n1. **光标隐藏（cursor-none）**：使用CSS属性彻底隐藏浏览器默认光标\r\n2. **固定定位（Fixed Position）**：让自定义图案相对于视口定位，不受滚动影响\r\n3. **高层级（High Z-index）**：确保自定义图案显示在所有其他元素之上\r\n4. **鼠标事件穿透（pointer-events-none）**：让图案不干扰正常的鼠标交互\r\n5. **实时位置更新**：监听鼠标移动事件，动态更新图案位置\r\n\r\n### 关键代码解析\r\n\r\n```tsx\r\n// 步骤1：容器应用cursor-none隐藏系统光标\r\n\u003cdiv\r\n  className={`overflow-hidden ${\r\n    effectiveDisplayMode === 'tiled' ? 'cursor-none' : ''\r\n  }`}\r\n  onMouseMove={handleMouseMove}\r\n\u003e\r\n  {/* 页面内容 */}\r\n\u003c/div\u003e\r\n\r\n// 步骤2：监听鼠标移动，获取实时坐标\r\nuseEffect(() =\u003e {\r\n  const handleMouseMove = (e: MouseEvent) =\u003e {\r\n    setPosition({ x: e.clientX, y: e.clientY });\r\n  };\r\n  \r\n  document.addEventListener('mousemove', handleMouseMove);\r\n  return () =\u003e document.removeEventListener('mousemove', handleMouseMove);\r\n}, []);\r\n```\r\n\r\n这样一来，系统默认光标被完全隐藏，用户只能看到我们自定义的动画图案。同时，由于使用了 `pointer-events-none`，自定义光标不会干扰正常的点击、悬停等交互操作。\r\n\r\n## 实现思路\r\n\r\n### 状态管理\r\n\r\n首先，我们需要定义光标指示器的基本属性：\r\n\r\n```tsx\r\ninterface CursorPatternProps {\r\n  isDragging: boolean;     // 是否正在拖拽\r\n  isHovering: boolean;     // 是否正在悬停\r\n  position: { x: number; y: number };  // 光标位置\r\n}\r\n```\r\n\r\n### 动画框架选择\r\n\r\n使用 Framer Motion（也可以用别的，看个人喜好） 来实现动画效果：\r\n\r\n```tsx\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\n// 基础容器动画\r\n\u003cmotion.div\r\n  initial={{ opacity: 0, scale: 0 }}\r\n  animate={{ \r\n    opacity: 1, \r\n    scale: isDragging ? 1 : 0.7,  // 拖拽时放大\r\n  }}\r\n  exit={{ opacity: 0, scale: 0 }}\r\n  transition={{ duration: 0.2, ease: 'easeOut' }}\r\n\u003e\r\n```\r\n\r\n## 设计分层结构\r\n\r\n### 外层旋转环\r\n\r\n创建一个让用户感知到活跃状态的旋转虚线边框：\r\n\r\n```tsx\r\n\u003cmotion.div\r\n  className=\"absolute w-16 h-16 rounded-full border-2 border-dashed\"\r\n  style={{\r\n    borderColor: currentTheme.colors.primary,\r\n    filter: `drop-shadow(0 0 8px ${currentTheme.colors.primary}33)`,\r\n  }}\r\n  animate={{\r\n    rotate: isDragging ? [0, 360] : [0, 180, 0],  // 拖拽时连续旋转\r\n  }}\r\n  transition={{\r\n    duration: isDragging ? 3 : 4,\r\n    repeat: Infinity,\r\n    ease: 'linear',\r\n  }}\r\n/\u003e\r\n```\r\n\r\n### 内层脉冲圆\r\n\r\n添加一个脉冲动画的内圆：\r\n\r\n```tsx\r\n\u003cmotion.div\r\n  className=\"absolute w-16 h-16 rounded-full border\"\r\n  animate={{\r\n    scale: isDragging ? [1, 1.2, 1] : [1, 1.1, 1],\r\n    opacity: isDragging ? [0.7, 1, 0.7] : [0.4, 0.7, 0.4],\r\n  }}\r\n  transition={{\r\n    duration: isDragging ? 2 : 3,\r\n    repeat: Infinity,\r\n    ease: 'easeInOut',\r\n  }}\r\n/\u003e\r\n```\r\n\r\n### 中心几何图形\r\n\r\n在中心放置可识别的几何形状，如三角形和菱形：\r\n\r\n```tsx\r\n{/* 三角形指示器 */}\r\n\u003cmotion.div\r\n  className=\"absolute w-0 h-0\"\r\n  style={{\r\n    borderLeft: '6px solid transparent',\r\n    borderRight: '6px solid transparent',\r\n    borderBottom: `10px solid ${currentTheme.colors.primary}`,\r\n  }}\r\n  animate={{\r\n    y: isDragging ? [-2, 2, -2] : [-1, 1, -1],  // 轻微地上下浮动\r\n  }}\r\n/\u003e\r\n\r\n{/* 菱形装饰 */}\r\n\u003cmotion.div\r\n  className=\"absolute w-3 h-3 rotate-45\"\r\n  style={{\r\n    backgroundColor: currentTheme.colors.accent,\r\n  }}\r\n  animate={{\r\n    scale: isDragging ? [0.8, 1.2, 0.8] : [0.9, 1.1, 0.9],\r\n    rotate: isDragging ? [45, 135, 45] : [45, 90, 45],\r\n  }}\r\n/\u003e\r\n```\r\n\r\n### 扩散波浪\r\n\r\n在拖拽状态下添加向外扩散的波浪效果：\r\n\r\n```tsx\r\n{isDragging \u0026\u0026 [0, 1, 2].map((index) =\u003e (\r\n  \u003cmotion.div\r\n    key={`wave-${index}`}\r\n    className=\"absolute w-16 h-16 rounded-full border opacity-30\"\r\n    animate={{\r\n      scale: [1, 2.5],\r\n      opacity: [0.6, 0],\r\n    }}\r\n    transition={{\r\n      duration: 1.5,\r\n      repeat: Infinity,\r\n      ease: 'easeOut',\r\n      delay: index * 0.5,  // 错峰动画\r\n    }}\r\n  /\u003e\r\n))}\r\n```\r\n\r\n### 方向箭头\r\n\r\n添加四个方向的箭头，提示可拖拽的方向：\r\n\r\n```tsx\r\n{[0, 90, 180, 270].map((rotation, index) =\u003e (\r\n  \u003cmotion.div\r\n    key={`arrow-${index}`}\r\n    style={{\r\n      transform: `rotate(${rotation}deg) translateY(-24px)`,\r\n    }}\r\n    animate={{\r\n      opacity: isDragging ? [0.3, 1, 0.3] : [0.2, 0.6, 0.2],\r\n      y: isDragging ? [-2, 2, -2] : [-1, 1, -1],\r\n    }}\r\n    transition={{\r\n      delay: index * 0.2,  // 依次出现\r\n    }}\r\n  \u003e\r\n    {/* SVG 箭头图标 */}\r\n  \u003c/motion.div\u003e\r\n))}\r\n```\r\n\r\n## 主题集成\r\n\r\n### 动态颜色\r\n\r\n利用主题系统实现颜色的动态切换：\r\n\r\n```tsx\r\nconst { currentTheme } = useThemeStore();\r\n\r\n// 使用主题色\r\nstyle={{\r\n  currentTheme.colors.primary,\r\n  backgroundColor: currentTheme.colors.accent,\r\n  filter: `drop-shadow(0 0 8px ${currentTheme.colors.primary}33)`,\r\n}}\r\n```\r\n\r\n### 响应式设计\r\n\r\n考虑不同设备的显示需求：\r\n\r\n```tsx\r\n// 根据屏幕大小调整指示器尺寸\r\nconst indicatorSize = useMediaQuery('(max-width: 768px)') ? 48 : 64;\r\n```\r\n\r\n### 客户端渲染\r\n\r\n在服务端渲染项目中，确保光标图案只在客户端渲染：\r\n\r\n```tsx\r\nconst [mounted, setMounted] = useState(false);\r\n\r\nuseEffect(() =\u003e {\r\n  setMounted(true);\r\n}, []);\r\n\r\nif (!mounted) return null;\r\n```\r\n\r\n## 位置计算\r\n\r\n  ```tsx\r\n  style={{\r\n    position.x - 32,  // 容器宽度的一半\r\n    top: position.y - 32,   // 容器高度的一半\r\n  }}\r\n  ```\r\n\r\n## 完整代码全解析\r\n\r\n```tsx\r\n'use client';\r\n\r\nimport React, { useEffect, useState } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\nimport { useThemeStore } from '@/lib/stores/themeStore';\r\n\r\n// 定义组件的属性接口\r\ninterface DragIndicatorProps {\r\n  isDragging: boolean;     // 是否正在拖拽状态\r\n  isHovering: boolean;     // 是否正在悬停状态\r\n  position: { x: number; y: number };  // 当前鼠标位置坐标\r\n}\r\n\r\nexport function DragIndicator({ isDragging, isHovering, position }: DragIndicatorProps) {\r\n  const { currentTheme } = useThemeStore();  // 获取当前主题配置\r\n  const [mounted, setMounted] = useState(false);  // 客户端挂载状态\r\n\r\n  // 确保组件只在客户端渲染，避免服务端渲染的水合错误\r\n  useEffect(() =\u003e {\r\n    setMounted(true);\r\n  }, []);\r\n\r\n  // 未挂载时不渲染任何内容\r\n  if (!mounted) return null;\r\n\r\n  return (\r\n    \u003cAnimatePresence\u003e\r\n      {/* 只有在拖拽或悬停时才显示指示器 */}\r\n      {(isDragging || isHovering) \u0026\u0026 (\r\n        \u003cmotion.div\r\n          className=\"fixed pointer-events-none z-50 flex items-center justify-center\"\r\n          style={{\r\n            // 根据鼠标位置计算容器位置，减去容器尺寸的一半实现居中\r\n            left: position.x - 32,\r\n            top: position.y - 32,\r\n            width: '64px',    // 固定容器尺寸\r\n            height: '64px',\r\n          }}\r\n          // 进入动画：从透明缩小状态开始\r\n          initial={{ opacity: 0, scale: 0 }}\r\n          // 动画状态：拖拽时完全显示，悬停时略微缩小\r\n          animate={{ \r\n            opacity: 1, \r\n            scale: isDragging ? 1 : 0.7,\r\n          }}\r\n          // 退出动画：回到透明缩小状态\r\n          exit={{ opacity: 0, scale: 0 }}\r\n          transition={{ duration: 0.2, ease: 'easeOut' }}\r\n        \u003e\r\n          \r\n          {/* 外层旋转环 - 虚线边框 */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 rounded-full border-2 border-dashed\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n              borderColor: currentTheme.colors.primary,  // 使用主题主色\r\n              // 添加发光效果，透明度为33%\r\n              filter: `drop-shadow(0 0 8px ${currentTheme.colors.primary}33)`,\r\n              opacity: isDragging ? 1 : 0.6,  // 拖拽时更明显\r\n            }}\r\n            animate={{\r\n              // 拖拽时连续旋转360度，悬停时往返旋转180度\r\n              rotate: isDragging ? [0, 360] : [0, 180, 0],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 3 : 4,  // 拖拽时旋转更快\r\n              repeat: Infinity,\r\n              ease: 'linear',\r\n            }}\r\n          /\u003e\r\n\r\n          {/* 内层脉冲圆 - 实线边框 */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 rounded-full border\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n              borderColor: currentTheme.colors.accent,  // 使用主题强调色\r\n              // 添加15%透明度的背景色\r\n              backgroundColor: `${currentTheme.colors.primary}15`,\r\n            }}\r\n            animate={{\r\n              // 脉冲效果：缩放变化\r\n              scale: isDragging ? [1, 1.2, 1] : [1, 1.1, 1],\r\n              // 透明度变化\r\n              opacity: isDragging ? [0.7, 1, 0.7] : [0.4, 0.7, 0.4],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 2 : 3,  // 拖拽时脉冲更快\r\n              repeat: Infinity,\r\n              ease: 'easeInOut',\r\n            }}\r\n          /\u003e\r\n\r\n          {/* 中心几何图形容器 */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 flex items-center justify-center\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n            }}\r\n            animate={{\r\n              // 与外环相反方向旋转，形成视觉对比\r\n              rotate: isDragging ? [0, -360] : [0, -90, 0],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 4 : 6,  // 比外环稍慢\r\n              repeat: Infinity,\r\n              ease: 'linear',\r\n            }}\r\n          \u003e\r\n            {/* 三角形指示器 */}\r\n            \u003cmotion.div\r\n              className=\"absolute w-0 h-0\"\r\n              style={{\r\n                // 使用CSS边框技巧绘制三角形\r\n                borderLeft: '6px solid transparent',\r\n                borderRight: '6px solid transparent',\r\n                borderBottom: `10px solid ${currentTheme.colors.primary}`,\r\n                // 添加发光效果\r\n                filter: `drop-shadow(0 0 4px ${currentTheme.colors.primary}66)`,\r\n                opacity: isDragging ? 1 : 0.7,\r\n              }}\r\n              animate={{\r\n                // 轻微的上下浮动效果\r\n                y: isDragging ? [-2, 2, -2] : [-1, 1, -1],\r\n              }}\r\n              transition={{\r\n                duration: isDragging ? 1.5 : 2.5,\r\n                repeat: Infinity,\r\n                ease: 'easeInOut',\r\n              }}\r\n            /\u003e\r\n\r\n            {/* 菱形装饰 */}\r\n            \u003cmotion.div\r\n              className=\"absolute w-3 h-3 rotate-45\"\r\n              style={{\r\n                backgroundColor: currentTheme.colors.accent,\r\n                filter: `drop-shadow(0 0 4px ${currentTheme.colors.accent}66)`,\r\n                opacity: isDragging ? 1 : 0.7,\r\n              }}\r\n              animate={{\r\n                // 缩放和旋转组合动画\r\n                scale: isDragging ? [0.8, 1.2, 0.8] : [0.9, 1.1, 0.9],\r\n                rotate: isDragging ? [45, 135, 45] : [45, 90, 45],\r\n              }}\r\n              transition={{\r\n                duration: isDragging ? 2.5 : 3.5,\r\n                repeat: Infinity,\r\n                ease: 'easeInOut',\r\n              }}\r\n            /\u003e\r\n          \u003c/motion.div\u003e\r\n\r\n          {/* 扩散波浪 - 仅在拖拽时显示 */}\r\n          {isDragging \u0026\u0026 [0, 1, 2].map((index) =\u003e (\r\n            \u003cmotion.div\r\n              key={`wave-${index}`}\r\n              className=\"absolute w-16 h-16 rounded-full border opacity-30\"\r\n              style={{\r\n                left: 0,\r\n                top: 0,\r\n                borderColor: currentTheme.colors.primary,\r\n              }}\r\n              animate={{\r\n                scale: [1, 2.5],    // 从内向外扩散\r\n                opacity: [0.6, 0],  // 逐渐消失\r\n              }}\r\n              transition={{\r\n                duration: 1.5,\r\n                repeat: Infinity,\r\n                ease: 'easeOut',\r\n                delay: index * 0.5,  // 错峰动画，形成波浪效果\r\n              }}\r\n            /\u003e\r\n          ))}\r\n\r\n          {/* 方向箭头容器 */}\r\n          \u003cmotion.div\r\n            className=\"absolute w-16 h-16 flex items-center justify-center\"\r\n            style={{\r\n              left: 0,\r\n              top: 0,\r\n            }}\r\n            animate={{\r\n              // 整体缓慢旋转\r\n              rotate: isDragging ? [0, 360] : [0, 45, 0],\r\n            }}\r\n            transition={{\r\n              duration: isDragging ? 6 : 8,\r\n              repeat: Infinity,\r\n              ease: 'linear',\r\n            }}\r\n          \u003e\r\n            {/* 四个方向的箭头 */}\r\n            {[0, 90, 180, 270].map((rotation, index) =\u003e (\r\n              \u003cmotion.div\r\n                key={`arrow-${index}`}\r\n                className=\"absolute w-4 h-4\"\r\n                style={{\r\n                  // 根据角度分布在圆周上\r\n                  transform: `rotate(${rotation}deg) translateY(-24px)`,\r\n                  opacity: isDragging ? 1 : 0.5,\r\n                }}\r\n                animate={{\r\n                  // 透明度和位置的周期性变化\r\n                  opacity: isDragging ? [0.3, 1, 0.3] : [0.2, 0.6, 0.2],\r\n                  y: isDragging ? [-2, 2, -2] : [-1, 1, -1],\r\n                }}\r\n                transition={{\r\n                  duration: isDragging ? 1.8 : 2.5,\r\n                  repeat: Infinity,\r\n                  ease: 'easeInOut',\r\n                  delay: index * 0.2,  // 依次动画，形成流动感\r\n                }}\r\n              \u003e\r\n                {/* SVG箭头图标 */}\r\n                \u003csvg\r\n                  width=\"16\"\r\n                  height=\"16\"\r\n                  viewBox=\"0 0 16 16\"\r\n                  fill=\"none\"\r\n                  xmlns=\"http://www.w3.org/2000/svg\"\r\n                \u003e\r\n                  \u003cpath\r\n                    d=\"M8 2L8 14M8 2L4 6M8 2L12 6\"  // 箭头路径\r\n                    stroke={currentTheme.colors.accent}\r\n                    strokeWidth=\"2\"\r\n                    strokeLinecap=\"round\"\r\n                    strokeLinejoin=\"round\"\r\n                    filter={`drop-shadow(0 0 2px ${currentTheme.colors.accent}66)`}\r\n                  /\u003e\r\n                \u003c/svg\u003e\r\n              \u003c/motion.div\u003e\r\n            ))}\r\n          \u003c/motion.div\u003e\r\n\r\n          {/* 悬停状态的抓手图标 - 仅在非拖拽时显示 */}\r\n          {!isDragging \u0026\u0026 (\r\n            \u003cmotion.div\r\n              className=\"absolute w-16 h-16 flex items-center justify-center\"\r\n              style={{\r\n                left: 0,\r\n                top: 0,\r\n              }}\r\n              initial={{ opacity: 0 }}\r\n              animate={{ opacity: 1 }}\r\n              transition={{ duration: 0.3 }}\r\n            \u003e\r\n              \u003cmotion.div\r\n                className=\"w-6 h-6 flex items-center justify-center\"\r\n                animate={{\r\n                  scale: [1, 1.1, 1],  // 轻微的呼吸效果\r\n                }}\r\n                transition={{\r\n                  duration: 2,\r\n                  repeat: Infinity,\r\n                  ease: 'easeInOut',\r\n                }}\r\n              \u003e\r\n                {/* 抓手SVG图标 */}\r\n                \u003csvg\r\n                  width=\"20\"\r\n                  height=\"20\"\r\n                  viewBox=\"0 0 24 24\"\r\n                  fill=\"none\"\r\n                  xmlns=\"http://www.w3.org/2000/svg\"\r\n                \u003e\r\n                  \u003cpath\r\n                    d=\"M8 11V7C8 5.34315 9.34315 4 11 4C12.6569 4 14 5.34315 14 7V11M8 11L8 15C8 17.2091 9.79086 19 12 19C14.2091 19 16 17.2091 16 15V11M8 11H16M14 7V11M11 7V11\"\r\n                    stroke={currentTheme.colors.primary}\r\n                    strokeWidth=\"2\"\r\n                    strokeLinecap=\"round\"\r\n                    strokeLinejoin=\"round\"\r\n                    filter={`drop-shadow(0 0 4px ${currentTheme.colors.primary}66)`}\r\n                  /\u003e\r\n                \u003c/svg\u003e\r\n              \u003c/motion.div\u003e\r\n            \u003c/motion.div\u003e\r\n          )}\r\n        \u003c/motion.div\u003e\r\n      )}\r\n    \u003c/AnimatePresence\u003e\r\n  );\r\n}\r\n```\r\n\r\n*愿你如深藏的黄金，在出掘之日焕发出独属于你的，耀眼的光芒。* ✨"])</script><script>self.__next_f.push([1,"3a:Tcb11,"])</script><script>self.__next_f.push([1,"\r\n# 浮动导航球：从数学原理到交互实现\r\n\r\n编写导航栏菜单的时候我就在想，如何在突破传统布局的基础上表现出现代感与科技感呢？要不整个悬浮球类型的导航栏？......于是我就这么做了。\r\n\r\n想象一下，如果你的网站导航可以像一个智能助手一样，平时安静地待在角落，需要时优雅地滑向屏幕中央展开所有功能，用完后又乖巧地回到原位......嗯，确实挺不错的。\r\n\r\n这个浮动导航球集成了复杂的交互逻辑：可拖拽、可吸附到屏幕边缘、可展开为圆形菜单、还有流畅的动画过渡。在这篇文章中，我将从最基础的坐标计算开始，逐步深入每一个实现细节，全面剖析这个看似简单实则复杂的交互系统。\r\n\r\n## 状态管理\r\n\r\n任何复杂的交互系统都需要精心设计的状态管理，我们的浮动导航球也不例外。我们可以先快速阅览一下总体的状态成员：\r\n\r\n### 状态定义\r\n\r\n为什么需要这么多状态变量？因为每一个状态都承载着特定的职责，它们共同构成了一个完整的交互生态系统。\r\n\r\n```typescript\r\nconst [mounted, setMounted] = useState(false);\r\nconst [isExpanded, setIsExpanded] = useState(false);\r\nconst [position, setPosition] = useState\u003cPosition\u003e({x: 50, y: 50});\r\nconst [originalPosition, setOriginalPosition] = useState\u003cPosition\u003e({x: 50, y: 50});\r\nconst [isDragging, setIsDragging] = useState(false);\r\nconst [dragOffset, setDragOffset] = useState\u003cPosition\u003e({x: 0, y: 0});\r\nconst [dragStartPosition, setDragStartPosition] = useState\u003cPosition\u003e({x: 0, y: 0});\r\nconst [showRipple, setShowRipple] = useState(false);\r\n```\r\n\r\n### 核心状态详解\r\n\r\n让我逐一解释这些状态的作用：\r\n\r\n**mounted**: 这是一个\"保险丝\"状态。在服务端渲染的世界里，`window.innerWidth`在初始渲染时是未定义的，所以我们需要等到组件真正挂载到浏览器中后再进行位置计算。\r\n\r\n**isExpanded**: 导航球的\"开关\"状态。`false`时是一个小球，`true`时展开为圆形菜单。这个状态控制着整个UI的形态变化。\r\n\r\n**position**: 当前的实时位置坐标。这是整个拖拽系统的核心，所有的位置变化都反映在这里。\r\n\r\n**originalPosition**: \"记忆中的家\"。当导航球展开时，它会移动到屏幕中央，但我们需要记住它原来的位置，这样收起时就能回到原地。\r\n\r\n**isDragging**: 拖拽状态的标记。当用户按下鼠标开始拖拽时为`true`，释放鼠标时为`false`。这个状态影响着鼠标事件的监听和视觉反馈。\r\n\r\n**dragOffset**: 这个是最容易被忽视但又最重要的状态。它记录了鼠标点击位置相对于导航球左上角的偏移量，确保拖拽时球不会\"跳跃\"到鼠标位置。\r\n\r\n**dragStartPosition**: 拖拽起始点的记录员。我们需要它来计算拖拽距离，区分\"点击\"和\"真正的拖拽\"。\r\n\r\n**showRipple**: 视觉反馈的开关。在拖拽过程中显示波纹效果，让用户知道\"我正在移动这个东西\"。\r\n\r\n### 状态机设计\r\n\r\n这些状态之间的关系构成了一个复杂的状态机：\r\n\r\n```\r\n正常状态 ←→ 拖拽状态 → 吸附状态\r\n    ↓                  ↑\r\n展开状态 ←--------------┘\r\n```\r\n\r\n关键的状态转换逻辑：\r\n- **正常→拖拽**: `mouseDown`事件触发，同时设置`isDragging=true`和记录初始偏移\r\n- **拖拽→吸附**: `mouseUp`事件触发，执行边缘吸附算法\r\n- **正常→展开**: 点击事件触发（非拖拽），移动到屏幕中央\r\n- **展开→正常**: 再次点击或点击背景，回到原始位置\r\n\r\n这个状态机的精妙之处在于它能够正确处理边界情况，比如用户在拖拽过程中快速点击，或者在展开状态下开始拖拽等等。\r\n\r\n## 坐标系统与位置记录\r\n\r\n在浏览器的世界里，有很多种坐标系统可以选择，我们的选择决定了整个系统的复杂度和性能。\r\n\r\n### 坐标系统选择\r\n\r\n我选择了绝对定位(`position: fixed`) + `left/top`属性的方案，而不是更现代的`transform`方案。为什么？\r\n\r\n```typescript\r\n// 我们使用的方案\r\nstyle={{\r\n    left: `${position.x}px`,\r\n    top: `${position.y}px`,\r\n}}\r\n\r\n// 而不是这样\r\nstyle={{\r\n    transform: `translate(${position.x}px, ${position.y}px)`\r\n}}\r\n```\r\n\r\n~~（主要是懒）~~原因很简单：**计算的简单性**。使用`left/top`时，坐标值就直接对应屏幕位置，我们可以直接用`getBoundingClientRect()`获取元素位置进行计算。而使用`transform`时，元素的实际渲染位置和CSS中记录的位置可能不一致，增加了计算复杂度。\r\n\r\n虽然`transform`在某些情况下性能更好（GPU加速），但对于单个导航球来说，这点性能差异可以忽略不计。有时候，简单就是美。\r\n\r\n### 位置初始化策略\r\n\r\n```typescript\r\nconst initialX = window.innerWidth - 80;\r\nconst initialY = 100;\r\n```\r\n\r\n `window.innerWidth - 80`确保球完全在屏幕内，80px是球的大小加上一些余量，以确保浮动导航球在各种设备上都具有较高的初始可见性。\r\n\r\n### dragOffset的数学原理\r\n\r\n这是整个拖拽系统中最容易出错的部分。让我用一个例子来说明：\r\n\r\n假设导航球的左上角位置是`(100, 50)`，用户在球的中心位置`(132, 82)`点击开始拖拽（球的大小是64x64px）。\r\n\r\n```typescript\r\nconst handleMouseDown = (e: React.MouseEvent) =\u003e {\r\n    const rect = ballRef.current?.getBoundingClientRect();\r\n    if (rect) {\r\n        setDragOffset({\r\n            x: e.clientX - rect.left,  // 132 - 100 = 32\r\n            y: e.clientY - rect.top    // 82 - 50 = 32\r\n        });\r\n    }\r\n};\r\n```\r\n\r\n现在，当鼠标移动到`(200, 150)`时，新的球位置应该是：\r\n\r\n```typescript\r\nconst newPos = {\r\n    x: e.clientX - dragOffset.x,  // 200 - 32 = 168\r\n    y: e.clientY - dragOffset.y   // 150 - 32 = 118\r\n};\r\n```\r\n\r\n这样，球的中心点就会跟随鼠标，而不会产生\"跳跃\"效果。倘若没有最后修正的-32像素，那么当拖拽实际发生时，光标会指向球的左上角，而非球心位置，造成拖拽偏移误差。\r\n\r\n## 拖拽系统实现\r\n\r\n拖拽系统是整个导航球的核心功能，它需要处理复杂的事件序列和状态变化。\r\n\r\n### 拖拽生命周期\r\n\r\n一次完整的拖拽操作包含三个阶段：\r\n\r\n1. **mouseDown**: 初始化拖拽状态\r\n2. **mouseMove**: 持续更新位置\r\n3. **mouseUp**: 结束拖拽并执行后续逻辑\r\n\r\n每个阶段都有其特定的职责和处理逻辑。\r\n\r\n### 防抖动画实现\r\n\r\n传统的拖拽实现会在每次`mouseMove`时立即更新位置，但这会导致性能问题和视觉上的抖动。我采用了防抖策略：\r\n\r\n```typescript\r\nconst handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    if (!isDragging) return;\r\n\r\n    // 计算新位置\r\n    const newPos = {\r\n        x: e.clientX - dragOffset.x,\r\n        y: e.clientY - dragOffset.y\r\n    };\r\n\r\n    // 存储待更新的位置\r\n    pendingPositionRef.current = newPos;\r\n\r\n    // 立即显示波纹效果\r\n    setShowRipple(true);\r\n\r\n    // 清除已有的防抖定时器\r\n    if (debounceTimerRef.current) {\r\n        clearTimeout(debounceTimerRef.current);\r\n    }\r\n\r\n    // 设置新的防抖定时器\r\n    debounceTimerRef.current = setTimeout(() =\u003e {\r\n        setPosition(newPos);\r\n        setShowRipple(false);\r\n    }, 500);\r\n}, [isDragging, dragOffset]);\r\n```\r\n\r\n**注意：**我使用了`ref`而非`state`来存储待更新的位置，这是因为`useState`的更新是异步的，当我使用异步更新状态时，会存在读值隐患，即：我在读取\"更新后\"的值时，异步更新尚未完成，所以实际上读取的是更新前的值，导致实际的结果异常。而`ref`的更新策略是同步的，不会存在线程安全问题，这意味着我在\"更新后\"读取到的值就是更新后的值。\r\n\r\n### 拖拽距离判定\r\n\r\n如何区分\"点击\"和\"拖拽\"？这是一个经典的UI交互问题。我的解决方案基于欧几里得距离：\r\n\r\n```typescript\r\n// 记录拖拽起始位置\r\nsetDragStartPosition({x: e.clientX, y: e.clientY});\r\n\r\n// 在mouseMove中计算距离\r\nconst dragDistance = Math.sqrt(\r\n    Math.pow(e.clientX - dragStartPosition.x, 2) +\r\n    Math.pow(e.clientY - dragStartPosition.y, 2)\r\n);\r\n\r\nif (dragDistance \u003e 3) {\r\n    hasDraggedSignificantlyRef.current = true;\r\n}\r\n```\r\n\r\n只有在浮动导航球移动超过3像素时，才会被视为\"拖拽\"，否则会视为\"点击\"。一般来说，人手的自然抖动通常在1-2像素范围内，3像素可以有效过滤掉这些无意的微小移动，同时又不会妨碍真正的拖拽意图。\r\n\r\n### 拖拽结束的智能处理\r\n\r\n```typescript\r\nconst handleMouseUp = useCallback(() =\u003e {\r\n    if (!isDragging) return;\r\n\r\n    setIsDragging(false);\r\n    setShowRipple(false);\r\n\r\n    // 清除防抖定时器\r\n    if (debounceTimerRef.current) {\r\n        clearTimeout(debounceTimerRef.current);\r\n    }\r\n\r\n    if (hasDraggedSignificantlyRef.current) {\r\n        // 显著拖拽 - 执行吸附\r\n        const snappedPos = snapToEdge(pendingPositionRef.current);\r\n        setPosition(snappedPos);\r\n        setOriginalPosition(snappedPos);\r\n    }\r\n\r\n    // 重置拖拽标记\r\n    setTimeout(() =\u003e {\r\n        hasDraggedSignificantlyRef.current = false;\r\n    }, 100);\r\n}, [isDragging]);\r\n```\r\n\r\n这里有个细节：为什么重置拖拽标记要延迟100ms？因为`mouseUp`和`click`事件有时序差异，如果立即重置，可能会导致点击事件错误地被处理为拖拽后的点击。100ms的延迟确保了事件处理的正确顺序。\r\n\r\n## 边缘吸附算法\r\n\r\n吸附效果是一种人性化设计，它可以确保在你对导航球\"放手\"时，它会自动停留在距离屏幕边缘一个固定距离上的位置，解决视觉强迫症用户的核心痛点。~~（比如说我）~~\r\n\r\n### 吸附算法核心逻辑\r\n\r\n吸附的数学原理其实很简单：计算当前位置到四个边界的距离，然后移动到距离最近的边界：\r\n\r\n```typescript\r\nconst snapToEdge = useCallback((currentPos: Position) =\u003e {\r\n    const windowWidth = window.innerWidth;\r\n    const windowHeight = window.innerHeight;\r\n    const ballSize = 70;  // 球的大小\r\n    const margin = 20;    // 距离边缘的间距\r\n    \r\n    // 计算到四个边界的距离\r\n    const distanceToLeft = currentPos.x;\r\n    const distanceToRight = windowWidth - currentPos.x;\r\n    const distanceToTop = currentPos.y;\r\n    const distanceToBottom = windowHeight - currentPos.y;\r\n    \r\n    // 找到最小距离\r\n    const minDistance = Math.min(\r\n        distanceToLeft, \r\n        distanceToRight, \r\n        distanceToTop, \r\n        distanceToBottom\r\n    );\r\n    \r\n    let newPos = {...currentPos};\r\n    \r\n    // 根据最小距离决定吸附方向\r\n    if (minDistance === distanceToLeft) {\r\n        newPos.x = margin;\r\n    } else if (minDistance === distanceToRight) {\r\n        newPos.x = windowWidth - ballSize - margin;\r\n    } else if (minDistance === distanceToTop) {\r\n        newPos.y = margin;\r\n    } else {\r\n        newPos.y = windowHeight - ballSize - margin;\r\n    }\r\n    \r\n    return newPos;\r\n}, []);\r\n```\r\n\r\n### 边界计算的数学原理\r\n\r\n距离计算解释：\r\n\r\n- **distanceToLeft**: 直接等于`currentPos.x`，因为左边界就是x=0\r\n- **distanceToRight**: `windowWidth - currentPos.x`，因为右边界是窗口宽度\r\n- **distanceToTop**: 直接等于`currentPos.y`，因为上边界就是y=0  \r\n- **distanceToBottom**: `windowWidth - currentPos.y`，因为下边界是窗口高度\r\n\r\n`Math.min()`会找到这四个值中的最小值，对应着距离最近的边界。\r\n\r\n### 边界约束实现\r\n\r\n这是一个防止边界超出的保护逻辑：\r\n\r\n```typescript\r\nnewPos.x = Math.max(margin, Math.min(windowWidth - ballSize - margin, newPos.x));\r\nnewPos.y = Math.max(margin, Math.min(windowHeight - ballSize - margin, newPos.y));\r\n```\r\n\r\n\"双重夹逼\"策略：\r\n- `Math.min()`确保位置不会超出右边界和下边界\r\n- `Math.max()`确保位置不会小于左边界和上边界\r\n\r\n这样，无论算法计算出什么位置，最终的坐标都会被严格限制在安全范围内。\r\n\r\n为什么需要`ballSize`？因为CSS的`left`和`top`属性定位的是元素的左上角，而不是中心点。如果不考虑球的大小，球就可能有一部分跑到屏幕外面。\r\n\r\n## 展开收起的动画系统\r\n\r\n导航球的展开收起是一个具有过渡效果的动画过程，涉及位置移动、状态切换和时序控制。\r\n\r\n### 中心定位算法\r\n\r\n当用户点击导航球时，它需要移动到屏幕中央进行展开：\r\n\r\n```typescript\r\nconst centerX = window.innerWidth / 2 - 35;\r\nconst centerY = window.innerHeight / 2 - 35;\r\nsetPosition({x: centerX, y: centerY});\r\n```\r\n\r\n**为什么要减去35**？因为导航球的大小是70px，如果我们想让球的**中心**对齐屏幕中心，就需要向左向上偏移半个球的大小（70/2 = 35px）。\r\n\r\n这是视觉中心和几何中心的区别：\r\n- **几何中心**: 元素边界框的中心点\r\n- **视觉中心**: 人眼感知到的元素中心点\r\n\r\n对于圆形元素，这两者是一致的，所以我们使用几何计算即可。\r\n\r\n### 状态切换的时序控制\r\n\r\n展开和收起的动画需要精确的时序控制：\r\n\r\n```typescript\r\nconst handleBallClick = () =\u003e {\r\n    if (!hasDraggedSignificantlyRef.current) {\r\n        if (!isExpanded) {\r\n            // 展开：先保存当前位置，再移动到中心\r\n            setOriginalPosition(position);\r\n            const centerX = window.innerWidth / 2 - 35;\r\n            const centerY = window.innerHeight / 2 - 35;\r\n            setPosition({x: centerX, y: centerY});\r\n            setIsExpanded(true);\r\n        } else {\r\n            // 收起：先设置状态，延迟150ms后移动\r\n            setIsExpanded(false);\r\n            setTimeout(() =\u003e {\r\n                setPosition(originalPosition);\r\n            }, 150);\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n这里有个关键的设计决策：收起时为什么要延迟150ms？\r\n\r\n因为菜单项的消失动画需要时间。如果我们在设置`isExpanded=false`的同时立即移动球的位置，用户会看到菜单项还在消失的过程中，球就开始移动了，视觉效果会很突兀。\r\n\r\n150ms的延迟刚好让菜单项的消失动画完成，然后球再开始移动回原位。这种时序安排让整个动画感觉更加连贯和自然。\r\n\r\n### originalPosition的保存机制\r\n\r\n`originalPosition`的保存时机很关键：\r\n\r\n```typescript\r\n// 在展开之前保存\r\nsetOriginalPosition(position);\r\n\r\n// 在拖拽结束后更新\r\nsetOriginalPosition(snappedPos);\r\n```\r\n\r\n这确保了无论用户在展开前有没有拖拽过球，收起时都能回到正确的位置。如果用户拖拽球到新位置后再展开，收起时应该回到拖拽后的位置，而不是初始位置。\r\n\r\n## 圆形菜单布局算法\r\n\r\n当导航球展开时，菜单项需要均匀分布在一个圆形周围。这是一个典型的极坐标布局问题。\r\n\r\n### 极坐标布局的数学基础\r\n\r\n圆形布局的核心是极坐标到笛卡尔坐标的转换：\r\n\r\n```typescript\r\nconst getCircularPosition = (index: number, total: number, radius: number = 120) =\u003e {\r\n    const angle = (2 * Math.PI * index) / total - Math.PI / 2;\r\n    const centerX = window.innerWidth / 2;\r\n    const centerY = window.innerHeight / 2;\r\n    return {\r\n        x: centerX + Math.cos(angle) * radius - 60,\r\n        y: centerY + Math.sin(angle) * radius - 30,\r\n    };\r\n};\r\n```\r\n\r\n让我逐行解释这个算法：\r\n\r\n**角度计算**: `(2 * Math.PI * index) / total`将圆周（2π弧度）等分为`total`份，每个菜单项占据一份。\r\n\r\n**起始角度调整**: `- Math.PI / 2`将起始角度从3点钟方向（0弧度）调整到12点钟方向（-π/2弧度）。这样第一个菜单项会出现在正上方，符合视觉习惯。\r\n\r\n**坐标转换**: `Math.cos(angle) * radius`和`Math.sin(angle) * radius`将极坐标转换为相对于圆心的笛卡尔坐标。\r\n\r\n**位置偏移**: `- 60`和`- 30`是为了调整菜单项的定位点。这些值是根据菜单项的实际大小计算出来的，确保菜单项的中心点位于圆周上。\r\n\r\n### 角度分布策略\r\n\r\n假设我们有6个菜单项，它们的角度分布是这样的：\r\n\r\n```\r\n项目0: (2π × 0) / 6 - π/2 = -π/2   (12点钟方向)\r\n项目1: (2π × 1) / 6 - π/2 = -π/6   (2点钟方向)\r\n项目2: (2π × 2) / 6 - π/2 = π/6    (4点钟方向)\r\n项目3: (2π × 3) / 6 - π/2 = π/2    (6点钟方向)\r\n项目4: (2π × 4) / 6 - π/2 = 5π/6   (8点钟方向)\r\n项目5: (2π × 5) / 6 - π/2 = 7π/6   (10点钟方向)\r\n```\r\n\r\n这样的分布确保了菜单项在视觉上的均匀性和对称性。\r\n\r\n## 关键帧动画系统\r\n\r\n菜单项的出现和消失动画是保证流畅性的关键部分。\r\n\r\n### CSS-in-JS动画实现\r\n\r\n我使用CSS-in-JS的动画定义方式来保持组件的封装性：\r\n\r\n```jsx\r\n\u003cstyle jsx\u003e{`\r\n    @keyframes menuItemAppear {\r\n        0% {\r\n            opacity: 0;\r\n            transform: scale(0) translate(-50%, -50%);\r\n        }\r\n        50% {\r\n            opacity: 0.7;\r\n            transform: scale(0.8) translate(-25%, -25%);\r\n        }\r\n        100% {\r\n            opacity: 1;\r\n            transform: scale(1) translate(0%, 0%);\r\n        }\r\n    }\r\n    \r\n    .menu-item {\r\n        animation: menuItemAppear 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;\r\n    }\r\n`}\u003c/style\u003e\r\n```\r\n\r\n这个动画包含了三个关键帧：\r\n- **0%**: 完全透明，零缩放，大幅偏移\r\n- **50%**: 半透明，80%缩放，小幅偏移  \r\n- **100%**: 完全不透明，正常缩放，无偏移\r\n\r\n**为什么要包含translate偏移**？纯粹的缩放动画会让菜单项从中心点\"爆发\"出来，加上translate偏移可以创造一种\"从远处飞来\"的动态效果。\r\n\r\n### 动画延迟的层次感\r\n\r\n```typescript\r\nstyle={{\r\n    animationDelay: `${index * 120}ms`\r\n}}\r\n```\r\n\r\n每个菜单项的动画延迟120ms，这创造了一种\"波浪式\"的出现效果。菜单项不是同时出现，而是按顺序依次出现，就像多米诺骨牌一样。\r\n\r\n### 缓动函数选择\r\n\r\n`cubic-bezier(0.4, 0, 0.2, 1)`是Material Design中的\"标准\"缓动函数，它的特性是：\r\n- **慢启动**: 开始时加速较慢，符合物理直觉\r\n- **快结束**: 结束时快速到达目标状态，避免拖沓感\r\n- **平滑过渡**: 整个过程没有突兀的速度变化\r\n\r\n## 事件处理与性能优化\r\n\r\n在处理复杂交互时，正确的事件管理和性能优化是必不可少的。\r\n\r\n### 事件监听器的生命周期管理\r\n\r\n拖拽功能需要在文档级别监听鼠标事件，但这些监听器必须正确管理，避免内存泄漏：\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    if (isDragging) {\r\n        document.addEventListener('mousemove', handleMouseMove);\r\n        document.addEventListener('mouseup', handleMouseUp);\r\n        return () =\u003e {\r\n            document.removeEventListener('mousemove', handleMouseMove);\r\n            document.removeEventListener('mouseup', handleMouseUp);\r\n        };\r\n    } else {\r\n        // 确保在非拖拽状态下移除监听器\r\n        document.removeEventListener('mousemove', handleMouseMove);\r\n        document.removeEventListener('mouseup', handleMouseUp);\r\n    }\r\n}, [isDragging, handleMouseMove, handleMouseUp]);\r\n```\r\n\r\n设计特性：\r\n1. **条件监听**: 只在拖拽状态下添加监听器，减少不必要的事件处理\r\n2. **自动清理**: useEffect的返回函数确保组件卸载时清理监听器\r\n3. **状态同步**: 当拖拽状态改变时，监听器也相应更新\r\n\r\n### useCallback的性能优化\r\n\r\n```typescript\r\nconst handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    // 处理逻辑...\r\n}, [isDragging, dragOffset, dragStartPosition]);\r\n\r\nconst snapToEdge = useCallback((currentPos: Position) =\u003e {\r\n    // 吸附逻辑...\r\n}, []);\r\n```\r\n\r\n`useCallback`确保这些函数引用在依赖项不变时保持稳定，避免不必要的重新渲染和事件监听器的频繁添加/移除。\r\n\r\n### 防止事件冒泡的策略\r\n\r\n```typescript\r\nconst handleMouseDown = (e: React.MouseEvent) =\u003e {\r\n    e.preventDefault();  // 防止选中文本等默认行为\r\n    if (isExpanded) return;  // 展开状态下禁用拖拽\r\n    \r\n    setIsDragging(true);\r\n    // ... 其他逻辑\r\n};\r\n```\r\n\r\n`e.preventDefault()`防止了一些可能干扰拖拽的默认浏览器行为，比如文本选择、图片拖拽等。\r\n\r\n## 可复用设计模式总结\r\n\r\n通过这次深入的分析，我们可以提取出几个通用的设计模式，它们可以应用到其他类似的交互系统中。\r\n\r\n### 核心设计模式提取\r\n\r\n**拖拽系统模式**:\r\n```typescript\r\n// 1. 状态初始化\r\nconst [isDragging, setIsDragging] = useState(false);\r\nconst [dragOffset, setDragOffset] = useState({x: 0, y: 0});\r\nconst [position, setPosition] = useState({x: 0, y: 0});\r\n\r\n// 2. 事件处理\r\nconst handleMouseDown = (e) =\u003e {\r\n    const rect = elementRef.current?.getBoundingClientRect();\r\n    setDragOffset({\r\n        x: e.clientX - rect.left,\r\n        y: e.clientY - rect.top\r\n    });\r\n    setIsDragging(true);\r\n};\r\n\r\n// 3. 位置更新\r\nconst handleMouseMove = (e) =\u003e {\r\n    if (!isDragging) return;\r\n    setPosition({\r\n        x: e.clientX - dragOffset.x,\r\n        y: e.clientY - dragOffset.y\r\n    });\r\n};\r\n```\r\n\r\n**圆形布局模式**:\r\n```typescript\r\nconst getCircularPosition = (index, total, radius, centerX, centerY) =\u003e {\r\n    const angle = (2 * Math.PI * index) / total - Math.PI / 2;\r\n    return {\r\n        x: centerX + Math.cos(angle) * radius,\r\n        y: centerY + Math.sin(angle) * radius\r\n    };\r\n};\r\n```\r\n\r\n**状态机模式**:\r\n```typescript\r\n// 明确的状态定义\r\nconst states = {\r\n    IDLE: 'idle',\r\n    DRAGGING: 'dragging',\r\n    EXPANDED: 'expanded'\r\n};\r\n\r\n// 状态转换逻辑\r\nconst handleStateTransition = (currentState, action) =\u003e {\r\n    switch (currentState) {\r\n        case states.IDLE:\r\n            return action === 'drag' ? states.DRAGGING : \r\n                   action === 'click' ? states.EXPANDED : currentState;\r\n        // ... 其他状态转换\r\n    }\r\n};\r\n```\r\n\r\n**防抖动画模式**:\r\n```typescript\r\nconst [pendingValue, setPendingValue] = useState(null);\r\nconst timerRef = useRef(null);\r\n\r\nconst debouncedUpdate = (newValue) =\u003e {\r\n    setPendingValue(newValue);\r\n    \r\n    if (timerRef.current) clearTimeout(timerRef.current);\r\n    \r\n    timerRef.current = setTimeout(() =\u003e {\r\n        setActualValue(newValue);\r\n    }, delay);\r\n};\r\n```\r\n\r\n### 最佳实践提炼\r\n\r\n1. **事件监听器清理**: 始终在useEffect的返回函数中清理事件监听器\r\n2. **坐标计算边界保护**: 使用Math.min/max确保坐标在安全范围内\r\n3. **状态同步**: 相关状态的更新要保持同步，避免中间态\r\n4. **动画时序**: 复杂动画要考虑各部分的时序关系\r\n5. **用户反馈**: 即使在延迟更新的情况下，也要提供即时的视觉反馈\r\n\r\n## 完整源码全解析\r\n\r\n```typescript\r\n'use client';\r\nimport React, {useCallback, useEffect, useRef, useState} from 'react';\r\nimport {usePathname, useRouter} from 'next/navigation';\r\nimport {useTheme} from './ThemeProvider';\r\nimport {useLocaleStore} from '@/lib/stores/localeStore';\r\nimport {LOCALES} from '@/lib/utils/locales';\r\n\r\n// ==================== 类型定义 ====================\r\ninterface Position {\r\n    x: number;  // X坐标\r\n    y: number;  // Y坐标\r\n}\r\n\r\nexport function Navigation() {\r\n    // ==================== 状态管理 ====================\r\n    // 基础状态\r\n    const [mounted, setMounted] = useState(false);                    // 组件挂载状态\r\n    const [isExpanded, setIsExpanded] = useState(false);              // 菜单展开状态\r\n    \r\n    // 位置相关状态\r\n    const [position, setPosition] = useState\u003cPosition\u003e({x: 50, y: 50});           // 当前位置\r\n    const [originalPosition, setOriginalPosition] = useState\u003cPosition\u003e({x: 50, y: 50}); // 原始位置记录\r\n    \r\n    // 拖拽相关状态\r\n    const [isDragging, setIsDragging] = useState(false);              // 拖拽状态标记\r\n    const [dragOffset, setDragOffset] = useState\u003cPosition\u003e({x: 0, y: 0});         // 拖拽偏移量\r\n    const [dragStartPosition, setDragStartPosition] = useState\u003cPosition\u003e({x: 0, y: 0}); // 拖拽起始位置\r\n    const [showRipple, setShowRipple] = useState(false);              // 显示波纹效果\r\n    \r\n    // 引用和定时器\r\n    const debounceTimerRef = useRef\u003cNodeJS.Timeout | null\u003e(null);     // 防抖定时器\r\n    const hasDraggedSignificantlyRef = useRef(false);                 // 是否发生显著拖拽\r\n    const pendingPositionRef = useRef\u003cPosition\u003e({x: 50, y: 50});      // 待更新位置\r\n    const ballRef = useRef\u003cHTMLDivElement\u003e(null);                     // 导航球引用\r\n    \r\n    // Next.js和主题hooks\r\n    const router = useRouter();\r\n    const pathname = usePathname();\r\n    const {theme, toggleTheme} = useTheme();\r\n    const {locale, toggleLocale} = useLocaleStore();\r\n\r\n    // ==================== 初始化效果 ====================\r\n    /**\r\n     * 组件挂载时初始化位置\r\n     * 在客户端渲染时计算初始位置，避免服务端渲染时window未定义的问题\r\n     */\r\n    useEffect(() =\u003e {\r\n        setMounted(true);\r\n        const initialX = window.innerWidth - 80;   // 距离右边缘80px\r\n        const initialY = 100;                      // 距离顶部100px\r\n        setPosition({x: initialX, y: initialY});\r\n        setOriginalPosition({x: initialX, y: initialY});\r\n        pendingPositionRef.current = {x: initialX, y: initialY};\r\n    }, []);\r\n\r\n    /**\r\n     * 清理防抖定时器，防止内存泄漏\r\n     */\r\n    useEffect(() =\u003e {\r\n        return () =\u003e {\r\n            if (debounceTimerRef.current) {\r\n                clearTimeout(debounceTimerRef.current);\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    // ==================== 导航配置 ====================\r\n    /**\r\n     * 导航栏目配置\r\n     * 定义所有可导航的页面和对应的标识符\r\n     */\r\n    const sections = [\r\n        {\r\n            id: 'personal' as const,\r\n            label: 'Personal',\r\n            description: 'About Me',\r\n            href: '/personal'\r\n        },\r\n        {\r\n            id: 'works' as const,\r\n            label: 'Works',\r\n            description: 'Portfolio',\r\n            href: '/works'\r\n        },\r\n        {\r\n            id: 'contributions' as const,\r\n            label: 'Contributions',\r\n            description: 'Open Source',\r\n            href: '/contributions'\r\n        },\r\n        {\r\n            id: 'documents' as const,\r\n            label: 'Documents',\r\n            description: 'Insights',\r\n            href: '/documents'\r\n        },\r\n    ];\r\n\r\n    /**\r\n     * 根据当前路径获取活跃的导航项\r\n     * @returns 当前活跃的导航项ID或null\r\n     */\r\n    const getActiveSection = () =\u003e {\r\n        if (pathname === '/') return 'personal';\r\n        if (pathname === '/works') return 'works';\r\n        if (pathname === '/contributions') return 'contributions';\r\n        if (pathname === '/documents') return 'documents';\r\n        return null;\r\n    };\r\n\r\n    const activeSection = getActiveSection();\r\n\r\n    // ==================== 核心算法：边缘吸附 ====================\r\n    /**\r\n     * 边缘吸附算法\r\n     * 计算当前位置到四个边界的距离，移动到最近的边界\r\n     * @param currentPos 当前位置\r\n     * @returns 吸附后的位置\r\n     */\r\n    const snapToEdge = useCallback((currentPos: Position) =\u003e {\r\n        const windowWidth = window.innerWidth;\r\n        const windowHeight = window.innerHeight;\r\n        const ballSize = 70;    // 导航球大小\r\n        const margin = 20;      // 距离边缘的间距\r\n        let newPos = {...currentPos};\r\n\r\n        // 计算到四个边界的距离\r\n        const distanceToLeft = currentPos.x;\r\n        const distanceToRight = windowWidth - currentPos.x;\r\n        const distanceToTop = currentPos.y;\r\n        const distanceToBottom = windowHeight - currentPos.y;\r\n        \r\n        // 找到最小距离\r\n        const minDistance = Math.min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom);\r\n\r\n        // 根据最小距离决定吸附方向\r\n        if (minDistance === distanceToLeft) {\r\n            newPos.x = margin;  // 吸附到左边\r\n        } else if (minDistance === distanceToRight) {\r\n            newPos.x = windowWidth - ballSize - margin;  // 吸附到右边\r\n        } else if (minDistance === distanceToTop) {\r\n            newPos.y = margin;  // 吸附到顶部\r\n        } else {\r\n            newPos.y = windowHeight - ballSize - margin;  // 吸附到底部\r\n        }\r\n\r\n        // 边界约束：确保位置在安全范围内\r\n        newPos.x = Math.max(margin, Math.min(windowWidth - ballSize - margin, newPos.x));\r\n        newPos.y = Math.max(margin, Math.min(windowHeight - ballSize - margin, newPos.y));\r\n        \r\n        return newPos;\r\n    }, []);\r\n\r\n    // ==================== 拖拽事件处理 ====================\r\n    /**\r\n     * 鼠标按下事件处理\r\n     * 初始化拖拽状态，记录起始位置和偏移量\r\n     */\r\n    const handleMouseDown = (e: React.MouseEvent) =\u003e {\r\n        e.preventDefault();  // 防止默认行为（如文本选择）\r\n        if (isExpanded) return;  // 展开状态下禁用拖拽\r\n\r\n        setIsDragging(true);\r\n        hasDraggedSignificantlyRef.current = false;\r\n        setDragStartPosition({x: e.clientX, y: e.clientY});\r\n        \r\n        // 计算鼠标点击位置相对于导航球的偏移量\r\n        const rect = ballRef.current?.getBoundingClientRect();\r\n        if (rect) {\r\n            setDragOffset({\r\n                x: e.clientX - rect.left,  // 鼠标X - 球左边距 = X偏移\r\n                y: e.clientY - rect.top    // 鼠标Y - 球上边距 = Y偏移\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 鼠标移动事件处理（使用防抖策略）\r\n     * 实时更新位置，但使用防抖避免频繁渲染\r\n     */\r\n    const handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n        if (!isDragging) return;\r\n\r\n        // 根据鼠标位置和初始偏移量计算新位置\r\n        const newPos = {\r\n            x: e.clientX - dragOffset.x,\r\n            y: e.clientY - dragOffset.y\r\n        };\r\n\r\n        // 存储待更新位置（用于防抖更新）\r\n        pendingPositionRef.current = newPos;\r\n\r\n        // 立即显示波纹效果，提供即时反馈\r\n        setShowRipple(true);\r\n\r\n        // 清除现有的防抖定时器\r\n        if (debounceTimerRef.current) {\r\n            clearTimeout(debounceTimerRef.current);\r\n        }\r\n\r\n        // 设置新的防抖定时器（500ms延迟）\r\n        debounceTimerRef.current = setTimeout(() =\u003e {\r\n            setPosition(newPos);\r\n            setShowRipple(false);\r\n        }, 500);\r\n\r\n        // 计算拖拽距离，判断是否为显著拖拽\r\n        const dragDistance = Math.sqrt(\r\n            Math.pow(e.clientX - dragStartPosition.x, 2) +\r\n            Math.pow(e.clientY - dragStartPosition.y, 2)\r\n        );\r\n\r\n        // 超过3像素视为显著拖拽\r\n        if (dragDistance \u003e 3) {\r\n            hasDraggedSignificantlyRef.current = true;\r\n        }\r\n    }, [isDragging, dragOffset, dragStartPosition]);\r\n\r\n    /**\r\n     * 鼠标释放事件处理\r\n     * 结束拖拽，执行吸附逻辑\r\n     */\r\n    const handleMouseUp = useCallback(() =\u003e {\r\n        if (!isDragging) return;\r\n\r\n        setIsDragging(false);\r\n        setShowRipple(false);\r\n\r\n        // 清除防抖定时器\r\n        if (debounceTimerRef.current) {\r\n            clearTimeout(debounceTimerRef.current);\r\n            debounceTimerRef.current = null;\r\n        }\r\n\r\n        // 如果发生了显著拖拽，执行边缘吸附\r\n        if (hasDraggedSignificantlyRef.current) {\r\n            const snappedPos = snapToEdge(pendingPositionRef.current);\r\n            setPosition(snappedPos);\r\n            setOriginalPosition(snappedPos);  // 更新原始位置记录\r\n        }\r\n\r\n        // 延迟重置拖拽标记，避免与点击事件冲突\r\n        setTimeout(() =\u003e {\r\n            hasDraggedSignificantlyRef.current = false;\r\n        }, 100);\r\n    }, [isDragging]);\r\n\r\n    // ==================== 全局事件监听 ====================\r\n    /**\r\n     * 管理全局鼠标事件监听器\r\n     * 只在拖拽状态下添加监听器，优化性能\r\n     */\r\n    useEffect(() =\u003e {\r\n        if (isDragging) {\r\n            document.addEventListener('mousemove', handleMouseMove);\r\n            document.addEventListener('mouseup', handleMouseUp);\r\n            return () =\u003e {\r\n                document.removeEventListener('mousemove', handleMouseMove);\r\n                document.removeEventListener('mouseup', handleMouseUp);\r\n            };\r\n        } else {\r\n            // 确保在非拖拽状态下移除监听器\r\n            document.removeEventListener('mousemove', handleMouseMove);\r\n            document.removeEventListener('mouseup', handleMouseUp);\r\n        }\r\n    }, [isDragging]);\r\n\r\n    // ==================== 交互事件处理 ====================\r\n    /**\r\n     * 导航球点击事件处理\r\n     * 切换展开/收起状态，处理位置移动\r\n     */\r\n    const handleBallClick = () =\u003e {\r\n        // 只有在非显著拖拽时才处理点击\r\n        if (!hasDraggedSignificantlyRef.current) {\r\n            if (!isExpanded) {\r\n                // 展开：保存当前位置，移动到屏幕中央\r\n                setOriginalPosition(position);\r\n                const centerX = window.innerWidth / 2 - 35;   // 中心X - 球半径\r\n                const centerY = window.innerHeight / 2 - 35;  // 中心Y - 球半径\r\n                setPosition({x: centerX, y: centerY});\r\n                setIsExpanded(true);\r\n            } else {\r\n                // 收起：延迟150ms后回到原始位置\r\n                setIsExpanded(false);\r\n                setTimeout(() =\u003e {\r\n                    setPosition(originalPosition);\r\n                }, 150);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 菜单项点击事件处理\r\n     * 执行动作后收起菜单\r\n     */\r\n    const handleMenuItemClick = (action: () =\u003e void) =\u003e {\r\n        action();\r\n        setIsExpanded(false);\r\n        setTimeout(() =\u003e {\r\n            setPosition(originalPosition);\r\n        }, 150);\r\n    };\r\n\r\n    /**\r\n     * 页面导航处理\r\n     */\r\n    const navigateToPage = (href: string) =\u003e {\r\n        handleMenuItemClick(() =\u003e router.push(href));\r\n    };\r\n\r\n    /**\r\n     * 主题切换处理\r\n     */\r\n    const handleThemeToggle = () =\u003e {\r\n        handleMenuItemClick(() =\u003e toggleTheme());\r\n    };\r\n\r\n    /**\r\n     * 语言切换处理\r\n     * 支持文档页面的语言切换重定向\r\n     */\r\n    const handleLocaleToggle = () =\u003e {\r\n        handleMenuItemClick(() =\u003e {\r\n            toggleLocale((newLocale) =\u003e {\r\n                // 检查是否在文档页面，重定向到相同文章的新语言版本\r\n                if (pathname.startsWith('/documents/')) {\r\n                    const pathSegments = pathname.split('/').filter(Boolean);\r\n                    if (pathSegments.length \u003e= 4) {\r\n                        const [, currentLang, category, fileName] = pathSegments;\r\n                        const newPath = `/documents/${newLocale}/${category}/${fileName}`;\r\n                        router.push(newPath);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n\r\n    /**\r\n     * 背景点击事件处理\r\n     * 点击背景收起菜单\r\n     */\r\n    const handleBackdropClick = () =\u003e {\r\n        setIsExpanded(false);\r\n        setTimeout(() =\u003e {\r\n            setPosition(originalPosition);\r\n        }, 150);\r\n    };\r\n\r\n    // ==================== 核心算法：圆形布局 ====================\r\n    /**\r\n     * 圆形菜单布局算法\r\n     * 使用极坐标计算菜单项的位置\r\n     * @param index 菜单项索引\r\n     * @param total 菜单项总数\r\n     * @param radius 圆形半径\r\n     * @returns 菜单项的屏幕坐标\r\n     */\r\n    const getCircularPosition = (index: number, total: number, radius: number = 120) =\u003e {\r\n        // 计算角度：将圆周等分，起始角度为-π/2（12点钟方向）\r\n        const angle = (2 * Math.PI * index) / total - Math.PI / 2;\r\n        \r\n        // 屏幕中心坐标\r\n        const centerX = window.innerWidth / 2;\r\n        const centerY = window.innerHeight / 2;\r\n        \r\n        // 极坐标到笛卡尔坐标转换\r\n        return {\r\n            x: centerX + Math.cos(angle) * radius - 60,  // -60为菜单项宽度调整\r\n            y: centerY + Math.sin(angle) * radius - 30,  // -30为菜单项高度调整\r\n        };\r\n    };\r\n\r\n    // ==================== 样式工具函数 ====================\r\n    /**\r\n     * 获取统一的按钮样式\r\n     */\r\n    const getUniformButtonStyles = () =\u003e {\r\n        return \"fixed z-50 rounded-xl shadow-lg hover:scale-110 transition-all duration-300 group opacity-0 menu-item backdrop-blur-md border bg-surface/60 border-surface/40 hover:bg-surface/80\";\r\n    };\r\n\r\n    /**\r\n     * 获取主题按钮样式\r\n     */\r\n    const getThemeButtonStyles = () =\u003e {\r\n        return \"fixed z-50 w-16 h-12 rounded-xl shadow-lg hover:scale-110 transition-all duration-300 group opacity-0 menu-item backdrop-blur-md bg-transparent hover:bg-surface/20\";\r\n    };\r\n\r\n    // ==================== UI组件 ====================\r\n    /**\r\n     * 活跃状态指示器组件\r\n     */\r\n    const ActiveIndicator = ({isActive}: { isActive: boolean }) =\u003e {\r\n        if (!isActive) return null;\r\n\r\n        return (\r\n            \u003cdiv className=\"absolute -top-1 -right-1 w-3 h-3 rounded-full shadow-lg\"\u003e\r\n                \u003cdiv className=\"w-full h-full rounded-full bg-primary\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n        );\r\n    };\r\n\r\n    // 主题图标组件\r\n    const SunIcon = () =\u003e (\r\n        \u003cdiv className=\"w-5 h-5 text-accent transition-all duration-300\"\u003e\r\n            \u003csvg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\r\n                \u003cpath fillRule=\"evenodd\"\r\n                      d=\"M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z\"\r\n                      clipRule=\"evenodd\"/\u003e\r\n            \u003c/svg\u003e\r\n        \u003c/div\u003e\r\n    );\r\n\r\n    const MoonIcon = () =\u003e (\r\n        \u003cdiv className=\"w-5 h-5 text-accent transition-all duration-300\"\u003e\r\n            \u003csvg fill=\"currentColor\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\r\n                \u003cpath d=\"M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z\"/\u003e\r\n            \u003c/svg\u003e\r\n        \u003c/div\u003e\r\n    );\r\n\r\n    // 语言切换图标组件\r\n    const LocaleIcon = () =\u003e (\r\n        \u003cdiv className=\"w-5 h-5 text-accent transition-all duration-300 flex items-center justify-center\"\u003e\r\n            \u003cspan className=\"text-sm font-bold\"\u003e\r\n                {LOCALES[locale].flag}\r\n            \u003c/span\u003e\r\n        \u003c/div\u003e\r\n    );\r\n\r\n    // ==================== 渲染逻辑 ====================\r\n    /**\r\n     * 加载状态渲染\r\n     */\r\n    if (!mounted) {\r\n        return (\r\n            \u003cdiv className=\"fixed top-20 right-5 z-50\"\u003e\r\n                \u003cdiv\r\n                    className=\"w-16 h-16 rounded-full backdrop-blur-md border animate-pulse bg-surface/60 border-surface/40\"\u003e\u003c/div\u003e\r\n            \u003c/div\u003e\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 构建完整的菜单项数组\r\n     */\r\n    const allMenuItems = [\r\n        ...sections.map(section =\u003e ({\r\n            type: 'section' as const,\r\n            section,\r\n            action: () =\u003e navigateToPage(section.id === 'personal' ? '/' : section.href),\r\n            isActive: activeSection === section.id\r\n        })),\r\n        {\r\n            type: 'theme' as const,\r\n            action: handleThemeToggle,\r\n            isActive: false\r\n        },\r\n        {\r\n            type: 'locale' as const,\r\n            action: handleLocaleToggle,\r\n            isActive: false\r\n        }\r\n    ];\r\n\r\n    return (\r\n        \u003c\u003e\r\n            {/* ==================== 主导航球 ==================== */}\r\n            \u003cdiv\r\n                ref={ballRef}\r\n                className={`\r\n          fixed z-50 transition-all duration-500 cursor-pointer select-none\r\n          ${isDragging ? 'cursor-grabbing scale-110 duration-0' : 'cursor-grab hover:scale-105'}\r\n          ${isExpanded ? 'hover:scale-120' : ''}\r\n        `}\r\n                style={{\r\n                    left: `${position.x}px`,\r\n                    top: `${position.y}px`,\r\n                    transform: `${isDragging ? 'rotate(5deg)' : isExpanded ? 'rotate(0deg) scale(1.1)' : 'rotate(0deg)'}`\r\n                }}\r\n                onMouseDown={handleMouseDown}\r\n                onClick={handleBallClick}\r\n            \u003e\r\n                {/* 现代化导航球 */}\r\n                \u003cdiv className={`\r\n          relative w-16 h-16 rounded-full transition-all duration-500\r\n          ${isExpanded ? 'animate-pulse shadow-lg' : ''}\r\n        `}\u003e\r\n                    {/* 球体阴影 */}\r\n                    \u003cdiv className=\"absolute inset-0 rounded-full bg-black/20 blur-lg translate-y-2\"\u003e\u003c/div\u003e\r\n                    \r\n                    {/* 波纹效果 - 拖拽时显示 */}\r\n                    {showRipple \u0026\u0026 (\r\n                        \u003cdiv\r\n                            className=\"absolute rounded-full border-2 animate-ping pointer-events-none\"\r\n                            style={{\r\n                                borderColor: theme === 'dark' ? 'rgba(78, 205, 196, 0.6)' : 'rgba(0, 102, 204, 0.6)',\r\n                                width: '80px',\r\n                                height: '80px',\r\n                                top: '-8px',\r\n                                left: '-8px',\r\n                                animationDuration: '1s'\r\n                            }}\r\n                        \u003e\u003c/div\u003e\r\n                    )}\r\n\r\n                    {/* 主球体 */}\r\n                    \u003cdiv\r\n                        className=\"relative w-full h-full rounded-full shadow-xl transform-gpu backdrop-blur-md border transition-all duration-300 bg-surface/60 border-surface/40 hover:bg-surface/80\"\u003e\r\n                        {/* 高光效果 */}\r\n                        \u003cdiv className=\"absolute top-2 left-2 w-4 h-4 rounded-full bg-white/30 blur-sm\"\u003e\u003c/div\u003e\r\n                        \r\n                        {/* 菜单符号 */}\r\n                        \u003cdiv className=\"absolute inset-0 flex items-center justify-center\"\u003e\r\n                            \u003cdiv className={`\r\n                w-6 h-6 rounded-full border transition-all duration-300 flex items-center justify-center border-foreground/40\r\n                ${isExpanded ? 'rotate-90 scale-110' : 'rotate-0'}\r\n              `}\u003e\r\n                                {\r\n                                    isExpanded ? (\r\n                                        \u003cdiv\r\n                                            className=\"relative transition-all duration-300 w-2 h-2 opacity-50 text-center flex items-center justify-center text-foreground\"\r\n                                            style={{transform: 'translateY(-1px)'}}\r\n                                        \u003e×\u003c/div\u003e\r\n                                    ) : (\r\n                                        \u003cdiv\r\n                                            className=\"transition-all duration-300 w-1 h-1 opacity-50 rounded-full bg-foreground\"\u003e\u003c/div\u003e\r\n                                    )\r\n                                }\r\n\r\n                            \u003c/div\u003e\r\n                        \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n\r\n            {/* ==================== 圆形菜单 ==================== */}\r\n            {isExpanded \u0026\u0026 (\r\n                \u003c\u003e\r\n                    {/* 背景遮罩 */}\r\n                    \u003cdiv\r\n                        className=\"fixed inset-0 z-40 backdrop-blur-md transition-all duration-300 bg-background/20\"\r\n                        onClick={handleBackdropClick}\r\n                    \u003e\u003c/div\u003e\r\n\r\n                    {/* 圆形布局的菜单项 */}\r\n                    {allMenuItems.map((item, index) =\u003e {\r\n                        const circularPos = getCircularPosition(index, allMenuItems.length);\r\n\r\n                        if (item.type === 'section') {\r\n                            const section = item.section!;\r\n\r\n                            return (\r\n                                \u003cbutton\r\n                                    key={section.id}\r\n                                    onClick={item.action}\r\n                                    className={`${getUniformButtonStyles()} w-28 h-14 ${item.isActive ? 'ring-2 ring-blue-400/60 scale-105' : ''}`}\r\n                                    style={{\r\n                                        left: `${circularPos.x}px`,\r\n                                        top: `${circularPos.y}px`,\r\n                                        animationDelay: `${index * 120}ms`\r\n                                    }}\r\n                                \u003e\r\n                                    {/* 栏目内容 */}\r\n                                    \u003cdiv\r\n                                        className=\"absolute inset-0 flex flex-col items-center justify-center text-foreground\"\u003e\r\n                                        \u003cspan className=\"text-sm font-bold leading-tight text-center\"\u003e\r\n                                            {section.label}\r\n                                        \u003c/span\u003e\r\n                                        \u003cspan className=\"text-xs opacity-70 mt-0.5 font-medium\"\u003e\r\n                                            {section.description}\r\n                                        \u003c/span\u003e\r\n                                    \u003c/div\u003e\r\n\r\n                                    \u003cActiveIndicator isActive={item.isActive}/\u003e\r\n                                \u003c/button\u003e\r\n                            );\r\n                        } else if (item.type === 'theme') {\r\n                            return (\r\n                                \u003cbutton\r\n                                    key=\"theme\"\r\n                                    onClick={item.action}\r\n                                    className={getThemeButtonStyles()}\r\n                                    style={{\r\n                                        left: `${circularPos.x}px`,\r\n                                        top: `${circularPos.y}px`,\r\n                                        animationDelay: `${index * 120}ms`\r\n                                    }}\r\n                                \u003e\r\n                                    {/* 主题切换图标 */}\r\n                                    \u003cdiv className=\"flex items-center justify-center h-full\"\u003e\r\n                                        {theme === 'dark' ? \u003cSunIcon/\u003e : \u003cMoonIcon/\u003e}\r\n                                    \u003c/div\u003e\r\n                                \u003c/button\u003e\r\n                            );\r\n                        } else { // locale toggle\r\n                            return (\r\n                                \u003cbutton\r\n                                    key=\"locale\"\r\n                                    onClick={item.action}\r\n                                    className={getThemeButtonStyles()}\r\n                                    style={{\r\n                                        left: `${circularPos.x}px`,\r\n                                        top: `${circularPos.y}px`,\r\n                                        animationDelay: `${index * 120}ms`\r\n                                    }}\r\n                                \u003e\r\n                                    {/* 语言切换图标 */}\r\n                                    \u003cdiv className=\"flex items-center justify-center h-full\"\u003e\r\n                                        \u003cLocaleIcon/\u003e\r\n                                    \u003c/div\u003e\r\n                                \u003c/button\u003e\r\n                            );\r\n                        }\r\n                    })}\r\n                \u003c/\u003e\r\n            )}\r\n\r\n            {/* ==================== CSS动画定义 ==================== */}\r\n            \u003cstyle jsx\u003e{`\r\n                @keyframes menuItemAppear {\r\n                    0% {\r\n                        opacity: 0;\r\n                        transform: scale(0) translate(-50%, -50%);\r\n                    }\r\n                    50% {\r\n                        opacity: 0.7;\r\n                        transform: scale(0.8) translate(-25%, -25%);\r\n                    }\r\n                    100% {\r\n                        opacity: 1;\r\n                        transform: scale(1) translate(0%, 0%);\r\n                    }\r\n                }\r\n\r\n                @keyframes menuItemDisappear {\r\n                    0% {\r\n                        opacity: 1;\r\n                        transform: scale(1) translate(0%, 0%);\r\n                    }\r\n                    50% {\r\n                        opacity: 0.3;\r\n                        transform: scale(0.6) translate(-25%, -25%);\r\n                    }\r\n                    100% {\r\n                        opacity: 0;\r\n                        transform: scale(0) translate(-50%, -50%);\r\n                    }\r\n                }\r\n\r\n                .menu-item {\r\n                    animation: menuItemAppear 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;\r\n                }\r\n            `}\u003c/style\u003e\r\n        \u003c/\u003e\r\n    );\r\n}\r\n```\r\n\r\n### 核心算法流程图\r\n\r\n```\r\n用户交互 → 事件判断 → 状态更新 → 位置计算 → 视觉反馈\r\n    ↓        ↓         ↓         ↓         ↓\r\n鼠标按下   拖拽/点击 isDragging  dragOffset 波纹效果\r\n    ↓        ↓         ↓         ↓         ↓\r\n鼠标移动   距离计算   position更新 防抖更新  实时反馈\r\n    ↓        ↓         ↓         ↓         ↓\r\n鼠标释放   吸附算法   边界约束    菜单展开   动画过渡\r\n```\r\n\r\n### 关键算法解析\r\n\r\n**1. 边缘吸附核心算法**\r\n```typescript\r\n// 关键：计算到四边的距离，移动到最近边界\r\nconst distanceToLeft = currentPos.x;\r\nconst distanceToRight = windowWidth - currentPos.x;\r\nconst distanceToTop = currentPos.y;\r\nconst distanceToBottom = windowHeight - currentPos.y;\r\nconst minDistance = Math.min(distanceToLeft, distanceToRight, distanceToTop, distanceToBottom);\r\n\r\n// 根据最小距离确定吸附方向\r\nif (minDistance === distanceToLeft) {\r\n    newPos.x = margin;  // 吸附到左边\r\n}\r\n```\r\n\r\n**2. 圆形布局数学计算**\r\n```typescript\r\n// 关键：极坐标转换 + 角度均分\r\nconst angle = (2 * Math.PI * index) / total - Math.PI / 2;  // 角度计算\r\nconst x = centerX + Math.cos(angle) * radius;               // X坐标转换\r\nconst y = centerY + Math.sin(angle) * radius;               // Y坐标转换\r\n```\r\n\r\n**3. 防抖拖拽优化**\r\n```typescript\r\n// 关键：即时反馈 + 延迟更新\r\npendingPositionRef.current = newPos;     // 存储待更新位置\r\nsetShowRipple(true);                     // 立即显示反馈\r\nsetTimeout(() =\u003e {                       // 防抖更新\r\n    setPosition(newPos);\r\n    setShowRipple(false);\r\n}, 500);\r\n```\r\n\r\n**4. 拖拽距离判定**\r\n```typescript\r\n// 关键：欧几里得距离计算\r\nconst dragDistance = Math.sqrt(\r\n    Math.pow(e.clientX - dragStartPosition.x, 2) +\r\n    Math.pow(e.clientY - dragStartPosition.y, 2)\r\n);\r\nif (dragDistance \u003e 3) {  // 3像素阈值过滤手抖\r\n    hasDraggedSignificantlyRef.current = true;\r\n}\r\n```\r\n\r\n*愿你的导航如北极星般稳定，如流星般灵动。* ✨\r\n"])</script><script>self.__next_f.push([1,"3b:T99b0,"])</script><script>self.__next_f.push([1,"\r\n# 泡沫背景：从Canvas思维到DOM实现的粒子世界\r\n\r\n序言——这是美观性计划的一部分。\r\n\r\n在这篇文章中，我将从Canvas的思维模式开始，逐步展示如何用DOM + CSS的组合来创造出流畅的粒子动画效果，涵盖物理模拟、主题响应、性能优化等各个方面的实现细节。\r\n\r\n## Canvas思维在DOM世界的转译\r\n\r\n开始之前，我们先聊聊为什么要\"背叛\"Canvas，投靠DOM的怀抱。\r\n\r\n### Canvas vs DOM：一场哲学选择\r\n\r\n在Canvas的世界里，粒子系统的实现思路很直接：\r\n\r\n```javascript\r\n// Canvas的经典套路\r\nfunction drawParticle(ctx, particle) {\r\n    ctx.beginPath();\r\n    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\r\n    ctx.fillStyle = particle.color;\r\n    ctx.fill();\r\n}\r\n\r\nfunction animateFrame() {\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    particles.forEach(particle =\u003e {\r\n        updateParticle(particle);\r\n        drawParticle(ctx, particle);\r\n    });\r\n    requestAnimationFrame(animateFrame);\r\n}\r\n```\r\n\r\n简洁明了，性能也不错。但我选择DOM的原因是：\r\n\r\n1. 这是第一点\r\n2. 这是第二点\r\n3. 这是第三点\r\n4. 这是第四点\r\n5. 这是...\r\n\r\n好吧不开玩笑了。实际上是：\r\n\r\n1. **更好的可访问性**: DOM元素天生支持屏幕阅读器和其他辅助技术\r\n2. **更容易的主题集成**: CSS变量和主题系统无缝对接\r\n3. **更简单的事件处理**: 每个粒子都是真实的DOM元素，事件处理更直观\r\n4. **GPU加速的transform**: CSS的transform属性会自动触发GPU加速\r\n\r\n当然，代价就是复杂度的增加和一些性能上的权衡。~~（主要是AI一开始给我的就是DOM方案导致我在这条路上越走越深）~~\r\n\r\n### DOM粒子的创建艺术\r\n\r\n在DOM世界里，每个粒子都是一个真实的div元素：\r\n\r\n```typescript\r\nconst el = document.createElement('div');\r\nel.style.position = 'absolute';\r\nel.style.borderRadius = '50%';\r\nel.style.backgroundColor = colors.particle;\r\nel.style.pointerEvents = 'none';\r\nel.style.willChange = 'transform, opacity';\r\n\r\ncontainer.appendChild(el);\r\n```\r\n\r\n属性解释：\r\n\r\n- **position: absolute**: 让粒子脱离文档流，可以自由定位\r\n- **borderRadius: 50%**: 把方形div变成圆形，模拟泡沫的形状\r\n- **pointerEvents: none**: 确保粒子不会干扰用户与页面的交互\r\n- **willChange**: 提示浏览器这个元素会频繁变化，开启优化\r\n\r\n### 坐标系统的映射关系\r\n\r\nCanvas使用的是标准的笛卡尔坐标系，而DOM使用的是CSS坐标系。好在两者的映射关系很直接：\r\n\r\n```typescript\r\n// Canvas: drawCircle(x, y, radius)\r\n// DOM: element.style.left = x + 'px'; element.style.top = y + 'px';\r\n\r\n// 我们的实现\r\np.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\np.el.style.opacity = opacity.toString();\r\n```\r\n\r\n使用`transform`而不是直接修改`left/top`有个重要原因：**transform不会触发重排**，只会触发重绘和合成，性能更好。\r\n\r\n## 粒子的生命周期与数据架构\r\n\r\n现在让我们深入粒子系统的核心——数据结构设计。\r\n\r\n### 粒子接口设计\r\n\r\n```typescript\r\ninterface Particle {\r\n  el: HTMLDivElement;    // DOM元素引用\r\n  x: number;             // X坐标\r\n  y: number;             // Y坐标  \r\n  vx: number;            // X方向速度\r\n  vy: number;            // Y方向速度\r\n  size: number;          // 粒子大小\r\n  depth: number;         // 深度层次(0-1)\r\n}\r\n```\r\n\r\n字段解释：\r\n\r\n- **el**: 直接存储DOM元素引用，避免频繁的DOM查询\r\n- **x, y**: 当前的精确位置（可以是小数）\r\n- **vx, vy**: 速度向量，用于模拟物理运动\r\n- **size**: 粒子的基础大小，会结合depth计算最终显示大小\r\n- **depth**: 这是视觉深度的关键，控制着粒子的大小、透明度和运动速度\r\n\r\n### 粒子初始化的随机化策略\r\n\r\n```typescript\r\nconst initializeParticles = useCallback(() =\u003e {\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n    const colors = getThemeColors();\r\n\r\n    for (let i = 0; i \u003c NUM_PARTICLES; i++) {\r\n        const size = 2 + Math.random() * 4;      // 2-6px的随机大小\r\n        const depth = Math.random();             // 0-1的随机深度\r\n        const x = Math.random() * width;         // 随机X位置\r\n        const y = Math.random() * height;        // 随机Y位置\r\n\r\n        const particle = {\r\n            el, x, y,\r\n            vx: 0, vy: 0,                        // 初始速度为0\r\n            size, depth\r\n        };\r\n        \r\n        particlesRef.current.push(particle);\r\n    }\r\n}, [getThemeColors]);\r\n```\r\n\r\n**为什么初始速度为0**？让粒子从静止开始，只在受到外力（动画效果）时才运动，更符合物理直觉。\r\n\r\n### 动画循环的时间精度控制\r\n\r\n这是整个系统的心脏——动画循环：\r\n\r\n```typescript\r\nconst animate = useCallback(() =\u003e {\r\n    const mouse = mouseRef.current;\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    for (let p of particlesRef.current) {\r\n        // 基础漂移（模拟流体运动）\r\n        p.vx += 0.01 * p.depth;\r\n        p.vy += 0.005 * p.depth;\r\n\r\n        // 交互力场计算\r\n        if (mouse.down) {\r\n            const dx = p.x - mouse.x;\r\n            const dy = p.y - mouse.y;\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            if (dist \u003c 100) {\r\n                const baseForce = 100 / (dist + 10);\r\n                const force = baseForce * p.depth;\r\n\r\n                p.vx += force * (dx / dist);\r\n                p.vy += force * (dy / dist);\r\n            }\r\n        }\r\n\r\n        // 应用摩擦力\r\n        p.vx *= 0.95;\r\n        p.vy *= 0.95;\r\n\r\n        // 更新位置\r\n        p.x += p.vx;\r\n        p.y += p.vy;\r\n\r\n        // 边界环绕\r\n        if (p.x \u003c -10) p.x = width + 10;\r\n        if (p.x \u003e width + 10) p.x = -10;\r\n        if (p.y \u003c -10) p.y = height + 10;\r\n        if (p.y \u003e height + 10) p.y = -10;\r\n\r\n        // 视觉效果更新\r\n        const scale = 0.6 + 0.4 * p.depth;\r\n        const opacity = 0.4 + 0.6 * p.depth;\r\n\r\n        p.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\n        p.el.style.opacity = opacity.toString();\r\n    }\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n}, []);\r\n```\r\n\r\n数值解析：\r\n\r\n1. **0.01 * p.depth**: 基础漂移力，让粒子有轻微的自然运动\r\n2. **0.005 * p.depth**: Y方向的漂移更小，模拟重力的微弱影响\r\n3. **100 / (dist + 10)**: 反平方力场，距离越近力越大，+10避免除零错误\r\n4. **0.95**: 摩擦系数，让粒子运动逐渐减缓，模拟空气阻力\r\n5. **-10, +10**: 边界缓冲，让粒子从屏幕外进入，避免突然出现\r\n\r\n## 交互系统的物理世界\r\n\r\n你也不想背景UI只是一副动态贴图吧？——沃兹基索德\r\n\r\n### 鼠标事件的全生命周期管理\r\n\r\n```typescript\r\nconst mouseRef = useRef\u003cMouseState\u003e({ x: 0, y: 0, down: false });\r\n\r\nconst updateMousePos = useCallback((e: MouseEvent | Touch) =\u003e {\r\n    mouseRef.current.x = e.clientX;\r\n    mouseRef.current.y = e.clientY;\r\n}, []);\r\n\r\nconst handleMouseDown = useCallback((e: MouseEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e);\r\n}, [updateMousePos]);\r\n\r\nconst handleMouseUp = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n}, []);\r\n\r\nconst handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e);\r\n}, [updateMousePos]);\r\n```\r\n\r\n**为什么要用ref而不是state**？因为在60fps的动画循环中，我们需要在每一帧都读取鼠标位置，使用state会导致不必要的重渲染。ref提供了一个\"逃脱React渲染循环\"的后门。\r\n\r\n### 力场计算的数学原理\r\n\r\n这是物理模拟的核心部分：\r\n\r\n```typescript\r\n// 计算粒子到鼠标的向量\r\nconst dx = p.x - mouse.x;\r\nconst dy = p.y - mouse.y;\r\n\r\n// 计算距离（欧几里得距离）\r\nconst dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n// 反平方力场（类似万有引力）\r\nconst baseForce = 100 / (dist + 10);\r\n\r\n// 深度影响力的大小\r\nconst force = baseForce * p.depth;\r\n\r\n// 计算单位向量并应用力\r\np.vx += force * (dx / dist);\r\np.vy += force * (dy / dist);\r\n```\r\n\r\n这个公式模拟了一个\"排斥力场\"：\r\n\r\n1. **距离计算**: 使用勾股定理计算实际距离\r\n2. **力的大小**: 使用反平方定律，距离越近力越大\r\n3. **力的方向**: `(dx/dist, dy/dist)`是从鼠标指向粒子的单位向量\r\n4. **深度加权**: 靠近屏幕的粒子受力更明显，增加立体感\r\n\r\n### 多点触控的支持\r\n\r\n```typescript\r\nconst handleTouchStart = useCallback((e: TouchEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n\r\nconst handleTouchMove = useCallback((e: TouchEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n```\r\n\r\n移动设备支持只是取第一个触摸点，因为多点触控的物理模拟会变得非常复杂，而且大多数用户也只会用一个手指。~~（偷懒的合理化）~~\r\n\r\n### 摩擦力模拟\r\n\r\n```typescript\r\np.vx *= 0.95;\r\np.vy *= 0.95;\r\n```\r\n\r\n~~从网上随便找来的摩擦力系数。~~\r\n\r\n## 主题系统的色彩混合\r\n\r\n泡沫背景需要与网站的主题系统无缝集成，这里涉及到了较为复杂的颜色混合运算。\r\n\r\n### HSL颜色空间\r\n\r\n相比RGB，HSL更加适合生成相近的色彩：\r\n\r\n```typescript\r\nconst hexToHsl = useCallback((hex: string) =\u003e {\r\n    // 将16进制转换为RGB\r\n    const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n    const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n    const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n\r\n    // 找到最大值和最小值\r\n    const max = Math.max(r, g, b);\r\n    const min = Math.min(r, g, b);\r\n    let h = 0, s = 0, l = (max + min) / 2;\r\n\r\n    if (max !== min) {\r\n        const d = max - min;\r\n        s = l \u003e 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        \r\n        switch (max) {\r\n            case r: h = (g - b) / d + (g \u003c b ? 6 : 0); break;\r\n            case g: h = (b - r) / d + 2; break;\r\n            case b: h = (r - g) / d + 4; break;\r\n        }\r\n        h /= 6;\r\n    }\r\n\r\n    return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];\r\n}, []);\r\n```\r\n\r\n这个转换算法看起来复杂，但原理很直观：\r\n1. **将RGB标准化到0-1范围**\r\n2. **计算明度(L)**: 最大值和最小值的平均\r\n3. **计算饱和度(S)**: 基于明度和色彩范围\r\n4. **计算色相(H)**: 基于主导颜色的位置\r\n\r\n### 主题响应的动态生成策略\r\n\r\n```typescript\r\nconst getThemeColors = useCallback(() =\u003e {\r\n    const [primaryH, primaryS] = hexToHsl(currentTheme.colors.primary);\r\n    const [accentH, accentS] = hexToHsl(currentTheme.colors.accent);\r\n    \r\n    const isDark = currentTheme.id === 'dark';\r\n    \r\n    if (isDark) {\r\n        // 深色主题：更深、更饱和的颜色\r\n        return {\r\n            background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS + 10, 40)}%, 25%), hsl(${accentH}, ${Math.max(accentS + 5, 35)}%, 20%))`,\r\n            particle: `hsl(${primaryH}, ${Math.max(primaryS + 15, 50)}%, 45%)`\r\n        };\r\n    } else {\r\n        // 浅色主题：更亮的颜色\r\n        return {\r\n            background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS - 20, 20)}%, 60%), hsl(${accentH}, ${Math.max(accentS - 10, 30)}%, 50%))`,\r\n            particle: `hsl(${primaryH}, ${Math.max(primaryS - 10, 35)}%, 75%)`\r\n        };\r\n    }\r\n}, [currentTheme, hexToHsl]);\r\n```\r\n\r\n这个函数的设计考虑了多个因素：\r\n\r\n- **饱和度调整**: 深色模式增加饱和度，浅色模式降低饱和度，确保对比度适中\r\n- **明度控制**: 深色模式使用较低的明度值(20-45%)，浅色模式使用较高的明度值(50-75%)\r\n- **渐变设计**: 135度斜角渐变，从主色到强调色，创造空间深度感\r\n- **安全边界**: 使用`Math.max()`确保饱和度和明度不会过低\r\n\r\n### 动态色彩的实时更新\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    if (particlesRef.current.length \u003e 0) {\r\n        const colors = getThemeColors();\r\n        \r\n        // 更新所有粒子的颜色\r\n        particlesRef.current.forEach(p =\u003e {\r\n            p.el.style.backgroundColor = colors.particle;\r\n        });\r\n        \r\n        // 更新容器背景\r\n        if (containerRef.current) {\r\n            containerRef.current.style.background = colors.background;\r\n        }\r\n    }\r\n}, [currentTheme, getThemeColors]);\r\n```\r\n\r\n当主题切换时，所有粒子会同步更新颜色，无需重新创建DOM元素，保证了切换的流畅性。\r\n\r\n### 深度数学模型\r\n\r\n```typescript\r\nconst depth = Math.random(); // 0-1之间的随机深度值\r\n\r\n// 基于深度的缩放\r\nconst scale = 0.6 + 0.4 * depth;\r\n\r\n// 基于深度的透明度\r\nconst opacity = 0.4 + 0.6 * depth;\r\n\r\n// 基于深度的运动速度\r\np.vx += 0.01 * p.depth;\r\np.vy += 0.005 * p.depth;\r\n```\r\n\r\n层次感渲染：\r\n\r\n- **scale: 0.6-1.0**: 远处的粒子小，近处的粒子大\r\n- **opacity: 0.4-1.0**: 远处的粒子透明，近处的粒子不透明\r\n- **speed: depth倍数**: 近处的粒子移动更快，远处的粒子移动更慢\r\n\r\n### 视差运动的模拟\r\n\r\n```typescript\r\n// 在交互力计算中\r\nconst force = baseForce * p.depth;\r\n```\r\n\r\n深度值作为力的倍数，意味着：\r\n- 近处的粒子对交互更敏感\r\n- 远处的粒子反应更迟钝\r\n- 整体呈现出视差滚动的效果\r\n\r\n这种设计让用户感觉自己在与一个真正的3D空间互动，而不是平面上的点。（也许？）\r\n\r\n## 响应式布局的粒子重分配\r\n\r\n当窗口大小改变时，粒子系统需要灵活地适应新的尺寸。\r\n\r\n### 窗口尺寸变化的监听策略\r\n\r\n```typescript\r\nconst handleResize = useCallback(() =\u003e {\r\n    // 重新初始化粒子分布\r\n    initializeParticles();\r\n}, [initializeParticles]);\r\n\r\nuseEffect(() =\u003e {\r\n    window.addEventListener('resize', handleResize);\r\n    \r\n    return () =\u003e window.removeEventListener('resize', handleResize);\r\n}, [handleResize]);\r\n```\r\n\r\n**为什么选择重新初始化而不是重新定位**？因为重新定位现有粒子会导致视觉上的\"跳跃\"，而重新初始化虽然会有短暂的重建，但视觉效果更自然。\r\n\r\n### 粒子清理的内存安全\r\n\r\n```typescript\r\n// 清理现有粒子\r\nparticlesRef.current.forEach(p =\u003e p.el.remove());\r\nparticlesRef.current = [];\r\n```\r\n\r\n**为什么要手动remove**？因为我们使用的是原生DOM操作，React不会自动清理这些元素。如果不手动移除，会导致DOM中堆积大量隐形元素，造成内存泄漏。\r\n\r\n### 防抖处理的必要性\r\n\r\n用户调整窗口大小时，resize事件会疯狂触发。没有防抖的话，每一次微小的窗口变化都会重新创建300个粒子——反复拖几十个来回后，你也许就可以听到GPU风扇转动的美妙声音。\r\n\r\n**防抖实现**：\r\n\r\n```typescript\r\n// 防抖工具函数\r\nconst debounce = useCallback((func: Function, wait: number) =\u003e {\r\n    let timeout: NodeJS.Timeout;\r\n    return function executedFunction(...args: any[]) {\r\n        const later = () =\u003e {\r\n            clearTimeout(timeout);\r\n            func(...args);\r\n        };\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}, []);\r\n\r\n// 创建防抖版本的resize处理器\r\nconst debouncedHandleResize = useCallback(\r\n    debounce(handleResize, 1000), // 1秒的防抖延迟\r\n    [debounce, handleResize]\r\n);\r\n\r\n// 在事件监听中使用防抖版本\r\nuseEffect(() =\u003e {\r\n    window.addEventListener('resize', debouncedHandleResize);\r\n    \r\n    return () =\u003e {\r\n        window.removeEventListener('resize', debouncedHandleResize);\r\n    };\r\n}, [debouncedHandleResize]);\r\n```\r\n\r\n**防抖的工作原理**：\r\n\r\n1. 用户开始拖拽窗口 → 第一个resize事件到达\r\n2. 防抖函数设置1000ms定时器，准备执行重建\r\n3. 用户继续拖拽 → 更多resize事件到达\r\n4. 每次新事件都会取消之前的定时器，重新计时\r\n5. 用户停止拖拽1000ms后 → 定时器触发，执行粒子重建\r\n\r\n这样就把原本可能触发几十次的重建操作，优化成了只在用户真正\"完成调整\"后的一次重建。\r\n\r\n## 性能优化的关键策略\r\n\r\n300个DOM元素的同时动画是对浏览器的严峻考验，每一个优化细节都至关重要。\r\n\r\n### willChange属性的正确使用\r\n\r\n```typescript\r\nel.style.willChange = 'transform, opacity';\r\n```\r\n\r\n这行代码告诉浏览器：\"这个元素的transform和opacity会频繁变化，请为它准备GPU图层\"。\r\n\r\n但是！willChange是一把双刃剑：\r\n- **好处**: 开启GPU加速，动画更流畅\r\n- **坏处**: 消耗额外的GPU内存，过多使用会适得其反\r\n\r\n所以我们只在真正需要动画的属性上使用它。\r\n\r\n### requestAnimationFrame的生命周期管理\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    animate();\r\n    \r\n    return () =\u003e {\r\n        if (animationIdRef.current !== null) {\r\n            cancelAnimationFrame(animationIdRef.current);\r\n        }\r\n        \r\n        // 清理所有粒子\r\n        particlesRef.current.forEach(p =\u003e p.el.remove());\r\n    };\r\n}, [animate]);\r\n```\r\n\r\n这个cleanup函数做了两件重要的事：\r\n1. **取消动画帧**: 避免组件卸载后动画继续运行\r\n2. **清理DOM元素**: 防止内存泄漏\r\n\r\n### 层级管理的z-index策略\r\n\r\n```typescript\r\nclassName=\"fixed inset-0 w-full h-full overflow-hidden pointer-events-none z-0\"\r\n```\r\n\r\n- **z-0**: 确保背景永远在最底层，不会遮挡其他内容\r\n- **pointer-events-none**: 让整个容器不响应鼠标事件，避免干扰页面交互\r\n- **overflow-hidden**: 防止粒子跑到容器外面显示\r\n\r\n## 事件处理的边界情况\r\n\r\n真实世界的用户交互远比理想情况复杂，我们需要处理各种边界情况。\r\n\r\n### 触摸设备的特殊处理\r\n\r\n```typescript\r\nconst handleTouchStart = useCallback((e: TouchEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n\r\nconst handleTouchMove = useCallback((e: TouchEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e.touches[0]);\r\n}, [updateMousePos]);\r\n\r\nconst handleTouchEnd = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n}, []);\r\n```\r\n\r\n**为什么只取第一个触摸点**？因为多点触控会让力场计算变得极其复杂，而且大多数用户也只会用一个手指\"戳泡泡\"。\r\n\r\n### 事件监听器的作用域控制\r\n\r\n```typescript\r\n// 全局事件\r\ndocument.addEventListener('mousedown', handleMouseDown);\r\ndocument.addEventListener('mouseup', handleMouseUp);\r\ndocument.addEventListener('mousemove', handleMouseMove);\r\n\r\n// 容器局部事件\r\ncontainer.addEventListener('touchstart', handleTouchStart);\r\ncontainer.addEventListener('touchend', handleTouchEnd);\r\ncontainer.addEventListener('touchmove', handleTouchMove);\r\n```\r\n\r\n- **鼠标事件绑定到document**: 确保用户拖拽时即使鼠标移出容器，交互也能继续\r\n- **触摸事件绑定到容器**: 触摸事件的传播机制不同，绑定到容器更安全\r\n\r\n## 可复用设计模式总结\r\n\r\n通过这次深入的实现分析，我们可以提取出几个通用的设计模式。\r\n\r\n### 粒子系统的通用架构\r\n\r\n```typescript\r\n// 1. 数据结构设计\r\ninterface Particle {\r\n    el: HTMLElement;      // DOM引用\r\n    x: number; y: number; // 位置\r\n    vx: number; vy: number; // 速度\r\n    [key: string]: any;   // 其他属性\r\n}\r\n\r\n// 2. 生命周期管理\r\nconst createParticle = () =\u003e { /* 创建逻辑 */ };\r\nconst updateParticle = (particle: Particle) =\u003e { /* 更新逻辑 */ };\r\nconst destroyParticle = (particle: Particle) =\u003e { /* 销毁逻辑 */ };\r\n\r\n// 3. 动画循环\r\nconst animate = () =\u003e {\r\n    particles.forEach(updateParticle);\r\n    requestAnimationFrame(animate);\r\n};\r\n```\r\n\r\n### 物理模拟的基本模式\r\n\r\n```typescript\r\n// 力场计算模式\r\nconst calculateForce = (particle: Particle, target: Position) =\u003e {\r\n    const dx = particle.x - target.x;\r\n    const dy = particle.y - target.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    const force = strength / (distance + epsilon);\r\n    \r\n    return {\r\n        fx: force * (dx / distance),\r\n        fy: force * (dy / distance)\r\n    };\r\n};\r\n\r\n// 边界处理模式\r\nconst handleBoundaries = (particle: Particle, bounds: Bounds) =\u003e {\r\n    if (particle.x \u003c bounds.left) particle.x = bounds.right;\r\n    if (particle.x \u003e bounds.right) particle.x = bounds.left;\r\n    if (particle.y \u003c bounds.top) particle.y = bounds.bottom;\r\n    if (particle.y \u003e bounds.bottom) particle.y = bounds.top;\r\n};\r\n```\r\n\r\n### 主题响应的设计模式\r\n\r\n```typescript\r\n// 颜色系统模式\r\nconst createThemeColors = (baseTheme: Theme) =\u003e {\r\n    const [h, s, l] = hexToHsl(baseTheme.primary);\r\n    \r\n    return {\r\n        background: `hsl(${h}, ${s}%, ${l}%)`,\r\n        particle: `hsl(${h}, ${Math.max(s - 20, 20)}%, ${l + 20}%)`,\r\n        // ... 其他颜色\r\n    };\r\n};\r\n\r\n// 主题切换响应模式\r\nuseEffect(() =\u003e {\r\n    const colors = createThemeColors(currentTheme);\r\n    updateParticleColors(colors);\r\n}, [currentTheme]);\r\n```\r\n\r\n### 响应式粒子布局模式\r\n\r\n```typescript\r\n// 响应式重布局模式\r\nconst handleResize = useCallback(() =\u003e {\r\n    // 清理现有粒子\r\n    particles.forEach(particle =\u003e particle.el.remove());\r\n    \r\n    // 重新初始化\r\n    initializeParticles();\r\n}, []);\r\n\r\nuseEffect(() =\u003e {\r\n    window.addEventListener('resize', handleResize);\r\n    return () =\u003e window.removeEventListener('resize', handleResize);\r\n}, []);\r\n```\r\n\r\n### 性能优化的最佳实践\r\n\r\n1. **使用requestAnimationFrame而不是定时器**\r\n2. **用transform代替直接修改位置属性**\r\n3. **合理使用willChange提示**\r\n4. **及时清理DOM元素和事件监听器**\r\n5. **避免频繁的DOM查询，使用引用缓存**\r\n6. **在适当的时候使用防抖和节流**\r\n\r\n## 完整源码全解析\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport React, { useEffect, useRef, useCallback } from 'react';\r\nimport { useThemeStore } from '@/lib/stores/themeStore';\r\n\r\n// ==================== 类型定义 ====================\r\n/**\r\n * 粒子数据结构\r\n * 每个粒子都是一个独立的物理实体\r\n */\r\ninterface Particle {\r\n  el: HTMLDivElement;  // DOM元素引用，避免频繁查询\r\n  x: number;           // 当前X坐标（精确到小数）\r\n  y: number;           // 当前Y坐标（精确到小数）\r\n  vx: number;          // X方向速度\r\n  vy: number;          // Y方向速度\r\n  size: number;        // 粒子基础大小\r\n  depth: number;       // 深度层次(0-1)，影响大小、透明度、速度\r\n}\r\n\r\n/**\r\n * 鼠标/触摸状态\r\n * 用于交互力场计算\r\n */\r\ninterface MouseState {\r\n  x: number;      // 鼠标X坐标\r\n  y: number;      // 鼠标Y坐标\r\n  down: boolean;  // 是否按下状态\r\n}\r\n\r\nconst FoamBackground: React.FC = () =\u003e {\r\n  // ==================== 引用定义 ====================\r\n  const containerRef = useRef\u003cHTMLDivElement\u003e(null);        // 容器DOM引用\r\n  const particlesRef = useRef\u003cParticle[]\u003e([]);              // 粒子数组引用\r\n  const mouseRef = useRef\u003cMouseState\u003e({ x: 0, y: 0, down: false }); // 鼠标状态引用\r\n  const animationIdRef = useRef\u003cnumber | null\u003e(null);       // 动画ID引用，用于取消动画\r\n  const { currentTheme } = useThemeStore();                 // 主题状态\r\n\r\n  // ==================== 配置常量 ====================\r\n  const NUM_PARTICLES = 300;  // 粒子总数，平衡视觉效果与性能\r\n\r\n  // ==================== 工具函数 ====================\r\n  /**\r\n   * 防抖工具函数\r\n   * 用于优化resize事件处理，避免频繁重建粒子\r\n   * @param func 要防抖的函数\r\n   * @param wait 防抖延迟时间（毫秒）\r\n   */\r\n  const debounce = useCallback((func: Function, wait: number) =\u003e {\r\n    let timeout: NodeJS.Timeout;\r\n    return function executedFunction(...args: any[]) {\r\n      const later = () =\u003e {\r\n        clearTimeout(timeout);\r\n        func(...args);\r\n      };\r\n      clearTimeout(timeout);\r\n      timeout = setTimeout(later, wait);\r\n    };\r\n  }, []);\r\n\r\n  /**\r\n   * 十六进制颜色转HSL颜色空间\r\n   * HSL更适合生成相近的色彩变化\r\n   * @param hex 十六进制颜色值（如 \"#ff6600\"）\r\n   * @returns [色相, 饱和度, 明度] 数组\r\n   */\r\n  const hexToHsl = useCallback((hex: string) =\u003e {\r\n    // 将16进制转换为RGB（0-1范围）\r\n    const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n    const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n    const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n\r\n    // 计算最大值和最小值\r\n    const max = Math.max(r, g, b);\r\n    const min = Math.min(r, g, b);\r\n    let h = 0, s = 0, l = (max + min) / 2;  // 明度是最大值和最小值的平均\r\n\r\n    if (max !== min) {\r\n      const d = max - min;\r\n      // 根据明度计算饱和度\r\n      s = l \u003e 0.5 ? d / (2 - max - min) : d / (max + min);\r\n      \r\n      // 根据主导颜色计算色相\r\n      switch (max) {\r\n        case r: h = (g - b) / d + (g \u003c b ? 6 : 0); break;  // 红色主导\r\n        case g: h = (b - r) / d + 2; break;                // 绿色主导\r\n        case b: h = (r - g) / d + 4; break;                // 蓝色主导\r\n      }\r\n      h /= 6;  // 转换为0-1范围\r\n    }\r\n\r\n    // 返回标准HSL格式\r\n    return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];\r\n  }, []);\r\n\r\n  /**\r\n   * 根据当前主题生成动态颜色\r\n   * 深色主题使用更深、更饱和的颜色\r\n   * 浅色主题使用更亮、更柔和的颜色\r\n   */\r\n  const getThemeColors = useCallback(() =\u003e {\r\n    const [primaryH, primaryS] = hexToHsl(currentTheme.colors.primary);\r\n    const [accentH, accentS] = hexToHsl(currentTheme.colors.accent);\r\n    \r\n    const isDark = currentTheme.id === 'dark';\r\n    \r\n    if (isDark) {\r\n      // 深色主题：增加饱和度，降低明度\r\n      return {\r\n        background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS + 10, 40)}%, 25%), hsl(${accentH}, ${Math.max(accentS + 5, 35)}%, 20%))`,\r\n        particle: `hsl(${primaryH}, ${Math.max(primaryS + 15, 50)}%, 45%)`\r\n      };\r\n    } else {\r\n      // 浅色主题：降低饱和度，提高明度\r\n      return {\r\n        background: `linear-gradient(135deg, hsl(${primaryH}, ${Math.max(primaryS - 20, 20)}%, 60%), hsl(${accentH}, ${Math.max(accentS - 10, 30)}%, 50%))`,\r\n        particle: `hsl(${primaryH}, ${Math.max(primaryS - 10, 35)}%, 75%)`\r\n      };\r\n    }\r\n  }, [currentTheme, hexToHsl]);\r\n\r\n  // ==================== 鼠标和触摸事件处理 ====================\r\n  /**\r\n   * 更新鼠标位置\r\n   * 兼容鼠标事件和触摸事件\r\n   */\r\n  const updateMousePos = useCallback((e: MouseEvent | Touch) =\u003e {\r\n    mouseRef.current.x = e.clientX;\r\n    mouseRef.current.y = e.clientY;\r\n  }, []);\r\n\r\n  /**\r\n   * 鼠标按下事件处理\r\n   * 激活交互力场\r\n   */\r\n  const handleMouseDown = useCallback((e: MouseEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e);\r\n  }, [updateMousePos]);\r\n\r\n  /**\r\n   * 鼠标释放事件处理\r\n   * 关闭交互力场\r\n   */\r\n  const handleMouseUp = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n  }, []);\r\n\r\n  /**\r\n   * 鼠标移动事件处理\r\n   * 只有在按下状态才更新位置，减少不必要的计算\r\n   */\r\n  const handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e);\r\n  }, [updateMousePos]);\r\n\r\n  /**\r\n   * 触摸开始事件处理\r\n   * 移动设备的交互支持\r\n   */\r\n  const handleTouchStart = useCallback((e: TouchEvent) =\u003e {\r\n    mouseRef.current.down = true;\r\n    updateMousePos(e.touches[0]);  // 只取第一个触摸点\r\n  }, [updateMousePos]);\r\n\r\n  /**\r\n   * 触摸结束事件处理\r\n   */\r\n  const handleTouchEnd = useCallback(() =\u003e {\r\n    mouseRef.current.down = false;\r\n  }, []);\r\n\r\n  /**\r\n   * 触摸移动事件处理\r\n   */\r\n  const handleTouchMove = useCallback((e: TouchEvent) =\u003e {\r\n    if (mouseRef.current.down) updateMousePos(e.touches[0]);\r\n  }, [updateMousePos]);\r\n\r\n  // ==================== 粒子系统核心 ====================\r\n  /**\r\n   * 初始化粒子系统\r\n   * 创建指定数量的粒子并分布在屏幕上\r\n   */\r\n  const initializeParticles = useCallback(() =\u003e {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    // 清理现有粒子，防止内存泄漏\r\n    particlesRef.current.forEach(p =\u003e p.el.remove());\r\n    particlesRef.current = [];\r\n\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n    const colors = getThemeColors();\r\n\r\n    // 创建指定数量的粒子\r\n    for (let i = 0; i \u003c NUM_PARTICLES; i++) {\r\n      // 创建DOM元素\r\n      const el = document.createElement('div');\r\n      el.style.position = 'absolute';           // 绝对定位，脱离文档流\r\n      el.style.borderRadius = '50%';            // 圆形粒子\r\n      el.style.backgroundColor = colors.particle; // 主题色\r\n      el.style.pointerEvents = 'none';          // 不响应鼠标事件\r\n      el.style.willChange = 'transform, opacity'; // 提示浏览器优化\r\n      \r\n      container.appendChild(el);\r\n\r\n      // 随机大小（2-6px）\r\n      const size = 2 + Math.random() * 4;\r\n      el.style.width = `${size}px`;\r\n      el.style.height = `${size}px`;\r\n\r\n      // 随机深度和位置\r\n      const depth = Math.random();              // 0-1的深度值\r\n      const x = Math.random() * width;          // 随机X位置\r\n      const y = Math.random() * height;         // 随机Y位置\r\n\r\n      // 创建粒子对象\r\n      particlesRef.current.push({\r\n        el,\r\n        x, y,\r\n        vx: 0, vy: 0,    // 初始速度为0\r\n        size, depth\r\n      });\r\n    }\r\n  }, [getThemeColors]);\r\n\r\n  /**\r\n   * 动画循环函数\r\n   * 这是整个粒子系统的心脏，每帧都会调用\r\n   */\r\n  const animate = useCallback(() =\u003e {\r\n    const mouse = mouseRef.current;\r\n    const width = window.innerWidth;\r\n    const height = window.innerHeight;\r\n\r\n    // 遍历所有粒子进行物理更新\r\n    for (let p of particlesRef.current) {\r\n      // ==================== 基础漂移力 ====================\r\n      // 模拟自然的流体运动\r\n      p.vx += 0.01 * p.depth;   // X方向基础漂移\r\n      p.vy += 0.005 * p.depth;  // Y方向基础漂移（略小，模拟重力影响）\r\n\r\n      // ==================== 交互力场计算 ====================\r\n      if (mouse.down) {\r\n        // 计算粒子到鼠标的向量\r\n        const dx = p.x - mouse.x;\r\n        const dy = p.y - mouse.y;\r\n        // 计算距离（欧几里得距离）\r\n        const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        // 在影响范围内施加排斥力\r\n        if (dist \u003c 100) {\r\n          // 反平方力场：距离越近，力越大\r\n          const baseForce = 100 / (dist + 10);  // +10避免除零错误\r\n          const force = baseForce * p.depth;     // 深度影响力的大小\r\n\r\n          // 计算力的方向（单位向量）并应用\r\n          p.vx += force * (dx / dist);  // X方向分力\r\n          p.vy += force * (dy / dist);  // Y方向分力\r\n        }\r\n      }\r\n\r\n      // ==================== 物理系统 ====================\r\n      // 应用摩擦力（空气阻力）\r\n      p.vx *= 0.95;  // X方向摩擦\r\n      p.vy *= 0.95;  // Y方向摩擦\r\n\r\n      // 更新位置\r\n      p.x += p.vx;\r\n      p.y += p.vy;\r\n\r\n      // ==================== 边界处理 ====================\r\n      // 环绕边界：粒子从一边出去，从另一边进来\r\n      if (p.x \u003c -10) p.x = width + 10;    // 左边界 → 右边界\r\n      if (p.x \u003e width + 10) p.x = -10;    // 右边界 → 左边界\r\n      if (p.y \u003c -10) p.y = height + 10;   // 上边界 → 下边界\r\n      if (p.y \u003e height + 10) p.y = -10;   // 下边界 → 上边界\r\n\r\n      // ==================== 视觉效果更新 ====================\r\n      // 基于深度的视觉层次\r\n      const scale = 0.6 + 0.4 * p.depth;    // 缩放：0.6-1.0\r\n      const opacity = 0.4 + 0.6 * p.depth;  // 透明度：0.4-1.0\r\n\r\n      // 应用变换（使用transform优化性能）\r\n      p.el.style.transform = `translate(${p.x}px, ${p.y}px) scale(${scale})`;\r\n      p.el.style.opacity = opacity.toString();\r\n    }\r\n\r\n    // 请求下一帧动画\r\n    animationIdRef.current = requestAnimationFrame(animate);\r\n  }, []);\r\n\r\n  /**\r\n   * 窗口大小改变处理\r\n   * 重新初始化粒子分布\r\n   */\r\n  const handleResize = useCallback(() =\u003e {\r\n    // 重新初始化粒子分布以适应新的窗口尺寸\r\n    initializeParticles();\r\n  }, [initializeParticles]);\r\n\r\n  /**\r\n   * 防抖版本的resize处理器\r\n   * 避免窗口拖拽时频繁重建粒子\r\n   */\r\n  const debouncedHandleResize = useCallback(\r\n    debounce(handleResize, 1000),  // 1秒防抖延迟\r\n    [debounce, handleResize]\r\n  );\r\n\r\n  // ==================== 生命周期管理 ====================\r\n  /**\r\n   * 组件挂载和清理效果\r\n   * 管理事件监听器和动画生命周期\r\n   */\r\n  useEffect(() =\u003e {\r\n    // 初始化粒子\r\n    initializeParticles();\r\n\r\n    // ==================== 事件监听器注册 ====================\r\n    // 全局鼠标事件（确保拖拽时即使离开容器也能继续）\r\n    document.addEventListener('mousedown', handleMouseDown);\r\n    document.addEventListener('mouseup', handleMouseUp);\r\n    document.addEventListener('mousemove', handleMouseMove);\r\n    \r\n    // 容器触摸事件（移动设备支持）\r\n    const container = containerRef.current;\r\n    if (container) {\r\n      container.addEventListener('touchstart', handleTouchStart);\r\n      container.addEventListener('touchend', handleTouchEnd);\r\n      container.addEventListener('touchmove', handleTouchMove);\r\n    }\r\n\r\n    // 窗口resize事件\r\n    window.addEventListener('resize', debouncedHandleResize);\r\n\r\n    // 启动动画循环\r\n    animate();\r\n\r\n    // ==================== 清理函数 ====================\r\n    return () =\u003e {\r\n      // 移除事件监听器\r\n      document.removeEventListener('mousedown', handleMouseDown);\r\n      document.removeEventListener('mouseup', handleMouseUp);\r\n      document.removeEventListener('mousemove', handleMouseMove);\r\n      \r\n      if (container) {\r\n        container.removeEventListener('touchstart', handleTouchStart);\r\n        container.removeEventListener('touchend', handleTouchEnd);\r\n        container.removeEventListener('touchmove', handleTouchMove);\r\n      }\r\n\r\n      window.removeEventListener('resize', debouncedHandleResize);\r\n\r\n      // 取消动画循环\r\n      if (animationIdRef.current !== null) {\r\n        cancelAnimationFrame(animationIdRef.current);\r\n      }\r\n\r\n      // 清理所有粒子DOM元素\r\n      particlesRef.current.forEach(p =\u003e p.el.remove());\r\n    };\r\n  }, [animate, handleMouseDown, handleMouseUp, handleMouseMove, handleTouchStart, handleTouchEnd, handleTouchMove, debouncedHandleResize, initializeParticles]);\r\n\r\n  /**\r\n   * 主题变化响应\r\n   * 当主题切换时，动态更新所有粒子的颜色\r\n   */\r\n  useEffect(() =\u003e {\r\n    if (particlesRef.current.length \u003e 0) {\r\n      const colors = getThemeColors();\r\n      \r\n      // 更新所有粒子的颜色\r\n      particlesRef.current.forEach(p =\u003e {\r\n        p.el.style.backgroundColor = colors.particle;\r\n      });\r\n      \r\n      // 更新容器背景渐变\r\n      if (containerRef.current) {\r\n        containerRef.current.style.background = colors.background;\r\n      }\r\n    }\r\n  }, [currentTheme, getThemeColors]);\r\n\r\n  // ==================== 渲染 ====================\r\n  const colors = getThemeColors();\r\n\r\n  return (\r\n    \u003cdiv\r\n      ref={containerRef}\r\n      className=\"fixed inset-0 w-full h-full overflow-hidden pointer-events-none z-0\"\r\n      style={{\r\n        background: colors.background,\r\n      }}\r\n    /\u003e\r\n  );\r\n};\r\n\r\nexport default FoamBackground;\r\n```\r\n\r\n### 核心算法流程图\r\n\r\n```\r\n粒子初始化 → 动画循环启动 → 每帧物理更新 → 视觉效果应用 → 下一帧\r\n     ↓             ↓             ↓             ↓          ↓\r\n  创建300个       requestAF     基础漂移力      缩放/透明度   循环继续\r\n  随机分布粒子     调用animate   交互力场计算    depth加权     60fps\r\n     ↓             ↓             ↓             ↓          ↓\r\n  DOM元素创建      鼠标状态检测   摩擦力应用      transform     性能优化\r\n  样式设置        距离计算       位置更新        更新DOM      事件清理\r\n```\r\n\r\n### 关键算法解析\r\n\r\n**1. 力场物理计算**\r\n```typescript\r\n// 关键：反平方力场 + 深度加权\r\nconst dx = p.x - mouse.x;                    // 计算X方向距离\r\nconst dy = p.y - mouse.y;                    // 计算Y方向距离\r\nconst dist = Math.sqrt(dx * dx + dy * dy);   // 欧几里得距离\r\nconst baseForce = 100 / (dist + 10);         // 反平方衰减\r\nconst force = baseForce * p.depth;           // 深度影响力大小\r\np.vx += force * (dx / dist);                 // 应用单位向量力\r\n```\r\n\r\n**2. HSL颜色空间转换**\r\n```typescript\r\n// 关键：RGB到HSL的数学变换\r\nconst max = Math.max(r, g, b);              // 找到最大值\r\nconst min = Math.min(r, g, b);              // 找到最小值\r\nlet l = (max + min) / 2;                    // 明度：最大最小值平均\r\nlet s = l \u003e 0.5 ? d / (2 - max - min) : d / (max + min); // 饱和度计算\r\n// 色相根据主导颜色计算\r\n```\r\n\r\n**3. 深度视觉效果**\r\n```typescript\r\n// 关键：线性插值创建层次感\r\nconst scale = 0.6 + 0.4 * p.depth;         // 缩放：0.6-1.0\r\nconst opacity = 0.4 + 0.6 * p.depth;       // 透明度：0.4-1.0\r\np.vx += 0.01 * p.depth;                     // 速度：深度越大越快\r\nconst force = baseForce * p.depth;          // 交互：深度越大反应越强\r\n```\r\n\r\n**4. 边界环绕算法**\r\n```typescript\r\n// 关键：平滑的边界过渡\r\nif (p.x \u003c -10) p.x = width + 10;           // 左出右进，10px缓冲\r\nif (p.x \u003e width + 10) p.x = -10;           // 右出左进\r\nif (p.y \u003c -10) p.y = height + 10;          // 上出下进\r\nif (p.y \u003e height + 10) p.y = -10;          // 下出上进\r\n```\r\n\r\n**5. 防抖优化机制**\r\n```typescript\r\n// 关键：延迟执行 + 重复取消\r\nconst debounce = (func: Function, wait: number) =\u003e {\r\n    let timeout: NodeJS.Timeout;\r\n    return (...args: any[]) =\u003e {\r\n        clearTimeout(timeout);               // 取消之前的定时器\r\n        timeout = setTimeout(() =\u003e func(...args), wait); // 重新计时\r\n    };\r\n};\r\n```\r\n\r\n## 实现回顾\r\n\r\n通过这次深入的技术剖析，我们看到了一个看似简单的\"泡沫背景\"背后隐藏的复杂世界。从Canvas思维到DOM实现的转换，从物理模拟到视觉效果，从性能优化到边界处理，每一个环节都需要精心设计和仔细调试。\r\n\r\n选择DOM而不是Canvas可能看起来像是\"用大炮打蚊子\"，但这种选择带来了更好的可访问性、更容易的主题集成，以及更直观的事件处理。有时候，看起来\"笨\"的方法反而能开辟新的可能性。\r\n\r\n*愿你的粒子如星尘般闪耀，如泡沫般轻盈，在用户的指尖下翩翩起舞。* ✨\r\n"])</script><script>self.__next_f.push([1,"3c:Tc271,"])</script><script>self.__next_f.push([1,"\r\n# 3D案例卡片：从平面到立体的交互革命\r\n\r\n总得给用烂了的卡片内容展示加点画蛇添足的东西~~（不是）~~（不，就是！欧耶！）\r\n\r\n这个3D卡片系统集成了复杂的空间布局算法、物理模拟的鼠标跟踪、精细的状态管理，以及让人觉得眼前一亮的动画效果。在这篇文章中，我将从最基础的类型定义开始，逐步深入每一个实现细节，全面剖析这个3D卡片的立体交互系统。\r\n\r\n## 组件结构与类型定义\r\n\r\n任何复杂的交互系统都需要从严谨的类型定义开始，我们的3D卡片也不例外。让我们先看看这些看似简单的接口背后隐藏着些什么。\r\n\r\n### 数据模型设计\r\n\r\n```typescript\r\ninterface WorkItem {\r\n    id: string;\r\n    title: string;\r\n    description: string;\r\n    tags: string[];\r\n    image?: string;\r\n    accessUrl?: string;\r\n    githubUrl?: string;\r\n    accessible?: boolean;\r\n    tool?: boolean;\r\n}\r\n```\r\n\r\n字段解释：\r\n\r\n- **id**: 唯一标识符，在React的列表渲染中作为key使用，避免不必要的重渲染。（React的警告蠢蠢欲动）\r\n- **title \u0026 description**: 基础的展示信息，分别对应卡片正面的标题和描述。\r\n\r\n- **tags**: 技术标签数组，这里有个小心机——我们在正面只显示前3个标签，剩余的在翻转后的背面显示。这样既避免了正面信息过载，又增加了翻转的价值。\r\n- **可选字段们**: `image?`、`accessUrl?`、`githubUrl?`等可选字段让数据结构更加灵活，不是每个项目都有完整的展示信息。\r\n\r\n- **accessible \u0026 tool**: 这两个布尔标志用于在卡片上显示特殊标记，`accessible`表示项目支持无障碍访问，`tool`表示这是一个工具类项目。\r\n\r\n### 组件Props的传递\r\n\r\n```typescript\r\ninterface WorkCard3DProps {\r\n    work: WorkItem;\r\n    mode: 'tiled' | 'folded';\r\n    isActive: boolean;\r\n    index: number;\r\n    total: number;\r\n    activeIndex?: number;\r\n    onInteractionAction: (type: 'hover' | 'click' | 'flip' | 'detail') =\u003e void;\r\n}\r\n```\r\n\r\n这个Props接口是整个组件设计的核心，每个参数都承载着特定的职责：\r\n\r\n- **mode**: 这是最关键的参数，决定了卡片是以网格形式平铺（`tiled`）还是以叠加形式折叠（`folded`）。一个参数的变化决定了两种完全不同的布局逻辑。\r\n- **index \u0026 total**: 位置信息，用于计算卡片在空间中的具体坐标。在平铺模式下用于网格布局，在折叠模式下用于层叠排序。\r\n\r\n- **activeIndex**: 只在折叠模式下有意义，表示当前激活的卡片索引。这个设计让多个卡片可以共享同一个激活状态。\r\n\r\n- **onInteractionAction**: 事件回调的类型化设计。不同的交互类型（hover、click、flip、detail）对应不同的业务逻辑，类型安全确保了事件处理的正确性。\r\n\r\n## 状态管理的立体世界\r\n\r\n3D交互系统的状态管理比2D复杂得多，因为我们需要同时处理空间位置、时间序列和用户交互的多维状态。\r\n\r\n### 状态变量设置\r\n\r\n```typescript\r\nconst [hovered, setHovered] = useState(false);\r\nconst [flipped, setFlipped] = useState(false);\r\nconst [transform, setTransform] = useState('rotateX(0deg) rotateY(0deg)');\r\nconst [autoReturnTimer, setAutoReturnTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\nconst [hasInitialized, setHasInitialized] = useState(false);\r\n```\r\n\r\n状态和生命周期解释：\r\n\r\n- **hovered**: 悬停状态的代理者。它不仅控制着视觉效果的变化，还影响着鼠标跟踪倾斜功能的启用。在折叠模式下，它还会触发卡片的扇形展开效果。\r\n- **flipped**: 翻转状态的开关。`false`时显示正面，`true`时显示背面。看似简单，但它涉及到CSS 3D变换的复杂协调。\r\n\r\n- **transform**: 动态变换字符串。存储着实时的3D变换参数，主要用于鼠标跟踪倾斜效果。为什么不直接计算？因为我们需要在不同的交互状态间平滑过渡。\r\n\r\n- **autoReturnTimer**: 自动复位定时器。当用户停止交互1.5秒后，卡片会自动回到初始状态，避免卡片样式显示异常，例如交互完后卡片显示出一种\"被玩坏了\"的异常倾斜状态。\r\n- **hasInitialized**: 初始化标记。用于控制入场动画的触发时机，确保卡片以优雅的方式出现，而不是突然\"蹦\"出来。\r\n\r\n### 状态机的转换逻辑\r\n\r\n这些状态之间构成了一个复杂的状态机：\r\n\r\n```\r\n初始状态 → 已初始化 → 悬停状态 ↔ 倾斜状态\r\n   ↓                            ↓\r\n入场动画 → 呼吸动画 → 悬停动画 → 翻转状态\r\n```\r\n\r\n关键的状态转换：\r\n- **初始化触发**: 基于`index * 150ms`的延迟，实现错落有致的入场效果\r\n- **悬停触发**: 鼠标进入时启用倾斜跟踪，离开时启动自动复位定时器\r\n- **翻转触发**: 点击事件触发，与其他状态相互独立\r\n- **定时器管理**: 多个交互事件会清除和重置定时器，确保行为的一致性\r\n\r\n## 折叠与平铺：两种空间的数学诗篇\r\n\r\n这是整个系统中最关键的部分——如何用数学公式描述卡片在3D空间中的位置和状态。\r\n\r\n### 位置计算的核心算法\r\n\r\n```typescript\r\nconst getCardPosition = (): { x: number, y: number, z: number, opacity: number, scale: number } =\u003e {\r\n    if (mode === 'folded') {\r\n        const isActiveCard = index === activeIndex;\r\n        const relativeIndex = index - activeIndex;\r\n\r\n        if (isActiveCard) {\r\n            return {x: 0, y: 0, z: 0, opacity: 1, scale: 1};\r\n        } else if (Math.abs(relativeIndex) \u003c= 2) {\r\n            const horizontalOffset = relativeIndex * 2;\r\n            const verticalOffset = -Math.abs(relativeIndex) * 8;\r\n            const depth = -Math.abs(relativeIndex) * 15;\r\n            const scale = 1 - Math.abs(relativeIndex) * 0.03;\r\n            return {\r\n                x: horizontalOffset,\r\n                y: verticalOffset,\r\n                z: depth,\r\n                opacity: 1 - Math.abs(relativeIndex) * 0.15,\r\n                scale\r\n            };\r\n        } else {\r\n            const side = relativeIndex \u003e 0 ? 1 : -1;\r\n            return {\r\n                x: side * 200,\r\n                y: 0,\r\n                z: -100,\r\n                opacity: 0,\r\n                scale: 0.8\r\n            };\r\n        }\r\n    } else {\r\n        // 平铺模式的网格计算\r\n        const cols = Math.ceil(Math.sqrt(total));\r\n        const row = Math.floor(index / cols);\r\n        const col = index % cols;\r\n        const widthSpacing = 320;\r\n        const heightSpacing = 440;\r\n        return {\r\n            x: (col - (cols - 1) / 2) * widthSpacing,\r\n            y: (row - Math.floor((total - 1) / cols) / 2) * heightSpacing,\r\n            z: 0,\r\n            opacity: 1,\r\n            scale: 1\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n### 折叠模式的层叠美学\r\n\r\n在折叠模式下，卡片的位置基于`relativeIndex = index - activeIndex`计算，这个相对索引是整个算法的核心：\r\n\r\n**激活卡片** (`relativeIndex === 0`):\r\n- 位置：`(0, 0, 0)` - 正中心，最前方\r\n- 状态：完全可见，原始大小\r\n\r\n**相邻卡片** (`Math.abs(relativeIndex) \u003c= 2`):\r\n- **水平偏移**: `relativeIndex * 2` - 正负2像素的轻微错位，营造层叠感\r\n- **垂直偏移**: `-Math.abs(relativeIndex) * 8` - 向上偏移，模拟卡片厚度\r\n- **深度**: `-Math.abs(relativeIndex) * 15` - 向后推移，增强立体感\r\n- **缩放**: `1 - Math.abs(relativeIndex) * 0.03` - 轻微缩小，远小近大\r\n- **透明度**: `1 - Math.abs(relativeIndex) * 0.15` - 渐变透明，层次分明\r\n\r\n（调这些数值老费劲了）\r\n\r\n**远距离卡片** (`Math.abs(relativeIndex) \u003e 2`):\r\n- 完全隐藏在侧边，透明度为0\r\n- 这个优化避免了渲染过多不可见的卡片\r\n\r\n### 平铺模式的网格几何\r\n\r\n平铺模式使用了经典的网格布局算法：\r\n\r\n```typescript\r\nconst cols = Math.ceil(Math.sqrt(total));  // 计算列数\r\nconst row = Math.floor(index / cols);      // 计算行号\r\nconst col = index % cols;                  // 计算列号\r\n```\r\n\r\n**为什么用平方根**？这个算法会创建一个接近正方形的网格，比如9个卡片会排成3×3，10个卡片会排成4×3，视觉上最为平衡。\r\n\r\n**居中对齐的数学**：\r\n```typescript\r\nx: (col - (cols - 1) / 2) * widthSpacing\r\ny: (row - Math.floor((total - 1) / cols) / 2) * heightSpacing\r\n```\r\n\r\n这个公式让整个网格以屏幕中心为基准点，无论有多少卡片都能保持居中对齐。\r\n\r\n## 鼠标跟踪倾斜：从冰冷的公式到富含活力的反馈\r\n\r\n卡片：看我看我！（敲可爱！）\r\n\r\n### 坐标转换的数学基础\r\n\r\n```typescript\r\nconst handleMouseMove = (e: React.MouseEvent\u003cHTMLDivElement\u003e) =\u003e {\r\n    if (!cardRef.current || !hovered || mode === 'folded') return;\r\n\r\n    const rect = cardRef.current.getBoundingClientRect();\r\n    const centerX = rect.left + rect.width / 2;\r\n    const centerY = rect.top + rect.height / 2;\r\n\r\n    // 计算相对于中心的偏移量（-0.5 到 0.5）\r\n    const offsetX = (e.clientX - centerX) / rect.width;\r\n    const offsetY = (e.clientY - centerY) / rect.height;\r\n\r\n    // 转换为旋转角度（-15° 到 +15°）\r\n    const rotateX = -offsetY * 15;\r\n    const rotateY = offsetX * 15;\r\n\r\n    setTransform(`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\r\n};\r\n```\r\n\r\n坐标转换过程详细解释：\r\n\r\n### 第一步：获取精确位置\r\n\r\n```typescript\r\nconst rect = cardRef.current.getBoundingClientRect();\r\nconst centerX = rect.left + rect.width / 2;\r\nconst centerY = rect.top + rect.height / 2;\r\n```\r\n\r\n`getBoundingClientRect()`返回元素相对于视口的精确位置和尺寸。我们计算出卡片的几何中心点，这是所有旋转的基准。\r\n\r\n### 第二步：归一化处理\r\n\r\n```typescript\r\nconst offsetX = (e.clientX - centerX) / rect.width;\r\nconst offsetY = (e.clientY - centerY) / rect.height;\r\n```\r\n\r\n这个归一化过程有多个条件生效场景：\r\n- 鼠标在卡片中心时：`offsetX = 0, offsetY = 0`\r\n- 鼠标在卡片右边缘时：`offsetX = 0.5`\r\n- 鼠标在卡片左边缘时：`offsetX = -0.5`\r\n\r\n除以宽度和高度确保了旋转效果与卡片尺寸无关，大卡片和小卡片的倾斜幅度保持一致。\r\n\r\n### 第三步：角度映射\r\n\r\n```typescript\r\nconst rotateX = -offsetY * 15;  // Y轴取反\r\nconst rotateY = offsetX * 15;\r\n```\r\n\r\n**为什么Y轴要取反**？\r\n\r\n- 鼠标在上方时，我们希望卡片向上倾斜（正rotateX）\r\n- 但`offsetY`在上方时是负值\r\n- 所以需要取反：`-offsetY`\r\n\r\n从个人视感（叠甲）上来说15度是一个恰到好处的倾斜值。~~（实际上我就是喜欢这个值，你们说了我也不会改的！）~~\r\n\r\n### 交互禁用的智能判断\r\n\r\n```typescript\r\nif (!cardRef.current || !hovered || mode === 'folded') return;\r\n```\r\n\r\n这个条件判断包含了三个重要的边界情况：\r\n1. **!cardRef.current**: 组件未完全挂载\r\n2. **!hovered**: 鼠标未悬停，避免非预期的倾斜\r\n3. **mode === 'folded'**: 折叠模式下禁用倾斜，避免与层叠效果冲突\r\n\r\n## 悬停与呼吸\r\n\r\n没错，这就是我说的画蛇添足的东西（雾）\r\n\r\n### 动态计算动画属性\r\n\r\n```typescript\r\nconst getAnimationProps = () =\u003e {\r\n    if (hovered) {\r\n        return {\r\n            scale: 1.02,\r\n            boxShadow: '0 20px 40px rgba(0, 255, 255, 0.3)'\r\n        };\r\n    } else if (!flipped) {\r\n        // 呼吸效果\r\n        return {\r\n            scale: [1, 1.01, 1],\r\n            boxShadow: [\r\n                '0 10px 20px rgba(0, 0, 0, 0.1)',\r\n                '0 12px 24px rgba(0, 255, 255, 0.08)',\r\n                '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n            ]\r\n        };\r\n    } else {\r\n        return {\r\n            scale: 1,\r\n            boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n### 动画参数解释\r\n\r\n**悬停状态**：\r\n- **scale: 1.02**: 轻微的放大效果，2%的缩放既明显又不会过度\r\n- **boxShadow**: 青色阴影增强科技感，40px的模糊半径营造悬浮感\r\n\r\n**呼吸效果**：\r\n- **scale数组**: `[1, 1.01, 1]`实现往复缩放\r\n- **阴影变化**: 从暗到亮再到暗，配合缩放增强节奏感\r\n\r\n### 过渡函数\r\n\r\n```typescript\r\nconst getAnimationTransition = () =\u003e {\r\n    if (hovered) {\r\n        return {\r\n            type: \"spring\" as const,\r\n            damping: 20,\r\n            stiffness: 300\r\n        };\r\n    } else if (!flipped) {\r\n        return {\r\n            duration: 4,\r\n            repeat: Infinity,\r\n            ease: \"easeInOut\" as const\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n**弹簧动画**（悬停时）：\r\n- **damping: 20**: 阻尼系数，控制震荡程度\r\n- **stiffness: 300**: 刚度系数，控制响应速度\r\n- 这个组合产生了自然的弹性感，就像真实的物理弹簧\r\n\r\n**呼吸动画**（默认状态）：\r\n- **duration: 4**: 4秒一个周期，慢到几乎察觉不到\r\n- **repeat: Infinity**: 无限循环\r\n- **easeInOut**: 先加速后减速，模拟自然呼吸\r\n\r\n## 计时器系统：时间的艺术管理\r\n\r\n实话说，用户交互的时间控制是最需要仔细调试的一部分，要确保交互的连贯性和合理性也许需要精调很久。\r\n\r\n### 自动复位的生命周期\r\n\r\n```typescript\r\nconst handleMouseEnter = () =\u003e {\r\n    setHovered(true);\r\n    onInteractionAction('hover');\r\n\r\n    // 清除自动复位定时器\r\n    if (autoReturnTimer) {\r\n        clearTimeout(autoReturnTimer);\r\n        setAutoReturnTimer(null);\r\n    }\r\n};\r\n\r\nconst handleMouseLeave = () =\u003e {\r\n    setHovered(false);\r\n\r\n    // 启动自动复位定时器\r\n    const timer = setTimeout(() =\u003e {\r\n        setTransform('rotateX(0deg) rotateY(0deg)');\r\n        setFlipped(false);\r\n    }, 1500);\r\n\r\n    setAutoReturnTimer(timer);\r\n\r\n    // 立即重置变换\r\n    setTransform('rotateX(0deg) rotateY(0deg)');\r\n};\r\n```\r\n\r\n### 定时器管理解释\r\n\r\n**鼠标进入时**：\r\n- 立即清除现有定时器，防止意外的状态重置\r\n- 设置悬停状态，启用交互效果\r\n\r\n**鼠标离开时**：\r\n- 立即重置变换，确保视觉上的快速响应\r\n- 启动1500ms定时器，准备深度重置\r\n\r\n**为什么需要两次重置**？\r\n- **立即重置**: 快速移除倾斜效果，避免卡片出现异常的倾斜样式\r\n- **延迟重置**: 重置翻转状态，给用户足够时间查看背面内容\r\n\r\n### 内存泄漏防护\r\n\r\n```typescript\r\n// 在组件卸载时清理定时器\r\nuseEffect(() =\u003e {\r\n    return () =\u003e {\r\n        if (autoReturnTimer) {\r\n            clearTimeout(autoReturnTimer);\r\n        }\r\n    };\r\n}, [autoReturnTimer]);\r\n```\r\n\r\n这个cleanup函数确保组件卸载时不会留下\"孤儿\"定时器，避免内存泄漏和异常状态更新。\r\n\r\n## 翻转效果：3D变换的魔法\r\n\r\n卡片翻转涉及到了CSS 3D变换的核心原理。\r\n\r\n### CSS 3D变换的核心设置\r\n\r\n```typescript\r\nconst cardContainerStyle: React.CSSProperties = {\r\n    transformStyle: 'preserve-3d',\r\n    transform: flipped ? 'rotateY(180deg)' : transform,\r\n    transition: flipped ? 'transform 0.6s ease' : 'transform 0.4s ease-out',\r\n};\r\n\r\nconst cardFaceStyle: React.CSSProperties = {\r\n    backfaceVisibility: 'hidden',\r\n};\r\n\r\nconst cardBackStyle: React.CSSProperties = {\r\n    ...cardFaceStyle,\r\n    transform: 'rotateY(180deg)',\r\n};\r\n```\r\n\r\n### 3D变换的关键属性解析\r\n\r\n**transformStyle: 'preserve-3d'**：\r\n这是3D效果的基础，告诉浏览器保持子元素的3D变换关系。没有这个属性，所有的3D效果都会被\"压平\"成2D。\r\n\r\n**backfaceVisibility: 'hidden'**：\r\n隐藏元素的背面，确保翻转时不会看到\"透视\"效果。想象一下，如果你可以同时看到卡片的正面和背面~~，那证明你是一个四维生物~~，那会让正面和反面的内容互相重叠，最终导致卡片内容的可读性大幅度降低。\r\n\r\n**背面的预旋转**：\r\n\r\n```typescript\r\ntransform: 'rotateY(180deg)'\r\n```\r\n背面内容预先旋转180度，这样当容器旋转180度时，背面内容会以正确的方向显示。\r\n\r\n### 翻转动画\r\n\r\n```typescript\r\ntransition: flipped ? 'transform 0.6s ease' : 'transform 0.4s ease-out'\r\n```\r\n\r\n一般来说，当用户从反面翻回正面时，他已经阅读过整个卡片的正反面内容了，所以动画可以稍快一些。\r\n\r\n缓动函数解释：\r\n- **ease**: 翻转时的标准缓动，自然流畅\r\n- **ease-out**: 倾斜时的快速响应，然后慢慢停止\r\n\r\n## 入场动画：优雅登场的时间艺术\r\n\r\n入场动画是用户第一印象的关键，我得想个法子让卡片\"优雅地出现\"而不是\"突然蹦出来\"。\r\n\r\n### 初始化延迟\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    const timer = setTimeout(() =\u003e {\r\n        setHasInitialized(true);\r\n    }, index * 150);\r\n\r\n    return () =\u003e clearTimeout(timer);\r\n}, [index]);\r\n```\r\n\r\n这个`index * 150ms`的延迟设计创造了\"波浪式\"的入场效果：\r\n- 第0张卡片：立即开始动画\r\n- 第1张卡片：150ms后开始\r\n- 第2张卡片：300ms后开始\r\n- 依此类推...\r\n\r\n结果就是卡片们像多米诺骨牌一样依次优雅登场。\r\n\r\n### 入场动画的关键帧设计\r\n\r\n```typescript\r\ninitial={{ \r\n    opacity: 0, \r\n    scale: 0.8,\r\n    y: 50,\r\n    rotateX: -15\r\n}}\r\nanimate={hasInitialized ? { \r\n    opacity: 1,\r\n    y: 0,\r\n    rotateX: 0,\r\n    ...getAnimationProps()\r\n} : {\r\n    opacity: 0,\r\n    scale: 0.8,\r\n    y: 50,\r\n    rotateX: -15\r\n}}\r\n```\r\n\r\n**初始状态的设计思路**：\r\n\r\n- **opacity: 0**: 完全透明，初始不可见\r\n- **scale: 0.8**: 80%大小，从小到大\r\n- **y: 50**: 向下偏移50px，从下方飞入\r\n- **rotateX: -15**: 向前倾斜15度，增加立体感\r\n\r\n**目标状态**：\r\n- 所有属性回到正常值，同时开始呼吸动画\r\n\r\n### 呼吸效果的循环实现\r\n\r\n```typescript\r\n// 在getAnimationProps中\r\nscale: [1, 1.01, 1],\r\nboxShadow: [\r\n    '0 10px 20px rgba(0, 0, 0, 0.1)',\r\n    '0 12px 24px rgba(0, 255, 255, 0.08)',\r\n    '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n]\r\n```\r\n\r\n**数组动画**：\r\n\r\n- framer-motion会自动在数组元素间创建循环动画\r\n- `[1, 1.01, 1]`表示：正常→轻微放大→正常\r\n- 阴影的变化配合缩放，增强节奏感\r\n\r\n### 动画配置\r\n\r\n```typescript\r\ntransition={hasInitialized ? {\r\n    opacity: { duration: 0.6, ease: \"easeOut\" },\r\n    y: { duration: 0.8, ease: \"easeOut\" },\r\n    rotateX: { duration: 0.8, ease: \"easeOut\" }\r\n} : {\r\n    duration: 0.6,\r\n    ease: \"easeOut\"\r\n}}\r\n```\r\n\r\n**分别控制各属性的动画时间**：\r\n- **opacity**: 0.6s，快速显现\r\n- **y \u0026 rotateX**: 0.8s，稍慢的位置变化\r\n- **easeOut**: 快速开始，缓慢结束\r\n\r\n## 样式设计：现代感的视觉语言\r\n\r\n最后，我们可以探讨一下这套3D卡片的视觉设计哲学。\r\n\r\n### 渐变与透明度的层次感\r\n\r\n```typescript\r\nclassName=\"bg-gradient-to-br from-background/90 to-surface/90 backdrop-blur-sm border border-primary/20 shadow-xl\"\r\n```\r\n\r\n**渐变设计**：\r\n- `from-background/90 to-surface/90`: 从背景色到表面色的渐变，90%透明度\r\n- `bg-gradient-to-br`: 从左上到右下的对角渐变，增加立体感\r\n\r\n**模糊与边框**：\r\n- `backdrop-blur-sm`: 背景模糊效果，现代感的毛玻璃质感\r\n- `border-primary/20`: 主题色的淡边框，20%透明度恰到好处\r\n\r\n### 色彩系统的主题适配\r\n\r\n```typescript\r\n// 正面：主题色系\r\nclassName=\"bg-gradient-to-br from-background/90 to-surface/90\"\r\n\r\n// 背面：强调色系\r\nclassName=\"bg-gradient-to-br from-secondary/90 to-accent/90\"\r\n```\r\n\r\n### 阴影与光照的物理模拟\r\n\r\n```typescript\r\nboxShadow: '0 20px 40px rgba(0, 255, 255, 0.3)'\r\n```\r\n\r\n**阴影参数解析**：\r\n- **Y偏移 20px**: 光源在上方，符合现实世界的光照习惯\r\n- **模糊半径 40px**: 大范围的柔和阴影，营造悬浮感\r\n- **青色 + 30%透明度**: 科技感的色彩选择，呼应主题\r\n\r\n## 设计模式的提炼与总结\r\n\r\n通过这次深入的技术解析，我们可以提取出几个可复用的设计模式：\r\n\r\n### 3D交互组件的通用架构\r\n\r\n```typescript\r\n// 1. 严格的类型定义\r\ninterface ComponentProps {\r\n    mode: 'mode1' | 'mode2';\r\n    data: DataType;\r\n    onInteraction: (type: InteractionType) =\u003e void;\r\n}\r\n\r\n// 2. 状态管理模式\r\nconst [visualState, setVisualState] = useState(initialState);\r\nconst [interactionTimer, setInteractionTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\n\r\n// 3. 位置计算函数\r\nconst calculatePosition = (mode: Mode, index: number, total: number) =\u003e {\r\n    // 基于模式的位置算法\r\n};\r\n```\r\n\r\n### 鼠标跟踪倾斜的通用实现\r\n\r\n```typescript\r\nconst useMouseTracking = (ref: RefObject\u003cHTMLElement\u003e, enabled: boolean) =\u003e {\r\n    const handleMouseMove = useCallback((e: MouseEvent) =\u003e {\r\n        if (!ref.current || !enabled) return;\r\n        \r\n        const rect = ref.current.getBoundingClientRect();\r\n        const centerX = rect.left + rect.width / 2;\r\n        const centerY = rect.top + rect.height / 2;\r\n        \r\n        const offsetX = (e.clientX - centerX) / rect.width;\r\n        const offsetY = (e.clientY - centerY) / rect.height;\r\n        \r\n        const rotateX = -offsetY * maxRotation;\r\n        const rotateY = offsetX * maxRotation;\r\n        \r\n        return `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\r\n    }, [enabled, maxRotation]);\r\n    \r\n    return { handleMouseMove };\r\n};\r\n```\r\n\r\n### 自动复位定时器的管理模式\r\n\r\n```typescript\r\nconst useAutoReset = (resetAction: () =\u003e void, delay: number = 1500) =\u003e {\r\n    const [timer, setTimer] = useState\u003cNodeJS.Timeout | null\u003e(null);\r\n    \r\n    const startTimer = useCallback(() =\u003e {\r\n        if (timer) clearTimeout(timer);\r\n        const newTimer = setTimeout(resetAction, delay);\r\n        setTimer(newTimer);\r\n    }, [timer, resetAction, delay]);\r\n    \r\n    const clearTimer = useCallback(() =\u003e {\r\n        if (timer) {\r\n            clearTimeout(timer);\r\n            setTimer(null);\r\n        }\r\n    }, [timer]);\r\n    \r\n    return { startTimer, clearTimer };\r\n};\r\n```\r\n\r\n### 性能优化的最佳实践\r\n\r\n1. **合理使用willChange**: 只在真正需要GPU加速的元素上使用\r\n2. **避免不必要的重渲染**: 使用useCallback和useMemo优化计算\r\n3. **及时清理资源**: 定时器、事件监听器都要在组件卸载时清理\r\n4. **条件渲染优化**: 远离视口的元素可以考虑不渲染\r\n5. **动画性能**: 优先使用transform和opacity，避免触发重排\r\n\r\n## 完整源码全解析\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport React, {useRef, useState, useEffect} from 'react';\r\nimport {motion} from 'framer-motion';\r\nimport {useTranslation} from '@/lib/hooks/useTranslation';\r\n\r\n// ============================\r\n// 核心类型定义部分\r\n// ============================\r\n\r\n/**\r\n * 工作项目数据结构\r\n * 定义了每个卡片展示的完整信息模型\r\n */\r\ninterface WorkItem {\r\n    id: string;              // 唯一标识符，React key和数据追踪\r\n    title: string;           // 项目标题，显示在卡片正面\r\n    description: string;     // 项目描述，正反面都会使用\r\n    tags: string[];          // 技术标签数组，正面显示前3个，背面显示全部\r\n    image?: string;          // 可选项目预览图\r\n    accessUrl?: string;        // 可选演示链接\r\n    githubUrl?: string;      // 可选GitHub仓库链接\r\n    accessible?: boolean;    // 无障碍访问支持标记\r\n    tool?: boolean;          // 工具类项目标记\r\n}\r\n\r\n/**\r\n * 3D卡片组件属性接口\r\n * 控制卡片的布局模式、状态和交互行为\r\n */\r\ninterface WorkCard3DProps {\r\n    work: WorkItem;                    // 卡片数据源\r\n    mode: 'tiled' | 'folded';         // 布局模式：平铺网格 vs 层叠折叠\r\n    isActive: boolean;                // 当前卡片是否为激活状态\r\n    index: number;                    // 卡片在数组中的索引位置\r\n    total: number;                    // 卡片总数，用于布局计算\r\n    activeIndex?: number;             // 当前激活卡片的索引（折叠模式）\r\n    onInteractionAction: (type: 'hover' | 'click' | 'flip' | 'detail') =\u003e void; // 交互事件回调\r\n}\r\n\r\n// ============================\r\n// 主组件实现\r\n// ============================\r\n\r\nexport function WorkCard3D({\r\n                               work,\r\n                               mode,\r\n                               index,\r\n                               total,\r\n                               activeIndex = 0,\r\n                               onInteractionAction\r\n                           }: WorkCard3DProps) {\r\n    \r\n    // ============================\r\n    // Refs和状态管理\r\n    // ============================\r\n    \r\n    const cardRef = useRef\u003cHTMLDivElement\u003e(null);  // 卡片DOM引用，用于鼠标位置计算\r\n\r\n    // 核心交互状态\r\n    const [hovered, setHovered] = useState(false);           // 鼠标悬停状态\r\n    const [flipped, setFlipped] = useState(false);           // 卡片翻转状态\r\n    const [transform, setTransform] = useState('rotateX(0deg) rotateY(0deg)'); // 3D变换字符串\r\n    const [autoReturnTimer, setAutoReturnTimer] = useState\u003cNodeJS.Timeout | null\u003e(null); // 自动复位定时器\r\n    const [hasInitialized, setHasInitialized] = useState(false); // 初始化动画标记\r\n    \r\n    const { t } = useTranslation();  // 国际化翻译钩子\r\n\r\n    // ============================\r\n    // 初始化和入场动画控制\r\n    // ============================\r\n    \r\n    /**\r\n     * 错落有致的入场动画效果\r\n     * 基于卡片索引创建波浪式的延迟启动\r\n     */\r\n    useEffect(() =\u003e {\r\n        const timer = setTimeout(() =\u003e {\r\n            setHasInitialized(true);\r\n        }, index * 150); // 每张卡片延迟150ms，创造连锁反应效果\r\n\r\n        return () =\u003e clearTimeout(timer);\r\n    }, [index]);\r\n\r\n    // ============================\r\n    // 核心算法：3D空间位置计算系统\r\n    // ============================\r\n    \r\n    /**\r\n     * 根据布局模式计算卡片在3D空间中的精确位置\r\n     * 这是整个系统最核心的算法，决定了卡片的空间布局\r\n     */\r\n    const getCardPosition = (): { x: number, y: number, z: number, opacity: number, scale: number } =\u003e {\r\n        if (mode === 'folded') {\r\n            // ============= 折叠模式：层叠堆栈算法 =============\r\n            const isActiveCard = index === activeIndex;\r\n            const relativeIndex = index - activeIndex; // 相对于激活卡片的索引差\r\n\r\n            if (isActiveCard) {\r\n                // 激活卡片：位于最前方中心位置\r\n                return {x: 0, y: 0, z: 0, opacity: 1, scale: 1};\r\n            } else if (Math.abs(relativeIndex) \u003c= 2) {\r\n                // 相邻卡片：形成可见的层叠效果\r\n                const horizontalOffset = relativeIndex * 2;     // 水平错位：营造厚度感\r\n                const verticalOffset = -Math.abs(relativeIndex) * 8;  // 垂直偏移：模拟卡片厚度\r\n                const depth = -Math.abs(relativeIndex) * 15;          // 深度层次：远近分明\r\n                const scale = 1 - Math.abs(relativeIndex) * 0.03;     // 尺寸递减：透视效果\r\n                \r\n                return {\r\n                    x: horizontalOffset,\r\n                    y: verticalOffset,\r\n                    z: depth,\r\n                    opacity: 1 - Math.abs(relativeIndex) * 0.15,      // 透明度递减\r\n                    scale\r\n                };\r\n            } else {\r\n                // 远距离卡片：隐藏在侧边，优化性能\r\n                const side = relativeIndex \u003e 0 ? 1 : -1;\r\n                return {\r\n                    x: side * 200,  // 左右分散隐藏\r\n                    y: 0,\r\n                    z: -100,        // 推到后方\r\n                    opacity: 0,     // 完全透明\r\n                    scale: 0.8\r\n                };\r\n            }\r\n        } else {\r\n            // ============= 平铺模式：智能网格布局算法 =============\r\n            const cols = Math.ceil(Math.sqrt(total));  // 计算最优列数（接近正方形）\r\n            const row = Math.floor(index / cols);       // 计算行号\r\n            const col = index % cols;                   // 计算列号\r\n            \r\n            // 间距配置\r\n            const widthSpacing = 320;   // 卡片宽度 + 间隙\r\n            const heightSpacing = 440;  // 卡片高度 + 间隙\r\n            \r\n            // 居中对齐的数学计算\r\n            return {\r\n                x: (col - (cols - 1) / 2) * widthSpacing,     // 水平居中\r\n                y: (row - Math.floor((total - 1) / cols) / 2) * heightSpacing, // 垂直居中\r\n                z: 0,           // 平面布局，无深度差异\r\n                opacity: 1,     // 全部可见\r\n                scale: 1        // 统一尺寸\r\n            };\r\n        }\r\n    };\r\n\r\n    // ============================\r\n    // 鼠标跟踪倾斜算法\r\n    // ============================\r\n    \r\n    /**\r\n     * 实时鼠标位置追踪和3D倾斜计算\r\n     * 将2D鼠标坐标转换为3D旋转角度\r\n     */\r\n    const handleMouseMove = (e: React.MouseEvent\u003cHTMLDivElement\u003e) =\u003e {\r\n        // 安全检查：只在特定条件下启用倾斜效果\r\n        if (!cardRef.current || !hovered || mode === 'folded') return;\r\n\r\n        // 获取卡片的精确边界信息\r\n        const rect = cardRef.current.getBoundingClientRect();\r\n        const centerX = rect.left + rect.width / 2;   // 卡片中心X坐标\r\n        const centerY = rect.top + rect.height / 2;   // 卡片中心Y坐标\r\n\r\n        // 计算鼠标相对于卡片中心的偏移量（归一化到-0.5到0.5）\r\n        const offsetX = (e.clientX - centerX) / rect.width;\r\n        const offsetY = (e.clientY - centerY) / rect.height;\r\n\r\n        // 将偏移量转换为旋转角度（-15°到+15°）\r\n        const rotateX = -offsetY * 15; // Y轴取反，符合直觉的倾斜方向\r\n        const rotateY = offsetX * 15;\r\n\r\n        // 更新3D变换状态\r\n        setTransform(`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);\r\n    };\r\n\r\n    // ============================\r\n    // 交互事件处理系统\r\n    // ============================\r\n    \r\n    /**\r\n     * 鼠标进入事件：启用悬停效果和倾斜跟踪\r\n     */\r\n    const handleMouseEnter = () =\u003e {\r\n        setHovered(true);\r\n        onInteractionAction('hover');\r\n\r\n        // 清除自动复位定时器，防止意外重置\r\n        if (autoReturnTimer) {\r\n            clearTimeout(autoReturnTimer);\r\n            setAutoReturnTimer(null);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 鼠标离开事件：启动自动复位机制\r\n     */\r\n    const handleMouseLeave = () =\u003e {\r\n        setHovered(false);\r\n\r\n        // 启动延迟复位定时器\r\n        const timer = setTimeout(() =\u003e {\r\n            setTransform('rotateX(0deg) rotateY(0deg)'); // 重置倾斜\r\n            setFlipped(false);                           // 重置翻转\r\n        }, 1500); // 1.5秒延迟，给用户足够查看时间\r\n\r\n        setAutoReturnTimer(timer);\r\n\r\n        // 立即重置倾斜效果，保证视觉连贯性\r\n        setTransform('rotateX(0deg) rotateY(0deg)');\r\n    };\r\n\r\n    /**\r\n     * 点击事件：触发卡片翻转\r\n     */\r\n    const handleClick = () =\u003e {\r\n        setFlipped(!flipped);  // 切换翻转状态\r\n        onInteractionAction('flip');\r\n    };\r\n\r\n    // ============================\r\n    // 样式和动画计算系统\r\n    // ============================\r\n    \r\n    const position = getCardPosition(); // 获取当前位置参数\r\n\r\n    /**\r\n     * 折叠模式的扇形展开效果\r\n     * 在悬停时创建扇形排列，增强层次感\r\n     */\r\n    const getFoldedTransform = () =\u003e {\r\n        if (mode !== 'folded') return '';\r\n        \r\n        // 基础的微妙旋转，让堆叠看起来更自然\r\n        const baseAngle = (index - activeIndex) * 0.5;\r\n        \r\n        if (hovered \u0026\u0026 index !== activeIndex) {\r\n            // 悬停时的扇形展开效果\r\n            const fanAngle = (index - activeIndex) * 4; // 扇形角度\r\n            const translateX = Math.sin(fanAngle * Math.PI / 180) * 12; // 水平散开距离\r\n            return `rotateZ(${fanAngle}deg) translateX(${translateX}px)`;\r\n        }\r\n        \r\n        // 默认的微妙基础旋转\r\n        return `rotateZ(${baseAngle}deg)`;\r\n    };\r\n\r\n    /**\r\n     * 动态动画属性计算\r\n     * 根据当前状态返回相应的动画效果\r\n     */\r\n    const getAnimationProps = () =\u003e {\r\n        if (hovered) {\r\n            // 悬停状态：放大和发光效果\r\n            return {\r\n                scale: 1.02,\r\n                boxShadow: '0 20px 40px rgba(0, 255, 255, 0.3)' // 青色科技感阴影\r\n            };\r\n        } else if (!flipped) {\r\n            // 默认状态：微妙的呼吸动画\r\n            return {\r\n                scale: [1, 1.01, 1],    // 轻微的缩放循环\r\n                boxShadow: [\r\n                    '0 10px 20px rgba(0, 0, 0, 0.1)',           // 基础阴影\r\n                    '0 12px 24px rgba(0, 255, 255, 0.08)',      // 轻微发光\r\n                    '0 10px 20px rgba(0, 0, 0, 0.1)'            // 回到基础\r\n                ]\r\n            };\r\n        } else {\r\n            // 翻转状态：静态显示\r\n            return {\r\n                scale: 1,\r\n                boxShadow: '0 10px 20px rgba(0, 0, 0, 0.1)'\r\n            };\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 动画过渡效果配置\r\n     * 为不同状态配置合适的过渡动画\r\n     */\r\n    const getAnimationTransition = () =\u003e {\r\n        if (hovered) {\r\n            // 悬停：弹簧物理动画，自然的弹性感\r\n            return {\r\n                type: \"spring\" as const,\r\n                damping: 20,      // 阻尼系数\r\n                stiffness: 300    // 刚度系数\r\n            };\r\n        } else if (!flipped) {\r\n            // 呼吸动画：慢速循环，几乎察觉不到\r\n            return {\r\n                duration: 4,                    // 4秒周期\r\n                repeat: Infinity,               // 无限循环\r\n                ease: \"easeInOut\" as const      // 自然的加减速\r\n            };\r\n        } else {\r\n            return undefined;\r\n        }\r\n    };\r\n\r\n    // ============================\r\n    // CSS样式对象定义\r\n    // ============================\r\n    \r\n    /**\r\n     * 卡片容器的基础样式\r\n     * 控制卡片在3D空间中的位置和层级\r\n     */\r\n    const cardStyle: React.CSSProperties = {\r\n        position: 'absolute',\r\n        left: '50%',\r\n        top: '50%',\r\n        width: '300px',\r\n        height: '420px',\r\n        marginLeft: '-150px',    // 居中对齐\r\n        marginTop: '-210px',     // 居中对齐\r\n        // 核心3D变换：位置 + 缩放 + 折叠效果\r\n        transform: `translate3d(${position.x}px, ${position.y}px, ${position.z}px) scale(${position.scale}) ${getFoldedTransform()}`,\r\n        transformStyle: 'preserve-3d',  // 保持3D上下文\r\n        perspective: '1000px',          // 3D透视距离\r\n        opacity: position.opacity,\r\n        // 智能过渡效果\r\n        transition: mode === 'folded'\r\n            ? 'transform 0.5s ease, opacity 0.5s ease'  // 折叠模式：平滑切换\r\n            : hovered\r\n                ? 'transform 0.1s ease-out'              // 悬停：快速响应\r\n                : 'transform 0.6s ease',                 // 默认：优雅过渡\r\n        cursor: 'pointer',\r\n        // 智能层级管理\r\n        zIndex: mode === 'folded'\r\n            ? (index === activeIndex ? 10 : total - Math.abs(index - activeIndex))  // 折叠：基于距离\r\n            : (hovered ? 10 : index),                                               // 平铺：悬停优先\r\n    };\r\n\r\n    /**\r\n     * 卡片内容容器样式\r\n     * 控制翻转动画和3D效果\r\n     */\r\n    const cardContainerStyle: React.CSSProperties = {\r\n        width: '100%',\r\n        height: '100%',\r\n        position: 'relative',\r\n        transformStyle: 'preserve-3d',\r\n        // 核心翻转逻辑：翻转状态决定变换方式\r\n        transform: flipped ? 'rotateY(180deg)' : transform,\r\n        // 智能过渡：翻转和倾斜使用不同的动画时长\r\n        transition: flipped ? 'transform 0.6s ease' : 'transform 0.4s ease-out',\r\n    };\r\n\r\n    /**\r\n     * 卡片正面样式\r\n     */\r\n    const cardFaceStyle: React.CSSProperties = {\r\n        width: '100%',\r\n        height: '100%',\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        backfaceVisibility: 'hidden',  // 隐藏背面，防止透视穿帮\r\n        borderRadius: '12px',\r\n        overflow: 'hidden',\r\n    };\r\n\r\n    /**\r\n     * 卡片背面样式\r\n     * 预先旋转180度，配合容器旋转实现翻转效果\r\n     */\r\n    const cardBackStyle: React.CSSProperties = {\r\n        ...cardFaceStyle,\r\n        transform: 'rotateY(180deg)',  // 预旋转，确保翻转时内容正向显示\r\n    };\r\n\r\n    // ============================\r\n    // JSX渲染结构\r\n    // ============================\r\n    \r\n    return (\r\n        \u003cdiv style={cardStyle}\u003e\r\n            \u003cdiv\r\n                ref={cardRef}\r\n                style={cardContainerStyle}\r\n                onMouseMove={handleMouseMove}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseLeave={handleMouseLeave}\r\n                onClick={handleClick}\r\n            \u003e\r\n                {/* 卡片正面 */}\r\n                \u003cmotion.div\r\n                    style={cardFaceStyle}\r\n                    className=\"bg-gradient-to-br from-background/90 to-surface/90 backdrop-blur-sm border border-primary/20 shadow-xl\"\r\n                    initial={{ \r\n                        opacity: 0, \r\n                        scale: 0.8,\r\n                        y: 50,\r\n                        rotateX: -15\r\n                    }}\r\n                    animate={hasInitialized ? { \r\n                        opacity: 1,\r\n                        y: 0,\r\n                        rotateX: 0,\r\n                        ...getAnimationProps()\r\n                    } : {\r\n                        opacity: 0,\r\n                        scale: 0.8,\r\n                        y: 50,\r\n                        rotateX: -15\r\n                    }}\r\n                    transition={hasInitialized ? {\r\n                        ...getAnimationTransition(),\r\n                        opacity: { duration: 0.6, ease: \"easeOut\" },\r\n                        y: { duration: 0.8, ease: \"easeOut\" },\r\n                        rotateX: { duration: 0.8, ease: \"easeOut\" }\r\n                    } : {\r\n                        duration: 0.6,\r\n                        ease: \"easeOut\"\r\n                    }}\r\n                \u003e\r\n                    {/* 正面内容结构 */}\r\n                    \u003cdiv className=\"w-full h-full p-6 flex gap-4 flex-col justify-items-center\"\u003e\r\n                        {/* 项目预览区域 */}\r\n                        \u003cdiv className=\"h-40 bg-gradient-to-br from-primary/20 to-accent/20 rounded-lg flex items-center justify-center relative overflow-hidden\"\u003e\r\n                            {work.image ? (\r\n                                \u003cimg\r\n                                    src={work.image}\r\n                                    alt={work.title}\r\n                                    className=\"w-full h-full object-cover rounded-lg\"\r\n                                /\u003e\r\n                            ) : (\r\n                                \u003cdiv className=\"text-center\"\u003e\r\n                                    \u003cdiv className=\"text-primary/60 text-4xl mb-2\"\u003e🚀\u003c/div\u003e\r\n                                    \u003cspan className=\"text-foreground/60 text-sm\"\u003e{t('project.projectPreview')}\u003c/span\u003e\r\n                                \u003c/div\u003e\r\n                            )}\r\n\r\n                            {/* 特殊标记标签 */}\r\n                            \u003cdiv className=\"absolute top-2 right-2 flex gap-1\"\u003e\r\n                                {work.accessible \u0026\u0026 (\r\n                                    \u003cdiv className=\"bg-green-500 text-white text-xs px-2 py-1 rounded-full\"\u003e\r\n                                        {t('project.accessible')}\r\n                                    \u003c/div\u003e\r\n                                )}\r\n                                {work.tool \u0026\u0026 (\r\n                                    \u003cdiv className=\"bg-blue-500 text-white text-xs px-2 py-1 rounded-full\"\u003e\r\n                                        {t('project.tool')}\r\n                                    \u003c/div\u003e\r\n                                )}\r\n                            \u003c/div\u003e\r\n                        \u003c/div\u003e\r\n\r\n                        {/* 项目标题 */}\r\n                        \u003ch3 className=\"text-xl font-bold text-foreground line-clamp-2\"\u003e\r\n                            {work.title}\r\n                        \u003c/h3\u003e\r\n\r\n                        {/* 项目描述 */}\r\n                        \u003cp className=\"text-foreground/80 text-sm line-clamp-3 flex-1\"\u003e\r\n                            {work.description}\r\n                        \u003c/p\u003e\r\n\r\n                        {/* 技术标签（仅显示前3个） */}\r\n                        \u003cdiv className=\"flex flex-wrap gap-2\"\u003e\r\n                            {work.tags.slice(0, 3).map((tag) =\u003e (\r\n                                \u003cspan\r\n                                    key={tag}\r\n                                    className=\"px-2 py-1 bg-primary/20 text-primary text-xs rounded-full\"\r\n                                \u003e\r\n                                    {tag}\r\n                                \u003c/span\u003e\r\n                            ))}\r\n                            {work.tags.length \u003e 3 \u0026\u0026 (\r\n                                \u003cspan className=\"text-foreground/60 text-xs\"\u003e\r\n                                    +{work.tags.length - 3} {t('project.moreItems')}\r\n                                \u003c/span\u003e\r\n                            )}\r\n                        \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/motion.div\u003e\r\n\r\n                {/* 卡片背面 */}\r\n                \u003cmotion.div\r\n                    style={cardBackStyle}\r\n                    className=\"bg-gradient-to-br from-secondary/90 to-accent/90 backdrop-blur-sm border border-secondary/20 shadow-xl\"\r\n                    initial={{opacity: 0}}\r\n                    animate={{opacity: flipped ? 1 : 0}}\r\n                    transition={{delay: flipped ? 0.2 : 0}}\r\n                \u003e\r\n                    \u003cdiv className=\"w-full h-full p-6 flex flex-col text-white\"\u003e\r\n                        \u003ch3 className=\"text-xl font-bold mb-4\"\u003e{t('project.technicalDetails')}\u003c/h3\u003e\r\n\r\n                        {/* 完整技术标签 */}\r\n                        \u003cdiv className=\"mb-4\"\u003e\r\n                            \u003ch4 className=\"text-sm font-semibold mb-2\"\u003e{t('project.technologies')}\u003c/h4\u003e\r\n                            \u003cdiv className=\"flex flex-wrap gap-1\"\u003e\r\n                                {work.tags.map((tag) =\u003e (\r\n                                    \u003cspan\r\n                                        key={tag}\r\n                                        className=\"px-2 py-1 bg-white/20 text-white text-xs rounded-full\"\r\n                                    \u003e\r\n                                        {tag}\r\n                                    \u003c/span\u003e\r\n                                ))}\r\n                            \u003c/div\u003e\r\n                        \u003c/div\u003e\r\n\r\n                        {/* 详细描述 */}\r\n                        \u003cdiv className=\"mb-4 flex-1\"\u003e\r\n                            \u003ch4 className=\"text-sm font-semibold mb-2\"\u003e{t('project.description')}\u003c/h4\u003e\r\n                            \u003cp className=\"text-white/90 text-sm\"\u003e\r\n                                {work.description}\r\n                            \u003c/p\u003e\r\n                        \u003c/div\u003e\r\n\r\n                        {/* 操作按钮 */}\r\n                        \u003cdiv className=\"flex gap-2 mt-auto\"\u003e\r\n                            \u003cmotion.button\r\n                                whileHover={{scale: 1.05}}\r\n                                whileTap={{scale: 0.95}}\r\n                                className=\"flex-1 py-2 px-3 bg-white text-secondary text-sm rounded-lg hover:bg-white/90 transition-colors\"\r\n                                onClick={(e) =\u003e {\r\n                                    e.stopPropagation();\r\n                                    onInteractionAction('detail');\r\n                                }}\r\n                            \u003e\r\n                                {t('project.seeDetails')}\r\n                            \u003c/motion.button\u003e\r\n                            {work.githubUrl \u0026\u0026 (\r\n                                \u003cmotion.button\r\n                                    whileHover={{scale: 1.05}}\r\n                                    whileTap={{scale: 0.95}}\r\n                                    className=\"flex-1 py-2 px-3 border border-white text-white text-sm rounded-lg hover:bg-white/20 transition-colors\"\r\n                                    onClick={(e) =\u003e {\r\n                                        e.stopPropagation();\r\n                                        window.open(work.githubUrl, '_blank');\r\n                                    }}\r\n                                \u003e\r\n                                    {t('project.github')}\r\n                                \u003c/motion.button\u003e\r\n                            )}\r\n                        \u003c/div\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/motion.div\u003e\r\n            \u003c/div\u003e\r\n        \u003c/div\u003e\r\n    );\r\n}\r\n```\r\n\r\n### 系统架构流程图\r\n\r\n```\r\n    用户交互事件\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   事件处理系统       │\r\n    │ • 鼠标移动追踪       │ \r\n    │ • 悬停状态管理       │\r\n    │ • 点击翻转控制       │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   状态更新机制       │\r\n    │ • hovered状态        │\r\n    │ • flipped状态        │  \r\n    │ • transform字符串    │\r\n    │ • 定时器管理         │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   位置计算引擎       │\r\n    │ • 折叠模式算法       │\r\n    │ • 平铺模式算法       │\r\n    │ • 3D变换计算        │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   动画渲染系统       │\r\n    │ • Framer Motion     │\r\n    │ • CSS 3D Transform  │\r\n    │ • 入场动画控制       │\r\n    │ • 呼吸效果循环       │\r\n    └─────────────────────┘\r\n         ↓\r\n    ┌─────────────────────┐\r\n    │   视觉呈现结果       │\r\n    │ • 立体卡片效果       │\r\n    │ • 平滑过渡动画       │\r\n    │ • 响应式交互反馈     │\r\n    └─────────────────────┘\r\n```\r\n\r\n### 核心算法深度解析\r\n\r\n#### 1. 3D空间位置计算算法\r\n\r\n```typescript\r\n// 折叠模式的层叠堆栈算法\r\nconst relativeIndex = index - activeIndex;\r\nconst horizontalOffset = relativeIndex * 2;\r\nconst verticalOffset = -Math.abs(relativeIndex) * 8;\r\nconst depth = -Math.abs(relativeIndex) * 15;\r\nconst scale = 1 - Math.abs(relativeIndex) * 0.03;\r\n```\r\n\r\n这个算法通过相对索引计算每张卡片的精确位置，创造出层叠的视觉效果。\r\n\r\n#### 2. 鼠标追踪倾斜算法\r\n\r\n```typescript\r\n// 坐标归一化处理\r\nconst offsetX = (e.clientX - centerX) / rect.width;\r\nconst offsetY = (e.clientY - centerY) / rect.height;\r\n\r\n// 角度映射转换\r\nconst rotateX = -offsetY * 15;\r\nconst rotateY = offsetX * 15;\r\n```\r\n\r\n将鼠标的2D坐标转换为3D旋转角度，实现自然的倾斜跟踪效果。\r\n\r\n#### 3. 智能网格布局算法\r\n\r\n```typescript\r\n// 最优列数计算\r\nconst cols = Math.ceil(Math.sqrt(total));\r\n\r\n// 居中对齐数学\r\nconst x = (col - (cols - 1) / 2) * widthSpacing;\r\nconst y = (row - Math.floor((total - 1) / cols) / 2) * heightSpacing;\r\n```\r\n\r\n使用平方根算法创建接近正方形的网格，并通过数学计算实现完美的居中对齐。\r\n\r\n#### 4. 定时器级联管理\r\n\r\n```typescript\r\n// 清除现有定时器\r\nif (autoReturnTimer) {\r\n    clearTimeout(autoReturnTimer);\r\n    setAutoReturnTimer(null);\r\n}\r\n\r\n// 启动新的复位定时器\r\nconst timer = setTimeout(() =\u003e {\r\n    setTransform('rotateX(0deg) rotateY(0deg)');\r\n    setFlipped(false);\r\n}, 1500);\r\n```\r\n\r\n通过定时器的级联管理，确保用户交互的连贯性和状态的正确重置。\r\n\r\n#### 5. 扇形展开算法\r\n\r\n```typescript\r\n// 扇形角度计算\r\nconst fanAngle = (index - activeIndex) * 4;\r\n\r\n// 水平散开距离\r\nconst translateX = Math.sin(fanAngle * Math.PI / 180) * 12;\r\n\r\n// 组合变换\r\nreturn `rotateZ(${fanAngle}deg) translateX(${translateX}px)`;\r\n```\r\n\r\n使用三角函数计算扇形展开的精确位置，创造优雅的层次展示效果。\r\n\r\n## 写在最后\r\n\r\n这个3D卡片系统表面上看起来只是几个卡片在空间中的摆放和旋转，但背后涉及的数学计算、状态管理、性能优化和用户体验设计，每一个环节都需要精心考虑。\r\n\r\n技术的发展永远不会停止，但用户对美好体验的追求是永恒的。\r\n\r\n*愿你的卡片如羽毛般轻盈，如钻石般闪耀，在用户的指尖下演绎着数字世界的立体诗篇。* ✨\r\n"])</script><script>self.__next_f.push([1,"3d:T79ab,"])</script><script>self.__next_f.push([1,"\n# 粒子文字：从像素到粒子的数字炼金术\n\n鹰角官网同款粒子（这是粒子冲击！这是粒子文字！然而这是......粒子头大！啊哈哈哈哈哈哈哈哈！！）\n\n这个粒子文字系统可以将静态的文本转化为成千上万个活跃的粒子，它们会从屏幕各处飞向自己的目标位置，形成文字的形状，同时还会对鼠标的接近做出物理反应——有种将手伸进米粒堆中的感觉。在这篇文章中，我将从最基础的类型定义开始，逐步深入每一个实现细节，全面剖析这个将像素转化为粒子的数字炼金术。\n\n*警告：包含高级数学内容，可能导致对物理公式过敏的开发者出现暂时性头晕！🤯*\n\n## 组件结构与类型定义\n\n实际上每一个粒子都是一个单独的对象，拥有自己的个性和命运。\n\n### 粒子本粒设计\n\n```typescript\ninterface ParticleData {\n    x: number;\n    y: number;\n    color: number[];\n}\n```\n\n字段解释：\n\n- **x \u0026 y**: 粒子的目标位置坐标，注意这里存储的是最终位置，而不是当前位置。这个设计让粒子知道自己在画布上的确切目的地——就像给每个粒子配备了GPS导航！\n- **color**: RGB数值的数组格式可以直接用于`rgba()`函数的构建，在代码编写上可以享受到Javascript对于数组元素操作语法支持。这就像给每个粒子配了一个专属调色盘！🎨\n\n该类型定义了一个粒子的基本属性，而不涉及运动状态或渲染细节。\n\n### 组件Props\n\n```typescript\ninterface ParticleWordProps {\n    text?: string;\n    className?: string;\n}\n```\n\n字段解释：\n\n- **text?: string**: 可选的文本内容，不传入时会采用默认值，避免空指针异常。\n- **className?: string**: 样式扩展接口，遵循React组件的标准设计模式。\n\n### Particle类设计\n\n```typescript\nclass Particle {\n    x: number;           // 当前X位置\n    y: number;           // 当前Y位置\n    totalX: number;      // 目标X位置\n    totalY: number;      // 目标Y位置\n    mx: number = 0;      // X轴移动距离\n    my: number = 0;      // Y轴移动距离\n    vx: number = 0;      // X轴速度\n    vy: number = 0;      // Y轴速度\n    time: number;        // 动画时间\n    r: number;           // 粒子半径\n    color: number[];     // 粒子颜色\n    opacity: number;     // 透明度\n}\n```\n\n属性分组解析：\n- **位置相关**: `x, y`（当前位置）vs `totalX, totalY`（目标位置）的分离设计让粒子\"知道\"自己要去哪里——就像同时拥有当前位置和梦想目的地！\n- **运动相关**: `mx, my`是移动距离，`vx, vy`是计算出的速度，简单但有效的运动学模型，牛顿看了都会点头称赞 🍎\n- **视觉相关**: `time`控制动画节奏，`r`控制大小，`color`和`opacity`控制外观——数字粒子的全套化妆品！\n\n## 配置常量解析\n\n定义画布的基础属性。\n\n### 画布尺寸\n\n```typescript\nconst CANVAS_WIDTH = 600;\nconst CANVAS_HEIGHT = 200;\n```\n\n### 动画参数\n\n```typescript\nconst ANIMATE_TIME = 30;\nconst OPACITY_STEP = 1 / ANIMATE_TIME;\n```\n\n**ANIMATE_TIME = 30**：\n\n注意，这个30不是30毫秒，而是30帧！在60fps的动画循环中，粒子需要30帧（约500ms）来到达目标位置。就像给每个粒子准确半秒的时间回家！⏱️\n\n**透明度渐变**：\n\n```typescript\nconst OPACITY_STEP = 1 / 30 = 0.0333...\n```\n\n每一帧透明度增加约3.33%，30帧后达到完全不透明。这个线性渐变创造了粒子\"凭空出现\"的自然效果。\n\n### 交互参数\n\n```typescript\nconst RADIUS = 40;\nconst INTENSITY = 0.95;\n```\n\n参数解释：\n\n**RADIUS：**光标与粒子的交互半径为40像素\n\n**INTENSITY：**光标的\"推搡力度\"系数，这意味着在粒子位置持续性更新的过程中，其光标对其施加的力量会逐渐减弱\n\n## 粒子系统设计\n\n粒子系统是整个效果的核心，每个粒子都是一个小小的智能体，它们有自己的生命周期和行为模式。\n\n### 粒子从随机位置诞生\n\n```typescript\nconstructor(totalX: number, totalY: number, time: number, color: number[]) {\n    this.x = Math.random() * CANVAS_WIDTH;\n    this.y = Math.random() * CANVAS_HEIGHT;\n    this.totalX = totalX;\n    this.totalY = totalY;\n    this.time = time;\n    this.r = 1.2;\n    this.color = [...color];\n    this.opacity = 0;\n}\n```\n\n**随机初始位置**：\n\n每个粒子都从画布的随机位置开始它的旅程，这创造了一种\"混沌中诞生秩序\"的视觉效果。如果所有粒子都从同一个角落出发未免显得太单一，没有那种宇宙中星尘凝聚成文字的感觉。\n\n参数解释：\n- `totalX, totalY`: 粒子的目标点坐标\n- `time`: 粒子到达目的地所需要的时间\n- `color`: 粒子的颜色\n\n### 粒子于扩散中降速\n\n```typescript\nupdate(mouseX?: number, mouseY?: number) {\n    this.mx = this.totalX - this.x;\n    this.my = this.totalY - this.y;\n    this.vx = this.mx / this.time;\n    this.vy = this.my / this.time;\n    // ...\n}\n```\n\n**位移→速度的数学变换**：\n\n已知运动学公式：`速度 = 位移 / 时间`\n\n```\nvx = (目标X - 当前X) / 时间常数\nvy = (目标Y - 当前Y) / 时间常数\n```\n\n**为什么除以时间常数**？\n\n这创造了一个\"渐进式到达\"的效果——距离目标越近，速度越慢。\n\n### 轻触粒子之海\n\n```typescript\nif (mouseX !== undefined \u0026\u0026 mouseY !== undefined \u0026\u0026 mouseX \u003e 0 \u0026\u0026 mouseY \u003e 0) {\n    const dx = mouseX - this.x;\n    const dy = mouseY - this.y;\n    const distance = Math.sqrt(dx ** 2 + dy ** 2);\n\n    if (distance \u003c RADIUS) {\n        let disPercent = RADIUS / distance;\n        disPercent = disPercent \u003e 7 ? 7 : disPercent;\n\n        const angle = Math.atan2(dy, dx);\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const repX = cos * disPercent * -INTENSITY;\n        const repY = sin * disPercent * -INTENSITY;\n        this.vx += repX;\n        this.vy += repY;\n    }\n}\n```\n\n**距离计算的几何原理**：\n\n```typescript\nconst distance = Math.sqrt(dx ** 2 + dy ** 2);\n```\n\n使用欧几里得距离公式计算鼠标和粒子之间的直线距离。虽然开平方根运算稍重，但在现代浏览器中这点计算量完全不是问题。\n\n**力的衰减函数**：\n\n```typescript\nlet disPercent = RADIUS / distance;\ndisPercent = disPercent \u003e 7 ? 7 : disPercent;\n```\n\n这是一个反比例衰减函数，距离越近，作用力越强：\n- 当`distance = RADIUS`时，`disPercent = 1`（标准强度）\n- 当`distance = RADIUS/2`时，`disPercent = 2`（双倍强度）\n- 当`distance → 0`时，`disPercent → ∞`\n\n**为什么限制在7以内**？防止粒子在鼠标正下方时获得过大的加速度而\"飞出银河系\"。\n\n**角度计算与力的分解**：\n\n```typescript\nconst angle = Math.atan2(dy, dx);\nconst repX = cos * disPercent * -INTENSITY;\nconst repY = sin * disPercent * -INTENSITY;\n```\n\n这里使用了向量分解的经典方法：\n1. 计算从粒子指向鼠标的角度\n2. 使用三角函数将力分解为X和Y分量\n3. 负号创造\"排斥\"效果（如果想要\"吸引\"，去掉负号即可）\n\n### 渲染优化\n\n```typescript\ndraw(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n    ctx.strokeStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n    ctx.fillRect(this.x, this.y, this.r * 2, this.r * 2);\n}\n```\n\n**为什么使用fillRect而不是arc**？\n\n- **性能优势**: 矩形的绘制比圆形快约30%，当有数千个粒子时这个差异很明显\n- **视觉效果**: 1.2×1.2像素的小矩形在远距离观看时与圆形几乎无差别\n- **像素完美**: 矩形避免了圆形的抗锯齿问题\n\n**颜色插值的字符串拼接**：\n\n```typescript\nctx.fillStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n```\n\n## 文本转粒子原理\n\n（赛博磁吸板的底层逻辑）\n\n### 离屏Canvas\n\n```typescript\nconst tempCanvas = document.createElement('canvas');\nconst tempCtx = tempCanvas.getContext('2d')!;\ntempCanvas.width = CANVAS_WIDTH;\ntempCanvas.height = CANVAS_HEIGHT;\n```\n\n**为什么需要临时Canvas**？\n\n离屏渲染是计算机图形学中的经典技术：\n1. **隔离环境**: 临时Canvas不会影响主画布的状态\n2. **像素读取**: 只有先将文字\"画出来\"，才能读取像素数据\n3. **内存效率**: 临时Canvas在使用完毕后会被垃圾回收，不占用长期内存\n\n**离屏渲染的性能优势**：\n\n- 避免了主画布的重复清理和重绘\n- 可以在任意线程中进行\n- 若渲染复杂度渐高，可以在未来采用Web Worker将渲染并行化以提升性能（目前的渲染需求不需要）\n\n### 文字渲染参数\n\n```typescript\ntempCtx.font = 'bold 100px Arial, sans-serif';\ntempCtx.textAlign = 'center';\ntempCtx.textBaseline = 'middle';\n```\n\n**居中对齐的数学计算**：\n```typescript\ntempCtx.fillText(text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n```\n\n通过将文字绘制在画布的几何中心（300, 100），确保了无论文字长短，都能在画布中居中显示。\n\n**字体选择对粒子效果的影响**：\n\n- **sans-serif**: 无衬线字体避免了细节过多导致的粒子噪点\n\n### 像素采样算法：从连续到离散的智慧\n\n开源算法原作者：[XIwE1](https://github.com/XIwE1)，在此拜谢orz\n\n```typescript\nfor (let y = 0; y \u003c CANVAS_HEIGHT; y += 3) {\n    for (let x = 0; x \u003c CANVAS_WIDTH; x += 3) {\n        const index = (x + y * CANVAS_WIDTH) * 4;\n        const a = data[index + 3];\n        if (a \u003e 128) {\n            particles.push({\n                x,\n                y,\n                color: [...rgbColor]\n            });\n        }\n    }\n}\n```\n\n**双重循环的采样逻辑**：\n\n这个嵌套循环遍历了整个画布，但不是逐像素遍历——而是每3个像素采样一次。\n\n**为什么步长是3**？\n\n这是性能与质量的精妙平衡：\n- 步长1：每个像素都采样，粒子数量巨大（约40,000个），性能糟糕\n- 步长5：粒子太少，文字轮廓不清晰\n- 步长3：粒子数量适中（约4,000-8,000个），既保持了文字的清晰度又确保了流畅的动画\n\n**RGBA数据结构的内存布局**：\n\n```typescript\nconst index = (x + y * CANVAS_WIDTH) * 4;\n```\n\nCanvas的ImageData按照RGBA顺序存储每个像素：\n```\n[R0, G0, B0, A0, R1, G1, B1, A1, R2, G2, B2, A2, ...]\n```\n\n所以第(x,y)个像素的alpha值位于：`(x + y * width) * 4 + 3`\n\n**alpha阈值128的选择原理**：\n\n```typescript\nif (a \u003e 128) {\n    particles.push({x, y, color: [...rgbColor]});\n}\n```\n\nAlpha值范围是0-255，128是正好一半。这个阈值确保了：\n- 完全透明的背景（alpha=0）不会产生粒子\n- 有一定透明度的文字边缘也会被包含\n- 避免抗锯齿产生的半透明像素造成噪点\n\n**颜色转换的RGB拆解**：\n\n```typescript\ncolor: [...rgbColor]\n```\n\n这里使用扩展运算符复制颜色数组，避免了所有粒子共享同一个颜色数组的问题（浅拷贝陷阱）。\n\n## ParticleCanvas类：~~凯\u0026零~~粒子指挥官\n\n如果说Particle是士兵，那么ParticleCanvas就是指挥官，它协调着整个粒子军团的行动。\n\n### 事件系统设计：坐标转换\n\n```typescript\nsetupMouseEvents() {\n    this.canvas.addEventListener('mousemove', (e) =\u003e {\n        const rect = this.canvas.getBoundingClientRect();\n        this.mouseX = e.clientX - rect.left;\n        this.mouseY = e.clientY - rect.top;\n    });\n\n    this.canvas.addEventListener('mouseleave', () =\u003e {\n        this.mouseX = 0;\n        this.mouseY = 0;\n    });\n}\n```\n\n**getBoundingClientRect的精确定位**：\n\n这个方法返回元素相对于视口的精确位置，考虑了：\n- CSS变换（transform）\n- 滚动偏移（scroll）\n- 边框宽度（border）\n- 内边距（padding）\n\n**坐标转换的数学原理**：\n\n```typescript\nthis.mouseX = e.clientX - rect.left;\nthis.mouseY = e.clientY - rect.top;\n```\n\n- `e.clientX/Y`: 鼠标相对于视口的坐标\n- `rect.left/top`: Canvas元素相对于视口的坐标\n- 相减得到鼠标相对于Canvas的坐标\n\n**为什么需要mouseleave处理**？\n\n当鼠标离开Canvas时，将坐标设为(0,0)确保粒子不会继续受到\"幽灵鼠标\"的影响。这比保持最后位置更自然。\n\n### 动画循环的生命周期\n\n```typescript\nanimate() {\n    this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n    this.particles.forEach(particle =\u003e {\n        particle.update(this.mouseX, this.mouseY);\n        particle.draw(this.ctx);\n    });\n\n    this.animationId = requestAnimationFrame(() =\u003e this.animate());\n}\n```\n\n**清除→更新→绘制的标准循环**：\n\n这是Canvas动画的经典模式：\n1. **清除**: 擦掉上一帧的内容\n2. **更新**: 计算新的状态\n3. **绘制**: 渲染当前帧\n\n**requestAnimationFrame的优势**：\n\n相比`setTimeout`，`requestAnimationFrame`有诸多优势：\n- **垂直同步**: 与显示器刷新率同步，避免撕裂\n- **自动节流**: 页面不可见时自动暂停\n- **性能优化**: 浏览器会进行更好的优化\n\n**动画ID管理的重要性**：\n\n```typescript\nthis.animationId = requestAnimationFrame(() =\u003e this.animate());\n```\n\n保存动画ID是为了后续的取消操作。没有这个ID，动画循环将无法停止，造成内存泄漏。\n\n### 资源管理与内存泄漏防护\n\n```typescript\ndestroy() {\n    if (this.animationId) {\n        cancelAnimationFrame(this.animationId);\n    }\n}\n```\n\n**为什么需要手动销毁**？\n\nJavaScript的垃圾回收机制虽然强大，但对于以下资源需要手动清理：\n- 动画循环（requestAnimationFrame）\n- 事件监听器（虽然这里随着DOM元素删除会自动清理）\n- 定时器（setTimeout/setInterval）\n\n**React组件卸载时的清理工作**：\n\n在React的生命周期中，组件卸载时必须清理这些资源，否则：\n- 动画会继续运行，消耗CPU\n- 内存无法释放\n- 可能出现错误的状态更新\n\n## React集成的最佳实践\n\n将Canvas动画集成到React组件中需要处理生命周期、性能优化和状态同步等多个挑战。\n\n### useEffect的依赖管理\n\n```typescript\nuseEffect(() =\u003e {\n    if (canvasRef.current) {\n        if (particleCanvasRef.current) {\n            particleCanvasRef.current.destroy();\n        }\n        particleCanvasRef.current = new ParticleCanvas(canvasRef.current);\n        particleCanvasRef.current.generateTextParticles(text, currentTheme.colors.primary);\n        particleCanvasRef.current.animate();\n        setIsLoaded(true);\n    }\n\n    return () =\u003e {\n        if (particleCanvasRef.current) {\n            particleCanvasRef.current.destroy();\n        }\n    };\n}, [text, currentTheme.colors.primary]);\n```\n\n**依赖数组的选择策略**：\n\n这里只包含`text`和`currentTheme.colors.primary`两个依赖：\n- **text**: 文本变化时需要重新生成粒子\n- **currentTheme.colors.primary**: 主题色变化时需要更新粒子颜色\n- **不包含其他值**: 避免不必要的重新初始化\n\n**主题色变化的响应式更新**：\n\n当用户切换主题时，粒子的颜色需要立即更新。通过监听主题变化并重新生成粒子系统，确保视觉效果的一致性。\n\n**清理函数的必要性**：\n\n返回的清理函数确保了：\n- 组件卸载时停止动画\n- 依赖变化时先清理旧实例再创建新实例\n- 避免多个动画循环同时运行\n\n## 数学原理深度解析\n\n接下来是晕晕环节。\n\n### 向量运算在粒子系统中的应用\n\n**位置向量与速度向量的关系**：\n\n在我们的系统中，每个粒子的运动可以用向量来描述：\n- 位置向量：$\\vec{P} = (x, y)$\n- 目标向量：$\\vec{T} = (totalX, totalY)$\n- 移动向量：$\\vec{M} = \\vec{T} - \\vec{P}$\n- 速度向量：$\\vec{V} = \\frac{\\vec{M}}{time}$\n\n**力的合成与分解**：\n\n当鼠标影响粒子时，粒子受到两个力的作用：\n\n$$\\vec{F_1} = \\frac{\\vec{M}}{time}$$\n\n$$\\vec{F_2} = -INTENSITY \\cdot \\frac{RADIUS}{distance} \\cdot \\vec{u}$$\n\n其中$\\vec{u}$是从粒子指向鼠标的单位向量。\n\n**最终速度**是两个力的向量和：\n\n$$\\vec{V_{final}} = \\vec{F_1} + \\vec{F_2}$$\n\n### 距离衰减函数的设计\n\n**反比例函数的物理意义**：\n\n我们使用的衰减函数是：\n\n$$f(d) = \\frac{RADIUS}{d}$$\n\n这模拟了库仑力的衰减规律（虽然库仑力是$\\frac{1}{d^2}$，但$\\frac{1}{d}$在视觉效果上更佳）。\n\n**边界条件的处理**：\n\n当$d \\to 0$时，$f(d) \\to \\infty$，这在数学上是发散的。我们通过限制最大值解决：\n\n```typescript\ndisPercent = disPercent \u003e 7 ? 7 : disPercent;\n```\n\n这相当于给函数加了一个上界：\n\n$$f(d) = \\min\\left(7, \\frac{RADIUS}{d}\\right)$$\n\n### 颜色空间的转换\n\n**HEX到RGB的数学变换**：\n\n颜色转换函数`hexToRGB`执行以下变换：\n- 输入：`\"#ff6432\"`\n- 解析：`ff`(255), `64`(100), `32`(50)\n- 输出：`[255, 100, 50]`\n\n**透明度渐变的插值算法**：\n\n透明度的变化使用线性插值：\n\n$$opacity(t) = 0 + \\frac{t}{ANIMATE\\_TIME} \\cdot (1 - 0) = \\frac{t}{30}$$\n\n其中$t$是当前帧数，$t \\in [0, 30]$。\n\n## 性能优化的深度思考\n\n以下优化可以考虑在未来的需求中适当应用，例如要绘制的粒子或文字会频繁变化的情况。\n\n### 渲染性能优化\n\n**Canvas绘制调用的最小化**：\n\n每个粒子调用一次`fillRect`，这是不可避免的，但可以通过以下方式减少绘制调用：\n- 批量设置绘制状态\n- 使用路径绘制替代多次fillRect\n- 实现粒子池避免对象创建销毁\n\n**GPU加速的启用条件**：\n\n现代浏览器会自动为Canvas启用GPU加速，条件是：\n- 使用2D上下文的特定操作\n- 画布尺寸适中（当前的600×200符合条件）\n- 没有复杂的变换或滤镜\n\n**垃圾回收的时机控制**：\n\n可以通过以下方式减少GC压力：\n- 重用粒子对象而不是重新创建\n- 避免在动画循环中创建临时对象\n- 合理设置对象生命周期\n\n## 完整源码全解析\n\n```typescript\n'use client';\n\nimport React, {useEffect, useRef, useState} from 'react';\nimport {useThemeStore} from '@/lib/stores/themeStore';\nimport {hexToRGB} from \"@/lib/utils/color\";\n\n// ==================== 核心配置常量 ====================\nconst CANVAS_WIDTH = 600;   // 画布宽度\nconst CANVAS_HEIGHT = 200;  // 画布高度\n\n// 动画参数\nconst ANIMATE_TIME = 30;    // 粒子动画时间（帧数）\nconst OPACITY_STEP = 1 / ANIMATE_TIME;  // 透明度渐变步长\nconst RADIUS = 40;          // 鼠标交互半径\nconst INTENSITY = 0.95;     // 鼠标排斥强度\n\n// ==================== 类型定义 ====================\ninterface ParticleData {\n    x: number;          // 粒子目标X坐标\n    y: number;          // 粒子目标Y坐标\n    color: number[];    // 粒子RGB颜色数组\n}\n\ninterface ParticleWordProps {\n    text?: string;      // 显示的文本内容\n    className?: string; // 自定义样式类名\n}\n\n// ==================== 粒子类：每个粒子的智能体 ====================\nclass Particle {\n    // 位置相关属性\n    x: number;          // 当前X坐标\n    y: number;          // 当前Y坐标\n    totalX: number;     // 目标X坐标\n    totalY: number;     // 目标Y坐标\n    \n    // 运动相关属性\n    mx: number = 0;     // X轴移动距离\n    my: number = 0;     // Y轴移动距离\n    vx: number = 0;     // X轴速度\n    vy: number = 0;     // Y轴速度\n    time: number;       // 到达目标所需时间\n    \n    // 视觉相关属性\n    r: number;          // 粒子半径\n    color: number[];    // 粒子颜色（RGB数组）\n    opacity: number;    // 透明度\n\n    /**\n     * 粒子构造函数\n     * @param totalX 目标X坐标\n     * @param totalY 目标Y坐标\n     * @param time 动画时间\n     * @param color 粒子颜色\n     */\n    constructor(totalX: number, totalY: number, time: number, color: number[]) {\n        // 随机初始位置：让粒子从画布各处\"飞向\"目标位置\n        this.x = Math.random() * CANVAS_WIDTH;\n        this.y = Math.random() * CANVAS_HEIGHT;\n        \n        // 设置目标位置\n        this.totalX = totalX;\n        this.totalY = totalY;\n        \n        // 设置动画参数\n        this.time = time;\n        this.r = 1.2;  // 粒子大小\n        \n        // 复制颜色数组，避免引用问题\n        this.color = [...color];\n        this.opacity = 0;  // 初始透明度为0，实现渐显效果\n    }\n\n    /**\n     * 绘制粒子到Canvas\n     * @param ctx Canvas 2D上下文\n     */\n    draw(ctx: CanvasRenderingContext2D) {\n        // 设置填充和描边颜色，包含透明度\n        ctx.fillStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n        ctx.strokeStyle = `rgba(${this.color.join(',')}, ${this.opacity})`;\n        \n        // 绘制矩形粒子（比圆形性能更好）\n        ctx.fillRect(this.x, this.y, this.r * 2, this.r * 2);\n    }\n\n    /**\n     * 更新粒子状态\n     * @param mouseX 鼠标X坐标（可选）\n     * @param mouseY 鼠标Y坐标（可选）\n     */\n    update(mouseX?: number, mouseY?: number) {\n        // 计算到目标位置的距离\n        this.mx = this.totalX - this.x;\n        this.my = this.totalY - this.y;\n        \n        // 计算基础速度：距离除以时间，实现渐进式到达效果\n        this.vx = this.mx / this.time;\n        this.vy = this.my / this.time;\n\n        // 鼠标交互：计算排斥力\n        if (mouseX !== undefined \u0026\u0026 mouseY !== undefined \u0026\u0026 mouseX \u003e 0 \u0026\u0026 mouseY \u003e 0) {\n            // 计算鼠标与粒子的距离\n            const dx = mouseX - this.x;\n            const dy = mouseY - this.y;\n            const distance = Math.sqrt(dx ** 2 + dy ** 2);\n\n            // 如果在交互半径内，施加排斥力\n            if (distance \u003c RADIUS) {\n                // 计算排斥力强度：距离越近，力量越大\n                let disPercent = RADIUS / distance;\n                // 限制最大排斥力，防止粒子\"飞出银河系\"\n                disPercent = disPercent \u003e 7 ? 7 : disPercent;\n\n                // 计算排斥力的方向\n                const angle = Math.atan2(dy, dx);\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n\n                // 计算排斥力的分量（负号表示排斥）\n                const repX = cos * disPercent * -INTENSITY;\n                const repY = sin * disPercent * -INTENSITY;\n                \n                // 将排斥力添加到速度中\n                this.vx += repX;\n                this.vy += repY;\n            }\n        }\n\n        // 更新位置\n        this.x += this.vx;\n        this.y += this.vy;\n        \n        // 渐显效果：逐渐增加透明度\n        if (this.opacity \u003c 1) this.opacity += OPACITY_STEP;\n    }\n}\n\n// ==================== 粒子画布管理类 ====================\nclass ParticleCanvas {\n    canvas: HTMLCanvasElement;      // Canvas元素\n    ctx: CanvasRenderingContext2D;  // 2D绘图上下文\n    particles: Particle[];          // 粒子数组\n    mouseX: number = 0;             // 鼠标X坐标\n    mouseY: number = 0;             // 鼠标Y坐标\n    animationId: number = 0;        // 动画ID，用于取消动画\n\n    /**\n     * 构造函数\n     * @param canvas Canvas元素\n     */\n    constructor(canvas: HTMLCanvasElement) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d')!;\n        this.particles = [];\n        this.setupMouseEvents();\n    }\n\n    /**\n     * 设置鼠标事件监听\n     */\n    setupMouseEvents() {\n        // 鼠标移动事件：更新鼠标坐标\n        this.canvas.addEventListener('mousemove', (e) =\u003e {\n            const rect = this.canvas.getBoundingClientRect();\n            // 将屏幕坐标转换为Canvas坐标\n            this.mouseX = e.clientX - rect.left;\n            this.mouseY = e.clientY - rect.top;\n        });\n\n        // 鼠标离开事件：清除鼠标坐标\n        this.canvas.addEventListener('mouseleave', () =\u003e {\n            this.mouseX = 0;\n            this.mouseY = 0;\n        });\n    }\n\n    /**\n     * 根据文本生成粒子\n     * @param text 要显示的文本\n     * @param color 粒子颜色（十六进制）\n     */\n    generateTextParticles(text: string, color: string = '#000000') {\n        // 创建临时Canvas进行文本渲染\n        const tempCanvas = document.createElement('canvas');\n        const tempCtx = tempCanvas.getContext('2d')!;\n        tempCanvas.width = CANVAS_WIDTH;\n        tempCanvas.height = CANVAS_HEIGHT;\n\n        // 设置文本样式\n        tempCtx.font = 'bold 100px Arial, sans-serif';\n        tempCtx.textAlign = 'center';\n        tempCtx.textBaseline = 'middle';\n\n        // 在临时Canvas中绘制文本\n        tempCtx.fillText(text, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);\n\n        // 获取像素数据\n        const imageData = tempCtx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n        const data = imageData.data;\n\n        const particles: ParticleData[] = [];\n        \n        // 将十六进制颜色转换为RGB数组\n        const rgbColor = hexToRGB(color);\n\n        // 像素采样：每3个像素采样一次，平衡性能和质量\n        for (let y = 0; y \u003c CANVAS_HEIGHT; y += 3) {\n            for (let x = 0; x \u003c CANVAS_WIDTH; x += 3) {\n                // 计算像素在ImageData中的索引\n                const index = (x + y * CANVAS_WIDTH) * 4;\n                // 获取Alpha通道值\n                const a = data[index + 3];\n\n                // 只有Alpha值大于128的像素才生成粒子\n                if (a \u003e 128) {\n                    particles.push({\n                        x,\n                        y,\n                        color: [...rgbColor]\n                    });\n                }\n            }\n        }\n\n        // 为每个粒子数据创建Particle实例\n        this.particles = particles.map(\n            particle =\u003e new Particle(particle.x, particle.y, ANIMATE_TIME, particle.color)\n        );\n    }\n\n    /**\n     * 动画循环函数\n     */\n    animate() {\n        // 清除画布\n        this.ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        // 更新并绘制每个粒子\n        this.particles.forEach(particle =\u003e {\n            particle.update(this.mouseX, this.mouseY);\n            particle.draw(this.ctx);\n        });\n\n        // 请求下一帧动画\n        this.animationId = requestAnimationFrame(() =\u003e this.animate());\n    }\n\n    /**\n     * 销毁粒子系统，清理资源\n     */\n    destroy() {\n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n        }\n    }\n}\n\n// ==================== React组件 ====================\nexport const ParticleWord: React.FC\u003cParticleWordProps\u003e = ({\n    text = 'MilkWind',  // 默认文本\n    className = ''      // 默认样式类\n}) =\u003e {\n    // React Hooks\n    const canvasRef = useRef\u003cHTMLCanvasElement\u003e(null);\n    const particleCanvasRef = useRef\u003cParticleCanvas | null\u003e(null);\n    const [isLoaded, setIsLoaded] = useState(false);\n    const {currentTheme} = useThemeStore();\n\n    // 组件生命周期管理\n    useEffect(() =\u003e {\n        if (canvasRef.current) {\n            // 清理旧的粒子系统\n            if (particleCanvasRef.current) {\n                particleCanvasRef.current.destroy();\n            }\n            \n            // 创建新的粒子系统\n            particleCanvasRef.current = new ParticleCanvas(canvasRef.current);\n            particleCanvasRef.current.generateTextParticles(text, currentTheme.colors.primary);\n            particleCanvasRef.current.animate();\n            setIsLoaded(true);\n        }\n\n        // 清理函数：组件卸载时清理资源\n        return () =\u003e {\n            if (particleCanvasRef.current) {\n                particleCanvasRef.current.destroy();\n            }\n        };\n    }, [text, currentTheme.colors.primary]); // 依赖数组：文本或主题色变化时重新创建\n\n    return (\n        \u003cdiv className={`flex justify-center items-center ${className}`}\u003e\n            \u003cdiv className=\"relative\"\u003e\n                {/* Canvas元素 */}\n                \u003ccanvas\n                    ref={canvasRef}\n                    width={CANVAS_WIDTH}\n                    height={CANVAS_HEIGHT}\n                    className=\"rounded-lg cursor-default\"\n                    style={{\n                        maxWidth: '100%',\n                        height: 'auto',\n                    }}\n                /\u003e\n                {/* 加载状态提示 */}\n                {!isLoaded \u0026\u0026 (\n                    \u003cdiv\n                        className=\"absolute inset-0 flex items-center justify-center\"\n                        style={{color: currentTheme.colors.foreground}}\n                    \u003e\n                        Loading particle animation...\n                    \u003c/div\u003e\n                )}\n            \u003c/div\u003e\n        \u003c/div\u003e\n    );\n};\n```\n\n### 核心算法流程图\n\n```\n文本输入 → 离屏Canvas渲染 → 像素采样 → 粒子生成 → 动画循环\n    ↓           ↓             ↓         ↓         ↓\n \"MilkWind\"  临时画布绘制   每3像素采样  创建粒子对象  RAF循环\n    ↓           ↓             ↓         ↓         ↓\n 设置字体    提取像素数据    Alpha\u003e128   随机初始位置  更新+绘制\n    ↓           ↓             ↓         ↓         ↓\n 居中绘制    RGBA数据结构   生成坐标点   向目标移动   鼠标交互\n```\n\n### 关键函数解析\n\n**1. 像素采样核心算法**\n```typescript\n// 关键：每3个像素采样一次，平衡性能与质量\nfor (let y = 0; y \u003c CANVAS_HEIGHT; y += 3) {\n    for (let x = 0; x \u003c CANVAS_WIDTH; x += 3) {\n        const index = (x + y * CANVAS_WIDTH) * 4;  // RGBA索引计算\n        const a = data[index + 3];                  // 获取Alpha值\n        if (a \u003e 128) {                             // Alpha阈值判断\n            // 生成粒子数据\n        }\n    }\n}\n```\n\n**2. 鼠标交互物理计算**\n```typescript\n// 关键：反比例衰减 + 向量分解\nconst distance = Math.sqrt(dx ** 2 + dy ** 2);    // 欧几里得距离\nlet disPercent = RADIUS / distance;               // 反比例衰减\ndisPercent = disPercent \u003e 7 ? 7 : disPercent;    // 力的上限\nconst angle = Math.atan2(dy, dx);                 // 角度计算\nconst repX = cos * disPercent * -INTENSITY;      // 力的分解\n```\n\n**3. 渐进式运动算法**\n```typescript\n// 关键：距离除以时间，实现自然减速\nthis.vx = (this.totalX - this.x) / this.time;    // 速度递减\nthis.x += this.vx;                                // 位置更新\nthis.opacity += OPACITY_STEP;                     // 透明度渐变\n```\n\n## 写在最后\n\n开发途中，我不止一次地感叹道，数学真的是一门很美的学科，当粒子们对鼠标的接近做出灵动的回应，当主题色切换时整个粒子云瞬间变幻——这些看似魔法的效果，实际上都是数学与代码的诗意结合。\n\n技术永远不只是冰冷的逻辑，它是创造美好体验的工具，是连接想象与现实的桥梁。\n\n*愿你的文字如星尘般闪耀，在用户的指尖下演绎着数字世界的粒子诗篇。* ✨\n"])</script><script>self.__next_f.push([1,"3e:Ta204,"])</script><script>self.__next_f.push([1,"\r\n# 技能星座：每个人都是自己的宇宙\r\n\r\n宇宙闪烁之......走错地儿了，不好意思。\r\n\r\n咳咳，回归正题，本篇会详细解析技能星座所用到的动态布局、概率算法、SVG连线和复杂动画的每一处设计细节，期待能给你带来些许灵感。\r\n\r\n## 双层结构设计\r\n\r\ndiv战神的匠心力作......好吧，只是为标题和星座功能各分配了一个承载容器。\r\n\r\n### 容器层设计\r\n\r\n组件的最外层是一个双容器系统。\r\n\r\n```typescript\r\nconst containerRef = useRef\u003cHTMLDivElement\u003e(null);\r\nconst boxRef = useRef\u003cHTMLDivElement\u003e(null);\r\nconst svgRef = useRef\u003cSVGSVGElement\u003e(null);\r\nconst [containerSize, setContainerSize] = useState\u003cPosition\u003e({x: 320, y: 320});\r\n```\r\n\r\n- **boxRef**: 负责整个组件的外层包装，主要用于标题文字效果的定位计算\r\n- **containerRef**: 负责星座区域的布局容器，专门处理气泡的位置计算和响应式变化\r\n\r\n这种分离设计的作用在于：当我需要计算文字效果时，我只关心 `boxRef`；当我需要重新布局气泡时，我只关心 `containerRef`。\r\n\r\n### SVG连接线条层\r\n\r\n```typescript\r\n{/* Connecting Lines */}\r\n\u003csvg ref={svgRef} className=\"absolute inset-0 w-full h-full pointer-events-none\"/\u003e\r\n```\r\n\r\n**为什么连接线需要独立的 SVG 层**？\r\n\r\n1. **渲染性能**: SVG 是矢量图形，适合绘制动态线条，GPU 友好\r\n2. **层级管理**: `pointer-events-none` 确保不干扰气泡的点击事件\r\n3. **坐标系统**: SVG 有自己的坐标系统，便于处理百分比定位\r\n\r\n### 坐标系统管理\r\n\r\n```typescript\r\nconst [containerSize, setContainerSize] = useState\u003cPosition\u003e({x: 320, y: 320});\r\n```\r\n\r\n`containerSize` 作用：\r\n\r\n- **像素坐标 → 百分比坐标**: 用于 SVG 线条的定位\r\n- **响应式计算**: 当容器尺寸变化时，所有元素需要重新计算位置\r\n- **边界约束**: 确保所有气泡都在可视范围内\r\n\r\n## 气泡组件的生命周期管理\r\n\r\n每个技能气泡都是一个独立的个体，有着自己的生命周期和行为模式。\r\n\r\n### SkillBubble 组件解析\r\n\r\n```typescript\r\nconst SkillBubble = React.memo(({\r\n    skill,\r\n    index,\r\n    size,\r\n    colorClass,\r\n    elementRef,\r\n    initialRotation,\r\n    borderRadius\r\n}: {\r\n    skill: string;\r\n    index: number;\r\n    size: number;\r\n    colorClass: string;\r\n    elementRef: React.RefObject\u003cHTMLDivElement | null\u003e;\r\n    initialRotation: number;\r\n    borderRadius: string;\r\n}) =\u003e {\r\n```\r\n\r\n**React.memo 的性能优化意义**：\r\n\r\n在一个包含多个气泡的系统中，任何一个气泡的重新渲染都可能触发其他气泡的不必要更新。`React.memo` 确保只有当 props 真正发生变化时，气泡才会重新渲染。\r\n\r\n**Props 参数解释**：\r\n\r\n- **skill**: 显示的技能文本\r\n- **index**: 用于计算动画延迟和各种差异化效果\r\n- **size**: 气泡大小，统一为75px但可扩展\r\n- **colorClass**: 预定义的渐变颜色类\r\n- **elementRef**: DOM 引用，用于位置操作\r\n- **initialRotation**: 初始旋转角度，营造自然感\r\n- **borderRadius**: 边框圆角样式，增加形状多样性\r\n\r\n### 初始化动画序列：渐进式入场\r\n\r\n```typescript\r\ninitial={{\r\n    opacity: 0,\r\n    scale: 0,\r\n    rotate: initialRotation,\r\n}}\r\nanimate={{\r\n    opacity: 1,\r\n    scale: 1,\r\n    rotate: initialRotation,\r\n    transition: {\r\n        duration: 0.5,\r\n        delay: 1 + (index * 0.15),\r\n    },\r\n}}\r\n```\r\n\r\n**动画延迟计算**：\r\n\r\n$$延迟时间 = 1 + (index \\times 0.15)$$\r\n\r\n假设有8个技能，延迟时间序列为：1.0s, 1.15s, 1.30s, 1.45s, 1.60s, 1.75s, 1.90s, 2.05s\r\n\r\n总的入场时间约为2.5秒，既不会让用户等太久，也能充分展现动画的层次感。\r\n\r\n### 悬浮交互系统\r\n\r\n```typescript\r\nwhileHover={{\r\n    scale: 1.2,\r\n    rotate: 0,\r\n    zIndex: 10,\r\n}}\r\ntransition={{\r\n    duration: 1.5,\r\n    type: \"spring\" as const,\r\n    stiffness: 120,\r\n    damping: 15,\r\n}}\r\n```\r\n\r\nSpring 动画模拟了真实的物理弹簧系统，比传统的缓动函数更自然：\r\n\r\n$$F = -kx - bv$$\r\n\r\n其中：\r\n- **k (stiffness)**: 弹簧常数，值为120，决定\"弹性\"强度\r\n- **b (damping)**: 阻尼系数，值为15，决定\"摩擦力\"大小\r\n\r\n**参数设定**：\r\n\r\n- **stiffness: 120**: 适中的弹性，既不会太\"硬\"也不会太\"软\"\r\n- **damping: 15**: 轻微的阻尼，避免过度震荡但保留弹性感\r\n- **duration: 1.5s**: 给足时间展现spring效果的全过程\r\n\r\n**状态变化**：\r\n\r\n- **scale: 1.2**: 20%的放大\r\n- **rotate: 0**: 重置旋转，让倾斜的气泡\"站直\"\r\n- **zIndex: 10**: 提升层级，确保悬浮的气泡在最上层\r\n\r\n## 视觉效果设计\r\n\r\n“你这玩意怎么是个贴图啊？”\r\n\r\n“毛！”\r\n\r\n### 轨道旋转系统\r\n\r\n```typescript\r\n{/* Orbital Ring */}\r\n\u003cmotion.div\r\n    animate={{\r\n        rotate: 360,\r\n    }}\r\n    transition={{\r\n        duration: 20 + index * 2,\r\n        repeat: Infinity,\r\n        ease: \"linear\",\r\n    }}\r\n    className=\"absolute inset-0 border border-primary/20\"\r\n    style={{ borderRadius }}\r\n/\u003e\r\n```\r\n\r\n**轨道设计思考**：\r\n\r\n我没有使用复杂的 SVG 圆形路径，而是简单地复用了气泡的 border 样式。`border + borderRadius` 的组合既创造了轨道环效果，又保持了与气泡形状的一致性。\r\n\r\n**旋转周期的差异化策略**：\r\n\r\n$$旋转周期 = 20 + (index \\times 2)$$\r\n\r\n这意味着：\r\n- 第1个气泡：20秒一圈\r\n- 第2个气泡：22秒一圈  \r\n- 第3个气泡：24秒一圈\r\n- ...\r\n\r\n不同的旋转速度模拟了真实的行星系统，每个星球都有自己的公转周期。\r\n\r\n### 呼吸效果\r\n\r\n```typescript\r\n\u003cmotion.div\r\n    animate={{\r\n        y: [0, -5, 0],\r\n    }}\r\n    transition={{\r\n        duration: 3 + index * 0.2,\r\n        repeat: Infinity,\r\n        ease: \"easeInOut\",\r\n    }}\r\n```\r\n\r\n**Y轴浮动的数学原理**：\r\n\r\n关键帧序列 `[0, -5, 0]` 创造了一个完整的呼吸周期：\r\n- **起始位置 (0)**: 正常位置\r\n- **高峰位置 (-5)**: 向上浮动5像素\r\n- **结束位置 (0)**: 回到正常位置\r\n\r\n**周期差异化的自然感**：\r\n\r\n$$呼吸周期 = 3 + (index \\times 0.2)$$\r\n\r\n这个公式确保每个气泡都有轻微不同的呼吸节奏，避免了机械式的同步摆动。3秒的基础周期接近人类的自然呼吸频率，0.2秒的差异足以打破同步但不会太明显。\r\n\r\n### Shimmer 渐变\r\n\r\n```typescript\r\n{/* Shimmer Effect */}\r\n\u003cmotion.div\r\n    animate={{\r\n        x: ['-100%', '100%'],\r\n    }}\r\n    transition={{\r\n        duration: 2,\r\n        repeat: Infinity,\r\n        repeatDelay: 3,\r\n        ease: \"easeInOut\",\r\n    }}\r\n    className=\"absolute -inset-4 bg-gradient-to-r from-transparent via-white/20 to-transparent transform rotate-45\"\r\n/\u003e\r\n```\r\n\r\n**Shimmer 光晕的工作原理**：\r\n\r\n1. **渐变遮罩**: `from-transparent via-white/20 to-transparent` 创造了一个中间亮、两端透明的光带\r\n2. **旋转变换**: `rotate-45` 将光带倾斜45度，模拟真实的光线角度\r\n3. **移动动画**: `x: ['-100%', '100%']` 让光带从左到右扫过整个气泡\r\n4. **完整覆盖:**`-inset-4`确保光带能够完整覆盖那些不规则的星座形状\r\n\r\n**动画时序**：\r\n\r\n- **duration: 2s**: 光晕扫过的时间\r\n- **repeatDelay: 3s**: 间隔3秒\r\n- **总周期**: 2s动画 + 3s间隔 = 5s\r\n\r\n## 背景星空生成\r\n\r\n总感觉空白的背景空荡荡的。\r\n\r\n```typescript\r\n    // 记忆化背景星空\r\nconst backgroundStars = useMemo(() =\u003e (\r\n    Array.from({length: 20}).map((_, i) =\u003e (\r\n        \u003cmotion.div\r\n            key={`star-${i}`}\r\n            initial={{opacity: 0, scale: 0}}\r\n            animate={{\r\n                opacity: [0, 1, 0.3, 1],\r\n                scale: [0, 1, 0.8, 1],\r\n            }}\r\n            transition={{\r\n                duration: 2 + Math.random() * 3,\r\n                repeat: Infinity,\r\n                delay: Math.random() * 2,\r\n            }}\r\n            className=\"absolute w-1 h-1 bg-primary/40 rounded-full\"\r\n            style={{\r\n                left: `${Math.random() * 100}%`,\r\n                top: `${Math.random() * 100}%`,\r\n            }}\r\n        /\u003e\r\n    ))\r\n), []);\r\n```\r\n\r\n### 随机分布算法\r\n\r\n**位置随机化**：\r\n```typescript\r\nleft: `${Math.random() * 100}%`,\r\ntop: `${Math.random() * 100}%`,\r\n```\r\n\r\n`Math.random()` 产生 [0, 1) 区间的均匀分布随机数，乘以100转换为百分比坐标。这确保了每颗星星都有相等的概率出现在容器的任何位置。\r\n\r\n**动画随机化的层次设计**：\r\n\r\n- **持续时间**: `2 + Math.random() * 3` → [2, 5)秒的随机周期\r\n- **延迟启动**: `Math.random() * 2` → [0, 2)秒的随机延迟\r\n- **闪烁序列**: `[0, 1, 0.3, 1]` → 渐现-全亮-半暗-全亮的自然闪烁\r\n\r\n### useMemo 优化\r\n\r\n```typescript\r\nconst backgroundStars = useMemo(() =\u003e (\r\n```\r\n\r\n**为什么星空需要 useMemo**？\r\n\r\n星空的生成涉及20次随机计算和DOM元素创建，如果在每次组件渲染时都重新生成，会导致：\r\n1. **性能问题**: 重复的随机计算和元素创建\r\n2. **视觉问题**: 星星位置不断变化，破坏了静态背景的效果\r\n3. **动画问题**: 重新创建的星星会重新开始动画，导致闪烁\r\n\r\n通过 `useMemo`，我们确保星空只在组件首次渲染时生成一次，之后保持稳定。\r\n\r\n## 布局算法：随机与秩序的平衡\r\n\r\n~~（抽卡总得有保底是不是）~~\r\n\r\n其实是技能变多了之后不易于阅读，所以加了个整齐排列的隐藏触发。\r\n\r\n### 随机分布模式\r\n\r\n```typescript\r\n// 生成随机位置并直接更新DOM\r\nconst updatePositions = useCallback(() =\u003e {\r\n    if (!containerRef.current) return;\r\n\r\n    const containerWidth = containerRef.current.offsetWidth;\r\n    const containerHeight = containerRef.current.offsetHeight;\r\n    const padding = 80;\r\n    // 减少气泡的宽度和高度\r\n    const minX = padding - 75;\r\n    const minY = padding - 75;\r\n    const maxX = containerWidth - padding;\r\n    const maxY = containerHeight - padding;\r\n\r\n    setContainerSize({x: containerWidth, y: containerHeight});\r\n\r\n    // 使用直接DOM操作更新位置\r\n    skillRefs.forEach((skillRef) =\u003e {\r\n        if (skillRef.elementRef.current) {\r\n\r\n            const newX = Math.random() * (maxX - minX) + minX;\r\n            const newY = Math.random() * (maxY - minY) + minY;\r\n\r\n            // 在ref中更新位置\r\n            skillRef.position = {x: newX, y: newY};\r\n\r\n            // 使用Framer Motion的animate函数执行位置动画\r\n            const element = skillRef.elementRef.current;\r\n            if (element.animate) {\r\n                element.animate(\r\n                    {\r\n                        left: `${newX}px`,\r\n                        top: `${newY}px`\r\n                    },\r\n                    {\r\n                        duration: 1500,\r\n                        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n                        fill: 'forwards'\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    // 更新连接线\r\n    updateConnectingLines();\r\n}, [skillRefs]);\r\n```\r\n\r\n### 边界约束计算\r\n\r\n```typescript\r\nconst padding = 80;\r\nconst minX = padding - 75;  // -75是气泡尺寸的一半+余量\r\nconst minY = padding - 75;\r\nconst maxX = containerWidth - padding;\r\nconst maxY = containerHeight - padding;\r\n```\r\n\r\n这个看似简单的计算实际上解决了一个复杂的几何问题：\r\n\r\n$$有效区域 = 容器尺寸 - 2 \\times padding - 气泡尺寸$$\r\n\r\n**为什么 minX 要减去75？**\r\n\r\n因为CSS的 `left` 属性定位的是元素的左上角，而我们希望整个气泡（包括中心和边缘）都在可视范围内。75px 包含了：\r\n- 气泡半径：37.5px\r\n- 安全余量：37.5px（确保悬浮效果不会超出边界）\r\n\r\n### DOM 直接操作\r\n\r\n```typescript\r\n// 使用Framer Motion的animate函数执行位置动画\r\nconst element = skillRef.elementRef.current;\r\nif (element.animate) {\r\n    element.animate(\r\n        {\r\n            left: `${newX}px`,\r\n            top: `${newY}px`\r\n        },\r\n        {\r\n            duration: 1500,\r\n            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n            fill: 'forwards'\r\n        }\r\n    );\r\n} else {\r\n    // 不支持Web Animations API的浏览器的降级方案\r\n    element.style.transition = 'left 1.5s ease, top 1.5s ease';\r\n    element.style.left = `${newX}px`;\r\n    element.style.top = `${newY}px`;\r\n}\r\n```\r\n\r\n**为什么选择直接DOM操作而不是状态更新？**\r\n\r\n8个气泡同时更新位置，如果通过state，会触发8次组件重渲染，因此简单选择Web Animations API 直接在合成器线程运行。\r\n\r\n**降级策略**：\r\n\r\n对于不支持 Web Animations API 的浏览器，程序额外提供了 CSS transition 的fallback方案，确保在所有环境下都有平滑的动画效果。\r\n\r\n### 网格布局模式\r\n\r\n```typescript\r\n// 生成整齐网格布局\r\nconst updatePositionsNeat = useCallback(() =\u003e {\r\n    if (!containerRef.current) return;\r\n\r\n    const containerWidth = containerRef.current.offsetWidth;\r\n    const containerHeight = containerRef.current.offsetHeight;\r\n\r\n    setContainerSize({x: containerWidth, y: containerHeight});\r\n\r\n    // 计算网格布局\r\n    const skillCount = skillRefs.length;\r\n    const cols = Math.ceil(Math.sqrt(skillCount));\r\n    const rows = Math.ceil(skillCount / cols);\r\n\r\n    // 计算间距以使网格居中\r\n    const padding = 5;\r\n    const availableWidth = containerWidth - (2 * padding);\r\n    const availableHeight = containerHeight - (2 * padding);\r\n    const cellWidth = availableWidth / cols;\r\n    const cellHeight = availableHeight / rows;\r\n\r\n    skillRefs.forEach((skillRef, index) =\u003e {\r\n        if (skillRef.elementRef.current) {\r\n            const col = index % cols;\r\n            const row = Math.floor(index / cols);\r\n\r\n            // 在水平和垂直方向上都使网格居中\r\n            const startX = padding + (cellWidth / 2) - 38;\r\n            const startY = padding + (cellHeight / 2) - 38;\r\n\r\n            const newX = startX + (col * cellWidth);\r\n            const newY = startY + (row * cellHeight);\r\n\r\n            // 在ref中更新位置\r\n            skillRef.position = {x: newX, y: newY};\r\n\r\n            // 使用Web Animations API执行位置动画\r\n            const element = skillRef.elementRef.current;\r\n            if (element.animate) {\r\n                element.animate(\r\n                    {\r\n                        left: `${newX}px`,\r\n                        top: `${newY}px`\r\n                    },\r\n                    {\r\n                        duration: 1500,\r\n                        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n                        fill: 'forwards'\r\n                    }\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    // 更新连接线\r\n    updateConnectingLines();\r\n}, [skillRefs]);\r\n```\r\n\r\n**网格计算解析**：\r\n\r\n核心思想是创建一个接近正方形的网格布局：\r\n\r\n$$列数 = \\sqrt{技能数量}$$\r\n$$行数 = \\frac{技能数量}{列数}$$\r\n\r\n例如，8个技能的计算过程：\r\n- $\\sqrt{8} = 2.83$\r\n- $列数 = \\lceil 2.83 \\rceil = 3$\r\n- $行数 = \\lceil \\frac{8}{3} \\rceil = \\lceil 2.67 \\rceil = 3$\r\n\r\n最终得到一个 3×3 的网格，其中最后一个位置为空。\r\n\r\n**居中对齐的几何计算**：\r\n\r\n```typescript\r\nconst startX = padding + (cellWidth / 2) - 38;\r\nconst startY = padding + (cellHeight / 2) - 38;\r\n```\r\n\r\n确保每个气泡的中心点对齐到网格的中心点：\r\n- `cellWidth / 2`: 网格单元的中心\r\n- `- 38`: 气泡半径的偏移（75px / 2 ≈ 38px）\r\n\r\n**响应式间距的动态计算**：\r\n\r\n```typescript\r\nconst cellWidth = availableWidth / cols;\r\nconst cellHeight = availableHeight / rows;\r\n```\r\n\r\n无论容器大小如何变化，网格都会自动调整间距，保持完美的比例和对齐。\r\n\r\n## 保底概率\r\n\r\n### 点击概率机制\r\n\r\n```typescript\r\n// 整齐布局的概率系统\r\nconst [clickCount, setClickCount] = useState(0);\r\nconst baseProbability = 0.1; // 10%基础概率\r\n```\r\n\r\n```typescript\r\n// 带概率系统的节流点击处理器\r\nconst handleContainerClick = useCallback(() =\u003e {\r\n    const currentTime = Date.now();\r\n    if (currentTime - lastClickTime.current \u003e= throttleDelay) {\r\n        lastClickTime.current = currentTime;\r\n\r\n        // 计算当前概率（随每次点击递增）\r\n        const currentProbability = Math.min(baseProbability + (clickCount * 0.15), 0.9); // 最大90%\r\n        const shouldUseNeatArrangement = Math.random() \u003c currentProbability;\r\n\r\n        if (shouldUseNeatArrangement) {\r\n            updatePositionsNeat();\r\n            setClickCount(0); // 成功整齐布局后重置概率\r\n        } else {\r\n            updatePositions();\r\n            setClickCount(prev =\u003e prev + 1); // 增加点击计数以提高概率\r\n        }\r\n    }\r\n}, [updatePositions, updatePositionsNeat, clickCount, baseProbability, throttleDelay]);\r\n```\r\n\r\n**概率递增算法**：\r\n\r\n$$P(整齐布局) = \\min(0.1 + 点击次数 \\times 0.15, 0.9)$$\r\n\r\n| 点击次数 | 概率值 |\r\n|---------|--------|\r\n| 1 | 10% |\r\n| 3 | 55% |\r\n| 5 | 85% |\r\n| 6+ | 90% |\r\n\r\n确保用户在若干次点击后能够一次性清晰地阅览所有技能。\r\n\r\n### 节流防抖\r\n\r\n```typescript\r\nconst lastClickTime = useRef\u003cnumber\u003e(0);\r\nconst throttleDelay = 500;\r\n```\r\n\r\n**500ms间隔**\r\n\r\n```typescript\r\nif (currentTime - lastClickTime.current \u003e= throttleDelay) {\r\n    lastClickTime.current = currentTime;\r\n    // 执行布局切换逻辑\r\n}\r\n```\r\n\r\n## SVG 连接线\r\n\r\n### 动态线条生成\r\n\r\n```typescript\r\n// 更新SVG连接线\r\nconst updateConnectingLines = useCallback(() =\u003e {\r\n    if (!svgRef.current || !containerSize.x || !containerSize.y) return;\r\n\r\n    const svg = svgRef.current;\r\n    // 清除现有线条\r\n    svg.innerHTML = '';\r\n\r\n    skillRefs.forEach((skillRef, index) =\u003e {\r\n        if (index === skillRefs.length - 1) return;\r\n\r\n        const currentPos = skillRef.position;\r\n        const nextPos = skillRefs[index + 1].position;\r\n\r\n        const x1 = (currentPos.x / containerSize.x) * 100 - 80;\r\n        const y1 = (currentPos.y / containerSize.y) * 100;\r\n        const x2 = (nextPos.x / containerSize.x) * 100 - 80;\r\n        const y2 = (nextPos.y / containerSize.y) * 100 + 75;\r\n\r\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n        line.setAttribute(\"x1\", `${x1}%`);\r\n        line.setAttribute(\"y1\", `${y1}%`);\r\n        line.setAttribute(\"x2\", `${x2}%`);\r\n        line.setAttribute(\"y2\", `${y2}%`);\r\n        line.setAttribute(\"stroke\", \"currentColor\");\r\n        line.setAttribute(\"stroke-width\", \"1\");\r\n        line.setAttribute(\"stroke-dasharray\", \"5,5\");\r\n        line.setAttribute(\"class\", \"text-primary/30\");\r\n        line.style.opacity = '0';\r\n\r\n        svg.appendChild(line);\r\n\r\n        // 线条出现动画\r\n        setTimeout(() =\u003e {\r\n            line.style.transition = 'opacity 2s ease-in-out';\r\n            line.style.opacity = '0.3';\r\n        }, 2000 + index * 100);\r\n    });\r\n}, [skillRefs, containerSize]);\r\n```\r\n\r\n**坐标变换的数学原理**：\r\n\r\n从像素坐标到SVG百分比坐标的转换：\r\n\r\n$$SVG_x = \\frac{Pixel_x}{Container_{width}} \\times 100\\%$$\r\n$$SVG_y = \\frac{Pixel_y}{Container_{height}} \\times 100\\%$$\r\n\r\n### 线条动画编排\r\n\r\n```typescript\r\n// 线条出现动画\r\nsetTimeout(() =\u003e {\r\n    line.style.transition = 'opacity 2s ease-in-out';\r\n    line.style.opacity = '0.3';\r\n}, 2000 + index * 100);\r\n```\r\n\r\n**渐进式显示的时序设计**：\r\n\r\n$$延迟时间 = 2000 + index \\times 100$$\r\n\r\n公式解析：\r\n- **基础延迟 2秒**: 给气泡足够的入场时间\r\n- **递增间隔 100ms**: 线条按顺序依次显现\r\n- **总时间控制**: 对于8个气泡，最后一条线在2.7秒时出现\r\n\r\n**线条牵引逻辑**：\r\n\r\n```typescript\r\n// 连接最后一个到第一个\r\nif (skillRefs.length \u003e 2) {\r\n    const lastPos = skillRefs[skillRefs.length - 1].position;\r\n    const firstPos = skillRefs[0].position;\r\n\r\n    const x1 = (lastPos.x / containerSize.x) * 100;\r\n    const y1 = (lastPos.y / containerSize.y) * 100;\r\n    const x2 = (firstPos.x / containerSize.x) * 100;\r\n    const y2 = (firstPos.y / containerSize.y) * 100;\r\n\r\n    const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n    line.setAttribute(\"x1\", `${x1}%`);\r\n    line.setAttribute(\"y1\", `${y1}%`);\r\n    line.setAttribute(\"x2\", `${x2}%`);\r\n    line.setAttribute(\"y2\", `${y2}%`);\r\n    line.setAttribute(\"stroke\", \"currentColor\");\r\n    line.setAttribute(\"stroke-width\", \"1\");\r\n    line.setAttribute(\"stroke-dasharray\", \"5,5\");\r\n    line.setAttribute(\"class\", \"text-primary/30\");\r\n    line.style.opacity = '0';\r\n\r\n    svg.appendChild(line);\r\n\r\n    setTimeout(() =\u003e {\r\n        line.style.transition = 'opacity 2s ease-in-out';\r\n        line.style.opacity = '0.3';\r\n    }, 2000 + skillRefs.length * 100);\r\n}\r\n```\r\n\r\n这个闭环设计创造了真正的\"星座\"效果——所有技能气泡都被连接在一个完整的图形中，象征着技能之间的相互关联。\r\n\r\n## 性能优化与内存管理\r\n\r\n```typescript\r\n// 为技能元素创建稳定的引用\r\nconst skillRefs = useMemo(() =\u003e {\r\n    return skills.map((skill) =\u003e ({\r\n        id: skill,\r\n        elementRef: React.createRef\u003cHTMLDivElement\u003e(),\r\n        position: {x: 0, y: 0}\r\n    }));\r\n}, [skills]);\r\n```\r\n\r\n**为什么使用 useMemo 缓存引用数组**？\r\n\r\n每个 `skillRef` 对象包含：\r\n- **id**: 技能名称标识\r\n- **elementRef**: DOM 元素引用\r\n- **position**: 位置状态缓存\r\n\r\n如果不使用 `useMemo`，每次组件重渲染都会创建新的引用对象，导致：\r\n1. **不必要的子组件重渲染**\r\n2. **DOM 引用丢失**\r\n3. **位置状态重置**\r\n\r\n**位置状态缓存设计**：\r\n\r\n```typescript\r\nskillRef.position = {x: newX, y: newY};\r\n```\r\n\r\n避免频繁的 getBoundingClientRect 调用。\r\n## 响应式设计\r\n\r\n### 容器尺寸监听：智能重布局\r\n\r\n```typescript\r\n// 处理容器大小调整\r\nuseEffect(() =\u003e {\r\n    const handleResize = () =\u003e {\r\n        if (containerRef.current) {\r\n            updatePositions();\r\n        }\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    return () =\u003e window.removeEventListener('resize', handleResize);\r\n}, [updatePositions]);\r\n```\r\n\r\n当窗口大小变化时，各个技能重新随机分布。\r\n\r\n### 边界保护算法\r\n\r\n无论在什么尺寸的设备上，所有气泡都必须完全可见：\r\n\r\n```typescript\r\nconst padding = 80;\r\nconst minX = padding - 75;\r\nconst minY = padding - 75;\r\nconst maxX = containerWidth - padding;\r\nconst maxY = containerHeight - padding;\r\n\r\n// 边界约束\r\nnewPos.x = Math.max(minX, Math.min(maxX, newX));\r\nnewPos.y = Math.max(minY, Math.min(maxY, newY));\r\n```\r\n\r\n## 完整源码全解析\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport React, {useCallback, useEffect, useMemo, useRef, useState} from 'react';\r\nimport {motion} from 'framer-motion';\r\nimport VariableProximity from \"@/components/ui/text/VariableProximity\";\r\n\r\n// ==================== 类型定义 ====================\r\ninterface SkillsConstellationProps {\r\n    skills: string[];      // 技能列表\r\n    title: string;         // 标题文本\r\n}\r\n\r\ninterface Position {\r\n    x: number;            // X坐标\r\n    y: number;            // Y坐标\r\n}\r\n\r\n// ==================== 技能气泡组件 ====================\r\n/**\r\n * 单个技能气泡组件，使用React.memo优化渲染性能\r\n * 包含完整的动画生命周期：入场 → 悬浮 → 交互\r\n */\r\nconst SkillBubble = React.memo(({\r\n    skill,              // 技能名称\r\n    index,              // 序号（用于计算动画延迟）\r\n    size,               // 气泡大小\r\n    colorClass,         // 颜色样式类\r\n    elementRef,         // DOM引用\r\n    initialRotation,    // 初始旋转角度\r\n    borderRadius       // 边框圆角样式\r\n}: {\r\n    skill: string;\r\n    index: number;\r\n    size: number;\r\n    colorClass: string;\r\n    elementRef: React.RefObject\u003cHTMLDivElement | null\u003e;\r\n    initialRotation: number;\r\n    borderRadius: string;\r\n}) =\u003e {\r\n    return (\r\n        \u003cmotion.div\r\n            ref={elementRef}\r\n            key={skill}\r\n            // 入场动画：从透明缩放到正常状态\r\n            initial={{\r\n                opacity: 0,\r\n                scale: 0,\r\n                rotate: initialRotation,\r\n            }}\r\n            animate={{\r\n                opacity: 1,\r\n                scale: 1,\r\n                rotate: initialRotation,\r\n                transition: {\r\n                    duration: 0.5,\r\n                    delay: 1 + (index * 0.15),  // 渐进式入场\r\n                },\r\n            }}\r\n            // 悬浮交互：放大+重置旋转+提升层级\r\n            whileHover={{\r\n                scale: 1.2,\r\n                rotate: 0,\r\n                zIndex: 10,\r\n            }}\r\n            transition={{\r\n                duration: 1.5,\r\n                type: \"spring\",\r\n                stiffness: 120,    // 弹簧硬度\r\n                damping: 15,       // 阻尼系数\r\n            }}\r\n            className=\"absolute group select-none\"\r\n            style={{\r\n                width: `${size}px`,\r\n                height: `${size}px`,\r\n                transform: `translate(-50%, -50%)`,\r\n                left: '50%',\r\n                top: '50%',\r\n            }}\r\n        \u003e\r\n            {/* 轨道环：创造天体运行的视觉效果 */}\r\n            \u003cmotion.div\r\n                animate={{\r\n                    rotate: 360,\r\n                }}\r\n                transition={{\r\n                    duration: 20 + index * 2,  // 差异化旋转周期\r\n                    repeat: Infinity,\r\n                    ease: \"linear\",\r\n                }}\r\n                className=\"absolute inset-0 border border-primary/20\"\r\n                style={{ borderRadius }}\r\n            /\u003e\r\n\r\n            {/* 主体气泡：包含呼吸效果和多层特效 */}\r\n            \u003cmotion.div\r\n                animate={{\r\n                    y: [0, -5, 0],  // 呼吸式浮动\r\n                }}\r\n                transition={{\r\n                    duration: 3 + index * 0.2,  // 差异化呼吸周期\r\n                    repeat: Infinity,\r\n                    ease: \"easeInOut\",\r\n                }}\r\n                className={`w-full h-full bg-gradient-to-br ${colorClass} backdrop-blur-sm flex items-center justify-center border-2 transition-all duration-300 relative overflow-hidden`}\r\n                style={{ borderRadius }}\r\n            \u003e\r\n                {/* Shimmer光晕效果：周期性的光线扫过 */}\r\n                \u003cmotion.div\r\n                    animate={{\r\n                        x: ['-100%', '100%'],\r\n                    }}\r\n                    transition={{\r\n                        duration: 2,\r\n                        repeat: Infinity,\r\n                        repeatDelay: 3,\r\n                        ease: \"easeInOut\",\r\n                    }}\r\n                    className=\"absolute -inset-4 bg-gradient-to-r from-transparent via-white/20 to-transparent transform rotate-45\"\r\n                /\u003e\r\n\r\n                {/* 技能文本：主要内容展示 */}\r\n                \u003cspan className=\"text-xs font-semibold text-center px-2 leading-tight z-10 text-foreground\"\u003e\r\n                    {skill}\r\n                \u003c/span\u003e\r\n\r\n                {/* 悬浮粒子效果：8个粒子的圆形爆发 */}\r\n                \u003cmotion.div\r\n                    initial={{opacity: 0, scale: 0}}\r\n                    whileHover={{opacity: 1, scale: 1}}\r\n                    className=\"absolute -inset-2\"\r\n                \u003e\r\n                    {Array.from({length: 8}).map((_, i) =\u003e (\r\n                        \u003cmotion.div\r\n                            key={i}\r\n                            initial={{opacity: 0, scale: 0}}\r\n                            whileHover={{\r\n                                opacity: [0, 1, 0],\r\n                                scale: [0, 1, 0],\r\n                                x: Math.cos(i * 0.785) * 30,  // 圆形分布\r\n                                y: Math.sin(i * 0.785) * 30,\r\n                            }}\r\n                            transition={{\r\n                                duration: 0.6,\r\n                                delay: i * 0.05,\r\n                            }}\r\n                            className=\"absolute top-1/2 left-1/2 w-1 h-1 bg-primary rounded-full\"\r\n                        /\u003e\r\n                    ))}\r\n                \u003c/motion.div\u003e\r\n            \u003c/motion.div\u003e\r\n        \u003c/motion.div\u003e\r\n    );\r\n});\r\n\r\nSkillBubble.displayName = 'SkillBubble';\r\n\r\n// ==================== 主组件：技能星座 ====================\r\nexport function SkillsConstellation({skills, title}: SkillsConstellationProps) {\r\n    // ==================== 状态管理 ====================\r\n    const containerRef = useRef\u003cHTMLDivElement\u003e(null);\r\n    const boxRef = useRef\u003cHTMLDivElement\u003e(null);\r\n    const svgRef = useRef\u003cSVGSVGElement\u003e(null);\r\n    const [containerSize, setContainerSize] = useState\u003cPosition\u003e({x: 320, y: 320});\r\n    const lastClickTime = useRef\u003cnumber\u003e(0);\r\n    const throttleDelay = 500;\r\n\r\n    // 概率系统：智能交互的核心\r\n    const [clickCount, setClickCount] = useState(0);\r\n    const baseProbability = 0.1; // 10%基础概率\r\n\r\n    // 稳定的技能引用数组\r\n    const skillRefs = useMemo(() =\u003e {\r\n        return skills.map((skill) =\u003e ({\r\n            id: skill,\r\n            elementRef: React.createRef\u003cHTMLDivElement\u003e(),\r\n            position: {x: 0, y: 0}  // 位置状态缓存\r\n        }));\r\n    }, [skills]);\r\n\r\n    // 颜色和属性的预计算\r\n    const skillColors = useMemo(() =\u003e [\r\n        'from-blue-500/20 to-purple-500/20 border-blue-400/50',\r\n        'from-green-500/20 to-teal-500/20 border-green-400/50',\r\n        'from-orange-500/20 to-red-500/20 border-orange-400/50',\r\n        // ... 更多颜色配置\r\n    ], []);\r\n\r\n    const skillProperties = useMemo(() =\u003e {\r\n        return skills.map((_, index) =\u003e {\r\n            const initialRotation = (Math.random() - 0.5) * 30;\r\n            const borderRadiusVariations = [\r\n                '50%', '40% 60% 60% 40%', '30% 70% 70% 30%',\r\n                // ... 更多形状变化\r\n            ];\r\n            \r\n            return {\r\n                initialRotation,\r\n                borderRadius: borderRadiusVariations[index % borderRadiusVariations.length],\r\n                colorClass: skillColors[index % skillColors.length]\r\n            };\r\n        });\r\n    }, [skills, skillColors]);\r\n\r\n    // ==================== 核心算法：布局更新 ====================\r\n    \r\n    /**\r\n     * 随机分布模式：模拟真实宇宙的随机性\r\n     */\r\n    const updatePositions = useCallback(() =\u003e {\r\n        if (!containerRef.current) return;\r\n\r\n        const containerWidth = containerRef.current.offsetWidth;\r\n        const containerHeight = containerRef.current.offsetHeight;\r\n        const padding = 80;\r\n        const minX = padding - 75;\r\n        const minY = padding - 75;\r\n        const maxX = containerWidth - padding;\r\n        const maxY = containerHeight - padding;\r\n\r\n        setContainerSize({x: containerWidth, y: containerHeight});\r\n\r\n        skillRefs.forEach((skillRef) =\u003e {\r\n            if (skillRef.elementRef.current) {\r\n                // 随机位置计算\r\n                const newX = Math.random() * (maxX - minX) + minX;\r\n                const newY = Math.random() * (maxY - minY) + minY;\r\n\r\n                // 更新位置缓存\r\n                skillRef.position = {x: newX, y: newY};\r\n\r\n                // 执行动画（Web Animations API + CSS fallback）\r\n                const element = skillRef.elementRef.current;\r\n                if (element.animate) {\r\n                    element.animate(\r\n                        {left: `${newX}px`, top: `${newY}px`},\r\n                        {duration: 1500, easing: 'cubic-bezier(0.4, 0, 0.2, 1)', fill: 'forwards'}\r\n                    );\r\n                } else {\r\n                    element.style.transition = 'left 1.5s ease, top 1.5s ease';\r\n                    element.style.left = `${newX}px`;\r\n                    element.style.top = `${newY}px`;\r\n                }\r\n            }\r\n        });\r\n\r\n        updateConnectingLines();\r\n    }, [skillRefs]);\r\n\r\n    /**\r\n     * 网格布局模式\r\n     */\r\n    const updatePositionsNeat = useCallback(() =\u003e {\r\n        if (!containerRef.current) return;\r\n\r\n        const containerWidth = containerRef.current.offsetWidth;\r\n        const containerHeight = containerRef.current.offsetHeight;\r\n        setContainerSize({x: containerWidth, y: containerHeight});\r\n\r\n        // 智能网格计算\r\n        const skillCount = skillRefs.length;\r\n        const cols = Math.ceil(Math.sqrt(skillCount));\r\n        const rows = Math.ceil(skillCount / cols);\r\n\r\n        const padding = 5;\r\n        const availableWidth = containerWidth - (2 * padding);\r\n        const availableHeight = containerHeight - (2 * padding);\r\n        const cellWidth = availableWidth / cols;\r\n        const cellHeight = availableHeight / rows;\r\n\r\n        skillRefs.forEach((skillRef, index) =\u003e {\r\n            if (skillRef.elementRef.current) {\r\n                const col = index % cols;\r\n                const row = Math.floor(index / cols);\r\n\r\n                // 居中对齐计算\r\n                const startX = padding + (cellWidth / 2) - 38;\r\n                const startY = padding + (cellHeight / 2) - 38;\r\n                const newX = startX + (col * cellWidth);\r\n                const newY = startY + (row * cellHeight);\r\n\r\n                skillRef.position = {x: newX, y: newY};\r\n\r\n                // 执行位置动画\r\n                const element = skillRef.elementRef.current;\r\n                if (element.animate) {\r\n                    element.animate(\r\n                        {left: `${newX}px`, top: `${newY}px`},\r\n                        {duration: 1500, easing: 'cubic-bezier(0.4, 0, 0.2, 1)', fill: 'forwards'}\r\n                    );\r\n                }\r\n            }\r\n        });\r\n\r\n        updateConnectingLines();\r\n    }, [skillRefs]);\r\n\r\n    /**\r\n     * SVG连接线系统\r\n     */\r\n    const updateConnectingLines = useCallback(() =\u003e {\r\n        if (!svgRef.current || !containerSize.x || !containerSize.y) return;\r\n\r\n        const svg = svgRef.current;\r\n        svg.innerHTML = ''; // 清除现有线条\r\n\r\n        // 根据技能气泡绘制相对应分布的线条\r\n        skillRefs.forEach((skillRef, index) =\u003e {\r\n            if (index === skillRefs.length - 1) return;\r\n\r\n            const currentPos = skillRef.position;\r\n            const nextPos = skillRefs[index + 1].position;\r\n\r\n            // 坐标转换：像素 → 百分比\r\n            const x1 = (currentPos.x / containerSize.x) * 100 - 80;\r\n            const y1 = (currentPos.y / containerSize.y) * 100;\r\n            const x2 = (nextPos.x / containerSize.x) * 100 - 80;\r\n            const y2 = (nextPos.y / containerSize.y) * 100 + 75;\r\n\r\n            // 创建SVG线条元素\r\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n            line.setAttribute(\"x1\", `${x1}%`);\r\n            line.setAttribute(\"y1\", `${y1}%`);\r\n            line.setAttribute(\"x2\", `${x2}%`);\r\n            line.setAttribute(\"y2\", `${y2}%`);\r\n            line.setAttribute(\"stroke\", \"currentColor\");\r\n            line.setAttribute(\"stroke-width\", \"1\");\r\n            line.setAttribute(\"stroke-dasharray\", \"5,5\");\r\n            line.setAttribute(\"class\", \"text-primary/30\");\r\n            line.style.opacity = '0';\r\n\r\n            svg.appendChild(line);\r\n\r\n            // 延迟显示动画\r\n            setTimeout(() =\u003e {\r\n                line.style.transition = 'opacity 2s ease-in-out';\r\n                line.style.opacity = '0.3';\r\n            }, 2000 + index * 100);\r\n        });\r\n\r\n        // 线条牵引连接\r\n        if (skillRefs.length \u003e 2) {\r\n            const lastPos = skillRefs[skillRefs.length - 1].position;\r\n            const firstPos = skillRefs[0].position;\r\n\r\n            const x1 = (lastPos.x / containerSize.x) * 100;\r\n            const y1 = (lastPos.y / containerSize.y) * 100;\r\n            const x2 = (firstPos.x / containerSize.x) * 100;\r\n            const y2 = (firstPos.y / containerSize.y) * 100;\r\n\r\n            const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n            // ... 设置线条属性\r\n            svg.appendChild(line);\r\n\r\n            setTimeout(() =\u003e {\r\n                line.style.transition = 'opacity 2s ease-in-out';\r\n                line.style.opacity = '0.3';\r\n            }, 2000 + skillRefs.length * 100);\r\n        }\r\n    }, [skillRefs, containerSize]);\r\n\r\n    // ==================== 交互系统 ====================\r\n    \r\n    /**\r\n     * 概率驱动的点击处理\r\n     */\r\n    const handleContainerClick = useCallback(() =\u003e {\r\n        const currentTime = Date.now();\r\n        if (currentTime - lastClickTime.current \u003e= throttleDelay) {\r\n            lastClickTime.current = currentTime;\r\n\r\n            // 概率计算：基础概率 + 累积增长\r\n            const currentProbability = Math.min(baseProbability + (clickCount * 0.15), 0.9);\r\n            const shouldUseNeatArrangement = Math.random() \u003c currentProbability;\r\n\r\n            if (shouldUseNeatArrangement) {\r\n                updatePositionsNeat();\r\n                setClickCount(0); // 成功后重置\r\n            } else {\r\n                updatePositions();\r\n                setClickCount(prev =\u003e prev + 1); // 失败后递增\r\n            }\r\n        }\r\n    }, [updatePositions, updatePositionsNeat, clickCount, baseProbability, throttleDelay]);\r\n\r\n    // ==================== 生命周期管理 ====================\r\n    \r\n    // 初始化设置\r\n    useEffect(() =\u003e {\r\n        if (containerRef.current \u0026\u0026 skills.length \u003e 0) {\r\n            setTimeout(() =\u003e {\r\n                updatePositions();\r\n            }, 1500);\r\n        }\r\n    }, [updatePositions, skills]);\r\n\r\n    // 响应式重布局\r\n    useEffect(() =\u003e {\r\n        const handleResize = () =\u003e {\r\n            if (containerRef.current) {\r\n                updatePositions();\r\n            }\r\n        };\r\n\r\n        window.addEventListener('resize', handleResize);\r\n        return () =\u003e window.removeEventListener('resize', handleResize);\r\n    }, [updatePositions]);\r\n\r\n    // 背景星空的记忆化生成\r\n    const backgroundStars = useMemo(() =\u003e (\r\n        Array.from({length: 20}).map((_, i) =\u003e (\r\n            \u003cmotion.div\r\n                key={`star-${i}`}\r\n                initial={{opacity: 0, scale: 0}}\r\n                animate={{\r\n                    opacity: [0, 1, 0.3, 1],\r\n                    scale: [0, 1, 0.8, 1],\r\n                }}\r\n                transition={{\r\n                    duration: 2 + Math.random() * 3,\r\n                    repeat: Infinity,\r\n                    delay: Math.random() * 2,\r\n                }}\r\n                className=\"absolute w-1 h-1 bg-primary/40 rounded-full\"\r\n                style={{\r\n                    left: `${Math.random() * 100}%`,\r\n                    top: `${Math.random() * 100}%`,\r\n                }}\r\n            /\u003e\r\n        ))\r\n    ), []);\r\n\r\n    // ==================== 渲染结构 ====================\r\n    return (\r\n        \u003cmotion.div\r\n            ref={boxRef}\r\n            initial={{opacity: 0, y: 20}}\r\n            animate={{opacity: 1, y: 0}}\r\n            transition={{delay: 1.1, duration: 0.8}}\r\n            className=\"mb-8 relative text-center\"\r\n        \u003e\r\n            {/* 标题：响应式文字效果 */}\r\n            \u003cVariableProximity\r\n                label={title}\r\n                className={'text-2xl text-foreground/90 mb-8 variable-proximity'}\r\n                containerRef={boxRef}\r\n                radius={100}\r\n                falloff='linear'\r\n            /\u003e\r\n\r\n            {/* 星座容器：双层结构的核心 */}\r\n            \u003cdiv\r\n                className=\"relative w-full h-80 mx-auto overflow-hidden\"\r\n                onClick={handleContainerClick}\r\n            \u003e\r\n                {/* 背景星空层 */}\r\n                \u003cdiv className=\"absolute inset-0\"\u003e\r\n                    {backgroundStars}\r\n                \u003c/div\u003e\r\n\r\n                {/* 技能星座层 */}\r\n                \u003cdiv ref={containerRef} className=\"relative w-full h-full\"\u003e\r\n                    {skillRefs.map((skillRef, index) =\u003e (\r\n                        \u003cSkillBubble\r\n                            key={skillRef.id}\r\n                            skill={skillRef.id}\r\n                            index={index}\r\n                            size={75}\r\n                            colorClass={skillProperties[index].colorClass}\r\n                            elementRef={skillRef.elementRef}\r\n                            initialRotation={skillProperties[index].initialRotation}\r\n                            borderRadius={skillProperties[index].borderRadius}\r\n                        /\u003e\r\n                    ))}\r\n\r\n                    {/* SVG连接线层 */}\r\n                    \u003csvg ref={svgRef} className=\"absolute inset-0 w-full h-full pointer-events-none\"/\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n        \u003c/motion.div\u003e\r\n    );\r\n}\r\n```\r\n\r\n## 写在最后\r\n\r\n我总觉得，人应当做一些不一样的创造，来让自己的作品显得不那么单调，即便是一个很简单的功能也有玩出花的可能。实际上从这个角度看，前端设计的潜力是无限的。\r\n\r\n*愿你的技能如星座般闪耀，在代码的宇宙中编织出最美的图案。* ✨\r\n"])</script><script>self.__next_f.push([1,"3f:Tf830,"])</script><script>self.__next_f.push([1,"\r\n# 技能星系：从概念到实现\r\n\r\n想象一下，如果你的技能可以像星系中的行星一样运行，围绕着你这个\"太阳\"有序而美妙地旋转，那会是怎样的视觉体验？......好吧，不强行升华了，总的来说我想通过一种富有创造力的形式来展现那些关键但寻常的信息，突破所谓的\"流水账式布局\"，给人一种\"嚯！有点意思！\"的感觉。\r\n\r\n通过React、TypeScript、Framer Motion以及原生的requestAnimationFrame技术栈，我们就能够创造出如此效果的高性能动画。\r\n\r\n接下来，我将从最基础的数学原理开始，逐步深入每一个实现细节，全面剖析技能星系的实现原理。\r\n\r\n## 圆周运动的数学基础\r\n\r\n一切始于数学。要让星球绕着中心旋转，我们首先需要理解如何将旋转角度转换为屏幕上的具体坐标位置。\r\n\r\n### 极坐标系统的转换\r\n\r\n在我们的星系中，每个星球都遵循极坐标系统的规律。极坐标用`(r, θ)`来描述一个点的位置——`r`是到中心的距离（轨道半径），`θ`是角度。这种描述方式非常适合圆周运动，因为我们只需要改变角度，就能让星球沿着圆形轨道移动。\r\n\r\n但浏览器的世界是笛卡尔坐标系统，用`(x, y)`来定位元素。所以我们需要进行坐标转换：\r\n\r\n```typescript\r\n// 这就是让星球\"转起来\"的核心公式\r\nconst planetX = galaxyCenter.x + Math.cos(angle * Math.PI / 180) * orbitRadius;\r\nconst planetY = galaxyCenter.y + Math.sin(angle * Math.PI / 180) * orbitRadius;\r\n```\r\n\r\n这里有几个关键点值得注意：\r\n- `galaxyCenter.x` 和 `galaxyCenter.y` 是星系的中心坐标\r\n- `Math.cos()` 和 `Math.sin()` 是三角函数，负责将角度转换为坐标\r\n- `angle * Math.PI / 180` 将角度从度数转换为弧度（JavaScript的三角函数需要弧度）\r\n- `orbitRadius` 是轨道半径，决定星球离中心有多远\r\n\r\n### 简单示例：让一个点转起来\r\n\r\n让我用一个最简单的例子来展示这个原理：\r\n\r\n```typescript\r\n// 假设我们有一个中心点 (400, 300) 和半径 100px 的圆\r\nconst centerX = 400;\r\nconst centerY = 300;\r\nconst radius = 100;\r\nlet angle = 0;\r\n\r\n// 每一帧更新位置\r\nfunction updatePosition() {\r\n    const x = centerX + Math.cos(angle * Math.PI / 180) * radius;\r\n    const y = centerY + Math.sin(angle * Math.PI / 180) * radius;\r\n    \r\n    // 更新元素位置\r\n    element.style.left = x + 'px';\r\n    element.style.top = y + 'px';\r\n    \r\n    // 角度递增，让它转起来\r\n    angle += 1;\r\n    \r\n    requestAnimationFrame(updatePosition);\r\n}\r\n```\r\n\r\n这就是圆周运动的基础——技能星系的旋转效果建立在此基础原理之上。\r\n\r\n## 多层轨道系统的实现策略\r\n\r\n现在我们知道了如何让一个星球转起来，但一个真正的星系需要多条轨道，需要合理地分配星球，还要让它们看起来自然而不拥挤。\r\n\r\n### 轨道数是如何指定的？而星球又是如何平均分配到这些轨道上的？\r\n\r\n我们实际上指定的是一个轨道数的上限，该上限由技能数决定：\r\n\r\n```typescript\r\nconst orbitIndex = index % 7;\r\n```\r\n\r\n在这里，这个上限是7，也就是说最多含有7条轨道。\r\n\r\n举例来说，假设我们有15个技能：\r\n\r\n```\r\n技能0: index=0, orbitIndex=0%7=0 → 第1条轨道\r\n技能1: index=1, orbitIndex=1%7=1 → 第2条轨道\r\n技能2: index=2, orbitIndex=2%7=2 → 第3条轨道\r\n...\r\n技能7: index=7, orbitIndex=7%7=0 → 又回到第1条轨道\r\n技能8: index=8, orbitIndex=8%7=1 → 第2条轨道\r\n```\r\n\r\n### 轨道半径的计算\r\n\r\n```typescript\r\nconst orbitRadius = 100 + orbitIndex * 50; // 100px, 150px, 200px, 250px, 300px, 350px, 400px orbits\r\n```\r\n\r\n每条轨道的半径按照`100 + orbitIndex * 50`的规律递增：\r\n- 第1条轨道：100px\r\n- 第2条轨道：150px \r\n- 第3条轨道：200px\r\n- ...以此类推到400px\r\n\r\n### 避免星球在一开始就挤在一起\r\n\r\n为了让星球初始在同一轨道上不会重叠，我给每个星球分配了不同的初始角度：\r\n\r\n```typescript\r\nconst [angle, setAngle] = useState(index * 60); // 初始角度按index递增\r\n```\r\n\r\n### 轨道的视觉实现\r\n\r\n轨道本身是通过CSS创建的透明圆环：\r\n\r\n```html\r\n\u003cdiv\r\n    className=\"absolute border border-white/10 rounded-full pointer-events-none\"\r\n    style={{\r\n        width: orbitRadius * 2,\r\n        height: orbitRadius * 2,\r\n        left: galaxyCenter.x - orbitRadius,\r\n        top: galaxyCenter.y - orbitRadius,\r\n    }}\r\n/\u003e\r\n```\r\n\r\n这里有个重要的细节：`left: galaxyCenter.x - orbitRadius`。因为CSS定位是基于元素的左上角，所以我们需要向左向上偏移一个轨道半径的距离，才能让圆心对准星系中心。\r\n\r\n## Z-index与渲染层次控制\r\n\r\n在一个需求层次关系的3D效果中，元素间的层级关系的管理至关重要。具体如下：\r\n\r\n```typescript\r\n// 太阳中心 - 最高层级\r\n\u003cmotion.div className=\"absolute z-20 w-24 h-24 ...\"\u003e\r\n\r\n// 轨道 - 不响应鼠标事件\r\n\u003cdiv className=\"... pointer-events-none\"\u003e\r\n\r\n// 星球 - 可交互层级\r\n\u003cmotion.div className=\"... pointer-events-auto\"\u003e\r\n```\r\n\r\n这个设计有几个关键点：\r\n1. **太阳永远在最前面**：`z-20`确保中心的太阳不会被星球遮挡\r\n2. **轨道不干扰交互**：`pointer-events-none`让用户可以点击轨道上的星球，而不是轨道本身\r\n3. **星球可以交互**：`pointer-events-auto`让每个星球都能响应鼠标事件\r\n\r\n这种层级设计让用户能够自然地与星球交互，同时保持视觉层次的清晰性。\r\n\r\n## 动画循环实现\r\n\r\n现在到了最核心的部分——如何让这个星系平滑地转动起来。\r\n\r\n### 为什么选择requestAnimationFrame？\r\n\r\n相比于`setInterval`或`setTimeout`，`requestAnimationFrame`有几个无可替代的优势：\r\n- **与浏览器刷新率同步**：通常是60fps，给用户最流畅的体验\r\n- **自动优化**：当页面不可见时会暂停，节省CPU资源\r\n- **时间精确**：提供高精度的时间戳\r\n\r\n### 动画循环核心实现\r\n\r\n以下是实现平滑动画的核心代码：\r\n\r\n```typescript\r\nconst animate = (currentTime: number) =\u003e {\r\n    if (!lastTimeRef.current) lastTimeRef.current = currentTime;\r\n    const deltaTime = currentTime - lastTimeRef.current;\r\n    lastTimeRef.current = currentTime;\r\n    \r\n    frameCountRef.current++;\r\n    \r\n    // 采用帧率控制策略 - 每2帧更新一次位置\r\n    if (frameCountRef.current % 2 === 0) {\r\n        const currentData = planetsDataRef.current;\r\n        \r\n        // 更新星球位置和角度\r\n        const updatedPlanets = currentData.map(planet =\u003e {\r\n            if (planet.isPaused) return planet;\r\n\r\n            const baseSpeed = 0.15 + planet.orbitIndex * 0.08;\r\n            const currentSpeed = baseSpeed * planet.speedMultiplier * planet.collisionSpeedBoost;\r\n            const newAngle = (planet.angle + currentSpeed * deltaTime * 0.01) % 360;\r\n            const normalizedAngle = newAngle \u003c 0 ? newAngle + 360 : newAngle;\r\n\r\n            return {\r\n                ...planet,\r\n                angle: normalizedAngle,\r\n                x: galaxyCenter.x + Math.cos(normalizedAngle * Math.PI / 180) * planet.orbitRadius,\r\n                y: galaxyCenter.y + Math.sin(normalizedAngle * Math.PI / 180) * planet.orbitRadius,\r\n            };\r\n        });\r\n\r\n        // 每4帧进行一次碰撞检测（搅动时保持高频率）\r\n        let finalPlanets = updatedPlanets;\r\n        if (frameCountRef.current % 4 === 0 || isStirring) {\r\n            finalPlanets = detectCollisions(updatedPlanets);\r\n        }\r\n\r\n        // 只在有实际变化时更新状态\r\n        if (finalPlanets !== currentData) {\r\n            planetsDataRef.current = finalPlanets;\r\n            setPlanetsData(finalPlanets);\r\n        }\r\n    }\r\n    \r\n    animationRef.current = requestAnimationFrame(animate);\r\n};\r\n```\r\n\r\n主要功能解释：\r\n\r\n1. **初始化时间戳**：第一次调用时设置基准时间\r\n2. **计算时间差**：`deltaTime`是距离上次更新的毫秒数\r\n3. **更新时间戳**：为下次计算做准备\r\n4. **角度累积**：根据时间差按比例更新角度\r\n\r\n### 控制星球初始公转速度的0.01系数\r\n\r\n你可能注意到了`deltaTime * 0.01`这个系数。其意义为：\r\n- `deltaTime`的单位是毫秒，通常在16-17ms左右（60fps）\r\n- 乘以0.01后，每帧大概增加0.16-0.17度\r\n- 这个速度让星球的运动看起来既不会太快眼花缭乱，也不会太慢显得迟钝\r\n\r\n### 动画生命周期的管理\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    animationRef.current = requestAnimationFrame(animate);\r\n    \r\n    return () =\u003e {\r\n        if (animationRef.current) {\r\n            cancelAnimationFrame(animationRef.current);\r\n        }\r\n    };\r\n}, [isPaused, currentSpeed]);\r\n```\r\n\r\n这个useEffect确保了：\r\n- 组件挂载时启动动画\r\n- 组件卸载时清理动画，防止内存泄漏\r\n- 当暂停状态或速度改变时重启动画循环\r\n\r\n## 仿真天体运行的速度差异\r\n\r\n真实的太阳系中，内层行星运行得比外层行星快。这个物理现象被称为开普勒第三定律，我在星系中也模拟了这个效果：\r\n\r\n```typescript\r\nconst baseSpeed = 0.15 + orbitIndex * 0.08; // 基础速度加轨道系数\r\nconst currentSpeed = baseSpeed * speedMultiplier * collisionSpeedBoost;\r\n```\r\n\r\n让我们看看实际的速度分布：\r\n- 第1条轨道（orbitIndex=0）：0.15 - 最快\r\n- 第2条轨道（orbitIndex=1）：0.23\r\n- 第3条轨道（orbitIndex=2）：0.31\r\n- 第4条轨道（orbitIndex=3）：0.39\r\n- 第5条轨道（orbitIndex=4）：0.47\r\n- 第6条轨道（orbitIndex=5）：0.55\r\n- 第7条轨道（orbitIndex=6）：0.63 - 最慢\r\n\r\n......但是！如果你稍稍观察就会发现，在我的技能星系中，外层轨道实际上比内层轨道转得更快（数值更大）。这和真实的物理世界是相反的。\r\n\r\n而我选择故意保留这个\"bug\"，因为从实际的视觉体验上来说，外层轨道转得稍快一些实际上创造了更好的动态感。这波是艺术效果\u003e物理准确性a.a\r\n\r\n`speedMultiplier`是一个星球组件的扩展属性，它为\"搅动星系\"功能预留了接口，平时保持为1，需要加速时可以变成4-14倍。\r\n\r\n## 交互反馈\r\n\r\n用户体验的精髓在于反馈。当鼠标悬停在星球上时，会显现以下反应。\r\n\r\n### 智能暂停机制\r\n\r\n```typescript\r\nconst handleMouseEnter = useCallback((index: number) =\u003e {\r\n    const currentData = planetsDataRef.current;\r\n    const newData = currentData.map((planet, i) =\u003e\r\n        i === index ? {...planet, isPaused: true, isHovered: true} : planet\r\n    );\r\n    planetsDataRef.current = newData;\r\n    setPlanetsData(newData);\r\n}, []);\r\n\r\nconst handleMouseLeave = useCallback((index: number) =\u003e {\r\n    const currentData = planetsDataRef.current;\r\n    const newData = currentData.map((planet, i) =\u003e\r\n        i === index ? {...planet, isPaused: false, isHovered: false} : planet\r\n    );\r\n    planetsDataRef.current = newData;\r\n    setPlanetsData(newData);\r\n}, []);\r\n```\r\n\r\n通过`useCallback`优化的事件处理器确保了回调函数的引用稳定性，当用户悬停时，对应的星球会优雅地停下来，同时更新悬停状态，就像时间被冻结了一样。这个细节让用户能够仔细查看星球信息，而不会被持续的运动分散注意力。\r\n\r\n### 多层次状态样式系统\r\n\r\n```typescript\r\nclassName={`\r\n    w-16 h-16 rounded-full \r\n    bg-gradient-to-br from-white/20 to-white/5\r\n    backdrop-blur-sm border border-white/20\r\n    flex items-center justify-center\r\n    transition-all duration-300\r\n    ${planetData.isHovered ? 'bg-primary/30 border-primary/50 shadow-lg shadow-primary/20' : ''}\r\n    ${planetData.speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n    ${planetData.isCollided ? 'bg-red-500/30 border-red-400/50 shadow-lg shadow-red-400/20' : ''}\r\n    ${planetData.collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30 border-yellow-400/50 shadow-lg shadow-yellow-400/20' : ''}\r\n`}\r\n```\r\n\r\n这个多层次条件样式系统让星球能够根据不同状态展现丰富的视觉反馈：\r\n- **默认状态**：半透明白色，低调优雅\r\n- **悬停状态**：主题色高亮，增加阴影\r\n- **搅动状态**：紫色强调，表示正在高速运行\r\n- **碰撞状态**：红色警示，标示危险状态\r\n- **爆发状态**：黄色高亮，展示能量释放\r\n\r\n### 信息面板的动态更新\r\n\r\n最下方的信息面板通过`AnimatePresence`实现平滑的内容切换：\r\n\r\n```typescript\r\n\u003cAnimatePresence mode=\"wait\"\u003e\r\n    \u003cmotion.div\r\n        key={hoveredSkill?.category || 'default'}\r\n        initial={{opacity: 0, y: 20}}\r\n        animate={{opacity: 1, y: 0}}\r\n        exit={{opacity: 0, y: -20}}\r\n        transition={{duration: 0.3}}\r\n    \u003e\r\n        \u003ch4 className=\"text-xl font-bold text-white mb-2\"\u003e\r\n            {hoveredSkill?.category || t('personal.fullStackEngineer')}\r\n        \u003c/h4\u003e\r\n        \u003cp className=\"text-gray-300 text-sm leading-relaxed\"\u003e\r\n            {hoveredSkill?.description || t('personal.galaxyDefaultDescription')}\r\n        \u003c/p\u003e\r\n    \u003c/motion.div\u003e\r\n\u003c/AnimatePresence\u003e\r\n```\r\n\r\n`mode=\"wait\"`确保旧内容完全消失后才显示新内容，避免了重叠闪烁的问题。\r\n\r\n## 动态交互的随机化实现\r\n\r\n\"搅动星系\"功能模拟了对星系施加外力的效果，从而让这个星系显得不那么死板。\r\n\r\n### 随机选择算法\r\n\r\n```typescript\r\nconst numPlanetsToStir = Math.min(resumeData.skills.length, \r\n    Math.floor(resumeData.skills.length * Math.random() + 1));\r\n```\r\n\r\n- `resumeData.skills.length * Math.random() + 1`：产生1到总数之间的随机数\r\n- `Math.floor()`：向下取整\r\n- `Math.min()`：确保不会超过总星球数\r\n\r\n这意味着每次搅动，都会有随机数量的星球被影响，增加了不可预测性。\r\n\r\n### 避免重复选择\r\n\r\n```typescript\r\nconst indicesToStir: number[] = [];\r\n\r\nwhile (indicesToStir.length \u003c numPlanetsToStir) {\r\n    const randomIndex = Math.floor(Math.random() * resumeData.skills.length);\r\n    if (!indicesToStir.includes(randomIndex)) {\r\n        indicesToStir.push(randomIndex);\r\n    }\r\n}\r\n```\r\n\r\n这个while循环确保每个星球最多只被选中一次，避免了浪费\"搅动名额\"的情况。\r\n\r\n### 速度的增加算法\r\n\r\n```typescript\r\nsetPlanetSpeeds(prev =\u003e {\r\n    const newSpeeds = [...prev];\r\n    indicesToStir.forEach(index =\u003e {\r\n        // Set random speed\r\n        newSpeeds[index] = 4 + Math.random() * 10;\r\n    });\r\n    return newSpeeds;\r\n});\r\n```\r\n\r\n被选中的星球会获得4-14倍的随机速度，随机性让每次搅动都有不同的视觉效果。\r\n### 恢复机制\r\n\r\n```typescript\r\nsetTimeout(() =\u003e {\r\n    setPlanetSpeeds(prev =\u003e {\r\n        const resetSpeeds = [...prev];\r\n        indicesToStir.forEach(index =\u003e {\r\n            resetSpeeds[index] = 1;\r\n        });\r\n        return resetSpeeds;\r\n    });\r\n}, 3000);\r\n```\r\n\r\n3秒后，所有星球都会恢复到正常速度。这个时间长度刚好：不会太短让用户看不清效果，也不会太长让用户感到厌烦。\r\n\r\n### 高速状态的视觉提示\r\n\r\n当星球处于高速状态时，会显示特殊的紫色样式：\r\n\r\n```typescript\r\n${speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n```\r\n\r\n## 中心天体的动态光效设计\r\n\r\n为了使得中心的太阳不显得像个装饰品，我给它添加了一些隐约但观感舒适的光效动画。\r\n\r\n### 呼吸般的光晕变化\r\n\r\n```typescript\r\nanimate={{\r\n    boxShadow: [\r\n        \"0 0 30px rgba(255, 193, 7, 0.5)\",\r\n        \"0 0 50px rgba(255, 193, 7, 0.8)\",\r\n        \"0 0 30px rgba(255, 193, 7, 0.5)\"\r\n    ]\r\n}}\r\ntransition={{\r\n    duration: 3,\r\n    repeat: Infinity,\r\n    ease: \"easeInOut\"\r\n}}\r\n```\r\n\r\n这个动画创造了\"呼吸\"的效果：\r\n- **30px阴影**：收缩状态，较为内敛\r\n- **50px阴影**：扩张状态，光芒四射\r\n- **0.5→0.8→0.5透明度**：配合大小变化，增强明暗对比\r\n- **3秒周期**：不会太快显得焦躁，不会太慢显得迟缓\r\n- **easeInOut**：自然的加速和减速，就像真实的呼吸\r\n\r\n### 多层光晕\r\n\r\n```typescript\r\n{/* 主体太阳 */}\r\n\u003cdiv className=\"w-full h-full rounded-full bg-gradient-to-br from-amber-300 via-yellow-400 to-orange-500\"\u003e\r\n    👨‍💻\r\n\u003c/div\u003e\r\n\r\n{/* 背景光晕 */}\r\n\u003cdiv className=\"absolute inset-0 rounded-full bg-gradient-to-br from-amber-300/30 to-orange-500/30 animate-pulse -z-10 scale-150\"/\u003e\r\n```\r\n\r\n这里有两层光效：\r\n1. **主体太阳**：实体的渐变色彩，从琥珀色到橙色\r\n2. **背景光晕**：更大、更透明、有脉动效果的光圈\r\n\r\n`scale-150`让背景光晕比主体大50%，`-z-10`确保它在背景中，创造了多层次的光效。\r\n\r\n## 动态布局的中心定位系统\r\n\r\n在响应式设计中，星系的中心位置需要根据容器大小动态调整，避免窗口大小切换时出现星系偏移问题。\r\n\r\n### 中心计算\r\n\r\n```typescript\r\nconst updateCenter = () =\u003e {\r\n    if (galaxyRef.current) {\r\n        const rect = galaxyRef.current.getBoundingClientRect();\r\n        setGalaxyCenter({\r\n            x: rect.width / 2,\r\n            y: rect.height / 2\r\n        });\r\n    }\r\n};\r\n```\r\n\r\n`getBoundingClientRect()`是获取DOM元素实际尺寸的最可靠方法，它返回的是元素在页面中的实际渲染尺寸，包括了padding和所有样式影响。\r\n\r\n### 响应式监听\r\n\r\n```typescript\r\nuseEffect(() =\u003e {\r\n    updateCenter();\r\n    window.addEventListener('resize', updateCenter);\r\n    \r\n    return () =\u003e window.removeEventListener('resize', updateCenter);\r\n}, []);\r\n```\r\n\r\n这个effect做了三件事：\r\n1. **组件挂载时**：立即计算一次中心位置\r\n2. **窗口调整时**：重新计算中心位置\r\n3. **组件卸载时**：清理事件监听器，防止内存泄漏\r\n\r\n### 默认值的保险策略\r\n\r\n```typescript\r\nconst [galaxyCenter, setGalaxyCenter] = useState({x: 350, y: 350});\r\n```\r\n\r\n`{x: 350, y: 350}`这个默认值根据700x700px的容器计算而来，提供了以下功能：\r\n\r\n- 在实际尺寸计算完成前提供一个合理的初始位置\r\n- 避免初始渲染时星球位置的突然跳跃\r\n\r\n### getBoundingClientRect vs offsetWidth\r\n\r\n你可能会问，为什么不用`offsetWidth`和`offsetHeight`？\r\n\r\n```typescript\r\n// 这样不够准确\r\nconst width = galaxyRef.current.offsetWidth;\r\nconst height = galaxyRef.current.offsetHeight;\r\n\r\n// 这样更精确\r\nconst rect = galaxyRef.current.getBoundingClientRect();\r\nconst width = rect.width;\r\nconst height = rect.height;\r\n```\r\n\r\n`getBoundingClientRect()`提供了更精确的小数值，而`offsetWidth`只返回整数，在一些精细的布局中可能会导致1-2像素的偏差。\r\n\r\n## 星球碰撞系统\r\n\r\n我从让多个星球运行在同一个轨道上的那一刻就在思索了：得整点合理的东西。（真的合理吗？）\r\n\r\n### 碰撞检测的数学原理\r\n\r\n要判断两个在圆形轨道上运动的星球是否\"相撞\"，我们需要比较它们在极坐标系统中的角度差异。\r\n\r\n```typescript\r\n// 碰撞检测的核心逻辑\r\nconst angleDiff = Math.abs(otherPlanet.angle - currentPlanet.angle);\r\nconst normalizedAngleDiff = Math.min(angleDiff, 360 - angleDiff);\r\n\r\nif (normalizedAngleDiff \u003c collisionThreshold) {\r\n    // 碰撞发生！\r\n}\r\n```\r\n\r\n这里有个重要的数学细节：**角度差的标准化**。\r\n\r\n想象一下，如果一个星球在350°位置，另一个在10°位置，简单的`Math.abs(350 - 10) = 340°`会告诉我们它们相距很远。但实际上，它们只相差20°（350° → 360° → 10°）！\r\n\r\n所以我们用`Math.min(angleDiff, 360 - angleDiff)`来找到最小的角度距离，这样就解决了\"跨越0°边界\"的问题。\r\n\r\n### 碰撞阈值\r\n\r\n```typescript\r\nconst collisionThreshold = 13; // Angular distance threshold in degrees\r\n```\r\n\r\n随便设置的碰撞阈值，因为13可能是一个幸运数字（？\r\n\r\n### 同轨道碰撞原则\r\n\r\n```typescript\r\n// 只有同轨道的星球才能碰撞\r\nfor (let j = 0; j \u003c updatedPlanets.length; j++) {\r\n    if (i === j || updatedPlanets[j].orbitIndex !== planet.orbitIndex) continue;\r\n    // ...碰撞检测逻辑\r\n}\r\n```\r\n\r\n这个设计遵循了物理直觉：只有在同一轨道上的星球才能相遇。不同轨道的星球虽然在视觉上可能很接近，但它们在三维空间中处于不同的\"高度\"，不会发生碰撞。\r\n\r\n~~（其实是多轨道碰撞实现起来太复杂了，还需要计算二维欧几里得距离等等，干脆直接摸鱼好了）~~\r\n\r\n### 碰撞生命周期\r\n\r\n每个星球的碰撞状态遵循一个简单的状态机：\r\n\r\n```\r\n正常运行 → 检测到邻近星球 → 触发碰撞 → 粒子效果 → 速度爆发 → 恢复正常\r\n   ↑                                                    ↓\r\n   ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←\r\n```\r\n\r\n**关键的状态控制逻辑**：\r\n\r\n```typescript\r\nif (hasNearbyPlanet \u0026\u0026 !planet.isCollided) {\r\n    // 首次检测到碰撞 - 触发效果\r\n    updatedPlanets[i] = {\r\n        ...planet,\r\n        isCollided: true,\r\n        showParticles: true,\r\n        collisionSpeedBoost: 4 + Math.random() * 10\r\n    };\r\n} else if (!hasNearbyPlanet \u0026\u0026 planet.isCollided) {\r\n    // 不再有邻近星球 - 清除碰撞标记\r\n    updatedPlanets[i] = {\r\n        ...planet,\r\n        isCollided: false\r\n    };\r\n}\r\n```\r\n\r\n这个`!planet.isCollided`的条件需要注意，它确保了：\r\n- **只在首次检测到碰撞时触发效果**，而不是每一帧都重复触发\r\n- **碰撞效果不会无限叠加**，避免性能问题\r\n- **状态转换的清晰性**，每个星球在任何时刻都有明确的状态\r\n\r\n### 粒子效果\r\n\r\n当碰撞发生时，我们会在碰撞点生成一个绚烂的粒子爆炸效果：\r\n\r\n```typescript\r\nfunction ParticleEffect({ x, y, isActive, onComplete }: ParticleEffectProps) {\r\n    // 32个粒子，呈放射状散开\r\n    {[...Array(32)].map((_, i) =\u003e (\r\n        \u003cmotion.div\r\n            key={i}\r\n            className=\"absolute w-5 h-5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full\"\r\n            animate={{\r\n                x: Math.cos((i * 11.25) * Math.PI / 180) * 150,\r\n                y: Math.sin((i * 11.25) * Math.PI / 180) * 150,\r\n                opacity: [1, 0],\r\n                scale: [1, 0.2],\r\n            }}\r\n            transition={{\r\n                duration: 3,\r\n                ease: \"easeOut\"\r\n            }}\r\n        /\u003e\r\n    ))}\r\n}\r\n```\r\n\r\n参数值解释：\r\n\r\n1. **32个粒子，11.25度间隔**：`i * 11.25`确保粒子均匀分布在360度范围内\r\n2. **放射状运动**：使用极坐标转换让粒子向四面八方散开\r\n3. **同时淡出和缩小**：`opacity: [1, 0]`和`scale: [1, 0.2]`创造了消散效果\r\n4. **3000ms持续时间**：不会太快让人看不清，也不会太慢显得拖沓\r\n\r\n### 速度爆发\r\n\r\n```typescript\r\ncollisionSpeedBoost: 4 + Math.random() * 10  // 4-14倍随机速度提升\r\n```\r\n\r\n当星球碰撞时，它们会获得4-14倍的随机速度提升，持续0.1秒：\r\n\r\n```typescript\r\nconst timeout = setTimeout(() =\u003e {\r\n    setPlanetsData(prev =\u003e prev.map((p, idx) =\u003e \r\n        idx === i ? { ...p, collisionSpeedBoost: 1 } : p\r\n    ));\r\n}, 100); // 0.1秒后恢复\r\n```\r\n\r\n### 视觉状态的层次化设计\r\n\r\n碰撞系统为星球引入了多层次的视觉状态：\r\n\r\n```html\r\nclassName={`\r\n    // 基础样式\r\n    w-16 h-16 rounded-full bg-gradient-to-br from-white/20 to-white/5\r\n    // 悬停状态\r\n    ${planetData.isHovered ? 'bg-primary/30 border-primary/50 shadow-lg shadow-primary/20' : ''}\r\n    // 高速搅动状态  \r\n    ${planetData.speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n    // 碰撞标记状态\r\n    ${planetData.isCollided ? 'bg-red-500/30 border-red-400/50 shadow-lg shadow-red-400/20' : ''}\r\n    // 碰撞加速状态\r\n    ${planetData.collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30 border-yellow-400/50 shadow-lg shadow-yellow-400/20' : ''}\r\n`}\r\n```\r\n\r\n具体状态：\r\n- **默认白色**：平静的运行状态\r\n- **蓝色高亮**：用户正在关注（悬停）\r\n- **紫色强调**：被人为搅动（stir功能）\r\n- **红色警示**：处于碰撞状态，有\"危险\"的暗示\r\n- **黄色爆发**：碰撞加速中，充满能量感\r\n\r\n## 高性能动画架构设计\r\n\r\n为了确保星系在高负载情况下仍能保持流畅运行，整个动画系统采用了多层次的性能优化策略。\r\n\r\n### 智能帧率控制策略\r\n\r\n动画循环采用了差异化更新频率，根据操作的计算复杂度分配不同的执行频率：\r\n\r\n- **位置更新**：每2帧执行一次（30fps），保持视觉流畅性\r\n- **碰撞检测**：每4帧执行一次（15fps），减少计算开销\r\n- **特殊效果**：搅动时恢复高频率更新，确保效果质量\r\n\r\n这种策略在保持良好视觉体验的同时，显著降低了CPU负载。\r\n\r\n### 双重状态管理模式\r\n\r\n为了避免频繁的状态更新和重渲染，系统采用了`useRef`和`useState`的双重状态管理模式：\r\n\r\n```typescript\r\nconst planetsDataRef = useRef\u003cPlanetData[]\u003e([]);\r\nconst [planetsData, setPlanetsData] = useState\u003cPlanetData[]\u003e([]);\r\n\r\n// 动画循环中直接操作ref，避免频繁的状态更新\r\nconst currentData = planetsDataRef.current;\r\nconst updatedPlanets = currentData.map(planet =\u003e {\r\n    // ... 更新逻辑\r\n});\r\n\r\n// 只有在真正需要重新渲染时才更新React状态\r\nif (finalPlanets !== currentData) {\r\n    planetsDataRef.current = finalPlanets;\r\n    setPlanetsData(finalPlanets);\r\n}\r\n```\r\n\r\n这种架构的核心优势：\r\n\r\n- **减少React调度开销**：状态更新次数显著减少\r\n- **按需渲染**：只在视觉上有变化时才更新UI\r\n- **数据一致性**：ref和state始终保持同步\r\n\r\n### 组件记忆化架构\r\n\r\n整个组件系统采用了全面的记忆化策略，包括子组件和回调函数的缓存：\r\n\r\n```typescript\r\nconst ParticleEffect = React.memo(function ParticleEffect({x, y, isActive, onComplete}: ParticleEffectProps) {\r\n    // ... 组件逻辑\r\n});\r\n\r\nconst PlanetRenderer = React.memo(function PlanetRenderer({\r\n    planetData,\r\n    galaxyCenter,\r\n    onHover,\r\n    onMouseEnter,\r\n    onMouseLeave,\r\n    onParticleComplete\r\n}: PlanetRendererProps) {\r\n    // 使用useCallback确保回调函数的引用稳定\r\n    const handleMouseEnter = useCallback(() =\u003e {\r\n        onMouseEnter(planetData.index);\r\n        onHover(planetData.skill);\r\n    }, [planetData.index, planetData.skill, onMouseEnter, onHover]);\r\n    \r\n    // ... 其他逻辑\r\n});\r\n```\r\n\r\n父组件使用`useMemo`缓存整个星球列表：\r\n\r\n```typescript\r\nconst memoizedPlanets = useMemo(() =\u003e \r\n    planetsData.map((planetData) =\u003e (\r\n        \u003cPlanetRenderer\r\n            key={`planet-${planetData.index}`}\r\n            planetData={planetData}\r\n            galaxyCenter={galaxyCenter}\r\n            onHover={setHoveredSkill}\r\n            onMouseEnter={handleMouseEnter}\r\n            onMouseLeave={handleMouseLeave}\r\n            onParticleComplete={handleParticleComplete}\r\n        /\u003e\r\n    )), [planetsData, galaxyCenter, handleMouseEnter, handleMouseLeave, handleParticleComplete]);\r\n```\r\n\r\n### 高效的碰撞检测算法\r\n\r\n碰撞检测系统采用了双重循环结构，通过减少不必要的比较来提升性能：\r\n\r\n```typescript\r\n// 高效的碰撞检测实现\r\nfor (let i = 0; i \u003c planets.length; i++) {\r\n    for (let j = i + 1; j \u003c planets.length; j++) {\r\n        // 提前过滤：只检测同轨道星球\r\n        if (planets[j].orbitIndex !== planets[i].orbitIndex) continue;\r\n        \r\n        // 计算角度差进行碰撞判定\r\n        const angleDiff = Math.abs(planets[j].angle - planets[i].angle);\r\n        const normalizedAngleDiff = Math.min(angleDiff, 360 - angleDiff);\r\n        \r\n        if (normalizedAngleDiff \u003c 13) { // 13度的碰撞阈值\r\n            // 触发碰撞效果\r\n            updatedPlanets[i] = {\r\n                ...planet,\r\n                isCollided: true,\r\n                showParticles: true,\r\n                collisionSpeedBoost: 4 + Math.random() * 10\r\n            };\r\n            \r\n            // 100ms后重置碰撞加速\r\n            setTimeout(() =\u003e {\r\n                // 重置逻辑\r\n            }, 100);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n算法设计优势：\r\n\r\n- **避免重复计算**：(i,j)和(j,i)只需要计算一次\r\n- **轨道预过滤**：不同轨道的星球直接跳过检测\r\n- **计算量优化**：减少了不必要的角度差计算\r\n\r\n### 高效的粒子效果系统\r\n\r\n粒子爆炸效果需要在保持视觉冲击力的同时最大化性能：\r\n\r\n```typescript\r\n// 32个粒子的高效爆炸效果\r\n{[...Array(32)].map((_, i) =\u003e (\r\n    \u003cmotion.div\r\n        key={i}\r\n        className=\"absolute w-5 h-5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full\"\r\n        style={{\r\n            left: 25,\r\n            top: 25,\r\n        }}\r\n        animate={{\r\n            x: Math.cos((i * 11.25) * Math.PI / 180) * 150,\r\n            y: Math.sin((i * 11.25) * Math.PI / 180) * 150,\r\n            opacity: [1, 0],\r\n            scale: [1, 0.2],\r\n        }}\r\n        transition={{\r\n            duration: 3,\r\n            ease: \"easeOut\"\r\n        }}\r\n    /\u003e\r\n))}\r\n```\r\n\r\n参数解释：\r\n\r\n- **粒子数量**：32个粒子提供丰富的视觉密度\r\n- **粒子尺寸**：5x5像素确保清晰可见\r\n- **扩散半径**：150像素的广阔扩散范围\r\n- **动画时长**：3秒的充分展示时间\r\n\r\n### 搅动功能的防抖机制\r\n\r\n完善的防抖和批量更新策略可以确保星系在高频交互下保持稳定：\r\n\r\n```typescript\r\nconst [isStirring, setIsStirring] = useState(false);\r\n\r\nconst handleStirPlanets = useCallback(() =\u003e {\r\n    if (isStirring) return; // 防抖保护\r\n    \r\n    setIsStirring(true);\r\n    \r\n    // 随机选择要搅动的星球\r\n    const numPlanetsToStir = Math.min(currentData.length, \r\n        Math.floor(currentData.length * Math.random() + 1));\r\n    const indicesToStir: number[] = [];\r\n    \r\n    while (indicesToStir.length \u003c numPlanetsToStir) {\r\n        const randomIndex = Math.floor(Math.random() * currentData.length);\r\n        if (!indicesToStir.includes(randomIndex)) {\r\n            indicesToStir.push(randomIndex);\r\n        }\r\n    }\r\n    \r\n    // 批量更新所有受影响的星球\r\n    const stirredData = currentData.map((planet, index) =\u003e\r\n        indicesToStir.includes(index)\r\n            ? {...planet, speedMultiplier: 4 + Math.random() * 10}\r\n            : planet\r\n    );\r\n    \r\n    // 单次状态更新\r\n    planetsDataRef.current = stirredData;\r\n    setPlanetsData(stirredData);\r\n    \r\n    // 3秒后恢复正常速度\r\n    setTimeout(() =\u003e {\r\n        const resetData = planetsDataRef.current.map((planet, index) =\u003e\r\n            indicesToStir.includes(index)\r\n                ? {...planet, speedMultiplier: 1}\r\n                : planet\r\n        );\r\n        planetsDataRef.current = resetData;\r\n        setPlanetsData(resetData);\r\n        setIsStirring(false);\r\n    }, 3000);\r\n}, [isStirring]);\r\n```\r\n\r\n## 实现回顾\r\n\r\n通过这次深入的技术剖析，我们可以看到，一个看似简单的\"星球围绕太阳转动\"的效果，背后其实包含了大量的技术细节和设计思考。\r\n\r\n### 技术要点总结\r\n\r\n让我回顾一下这个项目的关键技术点：\r\n\r\n1. **数学基础**：极坐标到笛卡尔坐标的转换是一切的基础\r\n2. **架构设计**：轨道系统的生成和分配策略\r\n3. **动画优化**：requestAnimationFrame + deltaTime的时间差计算\r\n4. **交互体验**：多层次的用户反馈机制\r\n5. **响应式适配**：动态中心定位系统\r\n6. **碰撞检测**：基于角度差的同轨道碰撞判定算法\r\n7. **粒子系统**：放射状粒子效果与动画生命周期管理\r\n8. **状态机设计**：多层次的视觉状态与碰撞生命周期控制\r\n9. **智能帧率控制**：差异化更新频率策略，位置更新30fps，碰撞检测15fps\r\n10. **双重状态管理**：useRef影子状态 + useState按需更新的高效架构\r\n11. **组件记忆化**：React.memo + useCallback + useMemo的全面性能优化\r\n12. **高效碰撞算法**：双重循环优化与轨道预过滤机制\r\n13. **粒子系统优化**：32粒子放射状爆炸的高性能实现\r\n14. **防抖机制**：搅动功能的批量更新与状态保护策略\r\n\r\n### 设计模式的可复用性\r\n\r\n这个实现中有几个设计模式值得在其他项目中复用：\r\n\r\n**时间差动画模式**：\r\n```typescript\r\nconst deltaTime = currentTime - lastTimeRef.current;\r\nsetAngle(prevAngle =\u003e prevAngle + speed * deltaTime * coefficient);\r\n```\r\n这个模式可以用于任何需要平滑动画的场景。\r\n\r\n**状态机模式**：\r\n```typescript\r\n// 正常 → 暂停 → 高速 → 恢复正常\r\nconst [isPaused, setIsPaused] = useState(false);\r\nconst [speedMultiplier, setSpeedMultiplier] = useState(1);\r\n```\r\n适用于复杂的状态切换场景。\r\n\r\n**响应式中心定位模式**：\r\n```typescript\r\nconst updateCenter = () =\u003e {\r\n    const rect = containerRef.current.getBoundingClientRect();\r\n    setCenter({x: rect.width / 2, y: rect.height / 2});\r\n};\r\n```\r\n适用于任何需要动态居中的场景。\r\n\r\n**碰撞检测模式**：\r\n```typescript\r\nconst angleDiff = Math.abs(otherPlanet.angle - currentPlanet.angle);\r\nconst normalizedAngleDiff = Math.min(angleDiff, 360 - angleDiff);\r\nif (normalizedAngleDiff \u003c threshold \u0026\u0026 sameOrbit) {\r\n    // 触发碰撞效果\r\n}\r\n```\r\n适用于圆形轨道上的物体碰撞检测场景。\r\n\r\n**粒子爆炸模式**：\r\n```typescript\r\n{[...Array(particleCount)].map((_, i) =\u003e (\r\n    \u003cmotion.div\r\n        animate={{\r\n            x: Math.cos((i * angleStep) * Math.PI / 180) * distance,\r\n            y: Math.sin((i * angleStep) * Math.PI / 180) * distance,\r\n            opacity: [1, 0],\r\n            scale: [1, 0.2],\r\n        }}\r\n    /\u003e\r\n))}\r\n```\r\n适用于各种爆炸、散射效果的实现。\r\n\r\n**双重状态管理模式**：\r\n```typescript\r\n// 影子状态：高频更新，避免React重渲染开销\r\nconst dataRef = useRef\u003cStateType[]\u003e([]);\r\n// React状态：UI同步，按需更新\r\nconst [data, setData] = useState\u003cStateType[]\u003e([]);\r\n\r\n// 只在有实际变化时更新React状态\r\nif (newData !== dataRef.current) {\r\n    dataRef.current = newData;\r\n    setData(newData);\r\n}\r\n```\r\n适用于高频数据更新的性能优化场景。\r\n\r\n**帧率控制模式**：\r\n```typescript\r\nframeCountRef.current++;\r\n// 不同操作使用不同的更新频率\r\nif (frameCountRef.current % 2 === 0) { /* 30fps操作 */ }\r\nif (frameCountRef.current % 4 === 0) { /* 15fps操作 */ }\r\nif (frameCountRef.current % 8 === 0) { /* 7.5fps操作 */ }\r\n```\r\n适用于需要差异化性能控制的复杂动画场景。\r\n\r\n**组件记忆化模式**：\r\n```typescript\r\nconst MemoizedComponent = React.memo(function Component({data, onAction}) {\r\n    const handleAction = useCallback(() =\u003e onAction(data.id), [data.id, onAction]);\r\n    const memoizedData = useMemo(() =\u003e processData(data), [data]);\r\n    \r\n    return \u003cdiv onClick={handleAction}\u003e{memoizedData}\u003c/div\u003e;\r\n});\r\n```\r\n适用于复杂组件树的性能优化。\r\n\r\n## 完整源码全解析\r\n\r\n```typescript\r\n'use client';\r\n\r\nimport React, {useCallback, useEffect, useRef, useState, useMemo} from 'react';\r\nimport {AnimatePresence, motion} from 'framer-motion';\r\nimport {useTranslation} from '@/lib/hooks/useTranslation';\r\n\r\n// ==================== 类型定义 ====================\r\ninterface ResumeData {\r\n    skills: {\r\n        category: string;\r\n        description: string;\r\n    }[];\r\n}\r\n\r\ninterface SkillGalaxyProps {\r\n    resumeData: ResumeData;\r\n    personalDescription: string;\r\n    onCloseAction: () =\u003e void;\r\n}\r\n\r\n// 星球数据结构：集中管理所有星球的状态\r\ninterface PlanetData {\r\n    index: number;              // 星球索引\r\n    skill: { category: string; description: string };  // 技能信息\r\n    angle: number;              // 当前角度位置\r\n    orbitIndex: number;         // 轨道索引（0-6）\r\n    orbitRadius: number;        // 轨道半径\r\n    x: number;                  // 屏幕X坐标\r\n    y: number;                  // 屏幕Y坐标\r\n    isCollided: boolean;        // 碰撞状态\r\n    showParticles: boolean;     // 粒子效果显示状态\r\n    collisionSpeedBoost: number; // 碰撞速度加成（4-14倍）\r\n    isPaused: boolean;          // 暂停状态（鼠标悬停时）\r\n    speedMultiplier: number;    // 搅动速度倍数（4-14倍）\r\n    isHovered: boolean;         // 悬停状态\r\n}\r\n\r\n// ==================== 粒子效果组件 ====================\r\ninterface ParticleEffectProps {\r\n    x: number;\r\n    y: number;\r\n    isActive: boolean;\r\n    onComplete: () =\u003e void;\r\n}\r\n\r\n// 使用React.memo优化粒子效果组件性能\r\nconst ParticleEffect = React.memo(function ParticleEffect({x, y, isActive, onComplete}: ParticleEffectProps) {\r\n    useEffect(() =\u003e {\r\n        if (isActive) {\r\n            // 3秒后自动完成粒子效果\r\n            const timer = setTimeout(onComplete, 3000);\r\n            return () =\u003e clearTimeout(timer);\r\n        }\r\n    }, [isActive, onComplete]);\r\n\r\n    if (!isActive) return null;\r\n\r\n    return (\r\n        \u003cmotion.div\r\n            className=\"absolute pointer-events-none\"\r\n            style={{\r\n                left: x - 25,   // 居中定位\r\n                top: y - 25,\r\n                width: 50,\r\n                height: 50,\r\n            }}\r\n            initial={{opacity: 0, scale: 0}}\r\n            animate={{opacity: 1, scale: 1}}\r\n            exit={{opacity: 0, scale: 0}}\r\n            transition={{duration: 3}}\r\n        \u003e\r\n            {/* 32个粒子呈放射状散开 */}\r\n            {[...Array(32)].map((_, i) =\u003e (\r\n                \u003cmotion.div\r\n                    key={i}\r\n                    className=\"absolute w-5 h-5 bg-gradient-to-r from-yellow-400 to-orange-500 rounded-full\"\r\n                    style={{\r\n                        left: 25,\r\n                        top: 25,\r\n                    }}\r\n                    animate={{\r\n                        // 放射状运动：每个粒子间隔11.25度\r\n                        x: Math.cos((i * 11.25) * Math.PI / 180) * 150,\r\n                        y: Math.sin((i * 11.25) * Math.PI / 180) * 150,\r\n                        opacity: [1, 0],    // 渐隐效果\r\n                        scale: [1, 0.2],    // 缩小效果\r\n                    }}\r\n                    transition={{\r\n                        duration: 3,        // 3秒动画时长\r\n                        ease: \"easeOut\"     // 自然减速\r\n                    }}\r\n                /\u003e\r\n            ))}\r\n        \u003c/motion.div\u003e\r\n    );\r\n});\r\n\r\n// ==================== 单个星球渲染器 ====================\r\ninterface PlanetRendererProps {\r\n    planetData: PlanetData;\r\n    galaxyCenter: { x: number; y: number };\r\n    onHover: (skill: { category: string; description: string } | null) =\u003e void;\r\n    onMouseEnter: (index: number) =\u003e void;\r\n    onMouseLeave: (index: number) =\u003e void;\r\n    onParticleComplete: (index: number) =\u003e void;\r\n}\r\n\r\n// 使用React.memo优化单个星球的渲染性能\r\nconst PlanetRenderer = React.memo(function PlanetRenderer({\r\n                            planetData,\r\n                            galaxyCenter,\r\n                            onHover,\r\n                            onMouseEnter,\r\n                            onMouseLeave,\r\n                            onParticleComplete\r\n                        }: PlanetRendererProps) {\r\n    \r\n    // 使用useCallback确保回调函数的引用稳定性\r\n    const handleMouseEnter = useCallback(() =\u003e {\r\n        onMouseEnter(planetData.index);\r\n        onHover(planetData.skill);\r\n    }, [planetData.index, planetData.skill, onMouseEnter, onHover]);\r\n\r\n    const handleMouseLeave = useCallback(() =\u003e {\r\n        onMouseLeave(planetData.index);\r\n        onHover(null);\r\n    }, [planetData.index, onMouseLeave, onHover]);\r\n\r\n    const handleParticleComplete = useCallback(() =\u003e {\r\n        onParticleComplete(planetData.index);\r\n    }, [planetData.index, onParticleComplete]);\r\n\r\n    return (\r\n        \u003cdiv className=\"absolute inset-0 pointer-events-none\"\u003e\r\n            {/* 轨道路径：半透明圆环 */}\r\n            \u003cdiv\r\n                className=\"absolute border border-white/10 rounded-full pointer-events-none\"\r\n                style={{\r\n                    width: planetData.orbitRadius * 2,\r\n                    height: planetData.orbitRadius * 2,\r\n                    left: galaxyCenter.x - planetData.orbitRadius,\r\n                    top: galaxyCenter.y - planetData.orbitRadius,\r\n                }}\r\n            /\u003e\r\n\r\n            {/* 星球本体 */}\r\n            \u003cmotion.div\r\n                className=\"absolute pointer-events-auto select-none\"\r\n                style={{\r\n                    left: planetData.x - 32,   // 居中64px星球\r\n                    top: planetData.y - 32,\r\n                }}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseLeave={handleMouseLeave}\r\n                whileHover={{scale: 1.2}}      // 悬停放大效果\r\n                transition={{duration: 0.2}}\r\n            \u003e\r\n                {/* 多层次状态样式系统 */}\r\n                \u003cdiv className={`\r\n                    w-16 h-16 rounded-full \r\n                    bg-gradient-to-br from-white/20 to-white/5\r\n                    backdrop-blur-sm border border-white/20\r\n                    flex items-center justify-center\r\n                    transition-all duration-300\r\n                    ${planetData.isHovered ? 'bg-primary/30 border-primary/50 shadow-lg shadow-primary/20' : ''}\r\n                    ${planetData.speedMultiplier \u003e 1 ? 'bg-purple-500/30 border-purple-400/50 shadow-lg shadow-purple-400/20' : ''}\r\n                    ${planetData.isCollided ? 'bg-red-500/30 border-red-400/50 shadow-lg shadow-red-400/20' : ''}\r\n                    ${planetData.collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30 border-yellow-400/50 shadow-lg shadow-yellow-400/20' : ''}\r\n                `}\u003e\r\n                    \u003cspan className=\"text-xs font-medium text-white text-center px-1\"\u003e\r\n                        {planetData.skill.category}\r\n                    \u003c/span\u003e\r\n                \u003c/div\u003e\r\n            \u003c/motion.div\u003e\r\n\r\n            {/* 粒子爆炸效果 */}\r\n            \u003cAnimatePresence\u003e\r\n                {planetData.showParticles \u0026\u0026 (\r\n                    \u003cParticleEffect\r\n                        x={planetData.x}\r\n                        y={planetData.y}\r\n                        isActive={planetData.showParticles}\r\n                        onComplete={handleParticleComplete}\r\n                    /\u003e\r\n                )}\r\n            \u003c/AnimatePresence\u003e\r\n        \u003c/div\u003e\r\n    );\r\n});\r\n\r\n// ==================== 主要组件：技能星系 ====================\r\nexport function SkillGalaxy({resumeData, personalDescription, onCloseAction}: SkillGalaxyProps) {\r\n    // ==================== 状态管理 ====================\r\n    const [hoveredSkill, setHoveredSkill] = useState\u003c{ category: string; description: string } | null\u003e(null);\r\n    const [galaxyCenter, setGalaxyCenter] = useState({x: 350, y: 350});  // 星系中心坐标\r\n    const [isStirring, setIsStirring] = useState(false);                // 搅动状态防抖\r\n    \r\n    // ==================== Refs管理 ====================\r\n    const galaxyRef = useRef\u003cHTMLDivElement\u003e(null);                     // 星系容器引用\r\n    const animationRef = useRef\u003cnumber | null\u003e(null);                   // 动画ID引用\r\n    const lastTimeRef = useRef\u003cnumber | null\u003e(null);                    // 上一帧时间戳\r\n    const collisionTimeoutsRef = useRef\u003cMap\u003cnumber, NodeJS.Timeout\u003e\u003e(new Map()); // 碰撞定时器映射\r\n    const planetsDataRef = useRef\u003cPlanetData[]\u003e([]);                    // 星球数据引用（影子状态）\r\n    const frameCountRef = useRef(0);                                    // 帧计数器\r\n    \r\n    const {t} = useTranslation();\r\n\r\n    // ==================== 星球数据初始化 ====================\r\n    const [planetsData, setPlanetsData] = useState\u003cPlanetData[]\u003e(() =\u003e {\r\n        const initialData = resumeData.skills.map((skill, index) =\u003e {\r\n            const orbitIndex = index % 7;                       // 7条轨道循环分配\r\n            const orbitRadius = 100 + orbitIndex * 50;          // 轨道半径：100px, 150px, 200px...\r\n            const initialAngle = index * 60;                    // 初始角度分散\r\n\r\n            return {\r\n                index,\r\n                skill,\r\n                angle: initialAngle,\r\n                orbitIndex,\r\n                orbitRadius,\r\n                // 极坐标转笛卡尔坐标\r\n                x: galaxyCenter.x + Math.cos(initialAngle * Math.PI / 180) * orbitRadius,\r\n                y: galaxyCenter.y + Math.sin(initialAngle * Math.PI / 180) * orbitRadius,\r\n                isCollided: false,\r\n                showParticles: false,\r\n                collisionSpeedBoost: 1,         // 碰撞加速倍数\r\n                isPaused: false,                // 鼠标悬停暂停\r\n                speedMultiplier: 1,             // 搅动速度倍数\r\n                isHovered: false\r\n            };\r\n        });\r\n        planetsDataRef.current = initialData;   // 同步影子状态\r\n        return initialData;\r\n    });\r\n\r\n    // ==================== 响应式中心定位系统 ====================\r\n    useEffect(() =\u003e {\r\n        const updateCenter = () =\u003e {\r\n            if (galaxyRef.current) {\r\n                const rect = galaxyRef.current.getBoundingClientRect();\r\n                const newCenter = {\r\n                    x: rect.width / 2,\r\n                    y: rect.height / 2\r\n                };\r\n                setGalaxyCenter(newCenter);\r\n\r\n                // 基于新中心更新所有星球位置\r\n                const updatedData = planetsDataRef.current.map(planet =\u003e ({\r\n                    ...planet,\r\n                    x: newCenter.x + Math.cos(planet.angle * Math.PI / 180) * planet.orbitRadius,\r\n                    y: newCenter.y + Math.sin(planet.angle * Math.PI / 180) * planet.orbitRadius,\r\n                }));\r\n                \r\n                planetsDataRef.current = updatedData;\r\n                setPlanetsData(updatedData);\r\n            }\r\n        };\r\n\r\n        updateCenter();\r\n        window.addEventListener('resize', updateCenter);\r\n        return () =\u003e window.removeEventListener('resize', updateCenter);\r\n    }, []);\r\n\r\n    // ==================== 高效碰撞检测算法 ====================\r\n    const detectCollisions = useCallback((planets: PlanetData[]) =\u003e {\r\n        const collisionThreshold = 13;  // 13度碰撞阈值\r\n        let hasChanges = false;\r\n        const updatedPlanets = [...planets];\r\n\r\n        // 双重循环优化：避免重复比较\r\n        for (let i = 0; i \u003c updatedPlanets.length; i++) {\r\n            const planet = updatedPlanets[i];\r\n            let hasNearbyPlanet = false;\r\n\r\n            // 只检测同轨道星球\r\n            for (let j = i + 1; j \u003c updatedPlanets.length; j++) {\r\n                if (updatedPlanets[j].orbitIndex !== planet.orbitIndex) continue;\r\n\r\n                const otherPlanet = updatedPlanets[j];\r\n                const angleDiff = Math.abs(otherPlanet.angle - planet.angle);\r\n                // 处理跨越0°边界的情况\r\n                const normalizedAngleDiff = Math.min(angleDiff, 360 - angleDiff);\r\n\r\n                if (normalizedAngleDiff \u003c collisionThreshold) {\r\n                    hasNearbyPlanet = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (hasNearbyPlanet \u0026\u0026 !planet.isCollided) {\r\n                // 首次碰撞：触发效果\r\n                updatedPlanets[i] = {\r\n                    ...planet,\r\n                    isCollided: true,\r\n                    showParticles: true,\r\n                    collisionSpeedBoost: 4 + Math.random() * 10  // 4-14倍随机加速\r\n                };\r\n                hasChanges = true;\r\n\r\n                // 碰撞加速重置定时器：100ms后恢复\r\n                const existingTimeout = collisionTimeoutsRef.current.get(i);\r\n                if (existingTimeout) {\r\n                    clearTimeout(existingTimeout);\r\n                }\r\n\r\n                const timeout = setTimeout(() =\u003e {\r\n                    const currentData = planetsDataRef.current;\r\n                    const newData = currentData.map((p, idx) =\u003e\r\n                        idx === i ? {...p, collisionSpeedBoost: 1} : p\r\n                    );\r\n                    planetsDataRef.current = newData;\r\n                    setPlanetsData(newData);\r\n                    collisionTimeoutsRef.current.delete(i);\r\n                }, 100);\r\n\r\n                collisionTimeoutsRef.current.set(i, timeout);\r\n\r\n            } else if (!hasNearbyPlanet \u0026\u0026 planet.isCollided) {\r\n                // 清除碰撞标记\r\n                updatedPlanets[i] = {\r\n                    ...planet,\r\n                    isCollided: false\r\n                };\r\n                hasChanges = true;\r\n            }\r\n        }\r\n\r\n        return hasChanges ? updatedPlanets : planets;\r\n    }, []);\r\n\r\n    // ==================== 高性能动画循环 ====================\r\n    useEffect(() =\u003e {\r\n        const animate = (currentTime: number) =\u003e {\r\n            if (!lastTimeRef.current) lastTimeRef.current = currentTime;\r\n            const deltaTime = currentTime - lastTimeRef.current;\r\n            lastTimeRef.current = currentTime;\r\n\r\n            frameCountRef.current++;\r\n            \r\n            // 帧率控制：每2帧更新一次位置（30fps）\r\n            if (frameCountRef.current % 2 === 0) {\r\n                const currentData = planetsDataRef.current;\r\n                \r\n                // 更新星球位置和角度\r\n                const updatedPlanets = currentData.map(planet =\u003e {\r\n                    if (planet.isPaused) return planet;\r\n\r\n                    // 7种轨道速度：0.15, 0.23, 0.31, 0.39, 0.47, 0.55, 0.63\r\n                    const baseSpeed = 0.15 + planet.orbitIndex * 0.08;\r\n                    const currentSpeed = baseSpeed * planet.speedMultiplier * planet.collisionSpeedBoost;\r\n                    const newAngle = (planet.angle + currentSpeed * deltaTime * 0.01) % 360;\r\n                    const normalizedAngle = newAngle \u003c 0 ? newAngle + 360 : newAngle;\r\n\r\n                    return {\r\n                        ...planet,\r\n                        angle: normalizedAngle,\r\n                        // 极坐标转笛卡尔坐标\r\n                        x: galaxyCenter.x + Math.cos(normalizedAngle * Math.PI / 180) * planet.orbitRadius,\r\n                        y: galaxyCenter.y + Math.sin(normalizedAngle * Math.PI / 180) * planet.orbitRadius,\r\n                    };\r\n                });\r\n\r\n                // 每4帧进行一次碰撞检测（15fps）\r\n                let finalPlanets = updatedPlanets;\r\n                if (frameCountRef.current % 4 === 0 || isStirring) {\r\n                    finalPlanets = detectCollisions(updatedPlanets);\r\n                }\r\n\r\n                // 按需更新：只在有实际变化时更新状态\r\n                if (finalPlanets !== currentData) {\r\n                    planetsDataRef.current = finalPlanets;\r\n                    setPlanetsData(finalPlanets);\r\n                }\r\n            }\r\n\r\n            animationRef.current = requestAnimationFrame(animate);\r\n        };\r\n\r\n        animationRef.current = requestAnimationFrame(animate);\r\n\r\n        return () =\u003e {\r\n            if (animationRef.current) {\r\n                cancelAnimationFrame(animationRef.current);\r\n            }\r\n            // 清理所有碰撞定时器\r\n            collisionTimeoutsRef.current.forEach(timeout =\u003e clearTimeout(timeout));\r\n            collisionTimeoutsRef.current.clear();\r\n        };\r\n    }, [galaxyCenter, detectCollisions, isStirring]);\r\n\r\n    // ==================== 交互事件处理器 ====================\r\n    const handleMouseEnter = useCallback((index: number) =\u003e {\r\n        const currentData = planetsDataRef.current;\r\n        const newData = currentData.map((planet, i) =\u003e\r\n            i === index ? {...planet, isPaused: true, isHovered: true} : planet\r\n        );\r\n        planetsDataRef.current = newData;\r\n        setPlanetsData(newData);\r\n    }, []);\r\n\r\n    const handleMouseLeave = useCallback((index: number) =\u003e {\r\n        const currentData = planetsDataRef.current;\r\n        const newData = currentData.map((planet, i) =\u003e\r\n            i === index ? {...planet, isPaused: false, isHovered: false} : planet\r\n        );\r\n        planetsDataRef.current = newData;\r\n        setPlanetsData(newData);\r\n    }, []);\r\n\r\n    const handleParticleComplete = useCallback((index: number) =\u003e {\r\n        const currentData = planetsDataRef.current;\r\n        const newData = currentData.map((planet, i) =\u003e\r\n            i === index ? {...planet, showParticles: false} : planet\r\n        );\r\n        planetsDataRef.current = newData;\r\n        setPlanetsData(newData);\r\n    }, []);\r\n\r\n    // ==================== 搅动功能的防抖机制 ====================\r\n    const handleStirPlanets = useCallback(() =\u003e {\r\n        if (isStirring) return; // 防抖保护\r\n        \r\n        setIsStirring(true);\r\n        \r\n        const currentData = planetsDataRef.current;\r\n        const numPlanetsToStir = Math.min(currentData.length, Math.floor(currentData.length * Math.random() + 1));\r\n        const indicesToStir: number[] = [];\r\n\r\n        // 随机选择要搅动的星球（避免重复）\r\n        while (indicesToStir.length \u003c numPlanetsToStir) {\r\n            const randomIndex = Math.floor(Math.random() * currentData.length);\r\n            if (!indicesToStir.includes(randomIndex)) {\r\n                indicesToStir.push(randomIndex);\r\n            }\r\n        }\r\n\r\n        // 批量更新搅动状态\r\n        const stirredData = currentData.map((planet, index) =\u003e\r\n            indicesToStir.includes(index)\r\n                ? {...planet, speedMultiplier: 4 + Math.random() * 10}\r\n                : planet\r\n        );\r\n\r\n        planetsDataRef.current = stirredData;\r\n        setPlanetsData(stirredData);\r\n\r\n        // 3秒后重置速度\r\n        setTimeout(() =\u003e {\r\n            const currentData = planetsDataRef.current;\r\n            const resetData = currentData.map((planet, index) =\u003e\r\n                indicesToStir.includes(index)\r\n                    ? {...planet, speedMultiplier: 1}\r\n                    : planet\r\n            );\r\n            planetsDataRef.current = resetData;\r\n            setPlanetsData(resetData);\r\n            setIsStirring(false);\r\n        }, 3000);\r\n    }, [isStirring]);\r\n\r\n    // ==================== 记忆化星球渲染器 ====================\r\n    const memoizedPlanets = useMemo(() =\u003e \r\n        planetsData.map((planetData) =\u003e (\r\n            \u003cPlanetRenderer\r\n                key={`planet-${planetData.index}`}\r\n                planetData={planetData}\r\n                galaxyCenter={galaxyCenter}\r\n                onHover={setHoveredSkill}\r\n                onMouseEnter={handleMouseEnter}\r\n                onMouseLeave={handleMouseLeave}\r\n                onParticleComplete={handleParticleComplete}\r\n            /\u003e\r\n        )), [planetsData, galaxyCenter, handleMouseEnter, handleMouseLeave, handleParticleComplete]);\r\n\r\n    // ==================== 组件渲染 ====================\r\n    return (\r\n        \u003cmotion.div\r\n            initial={{opacity: 0, y: 50, scale: 0.95}}\r\n            animate={{opacity: 1, y: 0, scale: 1}}\r\n            exit={{opacity: 0, y: 50, scale: 0.95}}\r\n            transition={{duration: 0.8, ease: \"easeOut\"}}\r\n            className=\"mt-8 relative overflow-hidden\"\r\n        \u003e\r\n            {/* 星系内容区域 */}\r\n            \u003cdiv className=\"relative p-8 md:p-12 min-h-[800px]\"\u003e\r\n                {/* 星系头部 */}\r\n                \u003cdiv className=\"flex justify-between items-center mb-16 relative z-10\"\u003e\r\n                    \u003ch3 className=\"text-2xl md:text-3xl font-bold text-white\"\u003e\r\n                        {t('personal.skillGalaxy')}\r\n                    \u003c/h3\u003e\r\n                    \u003cdiv className=\"flex gap-4\"\u003e\r\n                        {/* 搅动按钮 */}\r\n                        \u003cmotion.button\r\n                            onClick={handleStirPlanets}\r\n                            disabled={isStirring}\r\n                            className={`px-4 py-2 border rounded-lg transition-all duration-300 hover:scale-105 ${\r\n                                isStirring \r\n                                    ? 'bg-purple-500/10 border-purple-500/20 text-purple-400/50 cursor-not-allowed'\r\n                                    : 'bg-purple-500/20 hover:bg-purple-500/30 border-purple-500/40 text-purple-300'\r\n                            }`}\r\n                            whileHover={!isStirring ? {scale: 1.05} : {}}\r\n                            whileTap={!isStirring ? {scale: 0.95} : {}}\r\n                        \u003e\r\n                            {isStirring ? t('personal.stirring') || 'Stirring...' : t('personal.stirGalaxy')}\r\n                        \u003c/motion.button\u003e\r\n                        \u003cbutton\r\n                            onClick={onCloseAction}\r\n                            className=\"px-4 py-2 bg-red-500/20 hover:bg-red-500/30 border border-red-500/40 rounded-lg text-red-300 transition-all duration-300 hover:scale-105\"\r\n                        \u003e\r\n                            {t('personal.closeResume')}\r\n                        \u003c/button\u003e\r\n                    \u003c/div\u003e\r\n                \u003c/div\u003e\r\n\r\n                {/* 技能星系容器 */}\r\n                \u003cdiv\r\n                    ref={galaxyRef}\r\n                    className=\"relative flex items-center justify-center mb-33\"\r\n                    style={{height: '700px'}}\r\n                \u003e\r\n                    {/* 中央核心（太阳）*/}\r\n                    \u003cmotion.div\r\n                        className=\"absolute z-20 w-24 h-24 rounded-full bg-gradient-to-br from-amber-300 via-yellow-400 to-orange-500 shadow-2xl\"\r\n                        style={{\r\n                            left: galaxyCenter.x - 48,\r\n                            top: galaxyCenter.y - 48,\r\n                        }}\r\n                        animate={{\r\n                            // 呼吸般的光晕变化\r\n                            boxShadow: [\r\n                                \"0 0 30px rgba(255, 193, 7, 0.5)\",\r\n                                \"0 0 50px rgba(255, 193, 7, 0.8)\",\r\n                                \"0 0 30px rgba(255, 193, 7, 0.5)\"\r\n                            ]\r\n                        }}\r\n                        transition={{\r\n                            duration: 3,\r\n                            repeat: Infinity,\r\n                            ease: \"easeInOut\"\r\n                        }}\r\n                        onMouseEnter={() =\u003e setHoveredSkill({\r\n                            category: \"MilkWind\",\r\n                            description: personalDescription\r\n                        })}\r\n                        onMouseLeave={() =\u003e setHoveredSkill(null)}\r\n                    \u003e\r\n                        \u003cdiv\r\n                            className=\"w-full h-full rounded-full flex items-center justify-center text-2xl font-bold text-white select-none\"\u003e\r\n                            👨‍💻\r\n                        \u003c/div\u003e\r\n                        {/* 多层光晕效果 */}\r\n                        \u003cdiv\r\n                            className=\"absolute inset-0 rounded-full bg-gradient-to-br from-amber-300/30 to-orange-500/30 animate-pulse -z-10 scale-150\"/\u003e\r\n                    \u003c/motion.div\u003e\r\n\r\n                    {/* 渲染记忆化星球 */}\r\n                    {memoizedPlanets}\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n\r\n            {/* 信息面板 */}\r\n            \u003cmotion.div\r\n                className=\"absolute bottom-0 left-0 right-0 h-32 p-6 flex items-center justify-center\"\r\n                initial={{y: 100, opacity: 0}}\r\n                animate={{y: 0, opacity: 1}}\r\n                transition={{delay: 0.5}}\r\n            \u003e\r\n                \u003cdiv className=\"text-center max-w-4xl\"\u003e\r\n                    \u003cAnimatePresence mode=\"wait\"\u003e\r\n                        \u003cmotion.div\r\n                            key={hoveredSkill?.category || 'default'}\r\n                            initial={{opacity: 0, y: 20}}\r\n                            animate={{opacity: 1, y: 0}}\r\n                            exit={{opacity: 0, y: -20}}\r\n                            transition={{duration: 0.3}}\r\n                        \u003e\r\n                            \u003ch4 className=\"text-xl font-bold text-white mb-2\"\u003e\r\n                                {hoveredSkill?.category || t('personal.fullStackEngineer')}\r\n                            \u003c/h4\u003e\r\n                            \u003cp className=\"text-gray-300 text-sm leading-relaxed\"\u003e\r\n                                {hoveredSkill?.description || t('personal.galaxyDefaultDescription')}\r\n                            \u003c/p\u003e\r\n                        \u003c/motion.div\u003e\r\n                    \u003c/AnimatePresence\u003e\r\n                \u003c/div\u003e\r\n            \u003c/motion.div\u003e\r\n        \u003c/motion.div\u003e\r\n    );\r\n}\r\n```\r\n\r\n### 核心算法架构图\r\n\r\n```\r\n初始化阶段 → 响应式布局 → 动画循环 → 交互处理 → 性能优化\r\n    ↓           ↓           ↓         ↓         ↓\r\n星球数据生成   中心定位     RAF驱动   事件回调   组件缓存\r\n    ↓           ↓           ↓         ↓         ↓\r\n轨道分配      坐标转换     位置更新   状态同步   内存管理\r\n    ↓           ↓           ↓         ↓         ↓\r\n角度分散      窗口监听     碰撞检测   防抖机制   批量更新\r\n```\r\n\r\n### 关键技术要点总结\r\n\r\n**1. 双重状态管理架构**\r\n```typescript\r\n// 影子状态：高频更新，避免React重渲染\r\nconst planetsDataRef = useRef\u003cPlanetData[]\u003e([]);\r\n// React状态：UI同步，按需更新\r\nconst [planetsData, setPlanetsData] = useState\u003cPlanetData[]\u003e([]);\r\n```\r\n\r\n**2. 帧率控制与性能优化**\r\n```typescript\r\n// 位置更新：每2帧执行（30fps）\r\nif (frameCountRef.current % 2 === 0) { /* 更新位置 */ }\r\n// 碰撞检测：每4帧执行（15fps）\r\nif (frameCountRef.current % 4 === 0 || isStirring) { /* 碰撞检测 */ }\r\n```\r\n\r\n**3. 数学模型：极坐标转换**\r\n```typescript\r\n// 核心转换公式\r\nx = galaxyCenter.x + Math.cos(angle * Math.PI / 180) * orbitRadius;\r\ny = galaxyCenter.y + Math.sin(angle * Math.PI / 180) * orbitRadius;\r\n```\r\n\r\n**4. 碰撞检测优化算法**\r\n```typescript\r\n// 双重循环优化：避免重复比较 (i,j) 和 (j,i)\r\nfor (let i = 0; i \u003c planets.length; i++) {\r\n    for (let j = i + 1; j \u003c planets.length; j++) {\r\n        // 同轨道预过滤 + 角度差计算\r\n    }\r\n}\r\n```\r\n\r\n**5. 多层次视觉状态系统**\r\n```typescript\r\n// 条件样式：悬停、搅动、碰撞、加速四种状态\r\n${isHovered ? 'bg-primary/30' : ''}\r\n${speedMultiplier \u003e 1 ? 'bg-purple-500/30' : ''}\r\n${isCollided ? 'bg-red-500/30' : ''}\r\n${collisionSpeedBoost \u003e 1 ? 'bg-yellow-500/30' : ''}\r\n```\r\n\r\n## 写在最后\r\n\r\n技能星系可以说是我迄今以来实现过的，最复杂且考虑项最多的动态效果了，尤其是性能优化部分。在该效果实际优化前，频繁的重渲染会导致\r\n\r\n*愿你的代码如星辰般闪耀，如星系般和谐运转。* ✨"])</script><script>self.__next_f.push([1,"40:Tb4e1,"])</script><script>self.__next_f.push([1,"\r\n# 样式注入：TailwindCSS Preflight破坏后的浴火重生\r\n\r\n鱼和熊掌不可兼得。——那不可能，我全都要！\r\n\r\n想象一个阳光明媚的春天......当你满怀期待地将精心编写的MDX文档渲染到页面上，却发现所有的标题、段落、代码块居然都变成了毫无样式的\"裸体HTML\"！那么——恭喜你，遇到了TailwindCSS Preflight的\"腹黑一面\"。这个看似无害的CSS重置机制，就像是一个过于热心的清洁工，把你家里的所有装饰都当成垃圾扔掉啦！\r\n\r\n为此，你最便捷的解决办法也许是哄着TailwindCSS ：\"好好好，CSS的渲染大权在你手上，我按你的来行了吧！委屈一下MDX，在她身上插点你的东西吧！\"\r\n\r\n如果你想歪了，那是你的问题，与我无关（摊手，欠揍脸）\r\n\r\n于是......当当当当！样式注入系统，应运而生！\r\n\r\n回归正题，在这篇文章中，我将从问题的根源开始，逐步深入每一个技术细节，全面剖析这个让文档重获样式的涅槃之术吧。（真有这么高大上么？）\r\n\r\n## 问题根源分析：Preflight的双刃剑效应\r\n\r\n在深入解决方案之前，我们需要理解Preflight的工作机制。\r\n\r\n### TailwindCSS Preflight机制解析\r\n\r\n```css\r\n/* Preflight重置样式示例 */\r\nh1, h2, h3, h4, h5, h6 {\r\n  font-size: inherit;\r\n  font-weight: inherit;\r\n}\r\n\r\np, blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre {\r\n  margin: 0;\r\n}\r\n\r\nol, ul {\r\n  list-style: none;\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\n```\r\n\r\n**Preflight的设计初衷**是消除浏览器默认样式的差异，提供一个\"干净的画布\"。这个想法本身很棒——在不同浏览器中保持一致的起点，避免各种奇怪的默认样式差异。\r\n\r\n但是！当我们使用Remarkable将MDX转换为HTML时，生成的是语义化的HTML结构：\r\n\r\n```html\r\n\u003ch1\u003e标题\u003c/h1\u003e\r\n\u003cp\u003e段落内容\u003c/p\u003e\r\n\u003ccode\u003e代码片段\u003c/code\u003e\r\n\u003cul\u003e\r\n  \u003cli\u003e列表项\u003c/li\u003e\r\n\u003c/ul\u003e\r\n```\r\n\r\n这些HTML标签本来应该有浏览器的默认样式，让它们看起来像\"标题\"、\"段落\"、\"代码\"。但Preflight一上场，直接把所有默认样式都重置了——所有文字看起来都一样，没有层次，没有重点，像是一篇渲染出了问题的文档。\r\n\r\n**为什么不能简单地关闭Preflight**？\r\n\r\n关闭Preflight看似是最简单的解决方案，但这会带来更大的问题：\r\n- 不同浏览器的默认样式差异会重新出现\r\n- 你的其他UI组件可能会出现意想不到的样式问题\r\n- TailwindCSS的许多工具类是基于重置后的基础样式设计的\r\n\r\n### MDX到HTML的渲染链路\r\n\r\n总结一下问题发生的完整链路：\r\n\r\n```typescript\r\nMDX源文件 → Remarkable解析 → HTML字符串 → Preflight重置 → 样式丢失的结果\r\n```\r\n\r\n1. **MDX源文件**：包含语义化的Markdown语法\r\n2. **Remarkable解析**：生成纯净的HTML结构，没有任何CSS类名\r\n3. **HTML字符串**：插入到React组件中渲染\r\n4. **Preflight重置**：TailwindCSS的基础层移除所有默认样式\r\n5. **最终结果**：一堆没有样式的HTML元素\r\n\r\n**为什么传统的CSS类名方案在这里失效**？\r\n\r\n你可能会想：\"为什么不直接给这些标签加上CSS类名？\" 问题在于：\r\n- Remarkable生成的是字符串形式的HTML，不是React组件\r\n- 我们无法在Markdown语法中为每个标签手动添加类名\r\n- 即使能添加，也会让Markdown失去简洁性\r\n\r\n这就引出了样式注入的必要性——我们需要一个系统，能够自动为生成的HTML标签添加合适的TailwindCSS类名。\r\n\r\n## 样式映射配置设计\r\n\r\n在开始编写复杂的注入算法之前，我们需要设计一个样式分明（~~我想怎么写就怎么写，一切样式皆由我控！~~自由度非常高）的配置系统。\r\n\r\n### JSON配置文件\r\n\r\n```json\r\n{\r\n  \"h1\": \"text-4xl font-bold mt-8 mb-4 text-foreground leading-tight\",\r\n  \"h2\": \"text-3xl font-semibold mt-6 mb-3 text-foreground leading-tight\",\r\n  \"p\": \"text-base leading-7 mb-4 text-foreground\",\r\n  \"code\": \"bg-surface text-primary px-1.5 py-0.5 rounded text-sm font-mono\",\r\n  \"ul\": \"list-disc list-inside mb-4 pl-6 space-y-2\",\r\n  \"li\": \"text-foreground leading-relaxed\"\r\n}\r\n```\r\n\r\n**标签到样式类的映射策略**：\r\n\r\n每个HTML标签对应一个TailwindCSS类名字符串，这种一对一的映射关系简单直接，避免了复杂的条件判断。\r\n\r\n**主题系统适配的设计考虑**：\r\n\r\n注意每个样式类都使用了主题系统的颜色变量：\r\n```\r\ntext-foreground\r\nbg-surface\r\ntext-primary\r\n```\r\n\r\n这些类名映射到CSS自定义属性，确保在主题切换时，文档内容能够无缝适配新的颜色方案。\r\n\r\n## 核心注入算法：正则表达式驱动的捕获与替换\r\n\r\n从我个人体感上来说，至少95%的匹配需求正则可以用AI来生成。（扣脑袋，沉思状）\r\n\r\n### 标签匹配的正则魔法\r\n\r\n```typescript\r\nconst tagRegex = new RegExp(`\u003c${tag}(\\\\s[^\u003e]*)?(?:\u003e|\\\\s*/\u003e)`, 'gi');\r\n```\r\n\r\n逐字符解析正则表达式：\r\n\r\n- `\u003c${tag}`：匹配开始的尖括号和标签名\r\n- `(\\\\s[^\u003e]*)?`：可选的属性部分\r\n  - `\\\\s`：至少一个空白字符\r\n  - `[^\u003e]*`：任意数量的非`\u003e`字符（属性内容）\r\n  - `?`：整个属性部分是可选的\r\n- `(?:\u003e|\\\\s*/\u003e)`：非捕获组，匹配结束部分\r\n  - `\u003e`：普通标签的结束\r\n  - `|`：或者\r\n  - `\\\\s*/\u003e`：自闭合标签的结束（可能有空格）\r\n- `gi`：全局匹配，忽略大小写\r\n\r\n**为什么要匹配开始标签而不是整个标签对**？\r\n\r\n因为我们只需要在开始标签中添加`class`属性，闭合标签不需要修改。这种设计可以避免考虑到复杂的嵌套匹配，而且支持自闭合标签（如`\u003cimg/\u003e`、`\u003cbr/\u003e`）\r\n\r\n**自闭合标签和普通标签的不同处理**：\r\n\r\n正则表达式中的`(?:\u003e|\\\\s*/\u003e`部分同时处理了这两种情况，无需额外的条件判断。\r\n\r\n### 类名注入算法\r\n\r\n```typescript\r\nstyledContent = styledContent.replace(tagRegex, (match) =\u003e {\r\n    // 防重复注入检查\r\n    if (match.includes(classes.split(' ')[0])) {\r\n        return match;\r\n    }\r\n\r\n    // 检查是否已有class属性\r\n    const classMatch = match.match(/class=[\"']([^\"']*)[\"']/);\r\n\r\n    if (classMatch) {\r\n        // 合并现有类名的逻辑\r\n        const existingClasses = classMatch[1];\r\n        const newClasses = classes.split(' ').filter(cls =\u003e !existingClasses.includes(cls)).join(' ');\r\n        if (newClasses) {\r\n            return match.replace(/class=[\"']([^\"']*)[\"']/, `class=\"$1 ${newClasses}\"`);\r\n        }\r\n        return match;\r\n    } else {\r\n        // 添加新类名的逻辑\r\n        if (match.endsWith('/\u003e')) {\r\n            // 自闭合标签\r\n            return match.replace(/\\s*\\/\u003e$/, ` class=\"${classes}\" /\u003e`);\r\n        } else {\r\n            // 普通开始标签\r\n            return match.replace(/\u003e$/, ` class=\"${classes}\"\u003e`);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n**类名合并vs新增的判断逻辑**：\r\n\r\n系统首先检查标签是否已有`class`属性：\r\n- **有**：将新类名与现有类名合并，避免重复\r\n- **无**：直接添加新的`class`属性\r\n\r\n**重复类名的去重算法**：\r\n\r\n```typescript\r\nconst newClasses = classes.split(' ').filter(cls =\u003e !existingClasses.includes(cls)).join(' ');\r\n```\r\n\r\n这行代码确保了不会添加重复的类名。\r\n\r\n**属性引号的处理**：\r\n\r\n正则表达式`/class=[\"']([^\"']*)[\"']/`同时支持单引号和双引号，保证了不同情况的兼容性。\r\n\r\n### 防重复注入的保护机制\r\n\r\n```typescript\r\nif (match.includes(classes.split(' ')[0])) {\r\n    return match;\r\n}\r\n```\r\n\r\n**为什么检查第一个类名就够了**？\r\n\r\n这是一个仅存在两种情况（注入过/没注入过）下可采用的判断方式。假设算法为`h1`标签注入的类名是`\"text-4xl font-bold mt-8 mb-4\"`，而在检查时，只需检查`text-4xl`是否已存在即可。\r\n\r\n**性能优化vs准确性的权衡**：\r\n\r\n虽然理论上可能存在误判（其他地方也使用了`text-4xl`），但在实际应用中，这种概率极低，而性能提升是显著的。\r\n\r\n## 代码块增强：这个小盒子才是代码永远的家\r\n\r\n普通的样式注入只能给人凑合看看，但对于代码块，程序员的执着会要求更多功能——语法高亮、复制功能、主题切换，以及现代化的交互体验。\r\n\r\n### 代码块识别与解构\r\n\r\n```typescript\r\nconst preCodeRegex = /\u003cpre\u003e\u003ccode([^\u003e]*?)\u003e([\\s\\S]*?)\u003c\\/code\u003e\u003c\\/pre\u003e/g;\r\n```\r\n\r\n**嵌套标签的正则匹配挑战**：\r\n\r\n代码块的HTML结构是嵌套的：`\u003cpre\u003e\u003ccode\u003e内容\u003c/code\u003e\u003c/pre\u003e`。这个正则表达式需要：\r\n- 精确匹配开始的`\u003cpre\u003e\u003ccode\u003e`\r\n- 捕获`\u003ccode\u003e`标签的属性（包含语言信息）\r\n- 捕获代码内容（可能包含换行符）\r\n- 匹配结束的`\u003c/code\u003e\u003c/pre\u003e`\r\n\r\n**非贪婪匹配的重要性**：\r\n\r\n`([\\s\\S]*?)`中的`?`实现了非贪婪匹配，确保在有多个代码块时不会匹配过度。\r\n\r\n**属性提取的技巧**：\r\n\r\n`([^\u003e]*?)`捕获`\u003ccode\u003e`标签内的所有属性，为后续的语言识别做准备。\r\n\r\n### 语言标识符的提取算法\r\n\r\n```typescript\r\nconst languageMatch = attributes.match(/class=[\"']([^\"']*language-([^\"'\\s]+)[^\"']*)[\"']/);\r\nconst language = languageMatch ? languageMatch[2] : '';\r\n```\r\n\r\n**highlight.js的类名规范解析**：\r\n\r\nhighlight.js使用`language-xxx`的类名格式来标识代码语言，如：\r\n- `language-typescript`\r\n- `language-javascript`\r\n- `language-python`\r\n- ......\r\n\r\n**复杂正则表达式的分组捕获**：\r\n\r\n- 第一个捕获组`([^\"']*language-([^\"'\\s]+)[^\"']*)`：捕获整个class属性值\r\n- 第二个捕获组`([^\"'\\s]+)`：捕获具体的语言名称\r\n\r\n**默认值的优雅降级**：\r\n\r\n如果无法识别语言，默认显示`'code'`，确保用户界面的一致性。\r\n\r\n### HTML实体的还原处理\r\n\r\n```typescript\r\nconst cleanContent = content\r\n    .replace(/\u0026lt;/g, '\u003c')\r\n    .replace(/\u0026gt;/g, '\u003e')\r\n    .replace(/\u0026amp;/g, '\u0026')\r\n    .replace(/\u0026quot;/g, '\"')\r\n    .replace(/\u0026#x27;/g, \"'\");\r\n```\r\n\r\n**为什么需要HTML实体还原**？\r\n\r\nRemarkable在处理代码内容时，会将特殊字符转换为HTML实体以避免XSS攻击。但在复制功能中，用户期望的是原始代码，而不是HTML实体。\r\n\r\n**替换顺序的重要性**：\r\n\r\n注意`\u0026amp;`的替换必须在最后，因为其他实体（如`\u0026lt;`）本身包含`\u0026`字符。错误的顺序会导致二次替换。\r\n\r\n**URL编码在data属性中的应用**：\r\n\r\n```typescript\r\ndata-code=\"${encodeURIComponent(cleanContent)}\"\r\n```\r\n\r\n清理后的代码通过URL编码存储在data属性中，确保复制功能能够获取到正确的内容。\r\n\r\n### 增强代码块的HTML结构设计\r\n\r\n生成的增强代码块具有复杂的HTML结构：\r\n\r\n```html\r\n\u003cdiv class=\"enhanced-codeblock relative mb-6 rounded-lg border bg-background border-gray-200...\"\u003e\r\n    \u003cdiv class=\"codeblock-header flex items-center justify-between px-4 py-2 bg-surface...\"\u003e\r\n        \u003cspan class=\"codeblock-language text-xs font-medium text-foreground opacity-70...\"\u003etypescript\u003c/span\u003e\r\n        \u003cbutton class=\"codeblock-copy-btn inline-flex items-center bg-background hover:bg-surface text-foreground hover:text-primary...\"\u003e\r\n            \u003c!-- SVG图标和文字 --\u003e\r\n        \u003c/button\u003e\r\n    \u003c/div\u003e\r\n    \u003cpre class=\"codeblock-content p-4 overflow-x-auto bg-surface text-foreground...\"\u003e\r\n        \u003ccode class=\"language-typescript\"\u003e原始代码内容\u003c/code\u003e\r\n    \u003c/pre\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n**CSS Grid vs Flexbox的布局选择**：\r\n\r\n头部区域使用Flexbox（`flex items-center justify-between`）实现语言标识和复制按钮的两端对齐，这比Grid更适合这种一维布局。\r\n\r\n**主题系统的无缝切换机制**：\r\n\r\n每个元素都使用了主题系统的颜色变量：\r\n```css\r\nbg-background\r\nbg-surface\r\ntext-foreground\r\ntext-primary\r\n```\r\n\r\n这些类名通过CSS自定义属性与主题系统连接，确保了主题切换时的自动适配。\r\n\r\n### 动态主题切换的实现机制\r\n\r\n为了让代码块能够响应主题变化，还有一套动态CSS注入系统：\r\n\r\n```typescript\r\n// 主题检测与CSS注入\r\nfunction injectThemeCSS() {\r\n    const existingStyle = document.getElementById('codeblock-theme-styles');\r\n    if (existingStyle) {\r\n        existingStyle.remove();\r\n    }\r\n    \r\n    // 检测当前主题\r\n    const isDark = document.documentElement.classList.contains('dark');\r\n    \r\n    // 生成主题相应的CSS\r\n    const themeStyles = `\r\n        .enhanced-codeblock {\r\n            background-color: var(--color-background) !important;\r\n            border-color: ${isDark ? '#374151' : '#e5e7eb'} !important;\r\n        }\r\n        .codeblock-header {\r\n            background-color: var(--color-surface) !important;\r\n            border-bottom-color: ${isDark ? '#374151' : '#e5e7eb'} !important;\r\n        }\r\n        .codeblock-copy-btn {\r\n            background-color: var(--color-background) !important;\r\n            color: var(--color-foreground) !important;\r\n        }\r\n        .codeblock-copy-btn:hover {\r\n            background-color: var(--color-surface) !important;\r\n            color: var(--color-primary) !important;\r\n        }\r\n        .codeblock-content {\r\n            background-color: var(--color-surface) !important;\r\n            color: var(--color-foreground) !important;\r\n        }\r\n    `;\r\n    \r\n    // 注入到文档头部\r\n    const styleElement = document.createElement('style');\r\n    styleElement.id = 'codeblock-theme-styles';\r\n    styleElement.textContent = themeStyles;\r\n    document.head.appendChild(styleElement);\r\n}\r\n```\r\n\r\n**主题变化监听机制**：\r\n\r\n```typescript\r\n// 监听DOM变化，检测主题切换\r\nconst observer = new MutationObserver(function(mutations) {\r\n    mutations.forEach(function(mutation) {\r\n        if (mutation.type === 'attributes' \u0026\u0026 \r\n            mutation.attributeName === 'class' \u0026\u0026 \r\n            mutation.target === document.documentElement) {\r\n            setTimeout(injectThemeCSS, 10);\r\n        }\r\n    });\r\n});\r\n\r\nobserver.observe(document.documentElement, {\r\n    attributes: true,\r\n    attributeFilter: ['class']\r\n});\r\n```\r\n\r\n**为什么使用动态CSS注入而不是静态类名**？\r\n\r\n1. **实时响应**：主题切换时立即更新样式，无需重新渲染组件\r\n2. **性能优化**：避免大量的条件类名判断\r\n3. **灵活性**：可以根据主题状态动态调整边框颜色等细节\r\n4. **优先级控制**：使用`!important`确保主题样式优先于默认样式\r\n\r\n**CSS自定义属性的优势**：\r\n\r\n主题系统通过`ThemeProvider`在根元素上设置CSS自定义属性：\r\n```typescript\r\nObject.entries(currentTheme.colors).forEach(([key, value]) =\u003e {\r\n    root.style.setProperty(`--color-${key}`, value);\r\n});\r\n```\r\n\r\n这样代码块就能通过`var(--color-background)`、`var(--color-surface)`等方式自动获取当前主题的颜色值。\r\n\r\n## 客户端交互脚本：监视与提示\r\n\r\n增强代码块的复制、通知、动态功能初始化。\r\n\r\n### 可降级的复制功能\r\n\r\n```typescript\r\nif (navigator.clipboard \u0026\u0026 navigator.clipboard.writeText) {\r\n    await navigator.clipboard.writeText(code);\r\n} else {\r\n    // 兼容性降级方案\r\n    const textArea = document.createElement('textarea');\r\n    textArea.value = code;\r\n    textArea.style.position = 'fixed';\r\n    textArea.style.left = '-999999px';\r\n    textArea.style.top = '-999999px';\r\n    document.body.appendChild(textArea);\r\n    textArea.focus();\r\n    textArea.select();\r\n    document.execCommand('copy');\r\n    textArea.remove();\r\n}\r\n```\r\n\r\n**现代Clipboard API vs 传统方案 的对比**：\r\n\r\n| 特性 | Clipboard API | document.execCommand |\r\n|------|---------------|---------------------|\r\n| 安全性 | 需要HTTPS或localhost | 相对宽松 |\r\n| 异步支持 | 原生Promise | 同步操作 |\r\n| 浏览器支持 | 现代浏览器 | 广泛支持但已废弃 |\r\n| 使用体验 | 无需用户交互 | 需要focus和select |\r\n\r\n**异步操作的错误处理**：\r\n\r\n```typescript\r\ntry {\r\n    await navigator.clipboard.writeText(code);\r\n    showToast('代码已复制到剪贴板！', 'success');\r\n} catch (err) {\r\n    console.error('Failed to copy code:', err);\r\n    showToast('复制失败', 'error');\r\n}\r\n```\r\n\r\n**安全策略对复制功能的影响**：\r\n\r\n现代浏览器的安全策略要求Clipboard API只能在安全上下文（HTTPS）中使用，这就是我们需要降级方案的原因。\r\n\r\n### 动态内容监听：MutationObserver\r\n\r\n```typescript\r\nconst observer = new MutationObserver(function(mutations) {\r\n    let shouldReinitialize = false;\r\n    mutations.forEach(function(mutation) {\r\n        mutation.addedNodes.forEach(function(node) {\r\n            if (node.nodeType === 1 \u0026\u0026 (node.classList.contains('enhanced-codeblock') || node.querySelector('.enhanced-codeblock'))) {\r\n                shouldReinitialize = true;\r\n            }\r\n        });\r\n    });\r\n    \r\n    if (shouldReinitialize) {\r\n        // 防抖机制\r\n        clearTimeout(window['__codeblock_reinit_timeout__']);\r\n        window['__codeblock_reinit_timeout__'] = setTimeout(initializeCodeBlocks, 100);\r\n    }\r\n});\r\n```\r\n\r\n**为什么需要DOM变化监听**？\r\n\r\n在React应用中，组件可能会动态更新内容。如果新添加了代码块，我们需要为它们重新绑定事件监听器。\r\n\r\n**防抖机制的性能优化**：\r\n\r\n当DOM频繁变化时，防抖机制确保初始化函数不会被过度调用，避免性能问题与UI异常。\r\n\r\n**内存泄漏的防护策略**：\r\n\r\n```typescript\r\nif (!window['__codeblock_observers__']) {\r\n    window['__codeblock_observers__'] = new Set();\r\n}\r\n\r\nif (!window['__codeblock_observers__'].has(observerId)) {\r\n    window['__codeblock_observers__'].add(observerId);\r\n    // 创建观察者\r\n}\r\n```\r\n\r\n使用全局Set来追踪已创建的观察者，避免重复创建导致的内存泄漏。\r\n\r\n### Toast通知系统的实现\r\n\r\n```typescript\r\nfunction showToast(message, type = 'success') {\r\n    // 移除现有通知\r\n    const existingToasts = document.querySelectorAll('.copy-toast');\r\n    existingToasts.forEach(toast =\u003e toast.remove());\r\n    \r\n    // 创建新通知\r\n    const toast = document.createElement('div');\r\n    toast.className = 'copy-toast fixed top-4 right-4 z-[9999] px-4 py-2 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full opacity-0';\r\n    \r\n    // 动画效果\r\n    setTimeout(() =\u003e {\r\n        toast.classList.remove('translate-x-full', 'opacity-0');\r\n    }, 10);\r\n    \r\n    // 自动移除\r\n    setTimeout(() =\u003e {\r\n        toast.classList.add('translate-x-full', 'opacity-0');\r\n        setTimeout(() =\u003e toast.remove(), 300);\r\n    }, 3000);\r\n}\r\n```\r\n\r\n**浮动提示的定位策略**：\r\n\r\n使用`fixed top-4 right-4`将通知固定在视口右上角，确保在任何滚动位置都能看到。\r\n\r\n**CSS动画的性能考虑**：\r\n\r\n使用`transform`而不是改变`top`/`right`值来实现动画，利用GPU加速提升性能。\r\n\r\n**Z-index层级的管理**：\r\n\r\n`z-[9999]`确保通知显示在所有其他元素之上，包括可能的模态框和下拉菜单。\r\n\r\n## 目录生成：文档导航构建\r\n\r\n某种程度上来说这其实是JS逆向的一部分。\r\n\r\n### 标题提取正则\r\n\r\n```typescript\r\nconst headingRegex = /\u003ch([1-6])(?:\\s[^\u003e]*)?\u003e[\\s\\S]*?\u003c\\/h[1-6]\u003e/gi;\r\n```\r\n\r\n**多行内容匹配**：\r\n\r\n标题内容可能包含换行符、嵌套HTML标签等复杂结构。`[\\s\\S]*?`确保能够匹配包含换行符的内容。\r\n\r\n**嵌套HTML处理**：\r\n\r\n标题内可能包含`\u003ccode\u003e`、`\u003cstrong\u003e`等内联标签，正则表达式需要准确地匹配到完整的标题结构。\r\n\r\n### 文本内容的精确提取\r\n\r\n```typescript\r\nconst text = tagContent\r\n    .replace(/\u003c[^\u003e]*\u003e/g, '')           // 移除HTML标签\r\n    .replace(/\u0026lt;/g, '\u003c')            // 解码HTML实体\r\n    .replace(/\u0026gt;/g, '\u003e')\r\n    .replace(/\u0026amp;/g, '\u0026')\r\n    .replace(/\u0026quot;/g, '\"')\r\n    .replace(/\u0026#x27;/g, \"'\")\r\n    .replace(/\u0026#39;/g, \"'\")\r\n    .replace(/\u0026nbsp;/g, ' ')\r\n    .replace(/\\s+/g, ' ')              // 标准化空白字符\r\n    .trim();\r\n```\r\n\r\n**HTML标签剥离算法**：\r\n\r\n`/\u003c[^\u003e]*\u003e/g`移除所有HTML标签，保留纯文本内容作为目录项。\r\n\r\n**实体解码覆盖方案**：\r\n\r\n涵盖了常见的HTML实体，确保目录文本的正确显示。\r\n\r\n**空白字符的标准化处理**：\r\n\r\n`\\s+`匹配所有类型的空白字符（空格、制表符、换行符），统一替换为单个空格。\r\n\r\n### ID生成算法的设计\r\n\r\n```typescript\r\nlet id = text\r\n    .toLowerCase()                                       // 转小写\r\n    .replace(/[^\\w\\s\\u00A0-\\uFFFF-]/g, '')               // 保留字母数字和Unicode字符\r\n    .replace(/\\s+/g, '-')                                // 空格转连字符\r\n    .replace(/-+/g, '-')                                 // 多个连字符合并\r\n    .replace(/^-+|-+$/g, '');                            // 移除首尾连字符\r\n```\r\n\r\n**URL安全的ID生成规则**：\r\n\r\n- 只保留字母、数字、Unicode字符（支持中文等）\r\n- 空格转换为连字符\r\n- 移除特殊字符避免URL问题\r\n\r\n**国际化字符的支持策略**：\r\n\r\n`\\u00A0-\\uFFFF`范围涵盖了大部分Unicode字符，确保中文、日文等标题能够正确生成ID。\r\n\r\n**ID冲突的解决机制**：\r\n\r\n```typescript\r\nlet uniqueId = id;\r\nlet counter = 1;\r\nwhile (toc.some(item =\u003e item.id === uniqueId)) {\r\n    uniqueId = `${id}-${counter}`;\r\n    counter++;\r\n}\r\n```\r\n\r\n通过添加数字后缀确保ID的唯一性。\r\n\r\n## 锚点生成：可导航文档的实现\r\n\r\n斯塔拉格加费尔根才能成功召唤塔迪乌斯，缺少其中任何一个，另一个都是个废物白板......好吧塔迪乌斯即便召唤出来了也很一般，但总比没有好。\r\n\r\n### 锚点HTML结构设计\r\n\r\n```typescript\r\nreturn `\u003c${tag} id=\"${tocItem.id}\" class=\"group relative\"\u003e\r\n    \u003ca href=\"#${tocItem.id}\" class=\"absolute -left-6 top-0 opacity-0 group-hover:opacity-100 transition-opacity text-primary/60 hover:text-primary\" aria-label=\"Link to ${tocItem.text}\"\u003e\r\n        \u003csvg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n            \u003cpath fill-rule=\"evenodd\" d=\"M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 11.414-1.414 4 4 0 105.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 10-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z\" clip-rule=\"evenodd\" /\u003e\r\n        \u003c/svg\u003e\r\n    \u003c/a\u003e\r\n    ${content}\r\n\u003c/${tag}\u003e`;\r\n```\r\n\r\n**CSS Group选择器**：\r\n\r\n`group`类配合`group-hover:opacity-100`实现了\"只有在鼠标悬浮在标题上时，锚点链接才会显示\"的效果。\r\n\r\n**相对定位控制**：\r\n\r\n`absolute -left-6 top-0`将锚点图标定位在标题左侧6个单位的位置，相对而言，那儿至少是个空位。\r\n\r\n**SVG图标的选择和优化**：\r\n\r\n使用链接图标的SVG版本，`fill=\"currentColor\"`确保图标颜色与文字颜色保持一致。\r\n\r\n### 可访问性的全面考虑\r\n\r\n```html\r\naria-label=\"Link to ${tocItem.text}\"\r\n```\r\n\r\n**screen reader的支持**：\r\n\r\n`aria-label`为视觉障碍用户提供了链接的描述信息。\r\n\r\n**键盘导航的友好性**：\r\n\r\n锚点链接可以通过Tab键聚焦，Enter键激活，确保键盘用户能够正常使用。\r\n\r\n## 完整源码全解析\r\n\r\n### 样式注入核心模块\r\n\r\n```typescript\r\n// src/lib/utils/styleInject.ts\r\nimport markdownStyles from '../../../public/styles/markdown.json';\r\n\r\n/**\r\n * 样式注入主函数：将Tailwind CSS类注入到HTML元素中\r\n * 解决Preflight重置样式后的显示问题\r\n */\r\nexport function styleInject(htmlContent: string, translations?: any): string {\r\n    let styledContent = htmlContent;\r\n\r\n    // 第一步：处理代码块增强功能\r\n    styledContent = processCodeBlocks(styledContent, translations);\r\n\r\n    // 第二步：为其他HTML标签注入样式类\r\n    Object.entries(markdownStyles).forEach(([tag, classes]) =\u003e {\r\n        if (typeof classes === 'string' \u0026\u0026 classes.trim()) {\r\n            // 跳过已被增强代码块处理的标签\r\n            if (tag === 'pre' || tag === 'code') {\r\n                return;\r\n            }\r\n\r\n            // 创建标签匹配的正则表达式\r\n            const tagRegex = new RegExp(`\u003c${tag}(\\\\s[^\u003e]*)?(?:\u003e|\\\\s*/\u003e)`, 'gi');\r\n\r\n            styledContent = styledContent.replace(tagRegex, (match) =\u003e {\r\n                // 防止重复注入检查\r\n                if (match.includes(classes.split(' ')[0])) {\r\n                    return match;\r\n                }\r\n\r\n                // 检查是否已有class属性\r\n                const classMatch = match.match(/class=[\"']([^\"']*)[\"']/);\r\n\r\n                if (classMatch) {\r\n                    // 合并现有类名\r\n                    const existingClasses = classMatch[1];\r\n                    const newClasses = classes.split(' ').filter(cls =\u003e !existingClasses.includes(cls)).join(' ');\r\n                    if (newClasses) {\r\n                        return match.replace(/class=[\"']([^\"']*)[\"']/, `class=\"$1 ${newClasses}\"`);\r\n                    }\r\n                    return match;\r\n                } else {\r\n                    // 添加新的class属性\r\n                    if (match.endsWith('/\u003e')) {\r\n                        return match.replace(/\\s*\\/\u003e$/, ` class=\"${classes}\" /\u003e`);\r\n                    } else {\r\n                        return match.replace(/\u003e$/, ` class=\"${classes}\"\u003e`);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    });\r\n\r\n    return styledContent;\r\n}\r\n\r\n/**\r\n * 代码块增强处理函数\r\n * 将普通代码块转换为带有复制功能和主题支持的增强代码块\r\n */\r\nexport function processCodeBlocks(htmlContent: string, translations?: any): string {\r\n    const preCodeRegex = /\u003cpre\u003e\u003ccode([^\u003e]*?)\u003e([\\s\\S]*?)\u003c\\/code\u003e\u003c\\/pre\u003e/g;\r\n    return htmlContent.replace(preCodeRegex, (match, attributes, content) =\u003e {\r\n        // 避免重复处理\r\n        if (match.includes('data-enhanced-codeblock')) {\r\n            return match;\r\n        }\r\n\r\n        // 提取语言信息\r\n        const languageMatch = attributes.match(/class=[\"']([^\"']*language-([^\"'\\s]+)[^\"']*)[\"']/);\r\n        const language = languageMatch ? languageMatch[2] : '';\r\n\r\n        // 清理HTML实体\r\n        const cleanContent = content\r\n            .replace(/\u0026lt;/g, '\u003c')\r\n            .replace(/\u0026gt;/g, '\u003e')\r\n            .replace(/\u0026amp;/g, '\u0026')\r\n            .replace(/\u0026quot;/g, '\"')\r\n            .replace(/\u0026#x27;/g, \"'\");\r\n\r\n        // 获取国际化文本\r\n        const copyText = translations?.codeblock?.copy || 'Copy';\r\n        const copyTooltip = translations?.codeblock?.copyTooltip || 'Copy code';\r\n\r\n        // 生成增强代码块HTML结构\r\n        return `\r\n            \u003cdiv class=\"enhanced-codeblock relative mb-6 rounded-lg border bg-background border-gray-200 dark:border-gray-700 overflow-hidden shadow-sm\" data-enhanced-codeblock=\"true\" data-language=\"${language}\" data-code=\"${encodeURIComponent(cleanContent)}\"\u003e\r\n                \u003cdiv class=\"codeblock-header flex items-center justify-between px-4 py-2 bg-surface border-b border-gray-200 dark:border-gray-700\"\u003e\r\n                    \u003cspan class=\"codeblock-language text-xs font-medium uppercase tracking-wide text-foreground opacity-70\"\u003e${language || 'code'}\u003c/span\u003e\r\n                    \u003cbutton class=\"codeblock-copy-btn inline-flex items-center gap-1.5 px-2 py-1 text-xs font-medium border rounded transition-all duration-200 bg-background hover:bg-surface text-foreground hover:text-primary border-gray-300 dark:border-gray-600 hover:scale-105 active:scale-95\" title=\"${copyTooltip}\"\u003e\r\n                        \u003csvg class=\"copy-icon w-4 h-4\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n                            \u003cpath d=\"M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z\" /\u003e\r\n                            \u003cpath d=\"M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z\" /\u003e\r\n                        \u003c/svg\u003e\r\n                        \u003csvg class=\"copied-icon w-4 h-4 hidden\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n                            \u003cpath fill-rule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clip-rule=\"evenodd\" /\u003e\r\n                        \u003c/svg\u003e\r\n                        \u003cspan class=\"copy-text\"\u003e${copyText}\u003c/span\u003e\r\n                    \u003c/button\u003e\r\n                \u003c/div\u003e\r\n                \u003cpre class=\"codeblock-content p-4 overflow-x-auto font-mono text-sm leading-relaxed bg-surface text-foreground\"\u003e\u003ccode${attributes}\u003e${content}\u003c/code\u003e\u003c/pre\u003e\r\n            \u003c/div\u003e\r\n        `;\r\n    });\r\n}\r\n\r\n/**\r\n * 生成客户端交互脚本\r\n * 包含复制功能、主题切换、DOM监听等\r\n */\r\nexport function getCodeBlockScript(translations?: any): string {\r\n    const copySuccessText = translations?.codeblock?.copySuccess || 'Code copied to clipboard!';\r\n    const copyErrorText = translations?.codeblock?.copyError || 'Failed to copy code';\r\n    \r\n    return `\r\n        \u003cscript\u003e\r\n            (function() {\r\n                // 主题CSS注入函数\r\n                function injectThemeCSS() {\r\n                    const existingStyle = document.getElementById('codeblock-theme-styles');\r\n                    if (existingStyle) {\r\n                        existingStyle.remove();\r\n                    }\r\n                    \r\n                    const isDark = document.documentElement.classList.contains('dark');\r\n                    \r\n                    const themeStyles = \\`\r\n                        .enhanced-codeblock {\r\n                            background-color: var(--color-background) !important;\r\n                            border-color: \\${isDark ? '#374151' : '#e5e7eb'} !important;\r\n                        }\r\n                        .codeblock-header {\r\n                            background-color: var(--color-surface) !important;\r\n                            border-bottom-color: \\${isDark ? '#374151' : '#e5e7eb'} !important;\r\n                        }\r\n                        .codeblock-copy-btn {\r\n                            background-color: var(--color-background) !important;\r\n                            color: var(--color-foreground) !important;\r\n                        }\r\n                        .codeblock-copy-btn:hover {\r\n                            background-color: var(--color-surface) !important;\r\n                            color: var(--color-primary) !important;\r\n                        }\r\n                        .codeblock-content {\r\n                            background-color: var(--color-surface) !important;\r\n                            color: var(--color-foreground) !important;\r\n                        }\r\n                    \\`;\r\n                    \r\n                    const styleElement = document.createElement('style');\r\n                    styleElement.id = 'codeblock-theme-styles';\r\n                    styleElement.textContent = themeStyles;\r\n                    document.head.appendChild(styleElement);\r\n                }\r\n                \r\n                // 复制功能初始化\r\n                function initializeCodeBlocks() {\r\n                    const codeBlocks = document.querySelectorAll('.enhanced-codeblock');\r\n                    \r\n                    codeBlocks.forEach(function(block, blockIndex) {\r\n                        const copyBtn = block.querySelector('.codeblock-copy-btn');\r\n                        if (!copyBtn || copyBtn.hasAttribute('data-initialized')) return;\r\n                        \r\n                        copyBtn.setAttribute('data-initialized', 'true');\r\n                        \r\n                        copyBtn.addEventListener('click', async function(e) {\r\n                            e.preventDefault();\r\n                            \r\n                            try {\r\n                                let code = block.getAttribute('data-code');\r\n                                if (code) {\r\n                                    code = decodeURIComponent(code);\r\n                                } else {\r\n                                    const codeElement = block.querySelector('pre code');\r\n                                    if (codeElement) {\r\n                                        code = codeElement.textContent || '';\r\n                                    }\r\n                                }\r\n                                \r\n                                // 复制到剪贴板\r\n                                if (navigator.clipboard \u0026\u0026 navigator.clipboard.writeText) {\r\n                                    await navigator.clipboard.writeText(code);\r\n                                } else {\r\n                                    // 降级方案\r\n                                    const textArea = document.createElement('textarea');\r\n                                    textArea.value = code;\r\n                                    textArea.style.position = 'fixed';\r\n                                    textArea.style.left = '-999999px';\r\n                                    document.body.appendChild(textArea);\r\n                                    textArea.select();\r\n                                    document.execCommand('copy');\r\n                                    textArea.remove();\r\n                                }\r\n                                \r\n                                showToast('${copySuccessText}', 'success');\r\n                                \r\n                            } catch (err) {\r\n                                showToast('${copyErrorText}', 'error');\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n                \r\n                // Toast通知系统\r\n                function showToast(message, type = 'success') {\r\n                    const existingToasts = document.querySelectorAll('.copy-toast');\r\n                    existingToasts.forEach(toast =\u003e toast.remove());\r\n                    \r\n                    const toast = document.createElement('div');\r\n                    toast.className = 'copy-toast fixed top-4 right-4 z-[9999] px-4 py-2 rounded-lg shadow-lg transition-all duration-300 transform translate-x-full opacity-0';\r\n                    \r\n                    if (type === 'success') {\r\n                        toast.className += ' bg-green-500 text-white';\r\n                    } else {\r\n                        toast.className += ' bg-red-500 text-white';\r\n                    }\r\n                    \r\n                    toast.textContent = message;\r\n                    document.body.appendChild(toast);\r\n                    \r\n                    setTimeout(() =\u003e {\r\n                        toast.classList.remove('translate-x-full', 'opacity-0');\r\n                    }, 10);\r\n                    \r\n                    setTimeout(() =\u003e {\r\n                        toast.classList.add('translate-x-full', 'opacity-0');\r\n                        setTimeout(() =\u003e toast.remove(), 300);\r\n                    }, 3000);\r\n                }\r\n                \r\n                // 初始化和监听\r\n                if (document.readyState === 'loading') {\r\n                    document.addEventListener('DOMContentLoaded', function() {\r\n                        initializeCodeBlocks();\r\n                        injectThemeCSS();\r\n                    });\r\n                } else {\r\n                    initializeCodeBlocks();\r\n                    injectThemeCSS();\r\n                }\r\n                \r\n                // 主题变化监听\r\n                const observer = new MutationObserver(function(mutations) {\r\n                    mutations.forEach(function(mutation) {\r\n                        if (mutation.type === 'attributes' \u0026\u0026 \r\n                            mutation.attributeName === 'class' \u0026\u0026 \r\n                            mutation.target === document.documentElement) {\r\n                            setTimeout(injectThemeCSS, 10);\r\n                        }\r\n                    });\r\n                });\r\n                \r\n                observer.observe(document.documentElement, {\r\n                    attributes: true,\r\n                    attributeFilter: ['class']\r\n                });\r\n            })();\r\n        \u003c/script\u003e\r\n    `;\r\n}\r\n\r\n/**\r\n * 提取目录结构\r\n */\r\nexport function extractTOC(htmlContent: string): Array\u003c{ id: string, text: string, level: number }\u003e {\r\n    const toc: Array\u003c{ id: string, text: string, level: number }\u003e = [];\r\n    const headingRegex = /\u003ch([1-6])(?:\\s[^\u003e]*)?\u003e[\\s\\S]*?\u003c\\/h[1-6]\u003e/gi;\r\n    let match;\r\n\r\n    while ((match = headingRegex.exec(htmlContent)) !== null) {\r\n        const level = parseInt(match[1]);\r\n        const fullMatch = match[0];\r\n        const tagContent = fullMatch.replace(/\u003ch[1-6](?:\\s[^\u003e]*)?\u003e|\u003c\\/h[1-6]\u003e/gi, '');\r\n\r\n        const text = tagContent\r\n            .replace(/\u003c[^\u003e]*\u003e/g, '')\r\n            .replace(/\u0026lt;/g, '\u003c')\r\n            .replace(/\u0026gt;/g, '\u003e')\r\n            .replace(/\u0026amp;/g, '\u0026')\r\n            .replace(/\u0026quot;/g, '\"')\r\n            .replace(/\u0026#x27;/g, \"'\")\r\n            .replace(/\u0026#39;/g, \"'\")\r\n            .replace(/\u0026nbsp;/g, ' ')\r\n            .replace(/\\s+/g, ' ')\r\n            .trim();\r\n\r\n        if (!text) continue;\r\n\r\n        let id = text\r\n            .toLowerCase()\r\n            .replace(/[^\\w\\s\\u00A0-\\uFFFF-]/g, '')\r\n            .replace(/\\s+/g, '-')\r\n            .replace(/-+/g, '-')\r\n            .replace(/^-+|-+$/g, '');\r\n\r\n        let uniqueId = id;\r\n        let counter = 1;\r\n        while (toc.some(item =\u003e item.id === uniqueId)) {\r\n            uniqueId = `${id}-${counter}`;\r\n            counter++;\r\n        }\r\n\r\n        if (text \u0026\u0026 uniqueId) {\r\n            toc.push({id: uniqueId, text, level});\r\n        }\r\n    }\r\n\r\n    return toc;\r\n}\r\n\r\n/**\r\n * 为标题添加锚点链接\r\n */\r\nexport function addHeadingAnchors(htmlContent: string): string {\r\n    const tocItems = extractTOC(htmlContent);\r\n    \r\n    if (tocItems.length === 0) {\r\n        return htmlContent;\r\n    }\r\n\r\n    const headingRegex = /\u003ch([1-6])(?:\\s[^\u003e]*)?\u003e[\\s\\S]*?\u003c\\/h[1-6]\u003e/gi;\r\n    let tocIndex = 0;\r\n\r\n    return htmlContent.replace(headingRegex, (match, level) =\u003e {\r\n        if (tocIndex \u003e= tocItems.length) return match;\r\n        if (match.includes(' id=')) return match;\r\n\r\n        const tocItem = tocItems[tocIndex];\r\n        tocIndex++;\r\n\r\n        const tag = `h${level}`;\r\n        const content = match.replace(/\u003ch[1-6](?:\\s[^\u003e]*)?\u003e|\u003c\\/h[1-6]\u003e/gi, '');\r\n\r\n        return `\u003c${tag} id=\"${tocItem.id}\" class=\"group relative\"\u003e\r\n            \u003ca href=\"#${tocItem.id}\" class=\"absolute -left-6 top-0 opacity-0 group-hover:opacity-100 transition-opacity text-primary/60 hover:text-primary\" aria-label=\"Link to ${tocItem.text}\"\u003e\r\n                \u003csvg class=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"\u003e\r\n                    \u003cpath fill-rule=\"evenodd\" d=\"M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 11.414-1.414 4 4 0 105.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 10-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z\" clip-rule=\"evenodd\" /\u003e\r\n                \u003c/svg\u003e\r\n            \u003c/a\u003e\r\n            ${content}\r\n        \u003c/${tag}\u003e`;\r\n    });\r\n}\r\n```\r\n\r\n### 样式配置文件\r\n\r\n```json\r\n// public/styles/markdown.json\r\n{\r\n  \"h1\": \"text-4xl font-bold mt-8 mb-4 text-foreground leading-tight\",\r\n  \"h2\": \"text-3xl font-semibold mt-6 mb-3 text-foreground leading-tight\",\r\n  \"h3\": \"text-2xl font-semibold mt-5 mb-2 text-foreground leading-snug\",\r\n  \"h4\": \"text-xl font-medium mt-4 mb-2 text-foreground leading-snug\",\r\n  \"p\": \"text-base leading-7 mb-4 text-foreground\",\r\n  \"code\": \"bg-surface text-primary px-1.5 py-0.5 rounded text-sm font-mono\",\r\n  \"pre\": \"bg-surface text-foreground p-4 rounded-lg overflow-x-auto mb-4 font-mono text-sm leading-relaxed border border-gray-200\",\r\n  \"ul\": \"list-disc list-inside mb-4 pl-6 space-y-2\",\r\n  \"ol\": \"list-decimal list-inside mb-4 pl-6 space-y-2\", \r\n  \"li\": \"text-foreground leading-relaxed\",\r\n  \"strong\": \"font-bold text-foreground\",\r\n  \"em\": \"italic text-foreground\",\r\n  \"a\": \"text-primary hover:text-accent underline transition-colors duration-200\",\r\n  \"img\": \"max-w-full h-auto rounded-lg shadow-sm my-4 mx-auto block\",\r\n  \"table\": \"w-full border-collapse mb-4 shadow-sm rounded-lg overflow-hidden\",\r\n  \"th\": \"px-4 py-3 text-left text-xs font-medium text-foreground uppercase tracking-wider bg-surface\",\r\n  \"td\": \"px-4 py-3 text-sm text-foreground\",\r\n  \"blockquote\": \"border-l-4 border-primary pl-4 py-2 my-4 bg-surface text-foreground italic\",\r\n  \"hr\": \"border-0 h-px bg-gray-300 my-8\"\r\n}\r\n```\r\n\r\n### 服务端渲染集成\r\n\r\n```typescript\r\n// src/app/documents/[...slug]/page.tsx\r\nexport default async function DocumentPage({params}: PageProps) {\r\n    try {\r\n        const {slug} = await params;\r\n        const [lang, category, fileName] = slug;\r\n        const {content, frontMatter, readingTime} = getArticlesData(fileName, lang, false, category);\r\n\r\n        // 配置Remarkable解析器\r\n        const md = new Remarkable({\r\n            html: true,\r\n            breaks: true,\r\n            typographer: true,\r\n            highlight: function (str: string, lang: string) {\r\n                if (lang \u0026\u0026 hljs.getLanguage(lang)) {\r\n                    try {\r\n                        return hljs.highlight(str, {language: lang}).value;\r\n                    } catch (err) {}\r\n                }\r\n                try {\r\n                    return hljs.highlightAuto(str).value;\r\n                } catch (err) {}\r\n                return '';\r\n            }\r\n        })\r\n        .use(linkify)\r\n        .use(rkatex, {delimiter: '$'});\r\n\r\n        let htmlContent = md.render(content, frontMatter);\r\n\r\n        // 加载国际化文本\r\n        let translations = null;\r\n        try {\r\n            const translationsPath = path.join(process.cwd(), 'public', 'locales', lang, 'common.json');\r\n            if (fs.existsSync(translationsPath)) {\r\n                translations = JSON.parse(fs.readFileSync(translationsPath, 'utf8'));\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to load translations:', error);\r\n        }\r\n\r\n        // 处理流程：提取目录 → 添加锚点 → 样式注入\r\n        const tocItems = extractTOC(htmlContent);\r\n        htmlContent = addHeadingAnchors(htmlContent);\r\n        htmlContent = styleInject(htmlContent, translations);\r\n\r\n        return (\r\n            \u003cDocumentPageClient\r\n                htmlContent={htmlContent}\r\n                frontMatter={frontMatter}\r\n                readingTime={readingTime}\r\n                category={category}\r\n                tocItems={tocItems}\r\n                translations={translations}\r\n                lang={lang}\r\n            /\u003e\r\n        );\r\n    } catch (error) {\r\n        console.error('Error rendering document:', error);\r\n        notFound();\r\n    }\r\n}\r\n```\r\n\r\n### 客户端组件集成\r\n\r\n```typescript\r\n// src/app/documents/[...slug]/DocumentPageClient.tsx\r\nexport function DocumentPageClient({\r\n    htmlContent,\r\n    frontMatter,\r\n    readingTime,\r\n    category,\r\n    tocItems,\r\n    translations,\r\n    lang\r\n}: DocumentPageClientProps) {\r\n    const {t} = useTranslation();\r\n    const [formattedDate, setFormattedDate] = useState\u003cstring\u003e('');\r\n\r\n    // 注入客户端交互脚本\r\n    useEffect(() =\u003e {\r\n        const codeBlockScript = getCodeBlockScript(translations);\r\n        const tempDiv = document.createElement('div');\r\n        tempDiv.innerHTML = codeBlockScript;\r\n        const scriptElement = tempDiv.querySelector('script');\r\n        \r\n        if (scriptElement) {\r\n            const newScript = document.createElement('script');\r\n            newScript.textContent = scriptElement.textContent;\r\n            document.head.appendChild(newScript);\r\n            \r\n            return () =\u003e {\r\n                if (document.head.contains(newScript)) {\r\n                    document.head.removeChild(newScript);\r\n                }\r\n            };\r\n        }\r\n    }, [translations]);\r\n\r\n    return (\r\n        \u003c\u003e\r\n            \u003cdiv className=\"relative z-30 min-h-screen bg-background\"\u003e\r\n                \u003cdiv className=\"container mx-auto px-4 py-8 max-w-4xl\"\u003e\r\n                    \u003carticle className=\"prose max-w-none\"\u003e\r\n                        \u003cdiv \r\n                            className=\"prose-pre:p-4 prose-pre:bg-surface w-full\"\r\n                            dangerouslySetInnerHTML={{__html: htmlContent}}\r\n                        /\u003e\r\n                    \u003c/article\u003e\r\n                \u003c/div\u003e\r\n            \u003c/div\u003e\r\n            \u003cTableOfContents tocItems={tocItems}/\u003e\r\n        \u003c/\u003e\r\n    );\r\n}\r\n```\r\n\r\n### 核心算法流程图\r\n\r\n```\r\nMDX输入 → Remarkable解析 → 样式注入系统 → 增强HTML输出\r\n    ↓           ↓              ↓              ↓\r\n  原始语法    HTML字符串     样式类注入     完整渲染\r\n    ↓           ↓              ↓              ↓\r\n  语法高亮    代码块识别     主题适配       交互功能\r\n    ↓           ↓              ↓              ↓\r\n  目录提取    锚点生成       客户端脚本     用户体验\r\n```\r\n\r\n### 关键实现原理总结\r\n\r\n**1. 正则表达式驱动的样式注入**\r\n- 精确匹配HTML标签的开始部分\r\n- 智能处理现有class属性的合并\r\n- 支持自闭合标签的特殊处理\r\n\r\n**2. 代码块增强的三层架构**\r\n- HTML结构层：语义化的增强代码块\r\n- 样式层：动态主题适配CSS\r\n- 交互层：复制功能和用户反馈\r\n\r\n**3. 目录生成的文本处理算法**\r\n- 多行内容的准确提取\r\n- HTML实体的完整解码\r\n- URL安全的ID生成策略\r\n\r\n**4. 客户端脚本的内存管理**\r\n- 防重复监听器的全局状态跟踪\r\n- 自动清理机制避免内存泄漏\r\n- 防抖优化减少不必要的重初始化\r\n\r\n## 写在最后\r\n\r\n样式注入的整体方案的实现其实并不复杂，思路也较为简单，但正如那句话所说：*\"简单是复杂的终极形式\"*。样式注入系统在复杂的技术实现背后，为用户呈现的是简单、美观、易用的文档体验。\r\n\r\n*愿你的文档如艺术品般优雅，在样式注入的加持下焕发出数字时代的璀璨光芒。* ✨\r\n"])</script><script>self.__next_f.push([1,"41:Tae0b,"])</script><script>self.__next_f.push([1,"\r\n# Remarkable KaTeX Plus 插件代码解析\r\n\r\n**插件版本：v1.1.2**\r\n\r\n本篇文章将会对 `remarkable-katex-plus` 插件代码进行逐行解析，包括主要的插件文件 `index.js` 和测试文件 `index.test.js`。本解析不仅解释每行代码的作用，还详细说明所有非JavaScript标准库函数的用法和原理。\r\n\r\n## 概览\r\n\r\n`remarkable-katex-plus` 是一个用于 Remarkable Markdown 处理器的插件，它能够将 `$...$` 和 `$$..$$` 序列转换为使用 KaTeX 包渲染的数学公式 HTML。\r\n\r\n## 依赖库函数说明\r\n\r\n在深入代码解析之前，先了解本插件使用的主要非标准库函数：\r\n\r\n### Node.js 相关函数\r\n- **`require(moduleName)`**: Node.js模块加载函数，用于导入外部模块或库\r\n  - **形参**: \r\n    - `moduleName` (string): 模块名称或路径字符串\r\n  - **返回值**: 导入的模块对象或函数\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 导入外部npm包\r\n    const katex = require('katex');\r\n    \r\n    // 导入本地文件模块\r\n    const plugin = require('./index.js');\r\n    \r\n    // 使用解构语法导入特定导出\r\n    const { Remarkable } = require('remarkable');\r\n    ```\r\n- **`module.exports`**: Node.js模块导出对象，用于向外部提供模块功能\r\n  - **形参**: 无（这是一个属性，不是函数）\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 导出单个函数\r\n    module.exports = rkatex;\r\n    \r\n    // 导出包含多个函数的对象\r\n    module.exports = { renderKatex, parseInlineKatex };\r\n    ```\r\n\r\n### KaTeX 库函数\r\n- **`katex.renderToString(expression, options)`**: KaTeX核心渲染函数\r\n  - **形参**:\r\n    - `expression` (string): 要渲染的LaTeX数学表达式字符串\r\n    - `options` (Object): 渲染选项对象，包含以下可选配置：\r\n      - `displayMode` (boolean): 是否使用块级显示模式，默认false\r\n      - `throwOnError` (boolean): 遇到错误是否抛出异常，默认true\r\n      - `errorColor` (string): 错误文本颜色，默认'#cc0000'\r\n      - `macros` (Object): 自定义宏定义\r\n      - `strict` (boolean): 是否使用严格模式，默认true\r\n  - **返回值**: 渲染后的HTML字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 内联模式渲染数学公式\r\n    const inlineHtml = katex.renderToString('x^2 + y^2 = z^2', {\r\n      displayMode: false,    // 内联模式\r\n      throwOnError: false    // 遇到错误不抛出异常\r\n    });\r\n    \r\n    // 块级模式渲染分数公式\r\n    const blockHtml = katex.renderToString('\\\\frac{a}{b}', {\r\n      displayMode: true,     // 块级显示模式\r\n      throwOnError: false,   // 遇到错误不抛出异常\r\n      errorColor: '#ff0000'  // 自定义错误颜色为红色\r\n    });\r\n    ```\r\n\r\n### Remarkable 解析器状态对象属性\r\n- **`state.bMarks[line]`**: 每行开始位置的标记数组（begin marks）\r\n  - **类型**: Array\u003cnumber\u003e\r\n  - **说明**: 存储每行文本开始位置的字符索引（不包含前导空格）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取第一行的开始位置索引\r\n    const lineStart = state.bMarks[0];\r\n    ```\r\n- **`state.tShift[line]`**: 每行前导空格数组（tab shift）\r\n  - **类型**: Array\u003cnumber\u003e\r\n  - **说明**: 存储每行的缩进量（空格和制表符的数量）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取第一行的缩进量（空格数）\r\n    const indent = state.tShift[0];\r\n    ```\r\n- **`state.eMarks[line]`**: 每行结束位置的标记数组（end marks）\r\n  - **类型**: Array\u003cnumber\u003e\r\n  - **说明**: 存储每行文本结束位置的字符索引\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取第一行的结束位置索引\r\n    const lineEnd = state.eMarks[0];\r\n    ```\r\n- **`state.src`**: 完整的源文本字符串\r\n  - **类型**: string\r\n  - **说明**: 包含整个待解析的Markdown文本\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取指定位置的字符\r\n    const char = state.src.charAt(pos);\r\n    ```\r\n- **`state.pos`**: 当前解析位置\r\n  - **类型**: number\r\n  - **说明**: 当前解析器在源文本中的位置索引\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 更新当前解析位置\r\n    state.pos = newPos;\r\n    ```\r\n- **`state.posMax`**: 最大解析位置\r\n  - **类型**: number\r\n  - **说明**: 解析器能够处理的最大位置索引\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 检查是否到达解析末尾\r\n    if (state.pos \u003e= state.posMax) { \r\n      return false; \r\n    }\r\n    ```\r\n- **`state.level`**: 当前嵌套级别\r\n  - **类型**: number\r\n  - **说明**: 当前解析元素的嵌套深度\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取当前元素的嵌套级别\r\n    const tokenLevel = state.level;\r\n    ```\r\n- **`state.line`**: 当前行号\r\n  - **类型**: number\r\n  - **说明**: 当前解析器处理的行号（从0开始）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 更新当前处理的行号\r\n    state.line = nextLine;\r\n    ```\r\n- **`state.blkIndent`**: 块级元素缩进量\r\n  - **类型**: number\r\n  - **说明**: 当前块级元素的缩进量\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取当前块级元素的缩进量\r\n    const blockIndent = state.blkIndent;\r\n    ```\r\n\r\n### Remarkable 解析器状态方法\r\n- **`state.skipChars(pos, char)`**: 从指定位置跳过连续的相同字符\r\n  - **形参**:\r\n    - `pos` (number): 起始位置索引\r\n    - `char` (string): 要跳过的字符\r\n  - **返回值**: (number) 跳过连续字符后的新位置索引\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 从位置0开始跳过连续的$字符\r\n    const pos = state.skipChars(0, '$');\r\n    ```\r\n- **`state.skipSpaces(pos)`**: 从指定位置跳过空格字符\r\n  - **形参**:\r\n    - `pos` (number): 起始位置索引\r\n  - **返回值**: (number) 跳过空格和制表符后的位置索引\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 跳过当前位置的空格和制表符\r\n    const newPos = state.skipSpaces(pos);\r\n    ```\r\n- **`state.getLines(startLine, endLine, indent, keepLastLF)`**: 获取指定行范围的文本\r\n  - **形参**:\r\n    - `startLine` (number): 起始行号（包含）\r\n    - `endLine` (number): 结束行号（不包含）\r\n    - `indent` (number): 要移除的缩进量\r\n    - `keepLastLF` (boolean): 是否保留最后的换行符\r\n  - **返回值**: (string) 提取的文本字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取第1-4行的内容，无缩进移除，保留换行符\r\n    const content = state.getLines(1, 5, 0, true);\r\n    ```\r\n- **`state.push(token)`**: 向tokens数组添加新的token对象\r\n  - **形参**:\r\n    - `token` (Object): 要添加的token对象\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 添加内联数学公式token\r\n    state.push({ \r\n      type: 'katex',          // token类型\r\n      content: 'x^2',         // 数学表达式内容\r\n      block: false,           // 内联模式\r\n      level: state.level      // 当前嵌套级别\r\n    });\r\n    ```\r\n- **`state.tokens.push(token)`**: 直接向tokens数组添加token\r\n  - **形参**:\r\n    - `token` (Object): 要添加的token对象\r\n  - **返回值**: (number) 数组新的长度\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 直接向tokens数组添加块级数学公式token\r\n    state.tokens.push({\r\n      type: 'katex',            // token类型\r\n      content: '\\\\frac{a}{b}',  // LaTeX分数表达式\r\n      block: true,              // 块级模式\r\n      level: state.level        // 当前嵌套级别\r\n    });\r\n    ```\r\n\r\n### Remarkable 插件API\r\n- **`md.inline.ruler.push(name, fn, options)`**: 注册内联解析规则\r\n  - **形参**:\r\n    - `name` (string): 规则名称，用于标识解析规则\r\n    - `fn` (function): 解析函数，接收state和silent参数\r\n    - `options` (Object): 解析选项（可选）\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 注册内联KaTeX解析规则\r\n    md.inline.ruler.push('katex', parseInlineKatex, {\r\n      alt: ['paragraph', 'text']  // 可选的替代规则\r\n    });\r\n    ```\r\n- **`md.block.ruler.push(name, fn, options)`**: 注册块级解析规则\r\n  - **形参**:\r\n    - `name` (string): 规则名称，用于标识解析规则\r\n    - `fn` (function): 解析函数，接收state、startLine和endLine参数\r\n    - `options` (Object): 解析选项（可选）\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 注册块级KaTeX解析规则\r\n    md.block.ruler.push('katex', parseBlockKatex, {\r\n      alt: ['paragraph', 'blockquote']  // 可选的替代规则\r\n    });\r\n    ```\r\n- **`md.renderer.rules[name]`**: 渲染规则对象，用于定义如何将token转换为HTML\r\n  - **形参**:\r\n    - `name` (string): token类型名称\r\n  - **返回值**: 渲染函数\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 定义KaTeX token的渲染规则\r\n    md.renderer.rules.katex = function(tokens, idx) {\r\n      const token = tokens[idx];  // 获取当前token\r\n      // 调用KaTeX渲染函数\r\n      return renderKatex(token.content, token.block);\r\n    };\r\n    ```\r\n- **`md.use(plugin, options)`**: 使用插件\r\n  - **形参**:\r\n    - `plugin` (function): 插件函数\r\n    - `options` (Object): 插件选项（可选）\r\n  - **返回值**: Remarkable实例（支持链式调用）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 创建Remarkable实例并使用KaTeX插件\r\n    const md = new Remarkable();\r\n    md.use(katexPlugin, { \r\n      delimiter: '$',         // 使用$作为分隔符\r\n      throwOnError: false     // 遇到错误不抛出异常\r\n    });\r\n    ```\r\n- **`md.render(markdown)`**: 将Markdown文本渲染为HTML\r\n  - **形参**:\r\n    - `markdown` (string): 待渲染的Markdown文本\r\n  - **返回值**: (string) 渲染后的HTML字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 渲染包含内联数学公式的Markdown文本\r\n    const html = md.render('This is $x^2$ inline math.');\r\n    ```\r\n\r\n### 测试框架函数\r\n- **`vows.describe(name)`**: 创建测试套件\r\n  - **形参**:\r\n    - `name` (string): 测试套件名称\r\n  - **返回值**: 测试套件对象\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 创建名为'KatexPlugin'的测试套件\r\n    vows.describe('KatexPlugin').addBatch({\r\n      'Test case 1': {\r\n        topic: function() { /* 准备测试数据 */ },\r\n        'should work': function(topic) { /* 验证结果 */ }\r\n      }\r\n    });\r\n    ```\r\n- **`addBatch(tests)`**: 添加测试批次\r\n  - **形参**:\r\n    - `tests` (Object): 测试用例对象\r\n  - **返回值**: 测试套件对象（支持链式调用）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 向测试套件添加测试批次\r\n    suite.addBatch({\r\n      'Basic functionality': {\r\n        topic: 'test data',                    // 测试主题数据\r\n        'should pass': function(topic) {       // 断言测试\r\n          assert.equal(topic, 'test data');   // 验证相等性\r\n        }\r\n      }\r\n    });\r\n    ```\r\n- **`assert.*`**: Node.js断言库的各种断言方法\r\n  - **常用方法**:\r\n    - `assert.equal(actual, expected)`: 严格相等比较\r\n    - `assert.isTrue(value)`: 检查值是否为真\r\n    - `assert.notEqual(actual, unexpected)`: 检查值不相等\r\n    - `assert.throws(fn)`: 检查函数是否抛出异常\r\n    - `assert.isObject(value)`: 检查是否为对象\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 验证结果与期望值相等\r\n    assert.equal(result, '\u003cp\u003etest\u003c/p\u003e');\r\n    \r\n    // 验证HTML包含KaTeX元素\r\n    assert.isTrue(html.includes('\u003cspan class=\"katex\"\u003e'));\r\n    \r\n    // 验证函数抛出异常\r\n    assert.throws(function() { throw new Error(); });\r\n    ```\r\n\r\n---\r\n\r\n## index.js 代码逐行解析\r\n\r\n### 文件开头和模块声明\r\n\r\n```javascript\r\n\"use strict\";\r\n```\r\n**第1行**: 使用严格模式，确保代码在严格的 JavaScript 环境中运行，有助于捕获常见的编程错误。\r\n\r\n```javascript\r\n/**\r\n * Plugin for Remarkable Markdown processor which transforms $..$ and $$..$$ sequences into math HTML using the\r\n * Katex package.\r\n */\r\n```\r\n**第3-6行**: JSDoc 注释，描述了这个插件的作用：为 Remarkable Markdown 处理器提供插件，将数学公式标记转换为 KaTeX 渲染的 HTML。\r\n\r\n```javascript\r\nconst rkatex = (md, options) =\u003e {\r\n```\r\n**第7行**: 定义主函数 `rkatex`，接受两个参数：\r\n- `md`: Remarkable 实例\r\n- `options`: 配置选项对象\r\n\r\n### 基础配置和变量声明\r\n\r\n```javascript\r\n  const backslash = '\\\\';\r\n  const dollar = '$';\r\n```\r\n**第8-9行**: 定义常量字符：\r\n- `backslash`: 反斜杠字符，用于转义\r\n- `dollar`: 美元符号，默认的数学公式分隔符\r\n\r\n```javascript\r\n  const opts = options || {};\r\n  const delimiter = opts.delimiter || dollar;\r\n```\r\n**第10-11行**: 处理配置选项：\r\n- `opts`: 确保 options 存在，如果为空则使用空对象\r\n- `delimiter`: 从选项中获取分隔符，默认使用美元符号\r\n\r\n```javascript\r\n  if (delimiter.length !== 1) { throw new Error('invalid delimiter'); }\r\n```\r\n**第12行**: 验证分隔符长度，只允许单字符分隔符，否则抛出错误。\r\n\r\n### 工具模块导入和样式配置\r\n\r\n```javascript\r\n  // Import styling utilities\r\n  const { applyCustomStyling } = require('./utils');\r\n```\r\n**第14-15行**: 从 utils 模块导入自定义样式处理函数。\r\n- **`require('./utils')`**: Node.js模块加载函数，相对路径加载同目录下的utils.js文件\r\n- **解构赋值**: 从utils模块中提取applyCustomStyling函数\r\n\r\n```javascript\r\n  // Extract styling configuration (kept for backward compatibility)\r\n  const stylingConfig = {\r\n    useTailwind: opts.useTailwind || false,\r\n    // Add other styling options here as needed\r\n  };\r\n```\r\n**第17-21行**: 创建样式配置对象：\r\n- `useTailwind`: 是否使用 Tailwind CSS，默认为 false\r\n- 保留向后兼容性，可以添加其他样式选项\r\n\r\n```javascript\r\n  const katex = require(\"katex\");\r\n```\r\n**第23行**: 导入 KaTeX 库，用于数学公式渲染。\r\n- **`require(\"katex\")`**: 加载KaTeX npm包，这是一个快速的数学公式渲染库\r\n- **KaTeX**: 由Khan Academy开发的JavaScript数学公式渲染库，支持LaTeX语法\r\n\r\n### KaTeX 渲染函数\r\n\r\n```javascript\r\n  /**\r\n   * Render the contents as KaTeX\r\n   */\r\n  const renderKatex = (source, displayMode) =\u003e {\r\n```\r\n**第25-28行**: 定义 KaTeX 渲染函数，接受源内容和显示模式参数。\r\n\r\n```javascript\r\n    const rendered = katex.renderToString(source, {\r\n      displayMode: displayMode,\r\n      throwOnError: false\r\n    });\r\n```\r\n**第29-32行**: 使用 KaTeX 渲染数学公式：\r\n- **`katex.renderToString()`**: KaTeX核心渲染函数，将LaTeX表达式转换为HTML字符串\r\n  - `source`: 输入的LaTeX数学表达式字符串\r\n  - `options`: 渲染配置对象\r\n- `displayMode`: 布尔值，true时使用块级显示模式（居中、大字号），false时使用内联模式\r\n- `throwOnError: false`: 遇到LaTeX语法错误时不抛出异常，而是渲染错误提示信息\r\n\r\n```javascript\r\n    // Always apply custom styling to process aria-hidden elements\r\n    return applyCustomStyling(rendered, stylingConfig);\r\n```\r\n**第34-35行**: 对渲染结果应用自定义样式处理，特别是处理 aria-hidden 元素。\r\n\r\n### 块级 KaTeX 解析函数\r\n\r\n```javascript\r\n  /**\r\n   * Parse '$$' as a block. Based off of similar method in remarkable.\r\n   */\r\n  const parseBlockKatex = (state, startLine, endLine) =\u003e {\r\n```\r\n**第39-42行**: 定义块级 KaTeX 解析函数，基于 Remarkable 的类似方法实现。\r\n\r\n```javascript\r\n    let haveEndMarker = false;\r\n    let pos = state.bMarks[startLine] + state.tShift[startLine];\r\n    let max = state.eMarks[startLine];\r\n```\r\n**第43-45行**: 初始化解析状态：\r\n- `haveEndMarker`: 布尔标志，跟踪是否找到匹配的结束标记\r\n- **`state.bMarks[startLine]`**: Remarkable状态对象属性，获取指定行的开始字符位置（不包含前导空格）\r\n- **`state.tShift[startLine]`**: Remarkable状态对象属性，获取指定行的前导空格/制表符数量\r\n- `pos`: 计算得出的实际解析起始位置（跳过前导空格后的位置）\r\n- **`state.eMarks[startLine]`**: Remarkable状态对象属性，获取指定行的结束字符位置\r\n\r\n```javascript\r\n    if (pos + 1 \u003e max) { return false; }\r\n```\r\n**第47行**: 检查是否有足够的字符来形成标记，如果不够则返回 false。\r\n\r\n```javascript\r\n    const marker = state.src.charAt(pos);\r\n    if (marker !== delimiter) { return false; }\r\n```\r\n**第49-50行**: 检查当前字符是否为分隔符，如果不是则返回 false。\r\n\r\n```javascript\r\n    // scan marker length\r\n    let mem = pos;\r\n    pos = state.skipChars(pos, marker);\r\n    let len = pos - mem;\r\n```\r\n**第52-55行**: 扫描标记长度：\r\n- `mem`: 记住起始位置，用于后续长度计算\r\n- **`state.skipChars(pos, marker)`**: Remarkable状态方法，从指定位置开始跳过连续的相同字符\r\n  - `pos`: 起始位置\r\n  - `marker`: 要跳过的字符（这里是分隔符，如'$'）\r\n  - 返回值: 跳过连续字符后的新位置\r\n- `len`: 计算标记长度（连续分隔符的数量）\r\n\r\n```javascript\r\n    if (len !== 2) { return false; }\r\n```\r\n**第57行**: 块级公式需要恰好两个分隔符（如 $$），否则返回 false。\r\n\r\n```javascript\r\n    // search end of block\r\n    let nextLine = startLine;\r\n\r\n    for (; ;) {\r\n      ++nextLine;\r\n      if (nextLine \u003e= endLine) { break; }\r\n```\r\n**第59-64行**: 开始搜索块的结束标记，遍历后续行。\r\n\r\n```javascript\r\n      pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\r\n      max = state.eMarks[nextLine];\r\n\r\n      if (pos \u003c max \u0026\u0026 state.tShift[nextLine] \u003c state.blkIndent) { break; }\r\n      if (state.src.charAt(pos) !== delimiter) { continue; }\r\n      if (state.tShift[nextLine] - state.blkIndent \u003e= 4) { continue; }\r\n```\r\n**第66-71行**: 检查每一行：\r\n- 计算当前行的位置信息\r\n- 检查缩进是否合适\r\n- 检查是否以分隔符开始\r\n- 检查缩进是否超过4个空格（代码块规则）\r\n\r\n```javascript\r\n      pos = state.skipChars(pos, marker);\r\n      if (pos - mem \u003c len) { continue; }\r\n\r\n      pos = state.skipSpaces(pos);\r\n      if (pos \u003c max) { continue; }\r\n\r\n      haveEndMarker = true;\r\n      break;\r\n```\r\n**第73-80行**: 验证结束标记：\r\n- **`state.skipChars(pos, marker)`**: 跳过连续的分隔符字符\r\n- 检查跳过的字符数量是否与起始标记长度匹配\r\n- **`state.skipSpaces(pos)`**: Remarkable状态方法，从指定位置跳过空格和制表符\r\n  - `pos`: 起始位置\r\n  - 返回值: 跳过空格后的新位置\r\n- 如果跳过空格后行上还有其他内容，说明不是有效的结束标记\r\n- 找到有效的结束标记，设置标志并退出循环\r\n\r\n```javascript\r\n    // Only process if we found a complete block (with end marker)\r\n    if (!haveEndMarker) { return false; }\r\n```\r\n**第83-84行**: 只有找到完整的块（有结束标记）才继续处理。\r\n\r\n```javascript\r\n    // If a fence has heading spaces, they should be removed from its inner block\r\n    len = state.tShift[startLine];\r\n    state.line = nextLine + 1; // Always advance past the end marker\r\n    const content = state.getLines(startLine + 1, nextLine, len, true)\r\n      .replace(/[ \\n]+/g, ' ')\r\n      .trim();\r\n```\r\n**第86-91行**: 提取块内容：\r\n- 记录起始行的缩进量，用于后续内容提取时保持一致的缩进处理\r\n- **`state.line`**: 更新Remarkable状态对象的当前行号，跳过结束标记行\r\n- **`state.getLines(startLine + 1, nextLine, len, true)`**: Remarkable状态方法，提取指定行范围的文本\r\n  - `startLine + 1`: 从起始标记的下一行开始（跳过开始的$$行）\r\n  - `nextLine`: 到结束标记行结束（不包含结束的$$行）\r\n  - `len`: 要移除的缩进量（与起始行缩进保持一致）\r\n  - `true`: 保留最后的换行符\r\n- **`.replace(/[ \\n]+/g, ' ')`**: 使用正则表达式将多个连续空格和换行符替换为单个空格\r\n- **`.trim()`**: 去除字符串首尾的空白字符\r\n\r\n```javascript\r\n    state.tokens.push({\r\n      type: 'katex', params: null, content: content, lines: [startLine, state.line],\r\n      level: state.level, block: true\r\n    });\r\n    return true;\r\n```\r\n**第93-97行**: 创建并添加 token：\r\n- **`state.tokens.push()`**: 向Remarkable状态对象的tokens数组添加新的token对象\r\n- **Token对象结构**:\r\n  - `type: 'katex'`: 指定token类型，用于后续渲染器识别\r\n  - `params: null`: 附加参数（此处为空）\r\n  - `content: content`: 提取的LaTeX数学表达式内容\r\n  - `lines: [startLine, state.line]`: 记录token在源文档中的行号范围\r\n  - `level: state.level`: 当前嵌套级别\r\n  - `block: true`: 标记为块级元素（与内联元素区分）\r\n- `return true`: 返回true表示成功解析并处理了这个块\r\n\r\n### 内联 KaTeX 解析函数\r\n\r\n```javascript\r\n  /**\r\n   * Look for '$' or '$$' spans in Markdown text. Based off of the 'fenced' parser in remarkable.\r\n   */\r\n  const parseInlineKatex = (state, silent) =\u003e {\r\n```\r\n**第101-104行**: 定义内联 KaTeX 解析函数，基于 Remarkable 的 fenced 解析器。\r\n\r\n```javascript\r\n    const start = state.pos;\r\n    const max = state.posMax;\r\n    let pos = start;\r\n\r\n    // Unexpected starting character\r\n    if (state.src.charAt(pos) !== delimiter) { return false; }\r\n```\r\n**第105-110行**: 初始化解析状态并检查起始字符是否为分隔符。\r\n\r\n```javascript\r\n    ++pos;\r\n    while (pos \u003c max \u0026\u0026 state.src.charAt(pos) === delimiter) { ++pos; }\r\n\r\n    // Capture the length of the starting delimiter -- closing one must match in size\r\n    const marker = state.src.slice(start, pos);\r\n    if (marker.length \u003e 2) { return false; }\r\n```\r\n**第112-117行**: 扫描起始标记：\r\n- 跳过第一个分隔符\r\n- 继续跳过连续的分隔符\r\n- 记录标记内容\r\n- 限制标记长度不超过2（$ 或 $$）\r\n\r\n```javascript\r\n    const spanStart = pos;\r\n    let escapedDepth = 0;\r\n```\r\n**第119-120行**: 初始化内容解析：\r\n- `spanStart`: 记录内容开始位置\r\n- `escapedDepth`: 跟踪大括号嵌套深度\r\n\r\n```javascript\r\n    while (pos \u003c max) {\r\n      const char = state.src.charAt(pos);\r\n      if (char === '{' \u0026\u0026 (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\r\n        escapedDepth += 1;\r\n      } else if (char === '}' \u0026\u0026 (pos == 0 || state.src.charAt(pos - 1) != backslash)) {\r\n        escapedDepth -= 1;\r\n        if (escapedDepth \u003c 0) { return false; }\r\n```\r\n**第121-127行**: 处理大括号嵌套：\r\n- 遇到未转义的 `{` 时增加深度\r\n- 遇到未转义的 `}` 时减少深度\r\n- 如果深度为负数说明括号不匹配\r\n\r\n```javascript\r\n      } else if (char === delimiter \u0026\u0026 escapedDepth === 0) {\r\n        const matchStart = pos;\r\n        let matchEnd = pos + 1;\r\n        while (matchEnd \u003c max \u0026\u0026 state.src.charAt(matchEnd) === delimiter) { ++matchEnd; }\r\n\r\n        if (matchEnd - matchStart === marker.length) {\r\n```\r\n**第128-133行**: 寻找匹配的结束标记：\r\n- 只在大括号平衡时才考虑分隔符\r\n- 计算连续分隔符的长度\r\n- 检查长度是否与起始标记匹配\r\n\r\n```javascript\r\n          if (!silent) {\r\n            const content = state.src.slice(spanStart, matchStart)\r\n              .replace(/[ \\n]+/g, ' ')\r\n              .trim();\r\n            state.push({ type: 'katex', content: content, block: marker.length \u003e 1, level: state.level });\r\n          }\r\n          state.pos = matchEnd;\r\n          return true;\r\n```\r\n**第134-141行**: 处理匹配的标记：\r\n- `!silent`: 检查是否为非静默模式（静默模式只检查语法不创建token）\r\n- **`state.src.slice(spanStart, matchStart)`**: 从源文本中提取指定范围的内容\r\n  - `spanStart`: 内容开始位置（跳过起始分隔符后）\r\n  - `matchStart`: 结束分隔符开始位置（不包含结束分隔符）\r\n- 内容清理：替换多空格/换行为单空格，去除首尾空白\r\n- **`state.push(tokenObject)`**: Remarkable状态方法，向tokens数组添加token\r\n  - `type: 'katex'`: token类型\r\n  - `content: content`: 处理后的LaTeX表达式\r\n  - `block: marker.length \u003e 1`: 根据分隔符长度判断是否为块级（$$为块级，$为内联）\r\n  - `level: state.level`: 当前嵌套级别\r\n- **`state.pos`**: 更新Remarkable状态对象的当前解析位置到结束分隔符之后\r\n\r\n```javascript\r\n        }\r\n      }\r\n      pos += 1;\r\n    }\r\n\r\n    // If we reach here, no matching closing delimiter was found\r\n    // Don't add anything to pending and don't advance position to avoid partial rendering\r\n    return false;\r\n```\r\n**第142-148行**: 处理未找到匹配标记的情况：\r\n- 继续向前搜索\r\n- 如果到达末尾仍未找到匹配的结束标记\r\n- 返回 false，不创建 token，避免部分渲染\r\n\r\n### 插件注册\r\n\r\n```javascript\r\n  md.inline.ruler.push('katex', parseInlineKatex, options);\r\n  md.block.ruler.push('katex', parseBlockKatex, options);\r\n```\r\n**第151-152行**: 向 Remarkable 注册解析规则：\r\n- **`md.inline.ruler.push()`**: Remarkable插件API，向内联解析器注册新的解析规则\r\n  - `'katex'`: 规则名称，用于标识和排序\r\n  - `parseInlineKatex`: 内联解析函数\r\n  - `options`: 解析选项（可选）\r\n- **`md.block.ruler.push()`**: Remarkable插件API，向块级解析器注册新的解析规则\r\n  - `'katex'`: 规则名称\r\n  - `parseBlockKatex`: 块级解析函数\r\n  - `options`: 解析选项（可选）\r\n\r\n```javascript\r\n  md.renderer.rules.katex = (tokens, idx) =\u003e {\r\n    const token = tokens[idx];\r\n    const rendered = renderKatex(token.content, token.block);\r\n    // Return clean HTML without any markdown artifacts\r\n    return rendered;\r\n  };\r\n```\r\n**第153-158行**: 定义渲染规则：\r\n- **`md.renderer.rules.katex`**: Remarkable渲染器API，为'katex'类型的token定义渲染函数\r\n- **渲染函数参数**:\r\n  - `tokens`: 完整的tokens数组\r\n  - `idx`: 当前要渲染的token在数组中的索引\r\n- `tokens[idx]`: 获取当前要渲染的token对象\r\n- `renderKatex(token.content, token.block)`: 调用前面定义的KaTeX渲染函数\r\n- 返回渲染后的HTML字符串，无Markdown语法残留\r\n\r\n```javascript\r\n  md.renderer.rules.katex.delimiter = delimiter;\r\n```\r\n**第159行**: 将分隔符信息附加到渲染规则上，便于调试和配置检查。\r\n\r\n```javascript\r\n};\r\n\r\nmodule.exports = rkatex;\r\n```\r\n**第160-162行**: 结束函数定义并导出模块。\r\n- `};`: 结束rkatex函数定义\r\n- **`module.exports`**: Node.js模块导出机制，使rkatex函数可被其他模块通过require()导入使用\r\n\r\n---\r\n\r\n## index.test.js 代码逐行解析\r\n\r\n### 测试文件头部\r\n\r\n```javascript\r\n\"use strict\";\r\n```\r\n**第1行**: 启用严格模式。\r\n\r\n```javascript\r\nconst vows = require('vows');\r\nconst assert = require('assert');\r\nconst { Remarkable } = require('remarkable');\r\n\r\nconst plugin = require('./index.js');\r\n```\r\n**第3-6行**: 导入测试依赖：\r\n- **`require('vows')`**: 导入vows测试框架，一个用于Node.js的BDD（行为驱动开发）测试框架\r\n- **`require('assert')`**: 导入Node.js内置断言库，提供各种断言方法用于测试验证\r\n- **`require('remarkable')`**: 导入Remarkable Markdown处理器，使用解构语法获取Remarkable构造函数\r\n- **`require('./index.js')`**: 导入当前目录下的插件主文件（相对路径导入）\r\n\r\n### 测试实例准备\r\n\r\n```javascript\r\nconst mdWithDollar = new Remarkable();\r\nmdWithDollar.use(plugin);\r\n\r\nconst mdWithAt = new Remarkable();\r\nmdWithAt.use(plugin, {delimiter: '@'});\r\n```\r\n**第8-12行**: 创建测试实例：\r\n- **`new Remarkable()`**: 创建Remarkable Markdown处理器实例\r\n- **`mdWithDollar.use(plugin)`**: 使用Remarkable插件API加载KaTeX插件（使用默认配置）\r\n  - `plugin`: 前面导入的KaTeX插件函数\r\n- **`mdWithAt.use(plugin, {delimiter: '@'})`**: 加载插件并传入自定义配置\r\n  - `{delimiter: '@'}`: 配置对象，指定使用@符号作为数学公式分隔符替代默认的$符号\r\n\r\n### 测试套件开始\r\n\r\n```javascript\r\nvows.describe('KatexPlugin').addBatch({\r\n```\r\n**第14行**: 使用 vows 框架创建名为 'KatexPlugin' 的测试套件。\r\n- **`vows.describe('KatexPlugin')`**: vows测试框架API，创建一个测试套件（Test Suite）\r\n  - `'KatexPlugin'`: 测试套件的名称，用于测试输出和组织\r\n- **`.addBatch(testObject)`**: vows框架方法，向测试套件添加一批测试用例\r\n  - `testObject`: 包含多个测试用例的对象\r\n\r\n### 配置测试\r\n\r\n```javascript\r\n  'Config empty delimiter': {\r\n    topic() {\r\n      const md = new Remarkable();\r\n      md.use(plugin, {delimiter: ''});\r\n      return md;\r\n    },\r\n    'Uses default delimiter': function(topic) {\r\n      assert.equal(topic.renderer.rules.katex.delimiter, '$');\r\n    }\r\n  },\r\n```\r\n**第15-24行**: 测试空分隔符配置：\r\n- 创建使用空分隔符的实例\r\n- 验证是否回退到默认的 $ 分隔符\r\n\r\n```javascript\r\n  'Multi-char delimiter': {\r\n    topic() {\r\n      return () =\u003e {\r\n        const md = new Remarkable();\r\n        md.use(plugin, {delimiter: '$$'});\r\n        return md;\r\n      };\r\n    },\r\n    'Throws exception': function(topic) {\r\n      assert.throws(topic);\r\n    }\r\n  },\r\n```\r\n**第25-36行**: 测试多字符分隔符：\r\n- 尝试使用两个字符的分隔符\r\n- **`assert.throws(topic)`**: Node.js断言库方法，验证函数调用是否抛出异常\r\n  - `topic`: 要测试的函数（这里是返回Remarkable实例创建函数的函数）\r\n  - 如果函数没有抛出异常，断言失败\r\n\r\n### 基础文本渲染测试\r\n\r\n```javascript\r\n  'Render plain text': {\r\n    topic: mdWithDollar.render('This is a test.'),\r\n    'Nothing done': function(topic) {\r\n      assert.equal(topic, '\u003cp\u003eThis is a test.\u003c/p\u003e\\n');\r\n    }\r\n  },\r\n```\r\n**第37-42行**: 测试纯文本渲染：\r\n- **`mdWithDollar.render('This is a test.')`**: 使用Remarkable实例的render方法处理Markdown文本\r\n  - `render()`: Remarkable核心方法，将Markdown文本转换为HTML\r\n  - 返回值: 渲染后的HTML字符串\r\n- **`assert.equal(actual, expected)`**: Node.js断言库方法，验证两个值是否严格相等\r\n  - `actual`: 实际得到的值（render方法的返回值）\r\n  - `expected`: 期望的值（'\u003cp\u003eThis is a test.\u003c/p\u003e\\n'）\r\n- 确保插件不影响普通文本的正常渲染\r\n\r\n```javascript\r\n  'Render with single $ in text': {\r\n    topic: mdWithDollar.render('The car cost $20,000 new.'),\r\n    'Nothing done': function(topic) {\r\n      assert.equal(topic, '\u003cp\u003eThe car cost $20,000 new.\u003c/p\u003e\\n');\r\n    }\r\n  },\r\n```\r\n**第43-48行**: 测试单个美元符号：\r\n- 验证单独的 $ 符号不被误认为数学公式标记\r\n- 确保正常文本中的货币符号正确显示\r\n\r\n### 内联数学公式测试\r\n\r\n```javascript\r\n  'Render $...$ in text': {\r\n    topic: mdWithDollar.render('Equation $x + y$.'),\r\n    'Starts with \"\u003cp\u003eEquation \"': function(topic) {\r\n      assert.isTrue(topic.startsWith('\u003cp\u003eEquation '));\r\n    },\r\n    'Ends with \".\u003c/p\u003e\"': function(topic) {\r\n      assert.isTrue(topic.endsWith('\u003c/span\u003e.\u003c/p\u003e\\n'));\r\n    },\r\n    'Contains math span': function(topic) {\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\r\n    }\r\n  },\r\n```\r\n**第49-61行**: 测试基本内联数学公式：\r\n- **`assert.isTrue(condition)`**: Node.js断言库方法，验证条件是否为真值\r\n  - `topic.startsWith('\u003cp\u003eEquation ')`: JavaScript字符串方法，检查字符串是否以指定前缀开始\r\n  - `topic.endsWith('\u003c/span\u003e.\u003c/p\u003e\\n')`: JavaScript字符串方法，检查字符串是否以指定后缀结束\r\n- **`assert.notEqual(actual, unexpected)`**: Node.js断言库方法，验证两个值不相等\r\n  - `topic.indexOf('\u003cspan class=\"katex\"\u003e')`: JavaScript字符串方法，查找子字符串在字符串中的位置\r\n  - `-1`: indexOf方法未找到时的返回值\r\n  - 这个断言确保HTML中包含KaTeX渲染的span元素\r\n\r\n```javascript\r\n  'Render $...$ in text with embedded {$...$}': {\r\n    topic: mdWithDollar.render('Equation $\\\\colorbox{aqua}{$F=ma$}$.'),\r\n    // ... 类似的断言\r\n  },\r\n```\r\n**第62-74行**: 测试嵌套大括号的复杂公式：\r\n- 验证插件正确处理嵌套的大括号结构\r\n- 确保复杂的 LaTeX 命令正确渲染\r\n\r\n### 块级数学公式测试\r\n\r\n```javascript\r\n  'Render $$...$$ in text': {\r\n    topic: mdWithDollar.render('Before\\n$$\\nx + y\\n$$\\nafter.'),\r\n    'Starts with \"\u003cp\u003eBefore \"': function(topic) {\r\n      assert.isTrue(topic.startsWith('\u003cp\u003eBefore\\n'));\r\n    },\r\n    'Ends with \"after.\u003c/p\u003e\"': function(topic) {\r\n      assert.isTrue(topic.endsWith('\u003c/span\u003e\\nafter.\u003c/p\u003e\\n'));\r\n    },\r\n    'Contains math span': function(topic) {\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\r\n    }\r\n  },\r\n```\r\n**第87-99行**: 测试块级数学公式：\r\n- 验证多行的 $$ 块正确渲染\r\n- 确保使用 katex-display 类名\r\n\r\n### 自定义分隔符测试\r\n\r\n```javascript\r\n  'Render @...@ in text': {\r\n    topic: mdWithAt.render('Equation @x + y@.'),\r\n    // ... 验证使用 @ 分隔符的内联公式\r\n  },\r\n  'Render @@...@@ in text': {\r\n    topic: mdWithAt.render('Before @@x + y@@ after.'),\r\n    // ... 验证使用 @ 分隔符的块级公式\r\n  },\r\n```\r\n**第75-86行 和 100-112行**: 测试自定义分隔符：\r\n- 验证插件支持自定义分隔符（@ 替代 $）\r\n- 确保内联和块级公式都能正确使用自定义分隔符\r\n\r\n### 错误处理测试\r\n\r\n```javascript\r\n  'Incomplete inline expression (no closing delimiter)': {\r\n    topic: mdWithDollar.render('This has $incomplete math expression.'),\r\n    'Original text preserved': function(topic) {\r\n      assert.equal(topic, '\u003cp\u003eThis has $incomplete math expression.\u003c/p\u003e\\n');\r\n    },\r\n    'No KaTeX HTML generated': function(topic) {\r\n      assert.equal(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\r\n    }\r\n  },\r\n```\r\n**第113-122行**: 测试不完整的内联表达式：\r\n- 验证缺少结束分隔符时保持原文\r\n- 确保不生成错误的 KaTeX HTML\r\n\r\n```javascript\r\n  'Incomplete block expression (no closing delimiter)': {\r\n    topic: mdWithDollar.render('Before\\n$$\\nincomplete block\\nafter.'),\r\n    'Original text preserved': function(topic) {\r\n      assert.equal(topic, '\u003cp\u003eBefore\\n$$\\nincomplete block\\nafter.\u003c/p\u003e\\n');\r\n    },\r\n    'No KaTeX HTML generated': function(topic) {\r\n      assert.equal(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\r\n    }\r\n  },\r\n```\r\n**第123-132行**: 测试不完整的块级表达式：\r\n- 验证缺少结束标记时保持原文\r\n- 确保不生成部分的数学公式 HTML\r\n\r\n### 内容清理测试\r\n\r\n```javascript\r\n  'Original expression completely removed in inline math': {\r\n    topic: mdWithDollar.render('Test $x^2$ here.'),\r\n    'No dollar signs in output': function(topic) {\r\n      // Should not contain the original $ delimiters\r\n      assert.equal(topic.indexOf('$x^2$'), -1);\r\n    },\r\n    'Contains rendered math': function(topic) {\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\r\n    },\r\n    'Contains x^2 in rendered form': function(topic) {\r\n      // KaTeX should render x^2 as superscript\r\n      assert.notEqual(topic.indexOf('x'), -1);\r\n      assert.notEqual(topic.indexOf('2'), -1);\r\n    }\r\n  },\r\n```\r\n**第133-149行**: 测试原始表达式的完全移除：\r\n- 验证原始的 $ 分隔符不出现在输出中\r\n- 确保内容被正确转换为 KaTeX HTML\r\n- 验证数学符号正确渲染\r\n\r\n### KaTeX 注释保留测试\r\n\r\n```javascript\r\n  'Original expression completely removed in block math': {\r\n    topic: mdWithDollar.render('Before\\n$$\\n\\\\frac{a}{b}\\n$$\\nafter.'),\r\n    'No double dollar signs in output': function(topic) {\r\n      // Should not contain the original $$ delimiters\r\n      assert.equal(topic.indexOf('$$'), -1);\r\n    },\r\n    'Raw LaTeX preserved in annotation (correct behavior)': function(topic) {\r\n      // KaTeX preserves original LaTeX in annotation tags - this is correct\r\n      assert.notEqual(topic.indexOf('\\\\frac{a}{b}'), -1);\r\n      assert.notEqual(topic.indexOf('\u003cannotation encoding=\"application/x-tex\"\u003e'), -1);\r\n    },\r\n    'Contains rendered math': function(topic) {\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\r\n    }\r\n  },\r\n```\r\n**第150-165行**: 测试块级公式的处理：\r\n- 验证 $$ 分隔符被移除\r\n- 确认 KaTeX 在注释标签中保留原始 LaTeX（这是正确行为）\r\n- 验证包含渲染的数学元素\r\n\r\n### 多个表达式测试\r\n\r\n```javascript\r\n  'Multiple expressions all converted': {\r\n    topic: mdWithDollar.render('First $a+b$ and second $c+d$ expressions.'),\r\n    'No dollar signs remain': function(topic) {\r\n      assert.equal(topic.indexOf('$a+b$'), -1);\r\n      assert.equal(topic.indexOf('$c+d$'), -1);\r\n    },\r\n    'Two math spans created': function(topic) {\r\n      const matches = topic.match(/\u003cspan class=\"katex\"\u003e/g);\r\n      assert.equal(matches ? matches.length : 0, 2);\r\n    }\r\n  },\r\n```\r\n**第166-177行**: 测试多个数学表达式：\r\n- 验证所有原始分隔符都被移除\r\n- **`topic.match(/\u003cspan class=\"katex\"\u003e/g)`**: JavaScript字符串正则匹配方法\r\n  - `/\u003cspan class=\"katex\"\u003e/g`: 全局正则表达式，查找所有KaTeX span标签\r\n  - `g`标志: 全局匹配，返回所有匹配项而不是只返回第一个\r\n  - 返回值: 匹配项数组或null（无匹配时）\r\n- **三元运算符 `matches ? matches.length : 0`**: 安全获取匹配数量\r\n  - 如果matches不为null，返回数组长度\r\n  - 如果matches为null（无匹配），返回0\r\n- 确保创建了正确数量（2个）的数学span元素\r\n\r\n### 混合表达式测试\r\n\r\n```javascript\r\n  'Mixed inline and block expressions': {\r\n    topic: mdWithDollar.render('Inline $x$ and block:\\n$$\\ny = mx + b\\n$$\\ndone.'),\r\n    'No original delimiters remain': function(topic) {\r\n      assert.equal(topic.indexOf('$x$'), -1);\r\n      assert.equal(topic.indexOf('$$'), -1);\r\n      // Note: \"y = mx + b\" will be preserved in KaTeX annotation - this is correct\r\n    },\r\n    'Contains both inline and block math': function(topic) {\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex-display\"\u003e'), -1);\r\n    },\r\n    'LaTeX content preserved in annotations': function(topic) {\r\n      // KaTeX correctly preserves LaTeX in annotations\r\n      assert.notEqual(topic.indexOf('\u003cannotation encoding=\"application/x-tex\"\u003ex\u003c/annotation\u003e'), -1);\r\n      assert.notEqual(topic.indexOf('\u003cannotation encoding=\"application/x-tex\"\u003ey = mx + b\u003c/annotation\u003e'), -1);\r\n    }\r\n  },\r\n```\r\n**第178-194行**: 测试内联和块级表达式的混合使用：\r\n- 验证所有原始分隔符被移除\r\n- 确保同时包含内联和块级数学元素\r\n- 验证 LaTeX 内容在注释中的正确保留\r\n\r\n### 错误处理配置测试\r\n\r\n```javascript\r\n  'KaTeX error handling (throwOnError: false)': {\r\n    topic: mdWithDollar.render('Invalid math: $\\\\invalidcommand{test}$.'),\r\n    'Renders without throwing': function(topic) {\r\n      // Should render something even with invalid LaTeX (due to throwOnError: false)\r\n      assert.isTrue(topic.length \u003e 0);\r\n      assert.notEqual(topic.indexOf('\u003cspan class=\"katex\"\u003e'), -1);\r\n    },\r\n    'No original delimiters remain': function(topic) {\r\n      assert.equal(topic.indexOf('$\\\\invalidcommand{test}$'), -1);\r\n    }\r\n  },\r\n```\r\n**第195-206行**: 测试 KaTeX 错误处理：\r\n- 验证无效的 LaTeX 命令不会抛出异常\r\n- 确保仍然生成某种输出（错误显示）\r\n- 验证原始分隔符被移除\r\n\r\n### 配置选项测试\r\n\r\n```javascript\r\n  'Config with useTailwind=false (default)': {\r\n    topic() {\r\n      const md = new Remarkable();\r\n      md.use(plugin, { useTailwind: false });\r\n      return md;\r\n    },\r\n    'Configuration applied correctly': function(topic) {\r\n      // Test that configuration is accepted without error\r\n      assert.isObject(topic);\r\n    }\r\n  },\r\n  'Config with useTailwind=true': {\r\n    topic() {\r\n      const md = new Remarkable();\r\n      md.use(plugin, { useTailwind: true });\r\n      return md;\r\n    },\r\n    'Configuration applied correctly': function(topic) {\r\n      // Test that configuration is accepted without error\r\n      assert.isObject(topic);\r\n    }\r\n  },\r\n```\r\n**第207-225行**: 测试 Tailwind 配置选项：\r\n- 验证 `useTailwind: false` 配置正确应用\r\n- 验证 `useTailwind: true` 配置正确应用\r\n- 确保配置被接受且不产生错误\r\n\r\n### 样式处理测试\r\n\r\n```javascript\r\n  'Aria-hidden processing with default styling': {\r\n    topic() {\r\n      const md = new Remarkable();\r\n      md.use(plugin, { useTailwind: false });\r\n      // Create a mock rendered output with aria-hidden elements\r\n      const { applyCustomStyling } = require('./utils');\r\n      const mockHtml = '\u003cspan class=\"inline\" aria-hidden=\"true\"\u003ehidden content\u003c/span\u003e';\r\n      return applyCustomStyling(mockHtml, { useTailwind: false });\r\n    },\r\n    'Removes inline class and adds display:none style': function(topic) {\r\n      assert.equal(topic.indexOf('class=\"inline\"'), -1);\r\n      assert.notEqual(topic.indexOf('style=\"display:none\"'), -1);\r\n    }\r\n  },\r\n  'Aria-hidden processing with Tailwind styling': {\r\n    topic() {\r\n      const md = new Remarkable();\r\n      md.use(plugin, { useTailwind: true });\r\n      // Create a mock rendered output with aria-hidden elements\r\n      const { applyCustomStyling } = require('./utils');\r\n      const mockHtml = '\u003cspan class=\"inline\" aria-hidden=\"true\"\u003ehidden content\u003c/span\u003e';\r\n      return applyCustomStyling(mockHtml, { useTailwind: true });\r\n    },\r\n    'Removes inline class and adds display:none style': function(topic) {\r\n      assert.equal(topic.indexOf('class=\"inline\"'), -1);\r\n      assert.notEqual(topic.indexOf('style=\"display:none\"'), -1);\r\n    }\r\n  }\r\n```\r\n**第226-250行**: 测试 aria-hidden 元素的样式处理：\r\n- **`require('./utils')`**: 重新导入utils模块以直接测试applyCustomStyling函数\r\n- **模拟HTML测试**: 创建包含aria-hidden属性的测试HTML片段\r\n- **`applyCustomStyling(mockHtml, config)`**: 调用样式处理函数\r\n  - `mockHtml`: 模拟的KaTeX渲染HTML\r\n  - `config`: 样式配置对象（包含useTailwind等选项）\r\n- 测试不同配置下的样式处理行为\r\n- 验证可访问性改进：inline类被移除，display:none样式被添加\r\n\r\n```javascript\r\n}).export(module);\r\n```\r\n**第251行**: 导出测试套件模块。\r\n- **`.export(module)`**: vows测试框架方法，导出测试套件以便能够被测试运行器执行\r\n  - `module`: Node.js当前模块对象\r\n  - 这使得测试文件可以通过命令行工具运行\r\n\r\n---\r\n\r\n## 总结\r\n\r\n这个插件的核心功能包括：\r\n\r\n1. **灵活的分隔符支持**: 支持自定义分隔符（默认为 $）\r\n2. **内联和块级支持**: 同时支持 `$...$` (内联) 和 `$$...$$` (块级) \r\n3. **智能解析**: 正确处理嵌套大括号和转义字符\r\n4. **错误处理**: 不完整的表达式保持原文，无效的 LaTeX 显示错误而不崩溃\r\n5. **样式自定义**: 支持 Tailwind CSS 和自定义样式处理\r\n6. **可访问性**: 处理 aria-hidden 元素以改善可访问性\r\n\r\n### 非标准库函数使用总结\r\n\r\n本插件主要依赖以下非JavaScript标准库的函数和API：\r\n\r\n#### Node.js 生态系统\r\n- **模块系统**: `require()`, `module.exports` 用于模块的导入导出\r\n- **断言库**: `assert.*` 方法群用于测试验证\r\n\r\n#### Remarkable Markdown 处理器\r\n- **解析器状态管理**: `state.bMarks`, `state.tShift`, `state.eMarks` 等属性管理文本位置信息\r\n- **文本处理方法**: `state.skipChars()`, `state.skipSpaces()`, `state.getLines()` 等方法处理文本解析\r\n- **Token管理**: `state.push()`, `state.tokens.push()` 用于创建语法树节点\r\n- **插件注册**: `md.inline.ruler.push()`, `md.block.ruler.push()` 注册解析规则\r\n- **渲染系统**: `md.renderer.rules.*` 定义HTML渲染逻辑\r\n\r\n#### KaTeX 数学渲染库\r\n- **核心渲染**: `katex.renderToString()` 将LaTeX转换为HTML\r\n\r\n#### Vows 测试框架\r\n- **测试组织**: `vows.describe()`, `.addBatch()`, `.export()` 构建测试结构\r\n- **行为验证**: 各种 assert 方法进行功能验证\r\n\r\n测试覆盖了所有主要功能和边界情况，通过详细的函数级解析确保对插件架构和实现的深入理解。\r\n"])</script><script>self.__next_f.push([1,"42:T9fa0,"])</script><script>self.__next_f.push([1,"\r\n# Remarkable Mermaid Plus 插件代码解析\r\n\r\n**插件版本：v1.0.26**\r\n\r\n本篇文章将会对 `remarkable-mermaid-plus` 插件代码进行逐行解析，包括主要的插件文件 `index.js` 和工具函数文件 `mermaid-utils.js`。本解析不仅解释每行代码的作用，还详细说明所有非JavaScript标准库函数的用法和原理。\r\n\r\n## 概览\r\n\r\n`remarkable-mermaid-plus` 是一个用于 Remarkable Markdown 处理器的插件，它能够将 Markdown 代码块中的 `mermaid` 代码转换为可交互的 Mermaid 图表。该插件采用后处理的方式，在 Remarkable 完成基本渲染后对 HTML 内容进行二次处理。\r\n\r\n## 依赖库函数说明\r\n\r\n在深入代码解析之前，先了解本插件使用的主要非标准库函数：\r\n\r\n### Node.js 相关函数\r\n- **`require(moduleName)`**: Node.js模块加载函数，用于导入外部模块或库\r\n  - **形参**: \r\n    - `moduleName` (string): 模块名称或路径字符串\r\n  - **返回值**: 导入的模块对象或函数\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 从工具模块导入处理函数\r\n    const { processMermaidInHTML } = require('./mermaid-utils');\r\n    \r\n    // 导入Node.js核心模块\r\n    const fs = require('fs');\r\n    ```\r\n- **`module.exports`**: Node.js模块导出对象，用于向外部提供模块功能\r\n  - **形参**: 无（这是一个属性，不是函数）\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 导出单个插件函数\r\n    module.exports = rmermaid;\r\n    \r\n    // 导出包含多个函数的对象\r\n    module.exports = { processMermaidInHTML };\r\n    ```\r\n\r\n### Remarkable 插件API\r\n- **`md.render(src, env)`**: Remarkable的核心渲染方法\r\n  - **形参**:\r\n    - `src` (string): 输入的Markdown文本字符串\r\n    - `env` (Object): 渲染环境对象（可选），包含渲染上下文信息\r\n  - **返回值**: (string) 渲染后的HTML字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 渲染基本的Markdown文本\r\n    const html = md.render('# Hello World\\n\\nThis is **bold** text.');\r\n    \r\n    // 渲染时传递环境对象\r\n    const htmlWithEnv = md.render('# Title', { customData: 'value' });\r\n    ```\r\n- **`originalRender.call(this, src, env)`**: JavaScript函数调用方法\r\n  - **形参**:\r\n    - `this` (Object): 调用上下文（这里是Remarkable实例）\r\n    - `src` (string): 传递给原始render方法的Markdown文本\r\n    - `env` (Object): 传递给原始render方法的环境对象\r\n  - **返回值**: (string) 原始渲染结果\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 保存原始渲染方法\r\n    const originalRender = md.render;\r\n    \r\n    // 重写渲染方法以添加后处理\r\n    md.render = function(src, env) {\r\n      // 调用原始渲染方法\r\n      const htmlContent = originalRender.call(this, src, env);\r\n      // 对HTML进行后处理\r\n      return processHTML(htmlContent);\r\n    };\r\n    ```\r\n\r\n### 浏览器DOM API\r\n- **`document.querySelectorAll(selector)`**: 根据CSS选择器查找所有匹配的DOM元素\r\n  - **形参**:\r\n    - `selector` (string): CSS选择器字符串\r\n  - **返回值**: NodeList对象，包含所有匹配的元素\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 查找所有class为mermaid的元素\r\n    const mermaidDivs = document.querySelectorAll('.mermaid');\r\n    \r\n    // 查找所有pre标签下的code元素\r\n    const codeBlocks = document.querySelectorAll('pre code');\r\n    ```\r\n- **`document.createElement(tagName)`**: 创建指定标签名的新DOM元素\r\n  - **形参**:\r\n    - `tagName` (string): HTML标签名字符串\r\n  - **返回值**: 新创建的DOM元素对象\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 创建新的div元素\r\n    const div = document.createElement('div');\r\n    \r\n    // 创建新的span元素\r\n    const span = document.createElement('span');\r\n    ```\r\n- **`document.body`**: 文档的body元素引用\r\n  - **类型**: HTMLElement\r\n  - **说明**: 获取文档的body元素\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 将临时容器添加到页面body中\r\n    document.body.appendChild(tempContainer);\r\n    ```\r\n- **`element.appendChild(child)`**: 将子元素添加到父元素中\r\n  - **形参**:\r\n    - `child` (Node): 要添加的子元素\r\n  - **返回值**: 添加的子元素\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取父容器元素\r\n    const parent = document.getElementById('container');\r\n    \r\n    // 创建新的子元素\r\n    const child = document.createElement('div');\r\n    \r\n    // 将子元素添加到父容器中\r\n    parent.appendChild(child);\r\n    ```\r\n- **`element.removeChild(child)`**: 从父元素中移除子元素\r\n  - **形参**:\r\n    - `child` (Node): 要移除的子元素\r\n  - **返回值**: 被移除的子元素\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取父容器元素\r\n    const parent = document.getElementById('container');\r\n    \r\n    // 获取要移除的子元素\r\n    const child = document.getElementById('temp');\r\n    \r\n    // 从父容器中移除子元素\r\n    parent.removeChild(child);\r\n    ```\r\n- **`element.textContent`**: 获取或设置元素的文本内容\r\n  - **类型**: string\r\n  - **说明**: 获取元素的纯文本内容（不包含HTML标签）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取元素的纯文本内容\r\n    const text = div.textContent;\r\n    \r\n    // 设置元素的文本内容\r\n    div.textContent = 'New text content';\r\n    ```\r\n- **`element.innerText`**: 获取或设置元素的可见文本内容\r\n  - **类型**: string\r\n  - **说明**: 获取元素的可见文本内容（考虑CSS样式）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取元素的可见文本内容\r\n    const visibleText = div.innerText;\r\n    \r\n    // 设置元素的可见文本\r\n    div.innerText = 'Visible text';\r\n    ```\r\n- **`element.innerHTML`**: 获取或设置元素的HTML内容\r\n  - **类型**: string\r\n  - **说明**: 获取或设置元素的HTML内容\r\n  - **使用示例**:\r\n    ```javascript\r\n    const html = div.innerHTML;               // 获取HTML内容\r\n    div.innerHTML = '\u003cspan\u003eNew HTML\u003c/span\u003e';  // 设置HTML内容\r\n    ```\r\n- **`element.offsetParent`**: 获取元素的定位父元素\r\n  - **类型**: Element | null\r\n  - **说明**: 获取元素的定位父元素，如果元素不可见则返回null\r\n  - **使用示例**:\r\n    ```javascript\r\n    const isVisible = div.offsetParent !== null;\r\n    ```\r\n- **`element.style`**: 元素的样式对象，用于设置CSS样式\r\n  - **类型**: CSSStyleDeclaration\r\n  - **说明**: 获取元素的样式对象，可以设置CSS属性\r\n  - **使用示例**:\r\n    ```javascript\r\n    div.style.display = 'block';\r\n    div.style.width = '100%';\r\n    div.style.backgroundColor = 'red';\r\n    ```\r\n\r\n### JavaScript 内置对象和方法\r\n- **`Date.now()`**: 返回当前时间戳（毫秒）\r\n  - **形参**: 无\r\n  - **返回值**: (number) 当前时间戳（毫秒）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 获取当前时间戳\r\n    const timestamp = Date.now();\r\n    \r\n    // 生成带时间戳的唯一ID\r\n    const uniqueId = 'mermaid-' + Date.now();\r\n    ```\r\n- **`Math.random()`**: 生成0到1之间的随机数\r\n  - **形参**: 无\r\n  - **返回值**: (number) 0到1之间的随机数（不包含1）\r\n  - **使用示例**:\r\n    ```javascript\r\n    const randomValue = Math.random();\r\n    const randomId = Math.random().toString(36).substring(2, 9);\r\n    ```\r\n- **`parseInt(value, radix)`**: 将字符串转换为整数\r\n  - **形参**:\r\n    - `value` (string): 要转换的字符串\r\n    - `radix` (number): 进制基数，2-36之间（可选）\r\n  - **返回值**: (number) 转换后的整数，失败时返回NaN\r\n  - **使用示例**:\r\n    ```javascript\r\n    const num = parseInt('123', 10);        // 十进制：123\r\n    const hex = parseInt('FF', 16);         // 十六进制：255\r\n    ```\r\n- **`JSON.stringify(obj)`**: 将JavaScript对象转换为JSON字符串\r\n  - **形参**:\r\n    - `obj` (any): 要转换的JavaScript值\r\n  - **返回值**: (string) JSON字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    const config = { theme: 'dark', fontSize: 16 };\r\n    const jsonString = JSON.stringify(config);\r\n    ```\r\n- **`setInterval(callback, interval)`**: 设置定时器，每隔指定时间执行回调函数\r\n  - **形参**:\r\n    - `callback` (function): 要执行的回调函数\r\n    - `interval` (number): 时间间隔（毫秒）\r\n  - **返回值**: (number) 定时器ID，用于清除定时器\r\n  - **使用示例**:\r\n    ```javascript\r\n    const timerId = setInterval(function() {\r\n      console.log('每秒执行一次');\r\n    }, 1000);\r\n    ```\r\n- **`clearInterval(intervalId)`**: 清除定时器\r\n  - **形参**:\r\n    - `intervalId` (number): 定时器ID\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    clearInterval(timerId); // 清除定时器\r\n    ```\r\n- **`setTimeout(callback, delay)`**: 设置延时执行\r\n  - **形参**:\r\n    - `callback` (function): 要执行的回调函数\r\n    - `delay` (number): 延迟时间（毫秒）\r\n  - **返回值**: (number) 定时器ID\r\n  - **使用示例**:\r\n    ```javascript\r\n    const timeoutId = setTimeout(function() {\r\n      console.log('3秒后执行');\r\n    }, 3000);\r\n    ```\r\n\r\n### 正则表达式\r\n- **`string.replace(regex, replacement)`**: 使用正则表达式替换字符串内容\r\n  - **形参**:\r\n    - `regex` (RegExp): 正则表达式对象\r\n    - `replacement` (string | function): 替换字符串或替换函数\r\n  - **返回值**: (string) 替换后的新字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    const html = '\u003cspan class=\"hljs-keyword\"\u003egraph\u003c/span\u003e';\r\n    const clean = html.replace(/\u003cspan[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi, '$1');\r\n    ```\r\n- **`string.match(regex)`**: 使用正则表达式匹配字符串\r\n  - **形参**:\r\n    - `regex` (RegExp): 正则表达式对象\r\n  - **返回值**: (Array | null) 匹配结果数组，无匹配时返回null\r\n  - **使用示例**:\r\n    ```javascript\r\n    const matches = topic.match(/\u003cspan class=\"katex\"\u003e/g);\r\n    const count = matches ? matches.length : 0;\r\n    ```\r\n- **`string.includes(substring)`**: 检查字符串是否包含子字符串\r\n  - **形参**:\r\n    - `substring` (string): 要搜索的子字符串\r\n  - **返回值**: (boolean) 是否包含指定子字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    const hasSvg = content.includes('\u003csvg');\r\n    const isGraph = content.includes('graph');\r\n    ```\r\n- **`string.toLowerCase()`**: 将字符串转换为小写\r\n  - **形参**: 无\r\n  - **返回值**: (string) 转换为小写的新字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    const lowerType = type.toLowerCase();\r\n    const comparison = content.toLowerCase().includes('flowchart');\r\n    ```\r\n- **`string.substring(start, end)`**: 提取字符串的子串\r\n  - **形参**:\r\n    - `start` (number): 起始位置索引\r\n    - `end` (number): 结束位置索引（可选，不包含该位置）\r\n  - **返回值**: (string) 提取的子字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    const preview = content.substring(0, 50);\r\n    const randomStr = Math.random().toString(36).substring(2, 9);\r\n    ```\r\n- **`string.trim()`**: 去除字符串首尾空白字符\r\n  - **形参**: 无\r\n  - **返回值**: (string) 去除首尾空白后的新字符串\r\n  - **使用示例**:\r\n    ```javascript\r\n    const cleanContent = mermaidContent.trim();\r\n    ```\r\n\r\n### Mermaid 库函数\r\n- **`mermaid.initialize(config)`**: 初始化Mermaid库配置\r\n  - **形参**:\r\n    - `config` (Object): 配置对象，包含以下可选属性：\r\n      - `theme` (string): 主题名称，如'default'、'dark'、'forest'等\r\n      - `startOnLoad` (boolean): 是否在页面加载时自动开始渲染\r\n      - `securityLevel` (string): 安全级别，'strict'、'loose'、'sandbox'\r\n      - `fontFamily` (string): 字体族名称\r\n      - `fontSize` (number): 字体大小\r\n      - `flowchart` (Object): 流程图特定配置\r\n      - `sequence` (Object): 序列图特定配置\r\n  - **返回值**: 无\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 初始化Mermaid库配置\r\n    mermaid.initialize({\r\n      theme: 'dark',          // 使用暗色主题\r\n      startOnLoad: false,     // 不自动开始渲染\r\n      securityLevel: 'loose', // 设置安全级别为宽松\r\n      fontFamily: 'arial',    // 设置字体为Arial\r\n      fontSize: 16            // 设置字体大小为16px\r\n    });\r\n    ```\r\n- **`mermaid.render(id, definition, element)`**: 渲染Mermaid图表\r\n  - **形参**:\r\n    - `id` (string): 图表的唯一标识符\r\n    - `definition` (string): Mermaid图表定义代码\r\n    - `element` (Element): 用于渲染的DOM元素（可选）\r\n  - **返回值**: Promise\u003cObject\u003e 解析为包含SVG的结果对象\r\n    - `svg` (string): 渲染后的SVG字符串\r\n    - `bindFunctions` (function): 绑定交互函数（可选）\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 渲染简单的流程图\r\n    const result = await mermaid.render('graph-1', 'graph TD; A--\u003eB');\r\n    const svgString = result.svg;  // 获取SVG字符串\r\n    \r\n    // 在临时容器中渲染\r\n    const tempDiv = document.createElement('div');\r\n    const result2 = await mermaid.render('graph-2', 'flowchart LR; C--\u003eD', tempDiv);\r\n    ```\r\n\r\n### 数组方法\r\n- **`array.some(callback)`**: 检查数组中是否至少有一个元素满足条件\r\n  - **形参**:\r\n    - `callback` (function): 测试函数，接收三个参数：\r\n      - `element` (any): 当前元素\r\n      - `index` (number): 当前索引（可选）\r\n      - `array` (Array): 原数组（可选）\r\n  - **返回值**: (boolean) 是否存在满足条件的元素\r\n  - **使用示例**:\r\n    ```javascript\r\n    // 定义有效的Mermaid图表类型\r\n    const validMermaidTypes = ['graph', 'flowchart', 'sequence'];\r\n    \r\n    // 检查内容是否包含任何有效的图表类型\r\n    const isValid = validMermaidTypes.some(function(type) {\r\n      return content.toLowerCase().includes(type.toLowerCase());\r\n    });\r\n    \r\n    // 使用箭头函数的简化写法\r\n    const hasGraph = types.some(type =\u003e type === 'graph');\r\n    ```\r\n\r\n---\r\n\r\n## index.js 代码逐行解析\r\n\r\n### 文件开头和模块声明\r\n\r\n```javascript\r\n\"use strict\";\r\n```\r\n**第1行**: 使用严格模式，确保代码在严格的 JavaScript 环境中运行，有助于捕获常见的编程错误和提高代码质量。\r\n\r\n```javascript\r\n/**\r\n * Plugin for Remarkable Markdown processor which transforms mermaid code blocks into Mermaid diagrams.\r\n * Works as a post-processor on HTML content when html: true is enabled.\r\n */\r\n```\r\n**第3-6行**: JSDoc 注释，描述了这个插件的作用和工作原理：\r\n- 为 Remarkable Markdown 处理器提供插件功能\r\n- 将 mermaid 代码块转换为 Mermaid 图表\r\n- 作为后处理器工作，在 HTML 内容上进行二次处理\r\n\r\n### 主函数定义\r\n\r\n```javascript\r\nconst rmermaid = (md, options) =\u003e {\r\n```\r\n**第7行**: 定义主函数 `rmermaid`，这是插件的入口点，接受两个参数：\r\n- `md`: Remarkable 实例对象，提供 Markdown 处理功能\r\n- `options`: 配置选项对象，包含插件的各种设置参数\r\n\r\n### 工具函数导入\r\n\r\n```javascript\r\n  // Import HTML processing utilities\r\n  const { processMermaidInHTML } = require('./mermaid-utils');\r\n```\r\n**第8-9行**: 导入 HTML 处理工具函数：\r\n- **`require('./mermaid-utils')`**: Node.js模块加载函数，使用相对路径导入同目录下的mermaid-utils.js文件\r\n- **解构赋值**: 从mermaid-utils模块中提取processMermaidInHTML函数\r\n- `processMermaidInHTML`: 核心处理函数，负责在HTML内容中查找和转换mermaid代码块\r\n\r\n### 渲染方法重写\r\n\r\n```javascript\r\n  // Override the render method to post-process HTML content\r\n  const originalRender = md.render;\r\n```\r\n**第11-12行**: 保存原始的渲染方法：\r\n- **`md.render`**: Remarkable实例的核心渲染方法，将Markdown文本转换为HTML\r\n- `originalRender`: 保存原始渲染方法的引用，以便在后续的自定义渲染中调用\r\n\r\n```javascript\r\n  md.render = function(src, env) {\r\n```\r\n**第13行**: 重写Remarkable实例的render方法，使用函数表达式而非箭头函数以确保正确的this上下文：\r\n- `src`: 输入的Markdown源文本字符串\r\n- `env`: 渲染环境对象（可选），包含渲染上下文信息\r\n\r\n```javascript\r\n    // First, let Remarkable do its normal rendering\r\n    let htmlContent = originalRender.call(this, src, env);\r\n```\r\n**第14-15行**: 执行原始的Markdown渲染：\r\n- **`originalRender.call(this, src, env)`**: JavaScript函数调用方法，确保原始渲染方法在正确的上下文中执行\r\n  - `this`: 当前的Remarkable实例对象\r\n  - `src, env`: 传递给原始渲染方法的参数\r\n- `htmlContent`: 存储Remarkable标准渲染流程产生的HTML内容\r\n\r\n```javascript\r\n    // Then, post-process the HTML to transform mermaid code blocks\r\n    htmlContent = processMermaidInHTML(htmlContent, options);\r\n```\r\n**第17-18行**: 对HTML内容进行后处理：\r\n- **`processMermaidInHTML(htmlContent, options)`**: 调用工具函数处理HTML内容\r\n  - `htmlContent`: 经过Remarkable标准渲染的HTML字符串\r\n  - `options`: 插件配置选项，传递给处理函数\r\n- 返回值: 经过mermaid处理的HTML内容，其中mermaid代码块被转换为可渲染的图表容器\r\n\r\n```javascript\r\n    return htmlContent;\r\n  };\r\n```\r\n**第20-21行**: 返回处理后的HTML内容并结束函数定义。\r\n\r\n### 模块导出\r\n\r\n```javascript\r\n};\r\n\r\nmodule.exports = rmermaid;\r\n```\r\n**第22-24行**: 结束主函数定义并导出模块：\r\n- `};`: 结束rmermaid函数定义\r\n- **`module.exports`**: Node.js模块导出机制，使rmermaid函数可被其他模块通过require()导入使用\r\n\r\n---\r\n\r\n## mermaid-utils.js 代码逐行解析\r\n\r\n### 文件头部注释\r\n\r\n```javascript\r\n/**\r\n * Utility functions for processing Mermaid diagrams in Remarkable\r\n */\r\n```\r\n**第1-3行**: 文件说明注释，描述了这个工具文件的用途。\r\n\r\n### wrapWithDiv 函数\r\n\r\n```javascript\r\n/**\r\n * Wrap Mermaid mermaidCode code with a div element\r\n * @param {string} mermaidCode - The Mermaid mermaidCode code\r\n * @returns {string} - HTML div for client-side rendering\r\n */\r\nfunction wrapWithDiv(mermaidCode) {\r\n```\r\n**第5-10行**: 定义包装函数的JSDoc注释和函数声明：\r\n- 函数作用：将Mermaid代码包装在div元素中\r\n- 参数：mermaidCode - Mermaid图表定义代码字符串\r\n- 返回值：用于客户端渲染的HTML div字符串\r\n\r\n```javascript\r\n    if (typeof mermaidCode !== 'string') {\r\n        return '\u003cdiv class=\"mermaid-error\"\u003eInvalid Mermaid Code\u003c/div\u003e';\r\n    }\r\n```\r\n**第11-13行**: 输入验证：\r\n- **`typeof mermaidCode`**: JavaScript操作符，检查变量的数据类型\r\n- 如果输入不是字符串类型，返回错误提示的HTML div元素\r\n\r\n```javascript\r\n    // Generate a unique ID for this diagram\r\n    const diagramId = `mermaid-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\r\n```\r\n**第15-16行**: 生成唯一的图表ID：\r\n- **`Date.now()`**: JavaScript内置方法，返回当前时间戳（毫秒）\r\n- **`Math.random()`**: 生成0到1之间的随机数\r\n- **`.toString(36)`**: 将数字转换为36进制字符串（包含0-9和a-z）\r\n- **`.substring(2, 9)`**: 提取字符串的第2到第9个字符（跳过\"0.\"前缀）\r\n- 组合生成类似\"mermaid-1703123456789-abc123\"的唯一ID\r\n\r\n```javascript\r\n    return `\u003cdiv class=\"mermaid\" id=\"${diagramId}\"\u003e${mermaidCode}\u003c/div\u003e`;\r\n```\r\n**第18行**: 返回包装后的HTML：\r\n- 使用模板字符串创建div元素\r\n- `class=\"mermaid\"`: CSS类名，用于Mermaid库识别和渲染\r\n- `id=\"${diagramId}\"`: 唯一标识符，用于避免多个图表之间的冲突\r\n- `${mermaidCode}`: 嵌入原始的Mermaid代码\r\n\r\n### applyMermaidStyling 函数\r\n\r\n```javascript\r\n/**\r\n * Apply custom styling to Mermaid containers\r\n * @param {string} htmlContent - The HTML content to process\r\n * @param {Object} config - Configuration object\r\n * @returns {string} - Processed HTML content\r\n */\r\nfunction applyMermaidStyling(htmlContent, config = {}) {\r\n```\r\n**第21-27行**: 定义样式应用函数：\r\n- 参数：htmlContent - 要处理的HTML内容字符串\r\n- 参数：config - 配置对象，使用默认参数语法设置默认值为空对象\r\n- 返回值：处理后的HTML内容\r\n\r\n```javascript\r\n    if (!htmlContent || typeof htmlContent !== 'string') {\r\n        return htmlContent;\r\n    }\r\n```\r\n**第28-30行**: 输入验证，确保htmlContent是有效的字符串。\r\n\r\n```javascript\r\n    let processedContent = htmlContent;\r\n```\r\n**第32行**: 创建处理内容的副本，避免直接修改原始输入。\r\n\r\n```javascript\r\n    // Add custom CSS classes if specified\r\n    if (config.customClass) {\r\n        processedContent = processedContent.replace(\r\n            /class=\"mermaid\"/g,\r\n            `class=\"mermaid ${config.customClass}\"`\r\n        );\r\n    }\r\n```\r\n**第34-39行**: 添加自定义CSS类：\r\n- 检查配置中是否指定了自定义类名\r\n- **`string.replace(regex, replacement)`**: 使用正则表达式替换字符串内容\r\n- **`/class=\"mermaid\"/g`**: 全局正则表达式，匹配所有`class=\"mermaid\"`的出现\r\n- `g`标志: 全局替换，替换所有匹配项而不是只替换第一个\r\n- 在原有类名基础上添加自定义类名\r\n\r\n```javascript\r\n    return processedContent;\r\n```\r\n**第41行**: 返回处理后的内容。\r\n\r\n### addRenderingScript 函数\r\n\r\n```javascript\r\nfunction addRenderingScript(htmlContent, config) {\r\n    return htmlContent + `\r\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.3/mermaid.min.js\" integrity=\"sha512-HvxxeyPSnbU7/x0g15v3OMxTFeADyCUnCN3iCam3BDTxgFPKxa+ujRCbFuwjE8PASDwOH5LpzFfGGNWks7tuJQ==\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"\u003e\u003c/script\u003e\r\n```\r\n**第44-46行**: 定义脚本添加函数并开始添加Mermaid库：\r\n- 从CDN加载Mermaid 10.9.3版本\r\n- `integrity`: SRI（子资源完整性）属性，确保脚本未被篡改\r\n- `crossorigin=\"anonymous\"`: 跨域设置，以匿名方式加载资源\r\n- `referrerpolicy=\"no-referrer\"`: 不发送referrer信息，提高隐私性\r\n\r\n```javascript\r\n    \u003cscript\u003e\r\n(function() {\r\n        const initializeMermaid = async function() {\r\n```\r\n**第47-49行**: 开始内联脚本，使用立即执行函数表达式（IIFE）和异步函数：\r\n- **立即执行函数表达式**: 避免全局变量污染\r\n- **async function**: 使用异步函数以支持await语法\r\n\r\n```javascript\r\n            try {\r\n                // Configure mermaid with provided config\r\n                mermaid.initialize({\r\n                    startOnLoad: ${config.startOnLoad || false},\r\n                    theme: '${config.theme}',\r\n                    securityLevel: '${config.securityLevel}',\r\n                    fontFamily: '${config.fontFamily}',\r\n                    fontSize: ${config.fontSize},\r\n                    flowchart: ${JSON.stringify(config.flowchart)},\r\n                    sequence: ${JSON.stringify(config.sequence)},\r\n                    class: ${JSON.stringify(config.class)},\r\n                    gitGraph: ${JSON.stringify(config.gitGraph)}\r\n                });\r\n```\r\n**第50-62行**: 初始化Mermaid配置：\r\n- **`mermaid.initialize()`**: Mermaid库的初始化方法，设置全局配置\r\n- **模板字符串插值**: 使用${}语法将配置值插入到生成的脚本中\r\n- **`JSON.stringify()`**: 将JavaScript对象转换为JSON字符串，确保复杂对象正确序列化\r\n- 配置项说明：\r\n  - `startOnLoad`: 是否在页面加载时自动开始渲染\r\n  - `theme`: 主题设置（如'default', 'dark'等）\r\n  - `securityLevel`: 安全级别设置\r\n  - `fontFamily`: 字体族设置\r\n  - `fontSize`: 字体大小设置\r\n  - `flowchart`, `sequence`, `class`, `gitGraph`: 各种图表类型的特定配置\r\n\r\n```javascript\r\n                // Find all mermaid divs and render them\r\n                const mermaidDivs = document.querySelectorAll('.mermaid');\r\n```\r\n**第64-65行**: 查找所有Mermaid容器：\r\n- **`document.querySelectorAll('.mermaid')`**: DOM API方法，根据CSS选择器查找所有匹配的元素\r\n- 返回NodeList对象，包含所有class为\"mermaid\"的div元素\r\n\r\n```javascript\r\n                for (let i = 0; i \u003c mermaidDivs.length; i++) {\r\n                    const div = mermaidDivs[i];\r\n```\r\n**第67-68行**: 遍历所有找到的Mermaid容器：\r\n- 使用传统for循环而不是forEach，以便更好地控制异步操作\r\n- 获取当前处理的div元素\r\n\r\n```javascript\r\n                    // Get clean text content, avoiding any HTML that might be mixed in\r\n                    let mermaidContent = div.textContent || div.innerText || '';\r\n```\r\n**第70-71行**: 提取纯文本内容：\r\n- **`div.textContent`**: 获取元素的文本内容（不包含HTML标签）\r\n- **`div.innerText`**: 获取元素的可见文本内容（考虑CSS显示效果）\r\n- 使用逻辑或操作符提供后备选项\r\n\r\n```javascript\r\n                    // Clean up the content - remove any extra whitespace and HTML artifacts\r\n                    mermaidContent = mermaidContent.trim();\r\n```\r\n**第73-74行**: 清理内容：\r\n- **`string.trim()`**: 去除字符串首尾的空白字符（空格、制表符、换行符等）\r\n\r\n```javascript\r\n                    // Skip if content is empty or contains HTML tags (already processed)\r\n                    if (!mermaidContent || mermaidContent.includes('\u003csvg') || mermaidContent.includes('\u003cpath')) {\r\n                        continue;\r\n                    }\r\n```\r\n**第76-79行**: 跳过空内容或已处理的内容：\r\n- 检查内容是否为空\r\n- **`string.includes(substring)`**: 检查字符串是否包含指定的子字符串\r\n- 如果包含`\u003csvg`或`\u003cpath`标签，说明已经被渲染过，跳过处理\r\n\r\n```javascript\r\n                    // Validate that this is actually mermaid content\r\n                    const validMermaidTypes = ['graph', 'flowchart', 'sequenceDiagram', 'classDiagram', 'stateDiagram', 'erDiagram', 'journey', 'gantt', 'pie', 'gitgraph', 'mindmap', 'timeline'];\r\n                    const isValidMermaid = validMermaidTypes.some(function(type) {\r\n                        return mermaidContent.toLowerCase().includes(type.toLowerCase());\r\n                    });\r\n```\r\n**第81-85行**: 验证是否为有效的Mermaid内容：\r\n- 定义有效的Mermaid图表类型数组\r\n- **`array.some(callback)`**: 数组方法，检查是否至少有一个元素满足条件\r\n- **`string.toLowerCase()`**: 将字符串转换为小写，用于大小写不敏感的比较\r\n- 检查内容是否包含任何有效的Mermaid图表类型关键词\r\n\r\n```javascript\r\n                    if (!isValidMermaid) {\r\n                        console.warn('Skipping non-mermaid content:', mermaidContent.substring(0, 50) + '...');\r\n                        continue;\r\n                    }\r\n```\r\n**第87-90行**: 跳过非Mermaid内容：\r\n- 如果内容不是有效的Mermaid代码，输出警告信息\r\n- **`console.warn()`**: 在控制台输出警告信息\r\n- **`string.substring(start, end)`**: 提取字符串的子串，这里取前50个字符用于日志显示\r\n\r\n```javascript\r\n                    try {\r\n                        // Ensure the div is properly mounted and visible\r\n                        if (!div.offsetParent \u0026\u0026 div.style.display !== 'none') {\r\n                            div.style.display = 'block';\r\n                        }\r\n```\r\n**第92-96行**: 确保div元素正确挂载和可见：\r\n- **`div.offsetParent`**: DOM属性，如果元素不可见或未挂载则为null\r\n- **`div.style.display`**: 元素的显示样式属性\r\n- 如果元素不可见且不是显式隐藏，则设置为块级显示\r\n\r\n```javascript\r\n                        // Create a temporary container to avoid DOM issues\r\n                        const tempContainer = document.createElement('div');\r\n                        tempContainer.style.width = '100%';\r\n                        tempContainer.style.height = 'auto';\r\n                        tempContainer.style.visibility = 'hidden';\r\n                        tempContainer.style.position = 'absolute';\r\n                        tempContainer.style.top = '-9999px';\r\n                        document.body.appendChild(tempContainer);\r\n```\r\n**第98-105行**: 创建临时容器避免DOM问题：\r\n- **`document.createElement('div')`**: 创建新的div元素\r\n- 设置临时容器的样式：\r\n  - `width: '100%'`: 宽度占满父容器\r\n  - `height: 'auto'`: 高度自动\r\n  - `visibility: 'hidden'`: 隐藏但保留布局空间\r\n  - `position: 'absolute'`: 绝对定位\r\n  - `top: '-9999px'`: 移出可视区域\r\n- **`document.body.appendChild()`**: 将临时容器添加到页面中\r\n\r\n```javascript\r\n                        // Generate unique ID for this diagram\r\n                        const id = 'mermaid-render-' + Date.now() + '-' + i;\r\n```\r\n**第107-108行**: 生成渲染用的唯一ID：\r\n- 结合时间戳和循环索引创建唯一标识符\r\n- 用于Mermaid渲染时的内部标识\r\n\r\n```javascript\r\n                        // Use mermaid v10+ async API with proper DOM context\r\n                        const result = await mermaid.render(id, mermaidContent, tempContainer);\r\n                        const svg = result.svg;\r\n```\r\n**第110-112行**: 使用Mermaid异步API渲染图表：\r\n- **`await mermaid.render()`**: 调用Mermaid的异步渲染方法\r\n  - `id`: 图表的唯一标识符\r\n  - `mermaidContent`: 要渲染的Mermaid代码\r\n  - `tempContainer`: 临时DOM容器\r\n- **`result.svg`**: 从渲染结果中提取SVG字符串\r\n\r\n```javascript\r\n                        // Remove temporary container\r\n                        document.body.removeChild(tempContainer);\r\n```\r\n**第114-115行**: 移除临时容器：\r\n- **`document.body.removeChild()`**: 从DOM中移除临时容器元素\r\n\r\n```javascript\r\n                        // Replace the div content with the SVG\r\n                        div.innerHTML = svg;\r\n```\r\n**第117-118行**: 替换div内容：\r\n- **`div.innerHTML`**: 设置元素的HTML内容\r\n- 将原始的Mermaid代码替换为渲染后的SVG图表\r\n\r\n```javascript\r\n                    } catch (renderError) {\r\n                        console.error('Error rendering mermaid diagram:', renderError);\r\n                        console.error('Content that failed:', mermaidContent);\r\n                        // Keep the original content if rendering fails\r\n                        const errorMessage = renderError instanceof Error ? renderError.message : String(renderError);\r\n                        div.innerHTML = '\u003cpre style=\"color: red; background: #fee; padding: 10px; border-radius: 4px;\"\u003e' +\r\n                            'Error rendering mermaid diagram: ' + errorMessage + '\\\\n\\\\n' +\r\n                            'Original content:\\\\n' + mermaidContent + '\u003c/pre\u003e';\r\n                    }\r\n```\r\n**第120-128行**: 处理渲染错误：\r\n- **`console.error()`**: 在控制台输出错误信息\r\n- **`instanceof Error`**: 检查是否为Error对象实例\r\n- **`String(renderError)`**: 将错误对象转换为字符串\r\n- 创建错误显示的HTML，包含：\r\n  - 红色文本和浅红色背景\r\n  - 错误消息\r\n  - 原始内容，帮助调试\r\n\r\n```javascript\r\n                }\r\n            } catch (error) {\r\n                console.error('Error initializing mermaid:', error);\r\n            }\r\n        };\r\n```\r\n**第129-133行**: 处理整体初始化错误并结束initializeMermaid函数。\r\n\r\n```javascript\r\n        // Wait for DOM to be fully ready and ensure proper mounting\r\n        const timeoutId = setInterval(function() {\r\n            // Check if mermaid is available\r\n            if (typeof mermaid === 'undefined') {\r\n                console.warn('Mermaid library is not loaded yet.');\r\n                return;\r\n            }\r\n            // Double-check that we're in a browser environment\r\n            if (typeof window !== 'undefined' \u0026\u0026 document.body) {\r\n                initializeMermaid();\r\n                clearInterval(timeoutId)\r\n            }\r\n        }, 1000);\r\n```\r\n**第135-147行**: 等待DOM和Mermaid库就绪：\r\n- **`setInterval(callback, interval)`**: 设置定时器，每1000毫秒执行一次检查\r\n- **`typeof mermaid === 'undefined'`**: 检查Mermaid库是否已加载\r\n- **`typeof window !== 'undefined'`**: 检查是否在浏览器环境中\r\n- **`document.body`**: 检查DOM是否就绪\r\n- **`clearInterval(timeoutId)`**: 清除定时器，避免重复执行\r\n\r\n```javascript\r\n    })();\r\n    \u003c/script\u003e\r\n    `;\r\n}\r\n```\r\n**第148-151行**: 结束立即执行函数表达式、脚本标签和addRenderingScript函数。\r\n\r\n### processMermaidInHTML 函数\r\n\r\n```javascript\r\n/**\r\n * Process HTML content to transform mermaid code blocks into mermaid divs\r\n * @param {string} htmlContent - The HTML content to process\r\n * @param {Object} options - Processing options\r\n * @returns {string} - Processed HTML content\r\n */\r\nfunction processMermaidInHTML(htmlContent, options = {}) {\r\n```\r\n**第153-159行**: 定义主处理函数：\r\n- 参数：htmlContent - 要处理的HTML内容字符串\r\n- 参数：options - 处理选项对象，默认为空对象\r\n- 返回值：处理后的HTML内容\r\n\r\n```javascript\r\n    if (typeof htmlContent !== 'string') {\r\n        return htmlContent;\r\n    }\r\n```\r\n**第160-162行**: 输入验证，确保htmlContent是字符串类型。\r\n\r\n```javascript\r\n    const mermaidConfiguration = {\r\n        startOnLoad: options.startOnLoad || false,\r\n        theme: options.theme === 'light' ? 'default' : 'dark',\r\n        securityLevel: options.securityLevel || 'loose',\r\n        fontFamily: options.fontFamily || 'arial',\r\n        fontSize: options.fontSize || 16,\r\n        flowchart: options.flowchart || {\r\n            useMaxWidth: true,\r\n            htmlLabels: true,\r\n        },\r\n        sequence: options.sequence || {\r\n            useMaxWidth: true,\r\n            wrap: true,\r\n        },\r\n        class: options.class || {\r\n            useMaxWidth: true,\r\n        },\r\n        gitGraph: options.gitGraph || {\r\n            useMaxWidth: true,\r\n        },\r\n    };\r\n```\r\n**第164-183行**: 创建Mermaid配置对象：\r\n- 使用逻辑或操作符设置默认值\r\n- **三元运算符**: `options.theme === 'light' ? 'default' : 'dark'` 根据主题选项设置对应的Mermaid主题\r\n- 各种图表类型的配置：\r\n  - `useMaxWidth: true`: 图表使用最大可用宽度\r\n  - `htmlLabels: true`: 流程图使用HTML标签\r\n  - `wrap: true`: 序列图启用文本换行\r\n\r\n```javascript\r\n    // Find all mermaid code blocks in the HTML\r\n    // Pattern matches: \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e...\u003c/code\u003e\u003c/pre\u003e\r\n    const mermaidCodeBlockRegex = /\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e([\\s\\S]*?)\u003c\\/code\u003e\u003c\\/pre\u003e/gi;\r\n```\r\n**第185-187行**: 定义正则表达式匹配Mermaid代码块：\r\n- **正则表达式详解**:\r\n  - `\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e`: 匹配代码块的开始标签\r\n  - `([\\s\\S]*?)`: 捕获组，匹配任意字符（包括换行符）\r\n    - `[\\s\\S]`: 匹配任意空白字符或非空白字符（相当于匹配任意字符）\r\n    - `*?`: 非贪婪匹配，匹配尽可能少的字符\r\n  - `\u003c\\/code\u003e\u003c\\/pre\u003e`: 匹配代码块的结束标签\r\n  - `g`: 全局匹配标志\r\n  - `i`: 忽略大小写标志\r\n\r\n```javascript\r\n    htmlContent = htmlContent.replace(mermaidCodeBlockRegex, (match, content) =\u003e {\r\n```\r\n**第189行**: 使用正则表达式替换匹配的代码块：\r\n- **`string.replace(regex, callback)`**: 使用回调函数处理每个匹配项\r\n- `match`: 完整的匹配字符串\r\n- `content`: 第一个捕获组的内容（即mermaid代码）\r\n\r\n```javascript\r\n        // Check if content has been syntax highlighted by hljs\r\n        let cleanContent;\r\n        if (content.includes('\u003cspan class=\"hljs-')) {\r\n            // Extract text content from syntax-highlighted spans\r\n            cleanContent = content\r\n                .replace(/\u003cspan[^\u003e]*class=\"hljs-[^\"]*\"[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi, '$1')\r\n                .replace(/\u003cspan[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi, '$1')\r\n                .replace(/\u0026lt;/g, '\u003c')\r\n                .replace(/\u0026gt;/g, '\u003e')\r\n                .replace(/\u0026amp;/g, '\u0026')\r\n                .replace(/\u0026quot;/g, '\"')\r\n                .replace(/\u0026#39;/g, \"'\")\r\n                .replace(/\u0026#x27;/g, \"'\")\r\n                .trim();\r\n```\r\n**第190-202行**: 处理语法高亮的内容：\r\n- **`content.includes('\u003cspan class=\"hljs-')`**: 检查是否包含highlight.js的语法高亮标记\r\n- **正则表达式替换链**:\r\n  - `/\u003cspan[^\u003e]*class=\"hljs-[^\"]*\"[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi`: 移除hljs的span标签，保留内容\r\n  - `/\u003cspan[^\u003e]*\u003e(.*?)\u003c\\/span\u003e/gi`: 移除其他span标签\r\n  - `/\u0026lt;/g, '\u003c'`: 将HTML实体`\u0026lt;`转换为`\u003c`\r\n  - `/\u0026gt;/g, '\u003e'`: 将HTML实体`\u0026gt;`转换为`\u003e`\r\n  - `/\u0026amp;/g, '\u0026'`: 将HTML实体`\u0026amp;`转换为`\u0026`\r\n  - `/\u0026quot;/g, '\"'`: 将HTML实体`\u0026quot;`转换为`\"`\r\n  - `/\u0026#39;/g, \"'\"`: 将HTML实体`\u0026#39;`转换为`'`\r\n  - `/\u0026#x27;/g, \"'\"`: 将HTML实体`\u0026#x27;`转换为`'`\r\n- **`.trim()`**: 去除首尾空白字符\r\n\r\n```javascript\r\n        } else {\r\n            // Decode HTML entities in the content (no syntax highlighting)\r\n            cleanContent = content\r\n                .replace(/\u0026lt;/g, '\u003c')\r\n                .replace(/\u0026gt;/g, '\u003e')\r\n                .replace(/\u0026amp;/g, '\u0026')\r\n                .replace(/\u0026quot;/g, '\"')\r\n                .replace(/\u0026#39;/g, \"'\")\r\n                .replace(/\u0026#x27;/g, \"'\")\r\n                .trim();\r\n        }\r\n```\r\n**第203-213行**: 处理无语法高亮的内容：\r\n- 直接进行HTML实体解码\r\n- 使用相同的实体转换规则\r\n\r\n```javascript\r\n        // Transform into mermaid div\r\n        cleanContent = wrapWithDiv(cleanContent);\r\n        return applyMermaidStyling(cleanContent, options);\r\n```\r\n**第215-217行**: 转换为Mermaid div：\r\n- **`wrapWithDiv(cleanContent)`**: 调用前面定义的函数将内容包装在div中\r\n- **`applyMermaidStyling(cleanContent, options)`**: 应用自定义样式\r\n- 返回最终的HTML字符串\r\n\r\n```javascript\r\n    });\r\n\r\n    return addRenderingScript(htmlContent, mermaidConfiguration);\r\n}\r\n```\r\n**第218-221行**: 完成替换并添加渲染脚本：\r\n- 结束replace回调函数\r\n- **`addRenderingScript(htmlContent, mermaidConfiguration)`**: 添加Mermaid库和初始化脚本\r\n\r\n### 模块导出\r\n\r\n```javascript\r\nmodule.exports = {\r\n    processMermaidInHTML\r\n};\r\n```\r\n**第223-225行**: 导出模块：\r\n- **`module.exports`**: Node.js模块导出机制\r\n- 使用对象形式导出processMermaidInHTML函数，便于解构导入\r\n\r\n---\r\n\r\n## 总结\r\n\r\n这个插件的核心功能和特点包括：\r\n\r\n1. **后处理架构**: 不修改Remarkable的解析流程，而是在HTML渲染完成后进行二次处理\r\n2. **代码块识别**: 通过正则表达式识别`\u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e`格式的代码块\r\n3. **语法高亮兼容**: 智能处理highlight.js等语法高亮库产生的HTML结构\r\n4. **HTML实体解码**: 正确处理Markdown渲染过程中产生的HTML实体\r\n5. **客户端渲染**: 生成包含Mermaid库和初始化脚本的完整HTML\r\n6. **错误处理**: 提供完善的错误处理和调试信息\r\n7. **配置灵活**: 支持丰富的Mermaid配置选项\r\n8. **DOM安全**: 使用临时容器避免DOM操作问题\r\n\r\n### 非标准库函数使用总结\r\n\r\n本插件主要依赖以下非JavaScript标准库的函数和API：\r\n\r\n#### Node.js 生态系统\r\n- **模块系统**: `require()`, `module.exports` 用于模块的导入导出\r\n- **文件系统**: 相对路径模块导入\r\n\r\n#### Remarkable Markdown 处理器\r\n- **核心渲染**: `md.render()` 执行Markdown到HTML的转换\r\n- **方法重写**: 通过保存原始方法引用实现功能扩展\r\n\r\n#### Mermaid 图表库\r\n- **库加载**: 通过CDN加载Mermaid 10.9.3版本\r\n- **初始化**: `mermaid.initialize()` 配置全局参数\r\n- **异步渲染**: `mermaid.render()` 异步API渲染图表\r\n\r\n#### 浏览器DOM API\r\n- **元素查找**: `document.querySelectorAll()` 查找目标元素\r\n- **元素创建**: `document.createElement()` 创建临时容器\r\n- **DOM操作**: `appendChild()`, `removeChild()` 管理DOM树\r\n- **内容访问**: `textContent`, `innerHTML` 获取和设置元素内容\r\n\r\n#### 正则表达式处理\r\n- **模式匹配**: 复杂的正则表达式匹配HTML结构\r\n- **内容提取**: 使用捕获组提取代码块内容\r\n- **实体转换**: 批量HTML实体解码\r\n\r\n#### 异步编程\r\n- **定时器**: `setInterval()`, `clearInterval()` 等待库就绪\r\n- **异步函数**: `async/await` 处理Mermaid异步渲染\r\n\r\n该插件通过巧妙的后处理机制，实现了与Remarkable无缝集成的Mermaid图表渲染功能，同时保持了良好的兼容性和错误处理能力。\r\n"])</script><script>self.__next_f.push([1,"43:T6fa3,"])</script><script>self.__next_f.push([1,"\r\n# 提示词生成与响应解析：另一种机器语言的诞生\r\n\r\n我时常会想，让计算机能够识别机器语言是编程领域的第一大里程碑，那如今能够让AI识别自然语言算不算第二大里程碑？\r\n\r\n本文将全面解析Questions Party项目中的提示词管理系统，从PromptLoader的架构设计到响应解析的鲁棒性实现，带你阅览MCP的原始原理。\r\n\r\n## PromptLoader核心架构\r\n\r\n### 单例模式设计\r\n\r\n```javascript\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\nclass PromptLoader {\r\n    constructor() {\r\n        this.promptCache = new Map();\r\n        this.promptsDir = path.join(__dirname, '../prompts');\r\n    }\r\n}\r\n\r\n**为什么选择单例模式**：\r\n\r\n在整个应用生命周期中，PromptLoader只需要一个实例就够了——毕竟提示词模板不会跑路，文件系统也不会突然变脸。\r\n\r\n### 目录结构的约定\r\n\r\n```typescript\r\n// 实际的目录结构\r\nsrc/prompts/\r\n├── sentence-check-pure.txt        # 纯英文句子检查模板\r\n├── sentence-check-combined.txt    # 双语句子检查模板\r\n├── sentence-generation-pure.txt   # 纯英文句子生成模板\r\n├── sentence-generation-combined.txt  # 双语句子生成模板\r\n└── README.md                      # 文档说\r\n```\r\n\r\n### Map缓存\r\n\r\n```javascript\r\nthis.promptCache = new Map();\r\n```\r\n\r\n**为什么选择Map而不是Object**？\r\n\r\n这是一个经典的数据结构选择问题：\r\n\r\n| 特性 | Map | Object |\r\n|------|-----|---------|\r\n| 键类型 | 任意类型 | 字符串/Symbol |\r\n| 大小获取 | O(1) | O(n) |\r\n| 迭代性能 | 优秀 | 一般 |\r\n| 原型污染 | 无 | 有风险 |\r\n\r\n**缓存性能的数学分析**：\r\n\r\n假设每个提示词文件平均2KB，系统有4个模板文件：\r\n- **无缓存**：每次请求都需要读取文件，IO时间约1-5ms\r\n- **有缓存**：首次读取后，访问时间降至0.01ms以下\r\n\r\n缓存命中率达到90%时，性能提升约：\r\n$$性能提升 = \\frac{5ms}{0.01ms} \\times 0.9 = 450倍$$\r\n\r\n## loadPrompt函数\r\n\r\n### 缓存优先策略\r\n\r\n```javascript\r\nloadPrompt(type, grammarLanguageOption = 'combined') {\r\n    const cacheKey = `${type}-${grammarLanguageOption}`;\r\n    \r\n    // 如果缓存中有，返回缓存的版本\r\n    if (this.promptCache.has(cacheKey)) {\r\n        return this.promptCache.get(cacheKey);\r\n    }\r\n\r\n    try {\r\n        const filename = `${type}-${grammarLanguageOption}.txt`;\r\n        const filepath = path.join(this.promptsDir, filename);\r\n        \r\n        if (!fs.existsSync(filepath)) {\r\n            throw new Error(`Prompt file not found: ${filepath}`);\r\n        }\r\n\r\n        const promptTemplate = fs.readFileSync(filepath, 'utf8');\r\n```\r\n\r\n**缓存键设计**：\r\n\r\n`${type}-${grammarLanguageOption}`是一个复合键，分别对应\"功能-语言\"。\r\n\r\n### 文件系统的安全操作\r\n\r\n```javascript\r\nif (!fs.existsSync(filepath)) {\r\n    throw new Error(`Prompt file not found: ${filepath}`);\r\n}\r\n```\r\n\r\n**为什么先检查文件存在性**？\r\n\r\n这是防御性编程的经典案例：\r\n\r\n```typescript\r\n// ❌ 不安全的做法\r\nconst content = fs.readFileSync(filepath, 'utf8');  // 可能抛出ENOENT错误\r\n\r\n// ✅ 安全的做法\r\nif (!fs.existsSync(filepath)) {\r\n    throw new Error(`Prompt file not found: ${filepath}`);\r\n}\r\nconst content = fs.readFileSync(filepath, 'utf8');  // 明确的错误信息\r\n```\r\n\r\n**路径拼接兼容**：\r\n\r\n```typescript\r\nconst filepath = path.join(this.promptsDir, filename);\r\n```\r\n\r\n使用`path.join`而不是字符串拼接，避免了路径分隔符的跨平台问题：\r\n- Windows: `\\`\r\n- Unix/Linux: `/`\r\n- Node.js自动处理\r\n\r\n### 提示词加载降级处理\r\n\r\n```javascript\r\n} catch (error) {\r\n    console.error(`Error loading prompt ${type}-${grammarLanguageOption}:`, error.message);\r\n    \r\n    // 如果pure版本失败，降级到combined版本\r\n    if (grammarLanguageOption === 'pure') {\r\n        console.warn(`Falling back to combined prompt for ${type}`);\r\n        return this.loadPrompt(type, 'combined');\r\n    }\r\n    \r\n    // 如果combined版本也失败，抛出错误\r\n    throw new Error(`Failed to load prompt template: ${type}-${grammarLanguageOption}`);\r\n}\r\n```\r\n\r\n递归降级顺序：`pure → combined → error`\r\n\r\n错误处理的决策树：\r\n```\r\n加载pure版本\r\n    ↓\r\n失败？→ 是 → 尝试combined版本\r\n    ↓         ↓\r\n   否        失败？→ 是 → 抛出错误\r\n    ↓         ↓\r\n返回内容       否\r\n              ↓\r\n           返回内容\r\n```\r\n\r\n## 提示词结构化设计\r\n\r\n### Combined vs Pure：双语教学\r\n\r\n**Pure版本（纯英文）**：\r\n\r\n```\r\nAnalyze this sentence: \"{sentence}\"\r\n\r\nFollow this exact format (Output Example):\r\n\r\nGRAMMAR_ANALYSIS(Parsing required):\r\n1. Grammar and Style Issues\r\n```\r\n\r\n**Combined版本（双语）**：\r\n```\r\n分析这个句子: \"{sentence}\"\r\n\r\n请严格按照以下格式输出（输出示例）：\r\n\r\nGRAMMAR_ANALYSIS(Parsing required):\r\n1. 语法和风格问题\r\n```\r\n\r\n- **Pure版本**：面向英语学习者，提供纯正的英语环境\r\n- **Combined版本**：面向中文用户，降低理解门槛，提供双语对照\r\n\r\n## 缓存机制与性能优化\r\n\r\n### Map vs Object的性能对比\r\n\r\n```javascript\r\n// 性能测试伪代码\r\nconst iterations = 1000000;\r\n\r\n// Map性能测试\r\nconst mapCache = new Map();\r\nconsole.time('Map');\r\nfor (let i = 0; i \u003c iterations; i++) {\r\n    mapCache.set(`key${i}`, `value${i}`);\r\n    mapCache.get(`key${i}`);\r\n}\r\nconsole.timeEnd('Map');\r\n\r\n// Object性能测试\r\nconst objCache = {};\r\nconsole.time('Object');\r\nfor (let i = 0; i \u003c iterations; i++) {\r\n    objCache[`key${i}`] = `value${i}`;\r\n    const value = objCache[`key${i}`];\r\n}\r\nconsole.timeEnd('Object');\r\n```\r\n\r\n**实际测试结果**：\r\n- Map: ~661.084ms\r\n- Object: ~1005ms\r\n\r\nMap在大量操作时有约52%的性能优势！\r\n\r\n## 降级策略的容错设计\r\n\r\n### Pure → Combined的降级逻辑\r\n\r\n```javascript\r\n// 如果pure版本失败，降级到combined版本\r\nif (grammarLanguageOption === 'pure') {\r\n    console.warn(`Falling back to combined prompt for ${type}`);\r\n    return this.loadPrompt(type, 'combined');\r\n}\r\n```\r\n\r\n**降级决策的状态机**：\r\n\r\n```\r\n                    ┌─────────────┐\r\n                    │  加载Pure   │\r\n                    └─────┬───────┘\r\n                          │\r\n                     ┌────▼────┐     否\r\n                     │ 成功？   │────────────\r\n                     └────┬────┘           │\r\n                      是  │                 │\r\n                     ┌────▼────┐    ┌───────▼───────┐\r\n                     │ 返回内容 │    │ 尝试Combined  │\r\n                     └─────────┘    └───────┬───────┘\r\n                                            │\r\n                                       ┌────▼────┐\r\n                                       │ 成功？   │\r\n                                       └────┬────┘\r\n                                        是  │  否\r\n                                   ┌────▼────┐    ┌─────────┐\r\n                                   │ 返回内容 │    │ 抛出错误 │\r\n                                   └─────────┘    └─────────┘\r\n```\r\n\r\n### 系统健壮性保障\r\n\r\n```javascript\r\nvalidatePromptFiles() {\r\n    const requiredPrompts = [\r\n        'sentence-check-pure.txt',\r\n        'sentence-check-combined.txt',\r\n        'sentence-generation-pure.txt',\r\n        'sentence-generation-combined.txt'\r\n    ];\r\n\r\n    const missing = [];\r\n    const existing = [];\r\n\r\n    for (const filename of requiredPrompts) {\r\n        const filepath = path.join(this.promptsDir, filename);\r\n        if (fs.existsSync(filepath)) {\r\n            existing.push(filename);\r\n        } else {\r\n            missing.push(filename);\r\n        }\r\n    }\r\n```\r\n\r\n**启动时验证**：\r\n\r\n系统启动时进行完整性检查，遵循\"Fast Fail\"原则：\r\n- **早期发现**：部署时就能发现问题\r\n- **明确反馈**：哪些文件缺失一目了然\r\n- **运维友好**：减少生产环境的调试时间\r\n\r\n## parseSentenceCheckResponse深度剖析\r\n\r\n### 标记化响应格式的设计\r\n\r\n```javascript\r\n// 句子检查的响应格式配置\r\nthis.checkResponseFormat = {\r\n    grammarAnalysisMarker: \"GRAMMAR_ANALYSIS:\",\r\n    grammarCorrectionMarker: \"GRAMMAR_CORRECTION:\",\r\n    keywordAnalysisMarker: \"KEYWORD_ANALYSIS:\",\r\n    chineseDefinitionMarker: \"CHINESE_DEFINITION:\",\r\n    endMarker: \"END_FORMAT\"\r\n};\r\n```\r\n\r\n### 鲁棒性解析算法\r\n\r\n```javascript\r\nparseSentenceCheckResponse(content, locale = 'en') {\r\n    try {\r\n        const {\r\n            grammarAnalysisMarker,\r\n            grammarCorrectionMarker,\r\n            keywordAnalysisMarker,\r\n            chineseDefinitionMarker,\r\n            endMarker\r\n        } = this.checkResponseFormat;\r\n\r\n        // 存储原始内容用于回退\r\n        const rawContent = content;\r\n\r\n        // 清理内容 - 移除\"(Parsing required)\"和其他不需要的文本\r\n        let cleanedContent = this.cleanResponseContent(content);\r\n```\r\n\r\n**内容清理**：\r\n\r\nAI生成的内容可能包含：\r\n- 多余的标记：`(Parsing required)`\r\n- 格式错误：多余的空行\r\n- 无关内容：额外的说明文字\r\n\r\n```javascript\r\ncleanResponseContent(content) {\r\n    if (!content) return '';\r\n\r\n    let cleaned = content;\r\n\r\n    // 移除\"(Parsing required)\"文本\r\n    cleaned = cleaned.replace(/\\(Parsing required\\)/gi, '');\r\n\r\n    // 移除过多的空白字符，同时保持结构\r\n    cleaned = cleaned.replace(/\\n{3,}/g, '\\n\\n');\r\n\r\n    // 移除每行的首尾空白字符，同时保持整体结构\r\n    cleaned = cleaned.split('\\n')\r\n        .map(line =\u003e line.trim())\r\n        .join('\\n');\r\n```\r\n\r\n**清理算法的设计思路**：\r\n\r\n1. **保留结构**：不破坏原有的段落结构\r\n2. **移除噪声**：去除AI生成的标记文本\r\n3. **标准化空白**：统一空行和缩进\r\n\r\n### 部分解析的容错机制\r\n\r\n```javascript\r\n// 跟踪哪些标记存在\r\nconst markerPresence = {\r\n    grammarAnalysis: cleanedContent.includes(grammarAnalysisMarker),\r\n    grammarCorrection: cleanedContent.includes(grammarCorrectionMarker),\r\n    keywordAnalysis: cleanedContent.includes(keywordAnalysisMarker),\r\n    chineseDefinition: cleanedContent.includes(chineseDefinitionMarker)\r\n};\r\n\r\nconst presentMarkers = Object.values(markerPresence).filter(Boolean).length;\r\n\r\n// 如果没有标记存在，这是完全失败\r\nif (presentMarkers === 0) {\r\n    return {\r\n        isValid: false,\r\n        error: i18n.t('ai.noValidMarkers', locale) + ` | Response preview: \"${cleanedContent.substring(0, 200)}...\"`,\r\n        grammarAnalysis: '',\r\n        grammarCorrection: '',\r\n        keywordAnalysis: '',\r\n        chineseDefinition: '',\r\n        rawResponseContent: rawContent\r\n    };\r\n}\r\n```\r\n\r\n**部分解析的哲学**：\r\n\r\n宁可给用户部分有用的信息，也不要因为格式不完整就全盘否定。\r\n\r\n## parseStructuredResponse结构化解析\r\n\r\n### 结构化标记的提取逻辑\r\n\r\n```javascript\r\nparseStructuredResponse(content, locale = 'en') {\r\n    try {\r\n        const {sentenceMarker, grammarMarker, chineseMarker, endMarker} = this.responseFormat;\r\n\r\n        // 存储原始内容用于回退\r\n        const rawContent = content;\r\n\r\n        // 清理内容 - 移除\"(Parsing required)\"和其他不需要的文本\r\n        let cleanedContent = this.cleanResponseContent(content);\r\n\r\n        // 如果缺少END_FORMAT但其他标记存在，则添加\r\n        if (!cleanedContent.includes(endMarker)) {\r\n            const hasOtherMarkers = [sentenceMarker, grammarMarker, chineseMarker]\r\n                .some(marker =\u003e cleanedContent.includes(marker));\r\n```\r\n\r\n**自动修复机制**：\r\n\r\n系统会自动添加缺失的结束标记，这种检测修复逻辑可以大大提高解析成功率：\r\n\r\n```typescript\r\n// 自动修复逻辑\r\nif (!cleanedContent.includes(endMarker)) {\r\n    const hasOtherMarkers = [sentenceMarker, grammarMarker, chineseMarker]\r\n        .some(marker =\u003e cleanedContent.includes(marker));\r\n\r\n    if (hasOtherMarkers) {\r\n        cleanedContent += `\\n\\n${endMarker}`;  // 自动添加结束标记\r\n    }\r\n}\r\n```\r\n\r\n### 响应验证机制\r\n\r\n```javascript\r\nextractSectionsRobust(content, markers) {\r\n    const sections = {};\r\n\r\n    // 对于句子检查响应\r\n    if (markers.grammarAnalysisMarker) {\r\n        sections.grammarAnalysis = this.extractSection(\r\n            content,\r\n            markers.grammarAnalysisMarker,\r\n            [markers.grammarCorrectionMarker, markers.keywordAnalysisMarker, markers.chineseDefinitionMarker, markers.endMarker]\r\n        );\r\n```\r\n\r\n**鲁棒性提取的算法设计**：\r\n\r\n每个section的提取都使用了优先级队列的思想：\r\n\r\n```typescript\r\nextractSection(content, startMarker, endMarkers = []) {\r\n    const startIndex = content.indexOf(startMarker);\r\n    if (startIndex === -1) {\r\n        return null; // 标记未找到\r\n    }\r\n\r\n    const contentStart = startIndex + startMarker.length;\r\n\r\n    // 找到最早的结束标记\r\n    let endIndex = content.length; // 默认到内容结尾\r\n\r\n    for (const endMarker of endMarkers) {\r\n        const markerIndex = content.indexOf(endMarker, contentStart);\r\n        if (markerIndex !== -1 \u0026\u0026 markerIndex \u003c endIndex) {\r\n            endIndex = markerIndex;  // 更新最早的结束位置\r\n        }\r\n    }\r\n\r\n    const extractedContent = content.substring(contentStart, endIndex).trim();\r\n    return extractedContent.length \u003e= 5 ? extractedContent : null;\r\n}\r\n```\r\n\r\n**算法复杂度分析**：\r\n\r\n- **时间复杂度**：O(n × m)，其中n是内容长度，m是结束标记数量\r\n- **空间复杂度**：O(1)，不需要额外的存储空间\r\n\r\n### 数据清洗和格式化\r\n\r\n```javascript\r\n// 清理可能干扰的markdown痕迹\r\ncleaned = cleaned.replace(/```[\\s\\S]*?```/g, ''); // 移除代码块\r\ncleaned = cleaned.replace(/^\\s*#{1,6}\\s*/gm, ''); // 移除markdown标题\r\n\r\nreturn cleaned.trim();\r\n```\r\n\r\n**清洗规则的设计原则**：\r\n\r\n1. **保留内容**：不删除有意义的文本\r\n2. **移除干扰**：删除格式化标记\r\n3. **标准化**：统一空白字符处理\r\n\r\n**正则表达式的性能考量**：\r\n\r\n```typescript\r\n// 代码块清理\r\ncleaned = cleaned.replace(/```[\\s\\S]*?```/g, '');\r\n\r\n// 标题清理\r\ncleaned = cleaned.replace(/^\\s*#{1,6}\\s*/gm, '');\r\n```\r\n\r\n这些正则表达式的性能特征：\r\n- **非贪婪匹配**：`*?`确保最小匹配\r\n- **多行模式**：`m`标志处理多行文本\r\n- **字符类**：`\\s`比`[ \\t\\n\\r]`更高效\r\n\r\n## 完整解析流程的架构设计\r\n\r\n### 从模板加载到响应解析的生命周期\r\n\r\n完整的请求流程：\r\n\r\n```mermaid\r\ngraph TD\r\n    A[用户请求] --\u003e B[AIService.checkSentence]\r\n    B --\u003e C[promptLoader.getSentenceCheckPrompt]\r\n    C --\u003e D[loadPrompt缓存查找]\r\n    D --\u003e E{缓存命中?}\r\n    E --\u003e|是| F[返回缓存内容]\r\n    E --\u003e|否| G[读取文件]\r\n    G --\u003e H[缓存存储]\r\n    H --\u003e I[模板变量替换]\r\n    I --\u003e J[发送AI请求]\r\n    J --\u003e K[接收AI响应]\r\n    K --\u003e L[parseSentenceCheckResponse]\r\n    L --\u003e M[内容清理]\r\n    M --\u003e N[标记识别]\r\n    N --\u003e O[分段提取]\r\n    O --\u003e P[验证完整性]\r\n    P --\u003e Q[返回结构化结果]\r\n```\r\n\r\n**组件职责**：\r\n\r\n- **PromptLoader**：负责模板管理和缓存\r\n- **AIService**：负责请求处理和响应解析\r\n- **HttpUtils**：负责HTTP请求的封装\r\n- **i18n**：负责国际化和错误信息\r\n\r\n### 数据流向和状态管理\r\n\r\n```typescript\r\n// 数据流向的TypeScript类型定义\r\ninterface RequestFlow {\r\n    input: {\r\n        sentence: string;\r\n        userId?: string;\r\n        grammarLanguageOption: 'pure' | 'combined';\r\n    };\r\n    \r\n    processing: {\r\n        promptTemplate: string;\r\n        filledPrompt: string;\r\n        aiResponse: string;\r\n        cleanedContent: string;\r\n    };\r\n    \r\n    output: {\r\n        grammarAnalysis: string;\r\n        grammarCorrection: string;\r\n        keywordAnalysis: string;\r\n        chineseDefinition: string;\r\n        success: boolean;\r\n        error?: string;\r\n    };\r\n}\r\n```\r\n\r\n**状态管理的不可变性**：\r\n\r\n每个处理步骤都产生新的状态，而不是修改原有状态：\r\n\r\n```typescript\r\n// 不可变的状态转换\r\nconst state1 = { content: rawContent };\r\nconst state2 = { ...state1, content: cleanedContent };\r\nconst state3 = { ...state2, sections: extractedSections };\r\n```\r\n\r\n这种设计的优势：\r\n- **调试友好**：每个状态都可以独立检查\r\n- **错误追踪**：容易定位问题发生的环节\r\n- **并发安全**：避免状态竞争问题\r\n\r\n## 系统架构图与技术要点总结\r\n\r\n### 完整的系统架构流程图\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"用户请求层\"\r\n        A[用户输入] --\u003e B[API路由]\r\n    end\r\n    \r\n    subgraph \"业务逻辑层\"\r\n        B --\u003e C[AIService]\r\n        C --\u003e D[动态模型选择]\r\n        D --\u003e E[提示词加载]\r\n    end\r\n    \r\n    subgraph \"提示词管理层\"\r\n        E --\u003e F[PromptLoader]\r\n        F --\u003e G{缓存命中?}\r\n        G --\u003e|是| H[返回缓存]\r\n        G --\u003e|否| I[文件读取]\r\n        I --\u003e J[缓存更新]\r\n        J --\u003e K[模板替换]\r\n    end\r\n    \r\n    subgraph \"AI交互层\"\r\n        K --\u003e L[HTTP请求]\r\n        L --\u003e M[AI响应]\r\n        M --\u003e N[响应解析]\r\n    end\r\n    \r\n    subgraph \"解析处理层\"\r\n        N --\u003e O[内容清理]\r\n        O --\u003e P[标记识别]\r\n        P --\u003e Q[分段提取]\r\n        Q --\u003e R[验证完整性]\r\n        R --\u003e S[结构化输出]\r\n    end\r\n    \r\n    subgraph \"容错处理层\"\r\n        I --\u003e T{文件存在?}\r\n        T --\u003e|是| J\r\n        T --\u003e|否| U[降级策略]\r\n        U --\u003e V[Combined版本]\r\n        V --\u003e W{加载成功?}\r\n        W --\u003e|是| J\r\n        W --\u003e|否| X[错误处理]\r\n        N --\u003e Y{解析成功?}\r\n        Y --\u003e|是| S\r\n        Y --\u003e|否| Z[部分解析]\r\n    end\r\n    \r\n    S --\u003e AA[返回结果]\r\n    X --\u003e AA\r\n    Z --\u003e AA\r\n    H --\u003e K\r\n```\r\n\r\n## 完整源码全解析\r\n\r\n### PromptLoader完整源码解析\r\n\r\n```javascript\r\n// ==================== 依赖导入 ====================\r\nconst fs = require('fs');        // Node.js文件系统模块，用于文件操作\r\nconst path = require('path');    // Node.js路径模块，用于跨平台路径处理\r\n\r\n// ==================== PromptLoader核心类 ====================\r\nclass PromptLoader {\r\n    constructor() {\r\n        // 使用Map而非Object存储缓存，获得更好的性能和类型安全\r\n        this.promptCache = new Map();\r\n        \r\n        // 使用path.join确保跨平台路径兼容性\r\n        // __dirname指向当前文件所在目录，../prompts指向prompts文件夹\r\n        this.promptsDir = path.join(__dirname, '../prompts');\r\n    }\r\n\r\n    /**\r\n     * 核心方法：从文件加载提示词模板并缓存\r\n     * @param {string} type - 提示词类型 ('sentence-check' 或 'sentence-generation')\r\n     * @param {string} grammarLanguageOption - 语法语言选项 ('combined' 或 'pure')\r\n     * @returns {string} 提示词模板字符串\r\n     */\r\n    loadPrompt(type, grammarLanguageOption = 'combined') {\r\n        // 构造缓存键：类型-语言选项的复合键\r\n        // 例如：'sentence-check-combined', 'sentence-generation-pure'\r\n        const cacheKey = `${type}-${grammarLanguageOption}`;\r\n        \r\n        // 缓存优先策略：如果缓存中存在，直接返回\r\n        // Map.has()和Map.get()都是O(1)时间复杂度\r\n        if (this.promptCache.has(cacheKey)) {\r\n            return this.promptCache.get(cacheKey);\r\n        }\r\n\r\n        try {\r\n            // 根据约定构造文件名：类型-选项.txt\r\n            const filename = `${type}-${grammarLanguageOption}.txt`;\r\n            \r\n            // 构造完整文件路径，path.join自动处理路径分隔符\r\n            const filepath = path.join(this.promptsDir, filename);\r\n            \r\n            // 防御性编程：先检查文件是否存在\r\n            // 避免fs.readFileSync抛出难以理解的ENOENT错误\r\n            if (!fs.existsSync(filepath)) {\r\n                throw new Error(`Prompt file not found: ${filepath}`);\r\n            }\r\n\r\n            // 同步读取文件内容，使用utf8编码确保中文正确显示\r\n            const promptTemplate = fs.readFileSync(filepath, 'utf8');\r\n            \r\n            // 缓存策略：只有成功读取的内容才会被缓存\r\n            // 避免缓存错误或不完整的数据\r\n            this.promptCache.set(cacheKey, promptTemplate);\r\n            \r\n            return promptTemplate;\r\n        } catch (error) {\r\n            // 错误处理第一层：记录详细的错误信息\r\n            console.error(`Error loading prompt ${type}-${grammarLanguageOption}:`, error.message);\r\n            \r\n            // 降级策略：如果pure版本失败，尝试combined版本\r\n            // 这是一个优雅的回退机制，确保服务的可用性\r\n            if (grammarLanguageOption === 'pure') {\r\n                console.warn(`Falling back to combined prompt for ${type}`);\r\n                // 递归调用自身，但使用combined选项\r\n                return this.loadPrompt(type, 'combined');\r\n            }\r\n            \r\n            // 错误处理最后一道防线：如果combined版本也失败，抛出明确的错误\r\n            throw new Error(`Failed to load prompt template: ${type}-${grammarLanguageOption}`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取句子检查提示词（带变量替换）\r\n     * @param {string} sentence - 要分析的句子\r\n     * @param {string} grammarLanguageOption - 语言选项\r\n     * @returns {string} 格式化后的提示词\r\n     */\r\n    getSentenceCheckPrompt(sentence, grammarLanguageOption = 'combined') {\r\n        // 先获取模板，利用loadPrompt的缓存机制\r\n        const template = this.loadPrompt('sentence-check', grammarLanguageOption);\r\n        \r\n        // 简单而有效的模板变量替换\r\n        // 使用String.replace而非复杂的模板引擎，减少依赖和复杂度\r\n        return template.replace('{sentence}', sentence);\r\n    }\r\n\r\n    /**\r\n     * 获取句子生成提示词（带变量替换）\r\n     * @param {Array} words - 要使用的单词数组\r\n     * @param {string} grammarLanguageOption - 语言选项\r\n     * @returns {string} 格式化后的提示词\r\n     */\r\n    getSentenceGenerationPrompt(words, grammarLanguageOption = 'combined') {\r\n        const template = this.loadPrompt('sentence-generation', grammarLanguageOption);\r\n        \r\n        // 类型安全的数组处理：确保words是数组后再join\r\n        // 如果不是数组，直接使用原值\r\n        const wordsString = Array.isArray(words) ? words.join(', ') : words;\r\n        \r\n        return template.replace('{words}', wordsString);\r\n    }\r\n\r\n    /**\r\n     * 清空缓存（开发和测试时有用）\r\n     */\r\n    clearCache() {\r\n        // Map.clear()是O(1)操作，直接清空所有缓存\r\n        this.promptCache.clear();\r\n    }\r\n\r\n    /**\r\n     * 获取缓存状态信息（调试用）\r\n     * @returns {Object} 包含缓存大小和已缓存项目的信息\r\n     */\r\n    getCacheInfo() {\r\n        return {\r\n            // Map.size是O(1)操作，获取缓存项目数量\r\n            cacheSize: this.promptCache.size,\r\n            // 将Map的键转换为数组，便于调试查看\r\n            cachedPrompts: Array.from(this.promptCache.keys())\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 验证所有必需的提示词文件是否存在\r\n     * @returns {Object} 验证结果，包含存在/缺失的文件列表\r\n     */\r\n    validatePromptFiles() {\r\n        // 定义系统必需的提示词文件列表\r\n        // 这个数组定义了系统的完整性要求\r\n        const requiredPrompts = [\r\n            'sentence-check-pure.txt',\r\n            'sentence-check-combined.txt',\r\n            'sentence-generation-pure.txt',\r\n            'sentence-generation-combined.txt'\r\n        ];\r\n\r\n        const missing = [];   // 缺失的文件\r\n        const existing = [];  // 存在的文件\r\n\r\n        // 遍历所有必需文件，检查存在性\r\n        for (const filename of requiredPrompts) {\r\n            const filepath = path.join(this.promptsDir, filename);\r\n            // fs.existsSync是同步检查，适合启动时的一次性验证\r\n            if (fs.existsSync(filepath)) {\r\n                existing.push(filename);\r\n            } else {\r\n                missing.push(filename);\r\n            }\r\n        }\r\n\r\n        return {\r\n            // 系统完整性标志：只有当所有文件都存在时才为true\r\n            valid: missing.length === 0,\r\n            existing,\r\n            missing,\r\n            // 提供提示词目录路径，便于运维人员定位问题\r\n            promptsDirectory: this.promptsDir\r\n        };\r\n    }\r\n}\r\n\r\n// ==================== 模块导出 ====================\r\n// 导出单例实例，而不是类本身\r\n// 这确保了全局只有一个PromptLoader实例，节省内存且保证缓存一致性\r\nmodule.exports = new PromptLoader();\r\n```\r\n\r\n### 响应解析核心算法解析\r\n\r\n```javascript\r\n// ==================== 内容清理算法 ====================\r\ncleanResponseContent(content) {\r\n    if (!content) return '';\r\n\r\n    let cleaned = content;\r\n\r\n    // 第一步：移除AI生成的元标记\r\n    cleaned = cleaned.replace(/\\(Parsing required\\)/gi, '');\r\n\r\n    // 第二步：标准化空白字符，保持结构完整性\r\n    cleaned = cleaned.replace(/\\n{3,}/g, '\\n\\n');\r\n\r\n    // 第三步：清理每行的边缘空白，但保持整体布局\r\n    cleaned = cleaned.split('\\n')\r\n        .map(line =\u003e line.trim())\r\n        .join('\\n');\r\n\r\n    // 第四步：移除可能干扰解析的markdown元素\r\n    cleaned = cleaned.replace(/```[\\s\\S]*?```/g, '');\r\n    cleaned = cleaned.replace(/^\\s*#{1,6}\\s*/gm, '');\r\n\r\n    return cleaned.trim();\r\n}\r\n\r\n// ==================== 标记提取算法 ====================\r\nextractSection(content, startMarker, endMarkers = []) {\r\n    // 第一步：定位起始标记\r\n    const startIndex = content.indexOf(startMarker);\r\n    if (startIndex === -1) {\r\n        return null; // 标记未找到，返回null而非抛出异常\r\n    }\r\n\r\n    // 第二步：计算内容起始位置\r\n    const contentStart = startIndex + startMarker.length;\r\n\r\n    // 第三步：寻找最近的结束标记（贪婪算法）\r\n    let endIndex = content.length; // 默认到内容结尾\r\n\r\n    for (const endMarker of endMarkers) {\r\n        const markerIndex = content.indexOf(endMarker, contentStart);\r\n        if (markerIndex !== -1 \u0026\u0026 markerIndex \u003c endIndex) {\r\n            endIndex = markerIndex;  // 更新为更早的位置\r\n        }\r\n    }\r\n\r\n    // 第四步：提取并验证内容\r\n    const extractedContent = content.substring(contentStart, endIndex).trim();\r\n    \r\n    // 内容质量检查：长度至少5个字符才被认为是有效内容\r\n    return extractedContent.length \u003e= 5 ? extractedContent : null;\r\n}\r\n```\r\n\r\n**提取算法的时间复杂度分析**：\r\n\r\n- **最好情况**：O(n)，其中n是内容长度（只需要扫描一次）\r\n- **最坏情况**：O(n × m)，其中m是结束标记数量\r\n- **平均情况**：O(n)，因为通常第一个标记就能匹配\r\n\r\n**空间复杂度**：O(1)，只使用常量级别的额外空间\r\n\r\n## 写在最后\r\n\r\n如你所见，实际上MCP的原始设计思路就是这么朴实无华。与AI约定一套数据交互格式，并让其它应用读取这套格式，从而理解AI的输出，最终实现\"AI调用外部工具\"的效果。\r\n\r\n经过这次完整的源码解析，我们看到了一个看似简单的提示词管理系统背后的精妙设计：从单例模式的内存优化，到Map缓存的性能提升，从降级策略的服务可用性，到防御性编程的健壮性保障。\r\n\r\n**每一行代码都不是偶然的，每一个设计决策都有其深刻的考量。**\r\n\r\n*愿你的提示词如春风化雨，让AI理解你的每一个意图；愿你的解析算法如庖丁解牛，将复杂的响应化为清晰的结构。在这个AI与人类智慧交融的时代，让我们一起用代码编织更美好的明天！* ✨\r\n"])</script><script>self.__next_f.push([1,"44:Tc754,"])</script><script>self.__next_f.push([1,"\r\n# 密钥双刃剑：RSA加密在现代Web应用中的安全防护之道\r\n\r\n在密码学的长河中，如果说对称加密是一把精密的锁，那么非对称加密就是一把神奇的双刃剑——一面可以加密，一面可以解密，却永远不会伤到持剑者。\r\n\r\n回想起那个信息安全刚刚起步的年代，开发者们还在为如何安全地传输API密钥而头疼不已。明文传输？那是在裸奔。对称加密？密钥分发又成了新的难题。直到RSA算法的出现，才真正解决了这个看似无解的密钥分发问题。\r\n\r\n本文将深入解析Questions Party项目中RSA加密的完整实现，从数学原理到工程实践，从密钥生成到数据传输，带你看透这把\"密钥双刃剑\"的真正威力。\r\n\r\n## RSA算法的数学基础\r\n\r\n### 大数分解的数学难题\r\n\r\nRSA算法的安全性建立在一个看似简单却极其困难的数学问题上：**大整数的素因数分解**。\r\n\r\n给你两个大质数相乘很容易：\r\n$$p = 61, q = 53$$\r\n$$n = p \\times q = 61 \\times 53 = 3233$$\r\n\r\n但如果我现在告诉你 $n = 3233$，让你找出 $p$ 和 $q$，你可能需要试很多次才能找到答案。\r\n\r\n**现在想象一下，如果 $p$ 和 $q$ 都是1024位的质数...**\r\n\r\n这就是RSA的核心思想：**正向计算简单，逆向计算困难**。\r\n\r\n### 欧拉函数和模运算\r\n\r\nRSA算法的关键在于欧拉函数 $\\phi(n)$：\r\n\r\n$$\\phi(n) = \\phi(p \\times q) = (p-1)(q-1)$$\r\n\r\n继续我们的例子：\r\n$$\\phi(3233) = (61-1)(53-1) = 60 \\times 52 = 3120$$\r\n\r\n**为什么要计算欧拉函数？**因为它告诉我们在模 $n$ 意义下，有多少个数与 $n$ 互质。\r\n\r\n### 公钥私钥的数学生成过程\r\n\r\n**第一步：选择公钥指数 $e$**\r\n\r\n这里举一个小例子，选择 $e = 17$，它满足RSA的条件：\r\n- 1 \u003c e \u003c φ(n)，即 1 \u003c 17 \u003c 3120 ✓\r\n- gcd(17, 3120) = 1，即17与3120互质 ✓\r\n\r\n**注意**：在实际应用中通常选择 $e = 65537$，但那需要更大的质数使得 $\\phi(n)$ 远大于65537。\r\n\r\n**第二步：计算私钥指数 $d$**\r\n\r\n需要满足：\r\n$$e \\times d \\equiv 1 \\pmod{\\phi(n)}$$\r\n\r\n用我们的例子：\r\n$$17 \\times d \\equiv 1 \\pmod{3120}$$\r\n\r\n通过扩展欧几里得算法，可以计算出 $d = 2753$。\r\n\r\n**验证**：$17 \\times 2753 = 46801$，$46801 = 15 \\times 3120 + 1 = 46800 + 1$，所以 $17 \\times 2753 \\equiv 1 \\pmod{3120}$ ✓\r\n\r\n### 扩展欧几里得算法详解\r\n\r\n扩展欧几里得算法是求解线性丢番图方程 $ax + by = \\gcd(a,b)$ 的经典算法。在RSA中，我们需要求解：\r\n\r\n$$e \\cdot d + \\phi(n) \\cdot k = 1$$\r\n\r\n即找到 $d$ 和 $k$，使得 $e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$。\r\n\r\n**算法步骤**：\r\n\r\n以我们的例子为例，求解 $17 \\cdot d \\equiv 1 \\pmod{3120}$：\r\n\r\n1. **初始化**：\r\n   - $r_0 = 3120, r_1 = 17$\r\n   - $s_0 = 1, s_1 = 0$  \r\n   - $t_0 = 0, t_1 = 1$\r\n\r\n2. **迭代过程**：\r\n   ```\r\n   第1步：q₁ = ⌊3120/17⌋ = 183\r\n   r₂ = 3120 - 183×17 = 3120 - 3111 = 9\r\n   s₂ = 1 - 183×0 = 1\r\n   t₂ = 0 - 183×1 = -183\r\n   \r\n   第2步：q₂ = ⌊17/9⌋ = 1\r\n   r₃ = 17 - 1×9 = 8\r\n   s₃ = 0 - 1×1 = -1\r\n   t₃ = 1 - 1×(-183) = 184\r\n   \r\n   第3步：q₃ = ⌊9/8⌋ = 1\r\n   r₄ = 9 - 1×8 = 1\r\n   s₄ = 1 - 1×(-1) = 2\r\n   t₄ = -183 - 1×184 = -367\r\n   \r\n   第4步：r₄ = 1，算法结束\r\n   ```\r\n\r\n3. **最终结果**：\r\n   当 $r_4 = 1$ 时，对应的 $t_4 = -367$。\r\n   \r\n   由于我们需要正数，所以 $d = -367 + 3120 = 2753$。\r\n   \r\n   **验证**：$17 \\times 2753 = 46801 = 15 \\times 3120 + 1$，确实 $17 \\times 2753 \\equiv 1 \\pmod{3120}$ ✓\r\n\r\n**算法的数学原理**：\r\n扩展欧几里得算法基于这样的事实：如果 $\\gcd(e, \\phi(n)) = 1$，那么一定存在整数 $d$ 和 $k$，使得：\r\n$$e \\cdot d + \\phi(n) \\cdot k = 1$$\r\n\r\n这等价于：\r\n$$e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$$\r\n\r\n即 $d$ 是 $e$ 在模 $\\phi(n)$ 意义下的**模逆元**。\r\n\r\n### 加密解密的数学原理\r\n\r\n**符号说明**：\r\n\r\n让我们首先明确每个数学符号的含义：\r\n\r\n- **$m$** (message)：**明文消息**，需要加密的原始数据，必须满足 $0 \\leq m \u003c n$\r\n- **$c$** (ciphertext)：**密文**，加密后的数据\r\n- **$e$** (encryption exponent)：**公钥指数**，在我们的例子中是17，在实际应用中通常是65537\r\n- **$d$** (decryption exponent)：**私钥指数**，是e在模φ(n)下的模逆元，在我们的例子中是2753\r\n- **$n$**：**模数**，等于两个大质数的乘积，即 $n = p \\times q$\r\n- **$\\phi(n)$**：**欧拉函数值**，等于 $(p-1)(q-1)$，表示小于n且与n互质的正整数个数\r\n- **$k$**：**任意整数**，在数学证明中出现的辅助变量\r\n\r\n**加密过程**：\r\n$$c = m^e \\bmod n$$\r\n\r\n**解密过程**：\r\n$$m = c^d \\bmod n$$\r\n\r\n**RSA正确性的数学证明**：\r\n\r\n**第一步：应用欧拉定理**\r\n根据欧拉定理，对于互质的 $m$ 和 $n$（即 $\\gcd(m,n) = 1$）：\r\n$$m^{\\phi(n)} \\equiv 1 \\pmod{n}$$\r\n\r\n**第二步：利用私钥的定义**\r\n由于 $d$ 是 $e$ 的模逆元，我们有：\r\n$$e \\cdot d \\equiv 1 \\pmod{\\phi(n)}$$\r\n\r\n这意味着存在某个整数 $k$，使得：\r\n$$e \\cdot d = 1 + k \\cdot \\phi(n)$$\r\n\r\n**第三步：验证解密过程**\r\n现在我们证明解密确实能恢复原始消息：\r\n\r\n$$c^d = (m^e)^d = m^{ed} = m^{1 + k\\phi(n)} = m^1 \\cdot m^{k\\phi(n)} = m \\cdot (m^{\\phi(n)})^k$$\r\n\r\n根据欧拉定理，$m^{\\phi(n)} \\equiv 1 \\pmod{n}$，因此：\r\n\r\n$$m \\cdot (m^{\\phi(n)})^k \\equiv m \\cdot 1^k \\equiv m \\pmod{n}$$\r\n\r\n**结论**：\r\n$$c^d \\equiv m \\pmod{n}$$\r\n\r\n**具体数值验证**：\r\n\r\n- 设明文 $m = 123$\r\n- 加密：$c = 123^{17} \\bmod 3233$\r\n- 解密：$m' = c^{2753} \\bmod 3233 = 123$\r\n\r\n**重要说明**：本例子使用小质数仅为演示目的。在实际应用中，RSA使用1024位或2048位的大质数，此时通常选择 $e = 65537$，因为它在保证安全性的同时具有良好的计算性能。\r\n\r\n## RSA在Web安全中的角色定位\r\n\r\n### 对称加密 vs 非对称加密的选择策略\r\n\r\n在现代Web应用中，RSA通常不用于大量数据的加密，而是扮演着\"密钥保护者\"的角色：\r\n\r\n```\r\n传统的困境：\r\n用户 --[明文API密钥]--\u003e 服务器  ❌ 不安全\r\n用户 --[对称加密]--\u003e 服务器    ❌ 密钥分发问题\r\n\r\nRSA的解决方案：\r\n用户 --[RSA公钥加密]--\u003e 服务器 --[RSA私钥解密]--\u003e 安全存储  ✅\r\n```\r\n\r\n**性能对比**：\r\n\r\n| 加密方式 | 加密速度 | 解密速度 | 密钥分发 | 适用场景 |\r\n|---------|---------|---------|---------|---------|\r\n| AES-256 | 极快 | 极快 | 困难 | 大量数据 |\r\n| RSA-2048 | 慢 | 极慢 | 简单 | 小量数据/密钥交换 |\r\n\r\n### RSA-OAEP填充方案的安全性\r\n\r\n**为什么需要填充？**\r\n\r\n如果直接使用原始RSA：\r\n- 相同明文总是产生相同密文\r\n- 容易受到选择明文攻击\r\n- 明文长度信息泄露\r\n\r\n**OAEP填充的工作原理**：\r\n\r\n```\r\n明文 → 添加随机数 → 掩码生成 → 最终密文\r\n```\r\n\r\nOAEP确保：\r\n1. **随机性**：相同明文每次加密结果不同\r\n2. **完整性**：任何篡改都会导致解密失败\r\n3. **语义安全**：攻击者无法从密文推断明文信息\r\n\r\n### Questions Party安全架构设计\r\n\r\n更新API Key：\r\n\r\n```\r\n用户输入API密钥 → 前端RSA加密 → HTTPS传输 → 数据库存储（存储的是密文）\r\n```\r\n\r\n使用API Key发送请求：\r\n\r\n```\r\n用户输入请求内容 → HTTPS传输 → 后端RSA解密 → 使用解密后的明文Key调用大模型API → 解析响应并返回\r\n```\r\n\r\n## Questions Party项目中的RSA实现架构\r\n\r\n### 整体安全架构设计\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"前端浏览器\"\r\n        A[用户输入API密钥] --\u003e B[获取RSA公钥]\r\n        B --\u003e C[前端RSA加密]\r\n        C --\u003e D[HTTPS传输]\r\n    end\r\n    \r\n    subgraph \"后端服务器\"\r\n        D --\u003e E[接收加密数据]\r\n        E --\u003e G[数据库存储]\r\n    end\r\n    \r\n    subgraph \"密钥管理\"\r\n        H[环境变量文件] --\u003e I[RSA密钥对]\r\n        I --\u003e J[公钥分发]\r\n        I --\u003e K[私钥保护]\r\n    end\r\n    \r\n    J --\u003e B\r\n    K --\u003e G\r\n```\r\n\r\n### 前后端分离架构下的加密策略\r\n\r\n**前端职责**：\r\n- 获取公钥\r\n- 加密敏感数据\r\n- 传输加密数据\r\n\r\n**后端职责**：\r\n- 密钥对管理\r\n- 公钥分发\r\n- 存储加密数据\r\n\r\n**安全边界**：\r\n- 私钥永远不离开服务器\r\n- 公钥可以自由分发\r\n- 敏感数据只在必要时解密\r\n\r\n### 密钥管理和分发机制\r\n\r\n```javascript\r\nconst jsrsasign = require('jsrsasign');\r\nconst { KEYUTIL } = jsrsasign;\r\nconst crypto = require('crypto');\r\n\r\nclass RSACrypto {\r\n  constructor() {\r\n    this.keySize = 2048;\r\n    this.initializeKeys();\r\n  }\r\n\r\n  // 从环境变量初始化RSA密钥对或生成新的密钥对\r\n  initializeKeys() {\r\n    if (process.env.RSA_PUBLIC_KEY \u0026\u0026 process.env.RSA_PRIVATE_KEY) {\r\n      // 处理转义和非转义的换行符（兼容性考虑）\r\n      this.publicKeyPEM = process.env.RSA_PUBLIC_KEY.includes('\\\\n') \r\n        ? process.env.RSA_PUBLIC_KEY.replace(/\\\\n/g, '\\n')\r\n        : process.env.RSA_PUBLIC_KEY;\r\n      this.privateKeyPEM = process.env.RSA_PRIVATE_KEY.includes('\\\\n')\r\n        ? process.env.RSA_PRIVATE_KEY.replace(/\\\\n/g, '\\n')\r\n        : process.env.RSA_PRIVATE_KEY;\r\n    } else {\r\n      console.warn('RSA keys not found in environment. Generating new keys...');\r\n      const keyPair = this.generateKeyPair();\r\n      this.publicKeyPEM = keyPair.publicKeyPEM;\r\n      this.privateKeyPEM = keyPair.privateKeyPEM;\r\n      \r\n      console.log('Generated RSA Public Key:', this.publicKeyPEM);\r\n      console.log('Generated RSA Private Key:', this.privateKeyPEM);\r\n      console.log('Please add these keys to your .env file:');\r\n      console.log('RSA_PUBLIC_KEY=\"' + this.publicKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\r\n      console.log('RSA_PRIVATE_KEY=\"' + this.privateKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\r\n    }\r\n  }\r\n\r\n  // RSA密钥对生成：使用jsrsasign生成标准格式密钥\r\n  generateKeyPair(keySize = 2048) {\r\n    try {\r\n      const keyPair = KEYUTIL.generateKeypair('RSA', keySize);\r\n      const publicKeyPEM = KEYUTIL.getPEM(keyPair.pubKeyObj);       // 公钥PEM格式\r\n      const privateKeyPEM = KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV');  // 私钥PKCS8格式\r\n      \r\n      return { publicKeyPEM, privateKeyPEM };\r\n    } catch (error) {\r\n      throw new Error(`RSA key generation failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // 公钥分发接口：供前端获取公钥\r\n  getPublicKey() {\r\n    return this.publicKeyPEM;\r\n  }\r\n\r\n  // RSA-OAEP加密实现：使用Node.js crypto模块确保最佳性能和安全性\r\n  encrypt(plaintext) {\r\n    try {\r\n      // 输入验证：确保明文有效\r\n      if (!plaintext || typeof plaintext !== 'string') {\r\n        throw new Error('Invalid plaintext for encryption');\r\n      }\r\n\r\n      // UTF-8编码转换：确保中文等字符正确处理\r\n      const buffer = Buffer.from(plaintext, 'utf8');\r\n      \r\n      // 核心加密逻辑：使用OAEP填充的RSA加密\r\n      // 选择Node.js crypto而非jsrsasign的原因：更可靠的OAEP实现\r\n      const encrypted = crypto.publicEncrypt(\r\n        {\r\n          key: this.publicKeyPEM,                              // PEM格式公钥\r\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // OAEP填充，防止填充攻击\r\n          oaepHash: 'sha256',                                  // SHA-256哈希函数\r\n        },\r\n        buffer\r\n      );\r\n\r\n      // Base64编码：便于网络传输和存储\r\n      return encrypted.toString('base64');\r\n    } catch (error) {\r\n      throw new Error(`RSA encryption failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // RSA-OAEP解密实现：临时解密策略的核心\r\n  decrypt(encryptedData) {\r\n    try {\r\n      // 输入验证：确保密文格式正确\r\n      if (!encryptedData || typeof encryptedData !== 'string') {\r\n        throw new Error('Invalid encrypted data for decryption');\r\n      }\r\n\r\n      // Base64解码：恢复二进制密文\r\n      const encryptedBuffer = Buffer.from(encryptedData, 'base64');\r\n      \r\n      // 核心解密逻辑：使用私钥解密\r\n      const decrypted = crypto.privateDecrypt(\r\n        {\r\n          key: this.privateKeyPEM,                             // PEM格式私钥\r\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // 与加密保持一致的填充\r\n          oaepHash: 'sha256',                                  // 与加密保持一致的哈希\r\n        },\r\n        encryptedBuffer\r\n      );\r\n\r\n      // UTF-8解码：恢复原始字符串\r\n      return decrypted.toString('utf8');\r\n    } catch (error) {\r\n      throw new Error(`RSA decryption failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // 灵活加密接口：支持使用任意公钥加密（测试用）\r\n  encryptWithPublicKey(plaintext, publicKeyPEM) {\r\n    try {\r\n      if (!plaintext || typeof plaintext !== 'string') {\r\n        throw new Error('Invalid plaintext for encryption');\r\n      }\r\n\r\n      const buffer = Buffer.from(plaintext, 'utf8');\r\n      \r\n      // 使用外部提供的公钥进行加密\r\n      const encrypted = crypto.publicEncrypt(\r\n        {\r\n          key: publicKeyPEM,                                   // 外部公钥\r\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n          oaepHash: 'sha256',\r\n        },\r\n        buffer\r\n      );\r\n\r\n      return encrypted.toString('base64');\r\n    } catch (error) {\r\n      throw new Error(`RSA encryption with provided key failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // 密钥验证工具：确保密钥格式正确\r\n  validateKey(keyPEM, isPrivate = false) {\r\n    try {\r\n      const keyObj = KEYUTIL.getKey(keyPEM);\r\n      return keyObj \u0026\u0026 (isPrivate ? keyObj.isPrivate : keyObj.isPublic);\r\n    } catch (error) {\r\n      return false;   // 验证失败返回false而非抛出异常\r\n    }\r\n  }\r\n}\r\n\r\n// 单例模式导出：全局唯一实例，节省内存并保证缓存一致性\r\nconst rsaCrypto = new RSACrypto();\r\n\r\n// 模块导出：提供多种使用方式\r\nmodule.exports = {\r\n  RSACrypto,                                                    // 导出类（用于扩展）\r\n  rsaCrypto,                                                   // 导出单例实例\r\n  generateKeyPair: (keySize) =\u003e rsaCrypto.generateKeyPair(keySize),     // 便利函数\r\n  encrypt: (plaintext) =\u003e rsaCrypto.encrypt(plaintext),                 // 便利函数\r\n  decrypt: (encryptedData) =\u003e rsaCrypto.decrypt(encryptedData),         // 便利函数\r\n  getPublicKey: () =\u003e rsaCrypto.getPublicKey(),                         // 便利函数\r\n  encryptWithPublicKey: (plaintext, publicKey) =\u003e rsaCrypto.encryptWithPublicKey(plaintext, publicKey),\r\n  validateKey: (keyPEM, isPrivate) =\u003e rsaCrypto.validateKey(keyPEM, isPrivate)\r\n};\r\n```\r\n\r\n### 密钥初始化设计\r\n\r\n1. **环境变量优先**：生产环境使用预配置的密钥\r\n2. **自动生成兜底**：开发环境自动生成临时密钥\r\n3. **格式兼容性**：处理转义字符的兼容性问题\r\n\r\n### 加密数据的存储策略\r\n\r\n```javascript\r\n// 使用RSA解密API密钥的方法\r\nuserSchema.methods.decryptApiKey = function(encryptedKey = null) {\r\n  try {\r\n    const keyToDecrypt = encryptedKey || this.apiKey;\r\n    \r\n    if (!keyToDecrypt) {\r\n      return null;\r\n    }\r\n\r\n    // 检查是否为RSA加密（前端传来的base64格式）\r\n    if (keyToDecrypt.startsWith('rsa:')) {\r\n      const encryptedData = keyToDecrypt.substring(4);\r\n      return decrypt(encryptedData);\r\n    }\r\n    \r\n    // 如果不是加密的，直接返回（开发/测试用）\r\n    return keyToDecrypt;\r\n  } catch (error) {\r\n    throw new Error(`API key decryption failed: ${error.message}`);\r\n  }\r\n};\r\n```\r\n\r\n**存储策略**：\r\n\r\n1. **前缀标识**：`rsa:`前缀标识加密数据\r\n2. **兼容性处理**：支持明文存储（开发环境）\r\n\r\n## 后端RSA密钥管理与加密服务\r\n\r\n### RSACrypto类的单例模式设计\r\n\r\n```javascript\r\n// 导出单例实例\r\nconst rsaCrypto = new RSACrypto();\r\n\r\nmodule.exports = {\r\n  RSACrypto,\r\n  rsaCrypto,\r\n  generateKeyPair: (keySize) =\u003e rsaCrypto.generateKeyPair(keySize),\r\n  encrypt: (plaintext) =\u003e rsaCrypto.encrypt(plaintext),\r\n  decrypt: (encryptedData) =\u003e rsaCrypto.decrypt(encryptedData),\r\n  getPublicKey: () =\u003e rsaCrypto.getPublicKey(),\r\n  encryptWithPublicKey: (plaintext, publicKey) =\u003e rsaCrypto.encryptWithPublicKey(plaintext, publicKey),\r\n  validateKey: (keyPEM, isPrivate) =\u003e rsaCrypto.validateKey(keyPEM, isPrivate)\r\n};\r\n```\r\n\r\n### 密钥初始化策略\r\n\r\n**生成策略**：\r\n\r\n```javascript\r\n// 生产环境：使用环境变量\r\nif (process.env.RSA_PUBLIC_KEY \u0026\u0026 process.env.RSA_PRIVATE_KEY) {\r\n  // 使用预配置的密钥对\r\n} else {\r\n  // 开发环境：动态生成\r\n  const keyPair = this.generateKeyPair();\r\n}\r\n```\r\n\r\n**密钥生成的数学过程**：\r\n\r\n```javascript\r\n// 生成RSA密钥对\r\ngenerateKeyPair(keySize = 2048) {\r\n  try {\r\n    const keyPair = KEYUTIL.generateKeypair('RSA', keySize);\r\n    const publicKeyPEM = KEYUTIL.getPEM(keyPair.pubKeyObj);\r\n    const privateKeyPEM = KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV');\r\n    \r\n    return { publicKeyPEM, privateKeyPEM };\r\n  } catch (error) {\r\n    throw new Error(`RSA key generation failed: ${error.message}`);\r\n  }\r\n}\r\n```\r\n\r\n### Node.js crypto模块的OAEP实现\r\n\r\n```javascript\r\n// 使用RSA-OAEP和公钥加密数据\r\nencrypt(plaintext) {\r\n  try {\r\n    if (!plaintext || typeof plaintext !== 'string') {\r\n      throw new Error('Invalid plaintext for encryption');\r\n    }\r\n\r\n    // 将明文转换为Buffer\r\n    const buffer = Buffer.from(plaintext, 'utf8');\r\n    \r\n    // 使用Node.js crypto模块进行RSA-OAEP加密（比jsrsasign更可靠）\r\n    const encrypted = crypto.publicEncrypt(\r\n      {\r\n        key: this.publicKeyPEM,\r\n        padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        oaepHash: 'sha256',\r\n      },\r\n      buffer\r\n    );\r\n\r\n    return encrypted.toString('base64');\r\n  } catch (error) {\r\n    throw new Error(`RSA encryption failed: ${error.message}`);\r\n  }\r\n}\r\n```\r\n\r\n**OAEP参数解析**：\r\n\r\n1. **padding: RSA_PKCS1_OAEP_PADDING**：使用OAEP填充方案\r\n2. **oaepHash: 'sha256'**：使用SHA-256作为哈希函数\r\n3. **输出格式**：Base64编码便于传输\r\n\r\n**为什么混合使用jsrsasign和crypto？**\r\n\r\n- **jsrsasign**：密钥生成和管理\r\n- **crypto**：加密解密操作（性能更好）\r\n\r\n## 前端RSA加密实现深度剖析\r\n\r\n### Web Crypto API的使用\r\n\r\n```typescript\r\n// 使用RSA-OAEP进行加密（与后端兼容）\r\nasync encrypt(plaintext: string): Promise\u003cstring\u003e {\r\n  if (!this.publicKey) {\r\n    throw new Error('Public key not set. Call setPublicKey() first.');\r\n  }\r\n\r\n  if (!plaintext || typeof plaintext !== 'string') {\r\n    throw new Error('Invalid plaintext for encryption');\r\n  }\r\n\r\n  try {\r\n    // 使用Web Crypto API进行RSA-OAEP加密\r\n    // 首先，导入公钥\r\n    const publicKeyBuffer = this.pemToArrayBuffer(this.publicKey);\r\n\r\n    const cryptoKey = await window.crypto.subtle.importKey(\r\n      'spki',\r\n      publicKeyBuffer,\r\n      {\r\n        name: 'RSA-OAEP',\r\n        hash: 'SHA-256',\r\n      },\r\n      false,\r\n      ['encrypt']\r\n    );\r\n\r\n    // 加密明文\r\n    const plaintextBuffer = new TextEncoder().encode(plaintext);\r\n    const encryptedBuffer = await window.crypto.subtle.encrypt(\r\n      {\r\n        name: 'RSA-OAEP',\r\n      },\r\n      cryptoKey,\r\n      plaintextBuffer\r\n    );\r\n\r\n    // 转为base64以匹配后端格式\r\n    return this.arrayBufferToBase64(encryptedBuffer);\r\n  } catch (error) {\r\n    throw new Error(`RSA encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n  }\r\n}\r\n```\r\n\r\n### PEM格式密钥的处理\r\n\r\n```typescript\r\n// 辅助方法：将PEM格式转换为ArrayBuffer\r\nprivate pemToArrayBuffer(pem: string): ArrayBuffer {\r\n  // 移除头部和尾部\r\n  const pemHeader = '-----BEGIN PUBLIC KEY-----';\r\n  const pemFooter = '-----END PUBLIC KEY-----';\r\n  const pemContents = pem.replace(pemHeader, '').replace(pemFooter, '').replace(/\\s/g, '');\r\n\r\n  // base64解码为二进制字符串\r\n  const binaryString = atob(pemContents);\r\n\r\n  // 二进制字符串转ArrayBuffer\r\n  const bytes = new Uint8Array(binaryString.length);\r\n  for (let i = 0; i \u003c binaryString.length; i++) {\r\n    bytes[i] = binaryString.charCodeAt(i);\r\n  }\r\n\r\n  return bytes.buffer;\r\n}\r\n```\r\n\r\n**PEM格式解析**：\r\n\r\n1. **头尾去除**：移除PEM格式的标识头\r\n2. **空白清理**：去除所有空白字符\r\n3. **Base64解码**：将Base64字符串转换为二进制\r\n4. **ArrayBuffer转换**：转换为Web Crypto API需要的格式\r\n\r\n### ArrayBuffer和Base64的转换\r\n\r\n```typescript\r\n// 辅助方法：将ArrayBuffer转换为base64\r\nprivate arrayBufferToBase64(buffer: ArrayBuffer): string {\r\n  const bytes = new Uint8Array(buffer);\r\n  let binary = '';\r\n  for (let i = 0; i \u003c bytes.byteLength; i++) {\r\n    binary += String.fromCharCode(bytes[i]);\r\n  }\r\n  return btoa(binary);\r\n}\r\n```\r\n\r\n**数据转换**：\r\n\r\n```\r\n用户输入(String) → TextEncoder → ArrayBuffer → Web Crypto API → ArrayBuffer → Base64 → 网络传输\r\n```\r\n\r\n转换步骤解释：\r\n- **TextEncoder**：将字符串转换为UTF-8字节\r\n- **ArrayBuffer**：Web Crypto API的标准格式\r\n- **Base64**：网络传输的安全编码\r\n\r\n**降级策略**：\r\n\r\n```typescript\r\n// 检查Web Crypto API支持\r\nif (!window.crypto || !window.crypto.subtle) {\r\n  // 降级到jsrsasign实现\r\n  return this.jsrsasignEncrypt(plaintext);\r\n}\r\n```\r\n\r\n## API密钥更新流程的完整实现\r\n\r\n### updateApiKey接口的设计思路\r\n\r\n```javascript\r\n// @desc    更新用户API密钥\r\n// @route   PUT /api/auth/api-key\r\n// @access  Private\r\nexports.updateApiKey = async (req, res) =\u003e {\r\n  try {\r\n    const { apiKey, useCustomApiKey } = req.body;\r\n\r\n    // 校验输入，仅当useCustomApiKey为true且apiKey有值时才要求apiKey\r\n    // 允许useCustomApiKey为true但apiKey为空（用户打算自定义但还未输入）\r\n    if (useCustomApiKey \u0026\u0026 apiKey \u0026\u0026 apiKey.trim().length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: req.t('auth.apiKeyRequired')\r\n      });\r\n    }\r\n\r\n    const user = await User.findById(req.user.id);\r\n    if (!user) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: req.t('auth.userNotFound')\r\n      });\r\n    }\r\n\r\n    // 更新用户API密钥设置\r\n    if (useCustomApiKey) {\r\n      // 如果apiKey有值且非空，直接存储前端加密后的API密钥\r\n      // 前端发送带有'rsa:'前缀的RSA加密API密钥——此处不做解密\r\n      if (apiKey \u0026\u0026 apiKey.trim().length \u003e 0) {\r\n        user.apiKey = apiKey.trim(); // 直接存储加密数据\r\n      } else {\r\n        user.apiKey = undefined;\r\n      }\r\n      user.useCustomApiKey = true;\r\n    } else {\r\n      user.apiKey = undefined;\r\n      user.useCustomApiKey = false;\r\n    }\r\n\r\n    await user.save();\r\n\r\n    res.status(200).json({\r\n      success: true,\r\n      message: req.t('auth.apiKeyUpdatedSuccessfully'),\r\n      useCustomApiKey: user.useCustomApiKey\r\n    });\r\n  } catch (error) {\r\n    res.status(500).json({\r\n      success: false,\r\n      message: req.t('auth.serverError')\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### 前端加密 → 传输 → 后端解密的完整流程\r\n\r\n```typescript\r\nconst updateApiKey = async (apiKey: string, shouldUseCustomKey: boolean) =\u003e {\r\n  loading.value = true\r\n  try {\r\n    // 加密前获取最新公钥\r\n    if (shouldUseCustomKey \u0026\u0026 apiKey) {\r\n      const keyResult = await fetchPublicKey()\r\n      if (!keyResult.success) {\r\n        toast.error(t('apiKey.publicKeyFetchFailed'))\r\n        return {success: false, message: t('apiKey.publicKeyFetchError')}\r\n      }\r\n    }\r\n\r\n    // 如果有自定义密钥且有apiKey，进行加密\r\n    let encryptedApiKey = ''\r\n    if (shouldUseCustomKey \u0026\u0026 apiKey \u0026\u0026 publicKey.value) {\r\n      try {\r\n        const encrypted = await rsaCrypto.encrypt(apiKey)\r\n        encryptedApiKey = 'rsa:' + encrypted\r\n      } catch (encryptError) {\r\n        toast.error(t('apiKey.encryptionFailed'))\r\n        console.error(encryptedApiKey)\r\n        return {success: false, message: t('apiKey.encryptionError')}\r\n      }\r\n    }\r\n\r\n    const response = await aiConfigAPI.updateApiKey({\r\n      apiKey: shouldUseCustomKey ? encryptedApiKey : '',\r\n      useCustomApiKey: shouldUseCustomKey\r\n    })\r\n\r\n    if (response.data.success) {\r\n      useCustomApiKey.value = response.data.useCustomApiKey\r\n      hasCustomApiKey.value = shouldUseCustomKey \u0026\u0026 !!apiKey\r\n      customApiKey.value = apiKey\r\n      toast.success(t('apiKey.updateSuccess'))\r\n      return {success: true}\r\n    } else {\r\n      const message = response.data.message || t('common.error')\r\n      toast.error(message)\r\n      return {success: false, message}\r\n    }\r\n  } catch (error: any) {\r\n    const message = error.response?.data?.message || t('common.error')\r\n    toast.error(message)\r\n    return {success: false, message}\r\n  } finally {\r\n    loading.value = false\r\n  }\r\n}\r\n```\r\n\r\n**完整流程的数据变化**：\r\n\r\n**更新API密钥时**：\r\n```\r\n用户输入: \"sk-1234567890abcdef\"\r\n  ↓\r\n前端加密: \"rsa:Base64EncryptedData...\"\r\n  ↓\r\nHTTPS传输: [TLS加密的RSA加密数据]\r\n  ↓\r\n后端接收: \"rsa:Base64EncryptedData...\"\r\n  ↓\r\n数据库存储: \"rsa:Base64EncryptedData...\" (直接存储密文)\r\n```\r\n\r\n**使用API密钥调用模型时**：\r\n```\r\n数据库读取: \"rsa:Base64EncryptedData...\"\r\n  ↓\r\n临时解密: \"sk-1234567890abcdef\"\r\n  ↓\r\n调用大模型API: 使用明文密钥\r\n  ↓\r\n解密后立即清理: 明文密钥从内存销毁\r\n```\r\n\r\n### 错误处理和用户体验优化\r\n\r\n**多层错误处理**：\r\n\r\n```typescript\r\n// 层级1：加密失败\r\ntry {\r\n  const encrypted = await rsaCrypto.encrypt(apiKey)\r\n  encryptedApiKey = 'rsa:' + encrypted\r\n} catch (encryptError) {\r\n  toast.error(t('apiKey.encryptionFailed'))\r\n  return {success: false, message: t('apiKey.encryptionError')}\r\n}\r\n\r\n// 层级2：网络请求失败\r\ntry {\r\n  const response = await aiConfigAPI.updateApiKey({...})\r\n} catch (error: any) {\r\n  const message = error.response?.data?.message || t('common.error')\r\n  toast.error(message)\r\n  return {success: false, message}\r\n}\r\n```\r\n\r\n## 数据存储与解密策略\r\n\r\n### 加密数据的数据库存储格式\r\n\r\n```javascript\r\n// 自定义API密钥（可选，未设置时使用平台默认）\r\n// 数据库存储为加密形式\r\napiKey: {\r\n  type: String,\r\n  required: false,\r\n  trim: true\r\n},\r\n// 是否使用自定义API密钥\r\nuseCustomApiKey: {\r\n  type: Boolean,\r\n  default: false\r\n},\r\n```\r\n\r\n**数据库存储的数据格式**：\r\n\r\n```javascript\r\n// 用户文档示例\r\n{\r\n  _id: ObjectId(\"...\"),\r\n  username: \"testuser\",\r\n  email: \"test@example.com\",\r\n  apiKey: \"rsa:Base64EncodedEncryptedData...\",  // 加密存储\r\n  useCustomApiKey: true,\r\n  // ... 其他字段\r\n}\r\n```\r\n\r\n### rsa:前缀的标识机制\r\n\r\n```javascript\r\n// 使用RSA解密API密钥的方法\r\nuserSchema.methods.decryptApiKey = function(encryptedKey = null) {\r\n  try {\r\n    const keyToDecrypt = encryptedKey || this.apiKey;\r\n    \r\n    if (!keyToDecrypt) {\r\n      return null;\r\n    }\r\n\r\n    // 检查是否为RSA加密（前端传来的base64格式）\r\n    if (keyToDecrypt.startsWith('rsa:')) {\r\n      const encryptedData = keyToDecrypt.substring(4);\r\n      return decrypt(encryptedData);\r\n    }\r\n    \r\n    // 如果不是加密的，直接返回（开发/测试用）\r\n    return keyToDecrypt;\r\n  } catch (error) {\r\n    throw new Error(`API key decryption failed: ${error.message}`);\r\n  }\r\n};\r\n```\r\n\r\n### 解密时机的选择策略\r\n\r\n```javascript\r\n// 获取AI服务用的解密后API密钥的方法\r\nuserSchema.methods.getDecryptedApiKey = function() {\r\n  if (!this.apiKey || !this.useCustomApiKey) {\r\n    return null;\r\n  }\r\n  return this.decryptApiKey();\r\n};\r\n```\r\n\r\n**Questions Party的选择**：**按需临时解密**\r\n\r\n- 存储时：直接存储加密数据，不解密\r\n- 使用时：仅在调用大模型API时临时解密\r\n- 解密后：立即清理内存中的明文数据\r\n- 优势：最大化安全性，最小化明文暴露时间\r\n\r\n### 内存中明文数据的生命周期管理\r\n\r\n```javascript\r\n// 获取解密后的平台API密钥的辅助函数\r\nfunction getPlatformApiKey() {\r\n    // 优先尝试获取加密的API密钥\r\n    if (process.env.ENCRYPTED_PLATFORM_API_KEY) {\r\n        try {\r\n            const {decrypt} = require('../utils/rsaCrypto');\r\n\r\n            if (process.env.ENCRYPTED_PLATFORM_API_KEY.startsWith('rsa:')) {\r\n                const encryptedData = process.env.ENCRYPTED_PLATFORM_API_KEY.substring(4);\r\n                return decrypt(encryptedData);\r\n            }\r\n        } catch (error) {\r\n            console.warn('Failed to decrypt platform API key:', error.message);\r\n        }\r\n    }\r\n\r\n    // 如果有解密后的密钥则返回，否则返回null\r\n    return null;\r\n}\r\n```\r\n\r\n## 安全性分析与攻击防护\r\n\r\n### 常见的RSA攻击方式和防护措施\r\n\r\n**1. 小公钥指数攻击**\r\n\r\n```javascript\r\n// ❌ 危险的选择\r\ne = 3  // 太小，容易受到攻击\r\n\r\n// ✅ 安全的选择\r\ne = 65537  // 足够大，计算效率高\r\n```\r\n\r\n**2. 时间攻击**\r\n\r\n```javascript\r\n// ❌ 容易受到时间攻击\r\nfunction unsafeDecrypt(ciphertext) {\r\n  // 解密时间与私钥相关\r\n  return privateKey.decrypt(ciphertext);\r\n}\r\n\r\n// ✅ 使用常数时间算法\r\nfunction safeDecrypt(ciphertext) {\r\n  // Node.js crypto模块已经实现了时间攻击防护\r\n  return crypto.privateDecrypt({\r\n    key: privateKey,\r\n    padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\r\n  }, ciphertext);\r\n}\r\n```\r\n\r\n### 填充攻击的原理和OAEP的防护机制\r\n\r\n**PKCS#1 v1.5填充的漏洞**：\r\n\r\n```\r\n原始RSA: c = m^e mod n\r\nPKCS#1 v1.5: 00 || BT || PS || 00 || D\r\n\r\n问题：填充格式固定，容易受到填充攻击\r\n```\r\n\r\n**OAEP填充的防护机制**：\r\n\r\n```\r\nOAEP: 使用随机数和掩码生成函数\r\n结果：相同明文每次加密都不同\r\n```\r\n\r\n**数学表示**：\r\n\r\n$$\\text{OAEP}(m, r) = (X \\oplus G(Y)) \\| (Y \\oplus H(X))$$\r\n\r\n其中：\r\n- $m$：原始消息\r\n- $r$：随机数\r\n- $G$，$H$：掩码生成函数\r\n\r\n## 完整代码全解析\r\n\r\n### 后端RSA密钥管理核心实现 (`src/utils/rsaCrypto.js`)\r\n\r\n```javascript\r\n// 模块导入：密钥生成库和Node.js原生加密模块\r\nconst jsrsasign = require('jsrsasign');    // 用于密钥生成和管理\r\nconst { KEYUTIL } = jsrsasign;            // 密钥工具类\r\nconst crypto = require('crypto');          // Node.js原生加密模块，性能更好\r\n\r\nclass RSACrypto {\r\n  constructor() {\r\n    this.keySize = 2048;\r\n    this.initializeKeys();\r\n  }\r\n\r\n  // 从环境变量初始化RSA密钥对或生成新的密钥对\r\n  initializeKeys() {\r\n    if (process.env.RSA_PUBLIC_KEY \u0026\u0026 process.env.RSA_PRIVATE_KEY) {\r\n      // 处理转义和非转义的换行符（兼容性考虑）\r\n      this.publicKeyPEM = process.env.RSA_PUBLIC_KEY.includes('\\\\n') \r\n        ? process.env.RSA_PUBLIC_KEY.replace(/\\\\n/g, '\\n')\r\n        : process.env.RSA_PUBLIC_KEY;\r\n      this.privateKeyPEM = process.env.RSA_PRIVATE_KEY.includes('\\\\n')\r\n        ? process.env.RSA_PRIVATE_KEY.replace(/\\\\n/g, '\\n')\r\n        : process.env.RSA_PRIVATE_KEY;\r\n    } else {\r\n      console.warn('RSA keys not found in environment. Generating new keys...');\r\n      const keyPair = this.generateKeyPair();\r\n      this.publicKeyPEM = keyPair.publicKeyPEM;\r\n      this.privateKeyPEM = keyPair.privateKeyPEM;\r\n      \r\n      console.log('Generated RSA Public Key:', this.publicKeyPEM);\r\n      console.log('Generated RSA Private Key:', this.privateKeyPEM);\r\n      console.log('Please add these keys to your .env file:');\r\n      console.log('RSA_PUBLIC_KEY=\"' + this.publicKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\r\n      console.log('RSA_PRIVATE_KEY=\"' + this.privateKeyPEM.replace(/\\n/g, '\\\\n') + '\"');\r\n    }\r\n  }\r\n\r\n  // RSA密钥对生成：使用jsrsasign生成标准格式密钥\r\n  generateKeyPair(keySize = 2048) {\r\n    try {\r\n      const keyPair = KEYUTIL.generateKeypair('RSA', keySize);\r\n      const publicKeyPEM = KEYUTIL.getPEM(keyPair.pubKeyObj);       // 公钥PEM格式\r\n      const privateKeyPEM = KEYUTIL.getPEM(keyPair.prvKeyObj, 'PKCS8PRV');  // 私钥PKCS8格式\r\n      \r\n      return { publicKeyPEM, privateKeyPEM };\r\n    } catch (error) {\r\n      throw new Error(`RSA key generation failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // 公钥分发接口：供前端获取公钥\r\n  getPublicKey() {\r\n    return this.publicKeyPEM;\r\n  }\r\n\r\n  // RSA-OAEP加密实现：使用Node.js crypto模块确保最佳性能和安全性\r\n  encrypt(plaintext) {\r\n    try {\r\n      // 输入验证：确保明文有效\r\n      if (!plaintext || typeof plaintext !== 'string') {\r\n        throw new Error('Invalid plaintext for encryption');\r\n      }\r\n\r\n      // UTF-8编码转换：确保中文等字符正确处理\r\n      const buffer = Buffer.from(plaintext, 'utf8');\r\n      \r\n      // 核心加密逻辑：使用OAEP填充的RSA加密\r\n      // 选择Node.js crypto而非jsrsasign的原因：更可靠的OAEP实现\r\n      const encrypted = crypto.publicEncrypt(\r\n        {\r\n          key: this.publicKeyPEM,                              // PEM格式公钥\r\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // OAEP填充，防止填充攻击\r\n          oaepHash: 'sha256',                                  // SHA-256哈希函数\r\n        },\r\n        buffer\r\n      );\r\n\r\n      // Base64编码：便于网络传输和存储\r\n      return encrypted.toString('base64');\r\n    } catch (error) {\r\n      throw new Error(`RSA encryption failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // RSA-OAEP解密实现：临时解密策略的核心\r\n  decrypt(encryptedData) {\r\n    try {\r\n      // 输入验证：确保密文格式正确\r\n      if (!encryptedData || typeof encryptedData !== 'string') {\r\n        throw new Error('Invalid encrypted data for decryption');\r\n      }\r\n\r\n      // Base64解码：恢复二进制密文\r\n      const encryptedBuffer = Buffer.from(encryptedData, 'base64');\r\n      \r\n      // 核心解密逻辑：使用私钥解密\r\n      const decrypted = crypto.privateDecrypt(\r\n        {\r\n          key: this.privateKeyPEM,                             // PEM格式私钥\r\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,   // 与加密保持一致的填充\r\n          oaepHash: 'sha256',                                  // 与加密保持一致的哈希\r\n        },\r\n        encryptedBuffer\r\n      );\r\n\r\n      // UTF-8解码：恢复原始字符串\r\n      return decrypted.toString('utf8');\r\n    } catch (error) {\r\n      throw new Error(`RSA decryption failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // 灵活加密接口：支持使用任意公钥加密（测试用）\r\n  encryptWithPublicKey(plaintext, publicKeyPEM) {\r\n    try {\r\n      if (!plaintext || typeof plaintext !== 'string') {\r\n        throw new Error('Invalid plaintext for encryption');\r\n      }\r\n\r\n      const buffer = Buffer.from(plaintext, 'utf8');\r\n      \r\n      // 使用外部提供的公钥进行加密\r\n      const encrypted = crypto.publicEncrypt(\r\n        {\r\n          key: publicKeyPEM,                                   // 外部公钥\r\n          padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n          oaepHash: 'sha256',\r\n        },\r\n        buffer\r\n      );\r\n\r\n      return encrypted.toString('base64');\r\n    } catch (error) {\r\n      throw new Error(`RSA encryption with provided key failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // 密钥验证工具：确保密钥格式正确\r\n  validateKey(keyPEM, isPrivate = false) {\r\n    try {\r\n      const keyObj = KEYUTIL.getKey(keyPEM);\r\n      return keyObj \u0026\u0026 (isPrivate ? keyObj.isPrivate : keyObj.isPublic);\r\n    } catch (error) {\r\n      return false;   // 验证失败返回false而非抛出异常\r\n    }\r\n  }\r\n}\r\n\r\n// 单例模式导出：全局唯一实例，节省内存并保证缓存一致性\r\nconst rsaCrypto = new RSACrypto();\r\n\r\n// 模块导出：提供多种使用方式\r\nmodule.exports = {\r\n  RSACrypto,                                                    // 导出类（用于扩展）\r\n  rsaCrypto,                                                   // 导出单例实例\r\n  generateKeyPair: (keySize) =\u003e rsaCrypto.generateKeyPair(keySize),     // 便利函数\r\n  encrypt: (plaintext) =\u003e rsaCrypto.encrypt(plaintext),                 // 便利函数\r\n  decrypt: (encryptedData) =\u003e rsaCrypto.decrypt(encryptedData),         // 便利函数\r\n  getPublicKey: () =\u003e rsaCrypto.getPublicKey(),                         // 便利函数\r\n  encryptWithPublicKey: (plaintext, publicKey) =\u003e rsaCrypto.encryptWithPublicKey(plaintext, publicKey),\r\n  validateKey: (keyPEM, isPrivate) =\u003e rsaCrypto.validateKey(keyPEM, isPrivate)\r\n};\r\n```\r\n\r\n### 前端RSA加密核心实现 (`src/utils/rsaCrypto.ts`)\r\n\r\n```typescript\r\nimport * as jsrsasign from 'jsrsasign';   // RSA密钥操作库\r\n\r\nconst {KEYUTIL} = jsrsasign;\r\n\r\nexport class RSACrypto {\r\n    private publicKey: string | null = null;   // 存储从后端获取的公钥\r\n\r\n    // 静态工具方法：使用指定公钥加密（测试用）\r\n    static async encryptWithKey(plaintext: string, publicKeyPEM: string): Promise\u003cstring\u003e {\r\n        const rsa = new RSACrypto();\r\n        rsa.setPublicKey(publicKeyPEM);\r\n        return await rsa.encrypt(plaintext);\r\n    }\r\n\r\n    // 静态安全验证：确保公钥格式正确且不包含私钥信息\r\n    static validatePublicKey(keyPEM: string): boolean {\r\n        try {\r\n            const keyObj = KEYUTIL.getKey(keyPEM);\r\n            // 关键安全检查：RSA公钥只应包含模数(n)和公钥指数(e)\r\n            // 绝对不能包含私钥指数(d) - 这是安全防护的核心\r\n            return keyObj \u0026\u0026 \r\n                   'n' in keyObj \u0026\u0026    // 模数n必须存在\r\n                   'e' in keyObj \u0026\u0026    // 公钥指数e必须存在\r\n                   !('d' in keyObj);   // 私钥指数d绝对不能存在！\r\n        } catch {\r\n            return false;   // 解析失败，安全拒绝\r\n        }\r\n    }\r\n\r\n    // 密钥设置：接收后端分发的公钥\r\n    setPublicKey(publicKeyPEM: string) {\r\n        this.publicKey = publicKeyPEM;\r\n    }\r\n\r\n    // 密钥获取：返回当前设置的公钥\r\n    getPublicKey(): string | null {\r\n        return this.publicKey;\r\n    }\r\n\r\n    // 核心加密方法：使用Web Crypto API实现RSA-OAEP加密\r\n    async encrypt(plaintext: string): Promise\u003cstring\u003e {\r\n        // 前置检查：确保公钥已设置\r\n        if (!this.publicKey) {\r\n            throw new Error('Public key not set. Call setPublicKey() first.');\r\n        }\r\n\r\n        // 输入验证：确保明文有效\r\n        if (!plaintext || typeof plaintext !== 'string') {\r\n            throw new Error('Invalid plaintext for encryption');\r\n        }\r\n\r\n        try {\r\n            // 第一步：PEM格式密钥转换为Web Crypto API需要的ArrayBuffer\r\n            const publicKeyBuffer = this.pemToArrayBuffer(this.publicKey);\r\n\r\n            // 第二步：导入公钥到Web Crypto API\r\n            // 使用标准的SPKI格式和RSA-OAEP算法\r\n            const cryptoKey = await window.crypto.subtle.importKey(\r\n                'spki',                     // Subject Public Key Info格式\r\n                publicKeyBuffer,            // 二进制密钥数据\r\n                {\r\n                    name: 'RSA-OAEP',       // 算法名称，与后端保持一致\r\n                    hash: 'SHA-256',        // 哈希函数，与后端保持一致\r\n                },\r\n                false,                      // 不允许提取密钥（安全考虑）\r\n                ['encrypt']                 // 只允许加密操作\r\n            );\r\n\r\n            // 第三步：明文编码和加密\r\n            const plaintextBuffer = new TextEncoder().encode(plaintext);  // UTF-8编码\r\n            const encryptedBuffer = await window.crypto.subtle.encrypt(\r\n                {\r\n                    name: 'RSA-OAEP',      // 使用OAEP填充\r\n                },\r\n                cryptoKey,\r\n                plaintextBuffer\r\n            );\r\n\r\n            // 第四步：Base64编码以匹配后端格式\r\n            return this.arrayBufferToBase64(encryptedBuffer);\r\n        } catch (error) {\r\n            throw new Error(`RSA encryption failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n        }\r\n    }\r\n\r\n    // 私有工具方法：PEM格式转ArrayBuffer\r\n    private pemToArrayBuffer(pem: string): ArrayBuffer {\r\n        // 第一步：移除PEM格式的头尾标识和所有空白字符\r\n        const pemHeader = '-----BEGIN PUBLIC KEY-----';\r\n        const pemFooter = '-----END PUBLIC KEY-----';\r\n        const pemContents = pem.replace(pemHeader, '')\r\n                              .replace(pemFooter, '')\r\n                              .replace(/\\s/g, '');   // 移除所有空白字符\r\n\r\n        // 第二步：Base64解码为二进制字符串\r\n        const binaryString = atob(pemContents);\r\n\r\n        // 第三步：二进制字符串转ArrayBuffer（Web Crypto API标准格式）\r\n        const bytes = new Uint8Array(binaryString.length);\r\n        for (let i = 0; i \u003c binaryString.length; i++) {\r\n            bytes[i] = binaryString.charCodeAt(i);   // 逐字节转换\r\n        }\r\n\r\n        return bytes.buffer;\r\n    }\r\n\r\n    // 私有工具方法：ArrayBuffer转Base64（网络传输格式）\r\n    private arrayBufferToBase64(buffer: ArrayBuffer): string {\r\n        const bytes = new Uint8Array(buffer);\r\n        let binary = '';\r\n        // 逐字节转换为二进制字符串\r\n        for (let i = 0; i \u003c bytes.byteLength; i++) {\r\n            binary += String.fromCharCode(bytes[i]);\r\n        }\r\n        return btoa(binary);   // Base64编码\r\n    }\r\n}\r\n\r\n// 导出单例实例：全局唯一，便于状态管理\r\nexport const rsaCrypto = new RSACrypto();\r\n\r\n// 导出工具函数：便于直接调用\r\nexport const encryptWithKey = RSACrypto.encryptWithKey;\r\nexport const validatePublicKey = RSACrypto.validatePublicKey;\r\n```\r\n\r\n### 用户模型解密逻辑核心实现 (`src/models/User.js`)\r\n\r\n```javascript\r\n// 使用RSA解密API密钥的方法\r\nuserSchema.methods.decryptApiKey = function(encryptedKey = null) {\r\n  try {\r\n    const keyToDecrypt = encryptedKey || this.apiKey;\r\n    \r\n    if (!keyToDecrypt) {\r\n      return null;\r\n    }\r\n\r\n    // 检查是否为RSA加密（前端传来的base64格式）\r\n    if (keyToDecrypt.startsWith('rsa:')) {\r\n      const encryptedData = keyToDecrypt.substring(4);\r\n      return decrypt(encryptedData);\r\n    }\r\n    \r\n    // 如果不是加密的，直接返回（开发/测试用）\r\n    return keyToDecrypt;\r\n  } catch (error) {\r\n    throw new Error(`API key decryption failed: ${error.message}`);\r\n  }\r\n};\r\n\r\n// 按需解密的安全策略：只在真正需要时才解密\r\nuserSchema.methods.getDecryptedApiKey = function() {\r\n  // 双重安全检查：必须同时满足有密钥且启用自定义密钥\r\n  if (!this.apiKey || !this.useCustomApiKey) {\r\n    return null;   // 不满足条件，返回null\r\n  }\r\n  // 临时解密：调用解密方法获取明文密钥\r\n  return this.decryptApiKey();\r\n};\r\n```\r\n\r\n### 认证控制器密钥管理核心实现 (`src/controllers/authController.js`)\r\n\r\n```javascript\r\n// API接口：更新用户API密钥\r\n// @desc    更新用户API密钥\r\n// @route   PUT /api/auth/api-key\r\n// @access  Private (需要身份验证)\r\nexports.updateApiKey = async (req, res) =\u003e {\r\n  try {\r\n    const { apiKey, useCustomApiKey } = req.body;\r\n\r\n    // 输入验证的边界条件处理：精确的验证逻辑\r\n    // 只有在明确要使用自定义密钥且提供了空字符串时才报错\r\n    // 允许设置useCustomApiKey = true但暂不提供密钥的情况\r\n    if (useCustomApiKey \u0026\u0026 apiKey \u0026\u0026 apiKey.trim().length === 0) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: req.t('auth.apiKeyRequired')   // 国际化错误信息\r\n      });\r\n    }\r\n\r\n    // 用户身份验证：确保用户存在\r\n    const user = await User.findById(req.user.id);\r\n    if (!user) {\r\n      return res.status(404).json({\r\n        success: false,\r\n        message: req.t('auth.userNotFound')\r\n      });\r\n    }\r\n\r\n    // 密钥更新的核心逻辑：状态管理的原子性操作\r\n    if (useCustomApiKey) {\r\n      // 关键安全决策：直接存储前端加密的数据，绝不在此处解密\r\n      // 前端发送的是RSA加密数据，格式为 'rsa:Base64EncryptedData'\r\n      if (apiKey \u0026\u0026 apiKey.trim().length \u003e 0) {\r\n        user.apiKey = apiKey.trim();   // 直接存储密文，保持加密状态\r\n      } else {\r\n        user.apiKey = undefined;       // 清空密钥数据\r\n      }\r\n      user.useCustomApiKey = true;     // 启用自定义密钥标志\r\n    } else {\r\n      // 禁用自定义密钥：同时清空密钥数据和标志位，确保数据一致性\r\n      user.apiKey = undefined;\r\n      user.useCustomApiKey = false;\r\n    }\r\n\r\n    // 原子性数据库操作：确保状态变更的一致性\r\n    await user.save();\r\n\r\n    // 成功响应：返回操作结果和新状态\r\n    res.status(200).json({\r\n      success: true,\r\n      message: req.t('auth.apiKeyUpdatedSuccessfully'),\r\n      useCustomApiKey: user.useCustomApiKey    // 返回当前状态供前端确认\r\n    });\r\n  } catch (error) {\r\n    // 统一错误处理：记录错误并返回用户友好的错误信息\r\n    res.status(500).json({\r\n      success: false,\r\n      message: req.t('auth.serverError')\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n**代码架构的核心设计原则**：\r\n\r\n1. **安全优先原则**：后端永不存储明文密钥，只在使用时临时解密\r\n2. **职责分离原则**：前端负责加密，后端负责存储和按需解密\r\n3. **数据一致性原则**：确保密钥数据和使用标志的原子性更新\r\n4. **错误处理原则**：每个层级都有详细的错误处理和国际化支持\r\n5. **向前兼容原则**：支持开发环境的调试需求，保持系统灵活性\r\n\r\n通过这些代码的详细解析，我们可以看到Questions Party项目在RSA实现上的每一个细节都经过了深思熟虑，既保证了安全性，又兼顾了可维护性和易用性。整个架构体现了现代Web安全开发的最佳实践。\r\n\r\n## 完整的端到端加密流程追踪\r\n\r\n### 从用户输入到数据库存储的完整追踪\r\n\r\n**API密钥更新流程**：\r\n```mermaid\r\nsequenceDiagram\r\n    participant U as 用户\r\n    participant F as 前端\r\n    participant B as 后端\r\n    participant D as 数据库\r\n    \r\n    U-\u003e\u003eF: 输入API密钥\r\n    F-\u003e\u003eB: 获取RSA公钥\r\n    B-\u003e\u003eF: 返回公钥\r\n    F-\u003e\u003eF: RSA加密密钥\r\n    F-\u003e\u003eB: 发送加密数据\r\n    B-\u003e\u003eD: 直接存储加密数据\r\n    D-\u003e\u003eB: 确认存储\r\n    B-\u003e\u003eF: 返回成功状态\r\n    F-\u003e\u003eU: 显示成功消息\r\n```\r\n\r\n**API密钥使用流程**：\r\n```mermaid\r\nsequenceDiagram\r\n    participant U as 用户\r\n    participant F as 前端\r\n    participant B as 后端\r\n    participant D as 数据库\r\n    participant A as 大模型API\r\n    \r\n    U-\u003e\u003eF: 发送请求\r\n    F-\u003e\u003eB: 请求处理\r\n    B-\u003e\u003eD: 读取加密密钥\r\n    D-\u003e\u003eB: 返回加密数据\r\n    B-\u003e\u003eB: 临时解密密钥\r\n    B-\u003e\u003eA: 使用明文密钥调用API\r\n    A-\u003e\u003eB: 返回API响应\r\n    B-\u003e\u003eB: 清理明文密钥\r\n    B-\u003e\u003eF: 返回处理结果\r\n    F-\u003e\u003eU: 显示结果\r\n```\r\n\r\n### 每一步的数据状态变化\r\n\r\n**API密钥更新流程的数据状态**：\r\n\r\n| 步骤 | 位置 | 数据状态 | 格式 | 安全性 |\r\n|------|------|----------|------|--------|\r\n| 1 | 用户输入 | 明文 | String | 低 |\r\n| 2 | 前端内存 | 明文 | String | 低 |\r\n| 3 | 前端加密 | 密文 | Base64 | 高 |\r\n| 4 | 网络传输 | 密文+TLS | Encrypted | 极高 |\r\n| 5 | 后端接收 | 密文 | Base64 | 高 |\r\n| 6 | 数据库存储 | 密文 | rsa:Base64 | 高 |\r\n\r\n**API密钥使用流程的数据状态**：\r\n\r\n| 步骤 | 位置 | 数据状态 | 格式 | 安全性 |\r\n|------|------|----------|------|--------|\r\n| 1 | 数据库读取 | 密文 | rsa:Base64 | 高 |\r\n| 2 | 后端临时解密 | 明文 | String | 中 |\r\n| 3 | 调用大模型API | 明文 | String | 中 |\r\n| 4 | 内存清理 | 已销毁 | - | 极高 |\r\n\r\n### 调试和监控的最佳实践\r\n\r\n**日志记录策略**：\r\n\r\n```javascript\r\n// ✅ 安全的日志记录\r\nconsole.log('API key updated for user:', user.id);\r\nconsole.log('Using custom API key:', user.useCustomApiKey);\r\n\r\n// ❌ 危险的日志记录\r\nconsole.log('API key:', apiKey);  // 永远不要记录敏感数据\r\nconsole.log('Decrypted key:', decryptedKey);\r\n```\r\n\r\n**监控指标**：\r\n\r\n```javascript\r\nconst securityMetrics = {\r\n  encryptionSuccessRate: '99.9%',\r\n  decryptionErrorRate: '0.1%',\r\n  keyRotationFrequency: '90 days',\r\n  suspiciousActivityCount: 0\r\n};\r\n```\r\n\r\n## 系统架构总结与最佳实践\r\n\r\n### RSA在现代Web应用中的完整架构\r\n\r\n通过对Questions Party项目的深入分析，我们可以总结出一套完整的RSA加密架构：\r\n\r\n```mermaid\r\ngraph TB\r\n    subgraph \"安全边界\"\r\n        subgraph \"前端安全域\"\r\n            A[用户输入] --\u003e B[数据验证]\r\n            B --\u003e C[获取公钥]\r\n            C --\u003e D[RSA加密]\r\n            D --\u003e E[安全传输]\r\n        end\r\n        \r\n        subgraph \"传输安全域\"\r\n            E --\u003e F[HTTPS隧道]\r\n            F --\u003e G[TLS终结]\r\n        end\r\n        \r\n        subgraph \"后端安全域\"\r\n            G --\u003e H[数据接收]\r\n            H --\u003e I[身份验证]\r\n            I --\u003e J[直接存储密文]\r\n            J --\u003e K[按需临时解密]\r\n            K --\u003e L[业务处理]\r\n            L --\u003e M[内存清理]\r\n        end\r\n        \r\n        subgraph \"存储安全域\"\r\n            M --\u003e N[数据库]\r\n            N --\u003e O[备份加密]\r\n        end\r\n    end\r\n    \r\n    subgraph \"密钥管理域\"\r\n        P[密钥生成] --\u003e Q[密钥分发]\r\n        Q --\u003e R[密钥轮换]\r\n        R --\u003e S[密钥销毁]\r\n    end\r\n    \r\n    Q --\u003e C\r\n    P --\u003e K\r\n```\r\n\r\n## 写在最后\r\n\r\n在设计安全性加密架构的时候，我会假设：前端代码被逆向了，而中间传输被拦截了，它们的算法、数据完全暴露在攻击者的眼中，只有后端是安全的。在这种情况下，怎样的加密流程才能够确保安全呢？\r\n\r\n倘若只有后端是安全的，那么要解决这个问题，只能从后端下手。即——我需要有某个安全的东西来对解密这一步进行把关，确保明文密钥只会临时存在于后端，将攻击者窃取密钥的可能性降到最低。\r\n\r\n后来我想到了非对称加密。\r\n\r\n*愿你的加密如古老行星上的瘢痕般无法预测。公钥和私钥各为彼岸的一端，渡过中间长长的未知之河，带着你心中的信息安然来到彼岸吧。密钥如夜空中的双子星，公钥照亮世界，私钥守护自己；愿你的加密如古代的密语，只有真正理解的人才能解读其中的奥秘。在这个数字化的时代，让我们用代码编织更安全的未来，用数学构筑更牢固的防线！* 🔐✨\r\n"])</script><script>self.__next_f.push([1,"45:Tca02,"])</script><script>self.__next_f.push([1,"\r\n# 词汇摘录：共筑单词之海\r\n\r\n你有没有好奇过为什么只有在你输入的单词拼写正确的情况下才能添加成功呢？以及......添加成功后，回显的单词词义又是从哪儿来的呢？\r\n\r\n本文将全面解析Questions Party项目中的词汇识别与存储系统，从用户在前端输入一个单词，到后端通过AI技术识别其词性和含义，再到数据库存储的完整链路。\r\n\r\n## 系统架构概览\r\n\r\n### 整体数据流向\r\n\r\n```\r\n用户输入 → 前端验证 → 后端校验 → 拼写检查 → 词性分析 → 数据存储 → 前端展示\r\n```\r\n\r\n### MVC架构的现代化应用\r\n\r\n单词管理系统采用了经典的MVC架构模式：\r\n\r\n- **Model（模型层）**: MongoDB + Mongoose ODM\r\n- **View（视图层）**: Vue 3 + TypeScript + Pinia\r\n- **Controller（控制器层）**: Node.js + Express + 中间件\r\n\r\n```javascript\r\n// 控制器层的核心结构\r\nconst wordController = {\r\n  getUserWords: async (req, res) =\u003e { /* 获取用户词汇 */ },\r\n  addWord: async (req, res) =\u003e { /* 添加新词汇 */ },\r\n  deleteWord: async (req, res) =\u003e { /* 删除词汇 */ },\r\n  getRandomWords: async (req, res) =\u003e { /* 智能推荐 */ }\r\n};\r\n```\r\n\r\n## 前端交互界面设计\r\n\r\n### Composition API的状态管理\r\n\r\n前端使用Vue 3的Composition API：\r\n\r\n```javascript\r\n// Words.vue 中的响应式状态管理\r\nconst showAddForm = ref(false)\r\nconst loadingRandom = ref(false)\r\nconst randomWords = ref\u003cany[]\u003e([])\r\n\r\n// 拼写错误处理\r\nconst spellingError = ref(false)\r\nconst spellingSuggestions = ref\u003cstring[]\u003e([])\r\n\r\n// 过滤和搜索\r\nconst searchQuery = ref('')\r\nconst selectedFilter = ref('all')\r\n```\r\n\r\n### 防抖搜索\r\n\r\n```javascript\r\n// 防抖搜索函数\r\nconst debouncedSearch = () =\u003e {\r\n  if (searchTimeout.value) {\r\n    clearTimeout(searchTimeout.value)\r\n  }\r\n  \r\n  searchTimeout.value = setTimeout(() =\u003e {\r\n    wordsStore.setSearchQuery(searchQuery.value)\r\n  }, 300)\r\n}\r\n```\r\n\r\n**防抖原理**：\r\n\r\n假设用户在300ms内连续输入n个字符，传统方案会发起n次请求，防抖方案只发起1次请求。\r\n\r\n### Pinia状态管理\r\n\r\n```typescript\r\n// stores/words.ts - 状态管理的核心逻辑\r\nexport const useWordsStore = defineStore('words', () =\u003e {\r\n  const words = ref\u003cWord[]\u003e([])\r\n  const selectedWords = ref\u003cSet\u003cstring\u003e\u003e(new Set())\r\n  const loading = ref(false)\r\n  \r\n  // 计算属性：智能过滤\r\n  const filteredWords = computed(() =\u003e {\r\n    let filtered = words.value\r\n    \r\n    // 词性过滤\r\n    if (currentFilter.value \u0026\u0026 currentFilter.value !== 'all') {\r\n      filtered = filtered.filter(word =\u003e \r\n        word.primaryPartOfSpeech === currentFilter.value\r\n      )\r\n    }\r\n    \r\n    // 搜索过滤\r\n    if (searchQuery.value.trim()) {\r\n      const query = searchQuery.value.toLowerCase().trim()\r\n      filtered = filtered.filter(word =\u003e \r\n        word.word.toLowerCase().includes(query) ||\r\n        word.primaryDefinition?.toLowerCase().includes(query)\r\n      )\r\n    }\r\n    \r\n    return filtered\r\n  })\r\n  \r\n  return {\r\n    words,\r\n    selectedWords,\r\n    loading,\r\n    filteredWords,\r\n    // ... 其他方法\r\n  }\r\n})\r\n```\r\n\r\n### 前端拼写建议UI设计\r\n\r\n```vue\r\n\u003c!-- Words.vue - 拼写建议UI组件 --\u003e\r\n\u003cdiv v-if=\"spellingError \u0026\u0026 spellingSuggestions.length \u003e 0\"\r\n     class=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4\"\u003e\r\n  \u003cdiv class=\"flex items-start space-x-2\"\u003e\r\n    \u003cdiv class=\"flex-shrink-0 mt-0.5\"\u003e\r\n      \u003csvg class=\"w-5 h-5 text-blue-600 dark:text-blue-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"\u003e\r\n        \u003cpath stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\u003e\u003c/path\u003e\r\n      \u003c/svg\u003e\r\n    \u003c/div\u003e\r\n    \u003cdiv class=\"flex-1\"\u003e\r\n      \u003cp class=\"text-sm font-medium text-blue-800 dark:text-blue-200 mb-2\"\u003e\r\n        {{ $t('words.spellingNotRecognized') }}\r\n      \u003c/p\u003e\r\n      \u003cp class=\"text-sm text-blue-700 dark:text-blue-300 mb-3\"\u003e\r\n        {{ $t('words.didYouMean') }}\r\n      \u003c/p\u003e\r\n      \u003c!-- 拼写建议按钮 --\u003e\r\n      \u003cdiv class=\"flex flex-wrap gap-2\"\u003e\r\n        \u003cbutton\r\n            v-for=\"suggestion in spellingSuggestions\"\r\n            :key=\"suggestion\"\r\n            class=\"inline-flex items-center px-3 py-1.5 text-sm font-medium text-blue-700 dark:text-blue-200 bg-blue-100 dark:bg-blue-800 rounded-md hover:bg-blue-200 dark:hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\r\n            @click=\"selectSuggestion(suggestion)\"\r\n        \u003e\r\n          {{ suggestion }}\r\n        \u003c/button\u003e\r\n      \u003c/div\u003e\r\n      \u003c!-- 用户操作选项 --\u003e\r\n      \u003cdiv class=\"mt-3 flex items-center space-x-2\"\u003e\r\n        \u003cbutton\r\n            class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n            @click=\"addWordAnyway\"\r\n        \u003e\r\n          {{ $t('words.addAnyway') }}\r\n        \u003c/button\u003e\r\n        \u003cspan class=\"text-xs text-blue-500 dark:text-blue-400\"\u003e{{ $t('words.or') }}\u003c/span\u003e\r\n        \u003cbutton\r\n            class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n            @click=\"cancelSpelling\"\r\n        \u003e\r\n          {{ $t('words.tryAgain') }}\r\n        \u003c/button\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n  \u003c/div\u003e\r\n\u003c/div\u003e\r\n```\r\n\r\n### 前端拼写建议处理逻辑\r\n\r\n```javascript\r\n// Words.vue - 拼写建议处理的完整逻辑\r\nconst addWord = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim()\r\n  })\r\n\r\n  if (result.success) {\r\n    // 成功添加单词\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n    spellingError.value = false\r\n    spellingSuggestions.value = []\r\n  } else if (result.spellingError \u0026\u0026 result.suggestions?.length \u003e 0) {\r\n    // 显示拼写建议\r\n    spellingError.value = true\r\n    spellingSuggestions.value = result.suggestions\r\n  }\r\n}\r\n\r\n// 选择建议的单词\r\nconst selectSuggestion = (suggestion: string) =\u003e {\r\n  newWord.word = suggestion\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n}\r\n\r\n// 强制添加单词\r\nconst addWordAnyway = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n  \r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  \r\n  // 通过forceAdd标志强制添加\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim(),\r\n    forceAdd: true\r\n  })\r\n  \r\n  if (result.success) {\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n  }\r\n}\r\n\r\n// 取消并重试\r\nconst cancelSpelling = () =\u003e {\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  newWord.word = ''\r\n}\r\n```\r\n\r\n## 国际化机制\r\n\r\n### 前端语言指定流程\r\n\r\n前端通过HTTP请求头来指定后端返回的语言：\r\n\r\n```typescript\r\n// services/api.ts - 请求拦截器\r\napi.interceptors.request.use(\r\n  (config) =\u003e {\r\n    // 获取当前语言环境\r\n    const locale = getCurrentLocale()\r\n    \r\n    // 添加语言头\r\n    if (locale) {\r\n      config.headers['x-language'] = locale\r\n    }\r\n    \r\n    // 添加认证token\r\n    const token = localStorage.getItem('token')\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`\r\n    }\r\n    \r\n    return config\r\n  },\r\n  (error) =\u003e {\r\n    return Promise.reject(error)\r\n  }\r\n)\r\n```\r\n\r\n### 后端语言处理机制\r\n\r\n后端通过中间件来识别和处理语言设置：\r\n\r\n```javascript\r\n// 后端中间件的国际化处理\r\nconst i18nMiddleware = (req, res, next) =\u003e {\r\n  const locale = req.headers['x-language'] || 'en'\r\n  req.locale = locale\r\n  req.t = (key, options) =\u003e i18n.t(key, { locale, ...options })\r\n  next()\r\n}\r\n```\r\n\r\n### 词性翻译的动态实现\r\n\r\n系统支持实时的词性翻译：\r\n\r\n```javascript\r\n// wordController.js - 词性翻译的动态加载\r\nconst wordsWithTranslation = words.map(word =\u003e {\r\n  const wordObj = word.toObject()\r\n  if (wordObj.primaryPartOfSpeech) {\r\n    // 动态翻译词性\r\n    wordObj.primaryPartOfSpeechTranslated = req.t(`words.${wordObj.primaryPartOfSpeech}`)\r\n  }\r\n  return wordObj\r\n})\r\n```\r\n\r\n## 拼写检查引擎解析：Typo.js\r\n\r\n### Hunspell算法的JavaScript实现\r\n\r\nTypo.js基于著名的Hunspell拼写检查引擎，这是一个在OpenOffice、Mozilla等项目中被广泛使用的算法：\r\n\r\n```javascript\r\n// wordUtils.js - 拼写检查的核心实现\r\nconst Typo = require('typo-js')\r\n\r\n// 初始化拼写检查器\r\nlet spellChecker\r\ntry {\r\n  spellChecker = new Typo('en_US')\r\n} catch (error) {\r\n  console.error('Failed to initialize spell checker:', error)\r\n}\r\n\r\n// 拼写检查函数\r\nconst isWordSpelledCorrectly = (word) =\u003e {\r\n  if (!spellChecker) {\r\n    console.warn('Spell checker not available, assuming word is correct')\r\n    return true\r\n  }\r\n  \r\n  try {\r\n    const cleanWord = word.toLowerCase().trim()\r\n    return spellChecker.check(cleanWord)\r\n  } catch (error) {\r\n    console.error('Error checking spelling:', error)\r\n    return true // 防御性编程：默认为正确\r\n  }\r\n}\r\n```\r\n\r\n### 智能拼写建议系统\r\n\r\n当用户输入错误单词时，系统会自动提供拼写建议，而不是直接抛出错误：\r\n\r\n```javascript\r\n// 后端控制器中的拼写建议处理\r\nif (!wordProcessing.success) {\r\n  // 返回拼写建议（200状态码，不是错误）\r\n  return res.status(200).json({\r\n    success: false,\r\n    needsConfirmation: true,\r\n    spellingError: true,\r\n    message: req.t('words.spellingError'),\r\n    suggestions: wordProcessing.suggestions || [],\r\n    originalWord: wordProcessing.word,\r\n    suggestedCorrection: wordProcessing.suggestions \u0026\u0026 wordProcessing.suggestions.length \u003e 0 \r\n      ? wordProcessing.suggestions[0] : null\r\n  });\r\n}\r\n```\r\n\r\n### 强制添加机制\r\n\r\n系统支持用户强制添加拼写\"错误\"的单词，比如专有名词或新词：\r\n\r\n```javascript\r\n// 支持强制添加的验证Schema\r\nconst addWordSchema = Joi.object({\r\n  word: Joi.string().min(1).max(50).pattern(/^[a-zA-Z\\-']+$/).required(),\r\n  forceAdd: Joi.boolean().default(false) // 新增强制添加标志\r\n});\r\n\r\n// 根据forceAdd参数决定是否跳过拼写检查\r\nif (forceAdd) {\r\n  // 跳过拼写检查，直接获取WordNet数据\r\n  const wordNetData = await require('../utils/wordUtils').getWordNetData(cleanWord);\r\n  wordProcessing = {\r\n    success: true,\r\n    word: cleanWord,\r\n    ...wordNetData\r\n  };\r\n} else {\r\n  // 正常的拼写检查流程\r\n  wordProcessing = await processWord(cleanWord);\r\n}\r\n```\r\n\r\n### 编辑距离算法\r\n\r\n拼写建议的生成基于编辑距离算法（Levenshtein Distance），这是一个经典的动态规划问题：\r\n\r\n**编辑距离的数学定义**：\r\n\r\n编辑距离是指将字符串A转换成字符串B所需的最少单字符编辑操作次数。这些操作包括：\r\n- **插入**一个字符\r\n- **删除**一个字符  \r\n- **替换**一个字符\r\n\r\n对于字符串A和B，编辑距离D(A,B)的递推公式为：\r\n\r\n$$D(A,B) = \\min \\begin{cases}\r\nD(A_{i-1}, B_j) + 1 \u0026 \\text{(删除A[i])} \\\\\r\nD(A_i, B_{j-1}) + 1 \u0026 \\text{(插入B[j])} \\\\\r\nD(A_{i-1}, B_{j-1}) + cost \u0026 \\text{(替换A[i]为B[j])}\r\n\\end{cases}$$\r\n\r\n其中：\r\n- cost = 0（如果A[i] = B[j]，字符相同无需操作）\r\n- cost = 1（如果A[i] ≠ B[j]，需要替换操作）\r\n\r\n**举一个具体的例子**：\r\n\r\n假设我们要计算\"cat\"和\"cut\"的编辑距离：\r\n\r\n```\r\n    \"\"  c  u  t\r\n\"\"   0  1  2  3\r\nc    1  0  1  2\r\na    2  1  1  2\r\nt    3  2  2  1\r\n```\r\n\r\n**计算过程**：\r\n1. 初始化：空字符串到任何字符串的距离等于目标字符串的长度\r\n2. 逐步填充表格：\r\n   - D(\"c\", \"c\") = 0 (字符相同)\r\n   - D(\"ca\", \"c\") = 1 (删除'a')\r\n   - D(\"ca\", \"cu\") = 1 (替换'a'为'u')\r\n   - D(\"cat\", \"cut\") = 1 (替换'a'为'u')\r\n\r\n**算法实现思路**：\r\n\r\n```javascript\r\nfunction editDistance(str1, str2) {\r\n  const m = str1.length\r\n  const n = str2.length\r\n  \r\n  // 创建DP表\r\n  const dp = Array(m + 1).fill().map(() =\u003e Array(n + 1).fill(0))\r\n  \r\n  // 初始化边界条件\r\n  for (let i = 0; i \u003c= m; i++) dp[i][0] = i\r\n  for (let j = 0; j \u003c= n; j++) dp[0][j] = j\r\n  \r\n  // 填充DP表\r\n  for (let i = 1; i \u003c= m; i++) {\r\n    for (let j = 1; j \u003c= n; j++) {\r\n      if (str1[i-1] === str2[j-1]) {\r\n        dp[i][j] = dp[i-1][j-1]  // 字符相同，无需操作\r\n      } else {\r\n        dp[i][j] = Math.min(\r\n          dp[i-1][j] + 1,      // 删除\r\n          dp[i][j-1] + 1,      // 插入\r\n          dp[i-1][j-1] + 1     // 替换\r\n        )\r\n      }\r\n    }\r\n  }\r\n  \r\n  return dp[m][n]\r\n}\r\n```\r\n\r\n**在拼写检查中的应用**：\r\n\r\n当用户输入\"teh\"时，系统会计算它与词典中所有单词的编辑距离：\r\n- \"teh\" vs \"the\": 距离为1（交换e和h）\r\n- \"teh\" vs \"ten\": 距离为1（替换h为n）\r\n- \"teh\" vs \"tea\": 距离为1（替换h为a）\r\n\r\n然后系统会推荐编辑距离最小的单词作为拼写建议。\r\n\r\n**算法复杂度**：\r\n- 时间复杂度：O(m × n)，其中m和n分别是两个字符串的长度\r\n- 空间复杂度：O(m × n)，可以优化至O(min(m, n))\r\n\r\n```javascript\r\n// 拼写建议生成\r\nconst getSpellingSuggestions = (word) =\u003e {\r\n  if (!spellChecker) {\r\n    return []\r\n  }\r\n  \r\n  try {\r\n    const cleanWord = word.toLowerCase().trim()\r\n    return spellChecker.suggest(cleanWord) || []\r\n  } catch (error) {\r\n    console.error('Error getting spelling suggestions:', error)\r\n    return []\r\n  }\r\n}\r\n```\r\n\r\n### 容错机制\r\n\r\n拼写检查模块采用了\"宽进严出\"的设计：\r\n\r\n- **宽进**：即使拼写检查器初始化失败，系统依然能正常工作\r\n- **严出**：对于用户输入进行严格的验证和反馈\r\n\r\n```javascript\r\n// 容错机制的实现\r\nconst processWord = async (word) =\u003e {\r\n  const cleanWord = word.toLowerCase().trim()\r\n  \r\n  // 第一关：拼写检查\r\n  const isSpelledCorrectly = isWordSpelledCorrectly(cleanWord)\r\n  \r\n  if (!isSpelledCorrectly) {\r\n    const suggestions = getSpellingSuggestions(cleanWord)\r\n    return {\r\n      success: false,\r\n      error: 'SPELLING_ERROR',\r\n      suggestions,\r\n      word: cleanWord\r\n    }\r\n  }\r\n  \r\n  // 第二关：词性分析\r\n  const wordNetData = await getWordNetData(cleanWord)\r\n  \r\n  return {\r\n    success: true,\r\n    word: cleanWord,\r\n    ...wordNetData\r\n  }\r\n}\r\n```\r\n\r\n## WordNet词汇数据库集成：语义网络\r\n\r\n### WordNet的数据结构\r\n\r\nWordNet是一个基于语义关系的英语词汇数据库，它将词汇组织成同义词集（synsets）的形式：\r\n\r\n```javascript\r\n// wordUtils.js - WordNet初始化\r\nconst wordnet = require('wordnet')\r\n\r\nlet wordnetInitialized = false\r\nconst initializeWordNet = async () =\u003e {\r\n  if (!wordnetInitialized) {\r\n    try {\r\n      await wordnet.init()\r\n      wordnetInitialized = true\r\n      console.log('WordNet initialized successfully')\r\n    } catch (error) {\r\n      console.error('Failed to initialize WordNet:', error)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### 词性识别的自动化实现\r\n\r\nWordNet能够通过语义网络分析实现自动识别单词的词性：\r\n\r\n```javascript\r\n// 词性映射函数\r\nconst mapWordNetPoS = (wordnetPos) =\u003e {\r\n  if (!wordnetPos) return null\r\n  \r\n  const mapping = {\r\n    'noun': 'noun',\r\n    'verb': 'verb', \r\n    'adjective': 'adjective',\r\n    'adverb': 'adverb',\r\n    'n': 'noun',\r\n    'v': 'verb',\r\n    'a': 'adjective',\r\n    's': 'adjective', // adjective satellite\r\n    'r': 'adverb'\r\n  }\r\n  \r\n  return mapping[wordnetPos.toLowerCase()] || null\r\n}\r\n```\r\n\r\n### 异步初始化\r\n\r\nWordNet的初始化是一个异步过程，采用了懒加载策略：\r\n\r\n```javascript\r\n// 获取WordNet数据的完整实现\r\nconst getWordNetData = async (word) =\u003e {\r\n  try {\r\n    // 确保WordNet已初始化\r\n    await initializeWordNet()\r\n    \r\n    if (!wordnetInitialized) {\r\n      console.warn('WordNet not available')\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: false\r\n      }\r\n    }\r\n    \r\n    const cleanWord = word.toLowerCase().trim()\r\n    \r\n    try {\r\n      const definitions = await wordnet.lookup(cleanWord)\r\n      \r\n      if (!definitions || definitions.length === 0) {\r\n        console.log(`No WordNet data found for: ${cleanWord}`)\r\n        return {\r\n          definitions: [],\r\n          primaryDefinition: null,\r\n          primaryPartOfSpeech: null,\r\n          wordNetProcessed: true\r\n        }\r\n      }\r\n      \r\n      // 处理WordNet定义\r\n      const processedDefinitions = definitions.map(def =\u003e ({\r\n        text: def.glossary || def.gloss || '',\r\n        partOfSpeech: mapWordNetPoS(def.meta?.synsetType)\r\n      })).filter(def =\u003e def.text \u0026\u0026 def.partOfSpeech)\r\n      \r\n      // 获取主要定义和词性\r\n      const primaryDefinition = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].text \r\n        : null\r\n      const primaryPartOfSpeech = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].partOfSpeech \r\n        : null\r\n      \r\n      return {\r\n        definitions: processedDefinitions.slice(0, 10), // 限制为10个定义\r\n        primaryDefinition,\r\n        primaryPartOfSpeech,\r\n        wordNetProcessed: true\r\n      }\r\n    } catch (lookupError) {\r\n      console.error('Error looking up word in WordNet:', lookupError)\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: true\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error in getWordNetData:', error)\r\n    return {\r\n      definitions: [],\r\n      primaryDefinition: null,\r\n      primaryPartOfSpeech: null,\r\n      wordNetProcessed: false\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## 数据模型与存储设计：MongoDB文档\r\n\r\n### 优化的Schema设计\r\n\r\nMongoDB的文档结构设计是整个系统的基础：\r\n\r\n```javascript\r\n// models/Word.js - 完整的Schema设计\r\nconst wordSchema = new mongoose.Schema({\r\n  word: {\r\n    type: String,\r\n    required: true,\r\n    trim: true,\r\n    lowercase: true,\r\n    maxlength: 50\r\n  },\r\n  userIds: [{\r\n    type: mongoose.Schema.Types.ObjectId,\r\n    ref: 'User',\r\n    required: true\r\n  }],\r\n  // WordNet检索的数据\r\n  definitions: [{\r\n    text: {\r\n      type: String,\r\n      trim: true,\r\n      maxlength: 1000\r\n    },\r\n    partOfSpeech: {\r\n      type: String,\r\n      enum: ['noun', 'verb', 'adjective', 'adverb', 'preposition', \r\n             'conjunction', 'interjection', 'pronoun', 'determiner', \r\n             'adjective satellite']\r\n    }\r\n  }],\r\n  // 主要词性（最常见的）\r\n  primaryPartOfSpeech: {\r\n    type: String,\r\n    enum: ['noun', 'verb', 'adjective', 'adverb', 'preposition', \r\n           'conjunction', 'interjection', 'pronoun', 'determiner', \r\n           'adjective satellite']\r\n  },\r\n  // 主要定义（第一个/最常见的）\r\n  primaryDefinition: {\r\n    type: String,\r\n    trim: true,\r\n    maxlength: 1000\r\n  },\r\n  usageCount: {\r\n    type: Number,\r\n    default: 0,\r\n    min: 0\r\n  },\r\n  // 跟踪WordNet查找是否成功\r\n  wordNetProcessed: {\r\n    type: Boolean,\r\n    default: false\r\n  }\r\n}, {\r\n  timestamps: true\r\n})\r\n```\r\n\r\n### 复合索引的性能优化\r\n\r\n索引设计是数据库性能的关键：\r\n\r\n```javascript\r\n// 复合索引防止每名用户上传的重复单词\r\nwordSchema.index({ word: 1, userIds: 1 }, { unique: true })\r\n\r\n// 提高查询性能的索引\r\nwordSchema.index({ userIds: 1, createdAt: -1 })\r\nwordSchema.index({ usageCount: -1 })\r\nwordSchema.index({ primaryPartOfSpeech: 1 })\r\n```\r\n\r\n**索引性能分析**：\r\n\r\n- **无索引查询**：O(n) 时间复杂度\r\n- **有索引查询**：O(log n) 时间复杂度\r\n- **复合索引**：支持多字段查询优化\r\n\r\n### 多用户数据共享机制\r\n\r\n同一个单词可以被多个用户共享：\r\n\r\n```javascript\r\n// 用户数据隔离与共享的平衡\r\nconst query = { userIds: req.user.id }\r\n\r\n// 如果单词已存在，添加用户到共享列表\r\nif (existingWord) {\r\n  if (existingWord.userIds.includes(req.user.id)) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      message: req.t('words.wordAlreadyExists')\r\n    })\r\n  }\r\n  \r\n  // 添加用户到现有单词\r\n  existingWord.userIds.push(req.user.id)\r\n  await existingWord.save()\r\n}\r\n```\r\n\r\n## 后端控制器逻辑深度剖析：RESTful\r\n\r\n### 数据验证Schema设计\r\n\r\nJoi数据验证：\r\n\r\n```javascript\r\n// 输入验证Schema\r\nconst addWordSchema = Joi.object({\r\n  word: Joi.string()\r\n    .min(1)\r\n    .max(50)\r\n    .pattern(/^[a-zA-Z\\-']+$/)\r\n    .required()\r\n})\r\n\r\n// 在控制器中使用\r\nconst { error } = addWordSchema.validate(req.body)\r\nif (error) {\r\n  return res.status(400).json({\r\n    success: false,\r\n    message: error.details[0].message\r\n  })\r\n}\r\n```\r\n\r\n### 分页查询\r\n\r\n```javascript\r\n// getUserWords - 分页查询实现\r\nconst { page = 1, limit = 50, sortBy = 'recent', search, partOfSpeech } = req.query\r\nconst skip = (page - 1) * limit\r\n\r\n// 构建查询条件\r\nconst query = { userIds: req.user.id }\r\n\r\n// 搜索过滤\r\nif (search) {\r\n  query.word = { $regex: search.trim(), $options: 'i' }\r\n}\r\n\r\n// 词性过滤\r\nif (partOfSpeech \u0026\u0026 partOfSpeech !== 'all') {\r\n  query.primaryPartOfSpeech = partOfSpeech\r\n}\r\n\r\n// 排序条件\r\nlet sortCriteria\r\nswitch (sortBy) {\r\n  case 'alphabetical':\r\n    sortCriteria = { word: 1 }\r\n    break\r\n  case 'usage':\r\n    sortCriteria = { usageCount: -1, createdAt: -1 }\r\n    break\r\n  default:\r\n    sortCriteria = { createdAt: -1 }\r\n}\r\n\r\n// 分页查询\r\nconst words = await Word.find(query)\r\n  .sort(sortCriteria)\r\n  .skip(skip)\r\n  .limit(parseInt(limit))\r\n\r\n// 总数统计\r\nconst total = await Word.countDocuments(query)\r\n```\r\n\r\n### 错误处理的标准化实现\r\n\r\n统一的错误处理机制：\r\n\r\n```javascript\r\n// 标准化的错误处理\r\ntry {\r\n  // 业务逻辑\r\n} catch (error) {\r\n  if (error.code === 11000) {\r\n    return res.status(400).json({\r\n      success: false,\r\n      message: req.t('words.wordAlreadyExists')\r\n    })\r\n  }\r\n  console.error('Add word error:', error)\r\n  res.status(500).json({\r\n    success: false,\r\n    message: req.t('words.serverErrorAddingWord')\r\n  })\r\n}\r\n```\r\n\r\n## 智能推荐：MongoDB聚合\r\n\r\n### 随机单词推荐算法\r\n\r\n使用MongoDB的聚合管道实现智能的单词推荐功能：\r\n\r\n```javascript\r\n// getRandomWords - 智能推荐实现\r\nconst { count, excludeUserWords, partOfSpeech } = value\r\n\r\n// 构建聚合管道\r\nlet aggregationPipeline = []\r\n\r\n// 构建匹配条件\r\nlet matchCriteria = {}\r\n\r\n// 排除用户已有单词\r\nif (excludeUserWords) {\r\n  matchCriteria.userIds = { $ne: req.user.id }\r\n}\r\n\r\n// 词性过滤\r\nif (partOfSpeech) {\r\n  matchCriteria.primaryPartOfSpeech = partOfSpeech\r\n}\r\n\r\n// 添加匹配阶段\r\nif (Object.keys(matchCriteria).length \u003e 0) {\r\n  aggregationPipeline.push({ $match: matchCriteria })\r\n}\r\n\r\n// 随机采样\r\naggregationPipeline.push({\r\n  $sample: { size: count * 2 } // 获取比需要更多的数据以应对过滤\r\n})\r\n\r\n// 投影所需字段\r\naggregationPipeline.push({\r\n  $project: {\r\n    _id: 1,\r\n    word: 1,\r\n    primaryDefinition: 1,\r\n    primaryPartOfSpeech: 1,\r\n    usageCount: 1\r\n  }\r\n})\r\n\r\n// 执行聚合查询\r\nlet randomWords = await Word.aggregate(aggregationPipeline)\r\n```\r\n\r\n### 推荐算法的性能优化\r\n\r\nMongoDB的`$sample`操作符使用了高效的随机采样算法：\r\n\r\n**算法复杂度分析**：\r\n- **随机采样**：O(1) 时间复杂度\r\n- **传统排序**：O(n log n) 时间复杂度\r\n- **性能提升**：当n=100万时，提升约3000倍\r\n\r\n### 个性化过滤机制\r\n\r\n系统支持多层次的个性化过滤：\r\n\r\n```javascript\r\n// 多层过滤机制\r\nconst fallbackWords = await Word.aggregate(fallbackPipeline)\r\n\r\n// 合并结果，避免重复\r\nconst existingWordIds = new Set(randomWords.map(w =\u003e w._id.toString()))\r\nconst newWords = fallbackWords.filter(w =\u003e !existingWordIds.has(w._id.toString()))\r\n\r\nrandomWords = [...randomWords, ...newWords]\r\n```\r\n\r\n## 完整数据流向分析：从输入到存储\r\n\r\n### 完整流程图\r\n\r\n```mermaid\r\ngraph TD\r\n    A[用户输入单词] --\u003e B[前端验证]\r\n    B --\u003e C[发送API请求]\r\n    C --\u003e D[后端接收请求]\r\n    D --\u003e E[Joi数据验证]\r\n    E --\u003e F[拼写检查Typo.js]\r\n    F --\u003e G{拼写正确?}\r\n    G --\u003e|否| H[返回拼写建议]\r\n    G --\u003e|是| I[WordNet词性分析]\r\n    I --\u003e J[数据库查询]\r\n    J --\u003e K{单词存在?}\r\n    K --\u003e|是| L[添加用户到共享列表]\r\n    K --\u003e|否| M[创建新单词记录]\r\n    L --\u003e N[返回成功响应]\r\n    M --\u003e N\r\n    N --\u003e O[前端更新状态]\r\n    O --\u003e P[界面刷新展示]\r\n    H --\u003e Q[用户选择建议]\r\n    Q --\u003e C\r\n```\r\n\r\n## 技术库工具链\r\n\r\n### Typo.js\r\n\r\n**技术特点**：\r\n\r\n- 基于Hunspell算法\r\n- 支持离线工作\r\n- 轻量级（约100KB）\r\n- 多语言支持\r\n\r\n**使用场景**：\r\n\r\n- 实时拼写验证\r\n- 用户输入纠错\r\n- 批量文本处理\r\n\r\n**性能特点**：\r\n- 初始化时间：50-100ms\r\n- 单词检查：\u003c1ms\r\n- 建议生成：1-5ms\r\n\r\n### WordNet：语义网络的数字化\r\n\r\n**数据结构**：\r\n- 名词：约117,000个\r\n- 动词：约11,500个\r\n- 形容词：约22,000个\r\n- 副词：约4,600个\r\n\r\n**语义关系**：\r\n- 同义词（synonyms）\r\n- 反义词（antonyms）\r\n- 上下位关系（hypernyms/hyponyms）\r\n- 部分整体关系（meronyms/holonyms）\r\n\r\n**使用优势**：\r\n- 准确的词性标注\r\n- 丰富的语义信息\r\n- 标准化的定义\r\n\r\n### Joi：数据验证的艺术\r\n\r\n**设计理念**：\r\n- 声明式验证\r\n- 链式API\r\n- 丰富的内置规则\r\n\r\n**性能优势**：\r\n- 验证速度：微秒级\r\n- 内存占用：轻量级\r\n- 错误信息：友好明确\r\n\r\n### Mongoose：MongoDB的查询构建器\r\n\r\n**ORM特点**：\r\n- 类型安全的模型定义\r\n- 中间件支持\r\n- 查询构建器\r\n- 自动类型转换\r\n\r\n**性能优化**：\r\n- 连接池管理\r\n- 查询优化\r\n- 索引建议\r\n\r\n## 后端国际化响应实现\r\n\r\n### 请求头的语言协商\r\n\r\n前端通过HTTP请求头来实现语言协商：\r\n\r\n```typescript\r\n// 语言协商的完整实现\r\nconst getCurrentLocale = () =\u003e {\r\n  return localStorage.getItem('locale') || \r\n         navigator.language.split('-')[0] || \r\n         'en'\r\n}\r\n\r\n// 请求拦截器中的语言设置\r\nif (locale) {\r\n  config.headers['x-language'] = locale\r\n}\r\n```\r\n\r\n### 后端中间件的国际化处理\r\n\r\n```javascript\r\n// 国际化中间件\r\nconst i18nMiddleware = (req, res, next) =\u003e {\r\n  const locale = req.headers['x-language'] || 'en'\r\n  \r\n  // 设置当前请求的语言环境\r\n  req.locale = locale\r\n  \r\n  // 创建翻译函数\r\n  req.t = (key, options) =\u003e {\r\n    return i18n.t(key, { locale, ...options })\r\n  }\r\n  \r\n  next()\r\n}\r\n```\r\n\r\n### 实时语言切换的技术方案\r\n\r\n```javascript\r\n// 词性翻译的实时更新\r\nconst updateWordTranslations = (words, locale) =\u003e {\r\n  return words.map(word =\u003e {\r\n    if (word.primaryPartOfSpeech) {\r\n      word.primaryPartOfSpeechTranslated = \r\n        i18n.t(`words.${word.primaryPartOfSpeech}`, { locale })\r\n    }\r\n    return word\r\n  })\r\n}\r\n```\r\n\r\n## 用户体验\r\n\r\n### 实时反馈机制\r\n\r\n```javascript\r\n// 实时的用户反馈\r\nconst addWord = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n  \r\n  // 清除之前的错误状态\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  \r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim()\r\n  })\r\n  \r\n  if (result.success) {\r\n    // 成功反馈\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n  } else if (result.suggestions) {\r\n    // 拼写错误反馈\r\n    spellingError.value = true\r\n    spellingSuggestions.value = result.suggestions\r\n  }\r\n}\r\n```\r\n\r\n### 错误处理\r\n\r\n```javascript\r\n// 友好的错误处理\r\ntry {\r\n  const response = await wordsAPI.addWord(newWord)\r\n  // ...\r\n} catch (error) {\r\n  const message = error.response?.data?.message || t('common.error')\r\n  \r\n  // 特殊错误处理\r\n  if (error.response?.data?.error === 'SPELLING_ERROR') {\r\n    const suggestions = error.response.data.suggestions || []\r\n    const suggestionText = suggestions.length \u003e 0 \r\n      ? t('words.spellingErrorWithSuggestions', { \r\n          suggestions: suggestions.join(', ') \r\n        })\r\n      : t('words.spellingError')\r\n    \r\n    toast.error(suggestionText)\r\n    return { success: false, message: suggestionText, suggestions }\r\n  }\r\n  \r\n  toast.error(message)\r\n  return { success: false, message }\r\n}\r\n```\r\n\r\n## 完整源码全解析\r\n\r\n### 后端核心文件\r\n\r\n#### 1. wordController.js - 单词控制器\r\n\r\n```javascript\r\nconst Word = require('../models/Word');\r\nconst Joi = require('joi');\r\nconst { processWord } = require('../utils/wordUtils');\r\n\r\n// 数据验证Schema - 增加forceAdd参数支持强制添加\r\nconst addWordSchema = Joi.object({\r\n  word: Joi.string().min(1).max(50).pattern(/^[a-zA-Z\\-']+$/).required(),\r\n  forceAdd: Joi.boolean().default(false) // 新增：强制添加标志\r\n});\r\n\r\n// @desc    添加新单词\r\n// @route   POST /api/words\r\n// @access  Private\r\nexports.addWord = async (req, res) =\u003e {\r\n  try {\r\n    // 第一步：验证输入数据\r\n    const { error } = addWordSchema.validate(req.body);\r\n    if (error) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: error.details[0].message\r\n      });\r\n    }\r\n\r\n    // 第二步：提取参数并清理输入\r\n    const { word, forceAdd } = req.body;\r\n    const cleanWord = word.toLowerCase().trim();\r\n\r\n    // 第三步：根据forceAdd标志决定处理方式\r\n    let wordProcessing;\r\n    \r\n    if (forceAdd) {\r\n      // 强制添加模式：跳过拼写检查，直接获取WordNet数据\r\n      const wordNetData = await require('../utils/wordUtils').getWordNetData(cleanWord);\r\n      wordProcessing = {\r\n        success: true,\r\n        word: cleanWord,\r\n        ...wordNetData\r\n      };\r\n    } else {\r\n      // 正常模式：进行拼写检查和WordNet查询\r\n      wordProcessing = await processWord(cleanWord);\r\n      \r\n      if (!wordProcessing.success) {\r\n        // 拼写错误时返回建议（200状态码，非错误响应）\r\n        return res.status(200).json({\r\n          success: false,\r\n          needsConfirmation: true,        // 需要用户确认\r\n          spellingError: true,            // 标记为拼写错误\r\n          message: req.t('words.spellingError'),\r\n          suggestions: wordProcessing.suggestions || [],\r\n          originalWord: wordProcessing.word,\r\n          suggestedCorrection: wordProcessing.suggestions \u0026\u0026 wordProcessing.suggestions.length \u003e 0 \r\n            ? wordProcessing.suggestions[0] : null\r\n        });\r\n      }\r\n    }\r\n\r\n    // 第四步：检查数据库中是否已存在该单词\r\n    const existingWord = await Word.findOne({\r\n      word: cleanWord\r\n    });\r\n\r\n    if (existingWord) {\r\n      // 单词已存在，检查当前用户是否已拥有\r\n      if (existingWord.userIds.includes(req.user.id)) {\r\n        return res.status(400).json({\r\n          success: false,\r\n          message: req.t('words.wordAlreadyExists')\r\n        });\r\n      }\r\n\r\n      // 将用户添加到现有单词的共享列表\r\n      existingWord.userIds.push(req.user.id);\r\n      await existingWord.save();\r\n\r\n      // 添加翻译后的词性信息\r\n      const wordObj = existingWord.toObject();\r\n      if (wordObj.primaryPartOfSpeech) {\r\n        wordObj.primaryPartOfSpeechTranslated = req.t(`words.${wordObj.primaryPartOfSpeech}`);\r\n      }\r\n\r\n      res.status(201).json({\r\n        success: true,\r\n        word: wordObj\r\n      });\r\n    } else {\r\n      // 创建新单词记录\r\n      const newWord = await Word.create({\r\n        word: cleanWord,\r\n        userIds: [req.user.id],\r\n        definitions: wordProcessing.definitions || [],\r\n        primaryDefinition: wordProcessing.primaryDefinition,\r\n        primaryPartOfSpeech: wordProcessing.primaryPartOfSpeech,\r\n        wordNetProcessed: wordProcessing.wordNetProcessed\r\n      });\r\n\r\n      // 添加翻译后的词性信息\r\n      const wordObj = newWord.toObject();\r\n      if (wordObj.primaryPartOfSpeech) {\r\n        wordObj.primaryPartOfSpeechTranslated = req.t(`words.${wordObj.primaryPartOfSpeech}`);\r\n      }\r\n\r\n      res.status(201).json({\r\n        success: true,\r\n        word: wordObj\r\n      });\r\n    }\r\n  } catch (error) {\r\n    // 错误处理：处理重复键等数据库错误\r\n    if (error.code === 11000) {\r\n      return res.status(400).json({\r\n        success: false,\r\n        message: req.t('words.wordAlreadyExists')\r\n      });\r\n    }\r\n    console.error('Add word error:', error);\r\n    res.status(500).json({\r\n      success: false,\r\n      message: req.t('words.serverErrorAddingWord')\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n#### 2. wordUtils.js - 单词处理工具\r\n\r\n```javascript\r\nconst Typo = require('typo-js');\r\nconst wordnet = require('wordnet');\r\n\r\n// 初始化拼写检查器\r\nlet spellChecker;\r\ntry {\r\n  spellChecker = new Typo('en_US');\r\n} catch (error) {\r\n  console.error('Failed to initialize spell checker:', error);\r\n}\r\n\r\n// 初始化WordNet\r\nlet wordnetInitialized = false;\r\nconst initializeWordNet = async () =\u003e {\r\n  if (!wordnetInitialized) {\r\n    try {\r\n      await wordnet.init();\r\n      wordnetInitialized = true;\r\n      console.log('WordNet initialized successfully');\r\n    } catch (error) {\r\n      console.error('Failed to initialize WordNet:', error);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * 拼写检查核心函数\r\n * @param {string} word - 待检查的单词\r\n * @returns {boolean} - 拼写是否正确\r\n */\r\nconst isWordSpelledCorrectly = (word) =\u003e {\r\n  // 防御性编程：检查拼写检查器是否可用\r\n  if (!spellChecker) {\r\n    console.warn('Spell checker not available, assuming word is correct');\r\n    return true;\r\n  }\r\n\r\n  try {\r\n    const cleanWord = word.toLowerCase().trim();\r\n    return spellChecker.check(cleanWord);\r\n  } catch (error) {\r\n    console.error('Error checking spelling:', error);\r\n    return true; // 默认为正确，确保系统可用性\r\n  }\r\n};\r\n\r\n/**\r\n * 获取拼写建议\r\n * @param {string} word - 拼写错误的单词\r\n * @returns {string[]} - 拼写建议数组\r\n */\r\nconst getSpellingSuggestions = (word) =\u003e {\r\n  if (!spellChecker) {\r\n    return [];\r\n  }\r\n\r\n  try {\r\n    const cleanWord = word.toLowerCase().trim();\r\n    return spellChecker.suggest(cleanWord) || [];\r\n  } catch (error) {\r\n    console.error('Error getting spelling suggestions:', error);\r\n    return [];\r\n  }\r\n};\r\n\r\n/**\r\n * 获取WordNet词汇数据\r\n * @param {string} word - 待查询的单词\r\n * @returns {Promise\u003cObject\u003e} - 包含定义和词性的对象\r\n */\r\nconst getWordNetData = async (word) =\u003e {\r\n  try {\r\n    // 确保WordNet已初始化\r\n    await initializeWordNet();\r\n    \r\n    if (!wordnetInitialized) {\r\n      console.warn('WordNet not available');\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: false\r\n      };\r\n    }\r\n\r\n    const cleanWord = word.toLowerCase().trim();\r\n    \r\n    try {\r\n      // 从WordNet查询单词定义\r\n      const definitions = await wordnet.lookup(cleanWord);\r\n      \r\n      if (!definitions || definitions.length === 0) {\r\n        console.log(`No WordNet data found for: ${cleanWord}`);\r\n        return {\r\n          definitions: [],\r\n          primaryDefinition: null,\r\n          primaryPartOfSpeech: null,\r\n          wordNetProcessed: true\r\n        };\r\n      }\r\n\r\n      // 处理WordNet返回的定义数据\r\n      const processedDefinitions = definitions.map(def =\u003e ({\r\n        text: def.glossary || def.gloss || '',\r\n        partOfSpeech: mapWordNetPoS(def.meta?.synsetType)\r\n      })).filter(def =\u003e def.text \u0026\u0026 def.partOfSpeech);\r\n\r\n      // 获取主要定义（第一个/最常见的）\r\n      const primaryDefinition = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].text \r\n        : null;\r\n      const primaryPartOfSpeech = processedDefinitions.length \u003e 0 \r\n        ? processedDefinitions[0].partOfSpeech \r\n        : null;\r\n\r\n      return {\r\n        definitions: processedDefinitions.slice(0, 10), // 限制最多10个定义\r\n        primaryDefinition,\r\n        primaryPartOfSpeech,\r\n        wordNetProcessed: true\r\n      };\r\n    } catch (lookupError) {\r\n      console.error('Error looking up word in WordNet:', lookupError);\r\n      return {\r\n        definitions: [],\r\n        primaryDefinition: null,\r\n        primaryPartOfSpeech: null,\r\n        wordNetProcessed: true\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error('Error in getWordNetData:', error);\r\n    return {\r\n      definitions: [],\r\n      primaryDefinition: null,\r\n      primaryPartOfSpeech: null,\r\n      wordNetProcessed: false\r\n    };\r\n  }\r\n};\r\n\r\n/**\r\n * 映射WordNet词性代码到系统词性\r\n * @param {string} wordnetPos - WordNet词性代码\r\n * @returns {string|null} - 映射后的词性\r\n */\r\nconst mapWordNetPoS = (wordnetPos) =\u003e {\r\n  if (!wordnetPos) return null;\r\n  \r\n  const mapping = {\r\n    'noun': 'noun',\r\n    'verb': 'verb',\r\n    'adjective': 'adjective',\r\n    'adverb': 'adverb',\r\n    'n': 'noun',\r\n    'v': 'verb',\r\n    'a': 'adjective',\r\n    's': 'adjective', // adjective satellite\r\n    'r': 'adverb'\r\n  };\r\n\r\n  return mapping[wordnetPos.toLowerCase()] || null;\r\n};\r\n\r\n/**\r\n * 处理单词的完整流程\r\n * @param {string} word - 待处理的单词\r\n * @returns {Promise\u003cObject\u003e} - 处理结果\r\n */\r\nconst processWord = async (word) =\u003e {\r\n  const cleanWord = word.toLowerCase().trim();\r\n  \r\n  // 第一步：拼写检查\r\n  const isSpelledCorrectly = isWordSpelledCorrectly(cleanWord);\r\n  \r\n  if (!isSpelledCorrectly) {\r\n    // 拼写错误，返回建议\r\n    const suggestions = getSpellingSuggestions(cleanWord);\r\n    return {\r\n      success: false,\r\n      error: 'SPELLING_ERROR',\r\n      suggestions,\r\n      word: cleanWord\r\n    };\r\n  }\r\n\r\n  // 第二步：获取WordNet数据\r\n  const wordNetData = await getWordNetData(cleanWord);\r\n  \r\n  return {\r\n    success: true,\r\n    word: cleanWord,\r\n    ...wordNetData\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  isWordSpelledCorrectly,\r\n  getSpellingSuggestions,\r\n  getWordNetData,\r\n  processWord\r\n};\r\n```\r\n\r\n#### 3. words.js - 路由定义\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst {\r\n  getUserWords,\r\n  addWord,\r\n  deleteWord,\r\n  getRandomWords,\r\n  getWordStats,\r\n  getPartsOfSpeech\r\n} = require('../controllers/wordController');\r\nconst { auth } = require('../middleware/auth');\r\n\r\nconst router = express.Router();\r\n\r\n// 获取随机单词推荐\r\nrouter.get('/random', auth, getRandomWords);\r\n\r\n// 获取用户单词统计\r\nrouter.get('/stats', auth, getWordStats);\r\n\r\n// 获取可用词性列表\r\nrouter.get('/parts-of-speech', auth, getPartsOfSpeech);\r\n\r\n// 获取用户的单词列表\r\nrouter.get('/', auth, getUserWords);\r\n\r\n// 添加新单词（支持拼写建议）\r\nrouter.post('/', auth, addWord);\r\n\r\n// 删除单词\r\nrouter.delete('/:id', auth, deleteWord);\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n### 前端核心文件\r\n\r\n#### 4. Words.vue - 单词管理视图\r\n\r\n```vue\r\n\u003ctemplate\u003e\r\n  \u003cdiv class=\"space-y-6\"\u003e\r\n    \u003c!-- 添加单词表单 --\u003e\r\n    \u003cdiv v-if=\"showAddForm\" class=\"card\"\u003e\r\n      \u003cdiv class=\"card-header\"\u003e\r\n        \u003ch3 class=\"text-lg font-semibold\"\u003e{{ $t('words.add') }}\u003c/h3\u003e\r\n      \u003c/div\u003e\r\n      \u003cdiv class=\"card-body\"\u003e\r\n        \u003cform class=\"space-y-4\" @submit.prevent=\"addWord\"\u003e\r\n          \u003cdiv class=\"grid grid-cols-1 gap-4\"\u003e\r\n            \u003cdiv\u003e\r\n              \u003clabel class=\"block text-sm font-medium text-primary\" for=\"word\"\u003e\r\n                {{ $t('words.word') }} *\r\n              \u003c/label\u003e\r\n              \u003cinput\r\n                  id=\"word\"\r\n                  v-model=\"newWord.word\"\r\n                  :placeholder=\"$t('words.enterWord')\"\r\n                  class=\"input mt-1\"\r\n                  required\r\n                  type=\"text\"\r\n              /\u003e\r\n              \u003cp class=\"text-xs text-secondary mt-1\"\u003e\r\n                {{ $t('words.spellingWillBeChecked') }}\r\n              \u003c/p\u003e\r\n            \u003c/div\u003e\r\n\r\n            \u003cdiv class=\"flex items-end md:items-center\"\u003e\r\n              \u003cbutton\r\n                  :disabled=\"wordsStore.loading || !newWord.word.trim()\"\r\n                  class=\"btn btn-primary w-full\"\r\n                  type=\"submit\"\r\n              \u003e\r\n                \u003cdiv v-if=\"wordsStore.loading\" class=\"spinner mr-2\"\u003e\u003c/div\u003e\r\n                {{ $t('words.add') }}\r\n              \u003c/button\u003e\r\n            \u003c/div\u003e\r\n          \u003c/div\u003e\r\n\r\n          \u003c!-- 拼写建议UI --\u003e\r\n          \u003cdiv v-if=\"spellingError \u0026\u0026 spellingSuggestions.length \u003e 0\"\r\n               class=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4\"\u003e\r\n            \u003cdiv class=\"flex items-start space-x-2\"\u003e\r\n              \u003c!-- 信息图标 --\u003e\r\n              \u003cdiv class=\"flex-shrink-0 mt-0.5\"\u003e\r\n                \u003csvg class=\"w-5 h-5 text-blue-600 dark:text-blue-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"\u003e\r\n                  \u003cpath stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\u003e\u003c/path\u003e\r\n                \u003c/svg\u003e\r\n              \u003c/div\u003e\r\n              \u003cdiv class=\"flex-1\"\u003e\r\n                \u003c!-- 提示文本 --\u003e\r\n                \u003cp class=\"text-sm font-medium text-blue-800 dark:text-blue-200 mb-2\"\u003e\r\n                  {{ $t('words.spellingNotRecognized') }}\r\n                \u003c/p\u003e\r\n                \u003cp class=\"text-sm text-blue-700 dark:text-blue-300 mb-3\"\u003e\r\n                  {{ $t('words.didYouMean') }}\r\n                \u003c/p\u003e\r\n                \r\n                \u003c!-- 拼写建议按钮组 --\u003e\r\n                \u003cdiv class=\"flex flex-wrap gap-2\"\u003e\r\n                  \u003cbutton\r\n                      v-for=\"suggestion in spellingSuggestions\"\r\n                      :key=\"suggestion\"\r\n                      class=\"inline-flex items-center px-3 py-1.5 text-sm font-medium text-blue-700 dark:text-blue-200 bg-blue-100 dark:bg-blue-800 rounded-md hover:bg-blue-200 dark:hover:bg-blue-700 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\r\n                      @click=\"selectSuggestion(suggestion)\"\r\n                  \u003e\r\n                    {{ suggestion }}\r\n                  \u003c/button\u003e\r\n                \u003c/div\u003e\r\n                \r\n                \u003c!-- 用户操作选项 --\u003e\r\n                \u003cdiv class=\"mt-3 flex items-center space-x-2\"\u003e\r\n                  \u003cbutton\r\n                      class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n                      @click=\"addWordAnyway\"\r\n                  \u003e\r\n                    {{ $t('words.addAnyway') }}\r\n                  \u003c/button\u003e\r\n                  \u003cspan class=\"text-xs text-blue-500 dark:text-blue-400\"\u003e{{ $t('words.or') }}\u003c/span\u003e\r\n                  \u003cbutton\r\n                      class=\"text-xs text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200 underline\"\r\n                      @click=\"cancelSpelling\"\r\n                  \u003e\r\n                    {{ $t('words.tryAgain') }}\r\n                  \u003c/button\u003e\r\n                \u003c/div\u003e\r\n              \u003c/div\u003e\r\n            \u003c/div\u003e\r\n          \u003c/div\u003e\r\n        \u003c/form\u003e\r\n      \u003c/div\u003e\r\n    \u003c/div\u003e\r\n    \r\n    \u003c!-- 其他UI组件... --\u003e\r\n  \u003c/div\u003e\r\n\u003c/template\u003e\r\n\r\n\u003cscript lang=\"ts\" setup\u003e\r\nimport { onMounted, reactive, ref } from 'vue'\r\nimport { useWordsStore } from '../stores/words.ts'\r\nimport { useI18n } from 'vue-i18n'\r\n\r\nconst wordsStore = useWordsStore()\r\nconst { t } = useI18n()\r\n\r\n// 响应式状态\r\nconst showAddForm = ref(false)              // 是否显示添加表单\r\nconst spellingError = ref(false)            // 是否有拼写错误\r\nconst spellingSuggestions = ref\u003cstring[]\u003e([]) // 拼写建议数组\r\n\r\n// 新单词数据\r\nconst newWord = reactive({\r\n  word: ''\r\n})\r\n\r\n// 组件挂载时初始化\r\nonMounted(() =\u003e {\r\n  wordsStore.fetchWords()\r\n  wordsStore.fetchPartsOfSpeech()\r\n})\r\n\r\n/**\r\n * 添加单词的主要处理函数\r\n */\r\nconst addWord = async () =\u003e {\r\n  // 验证输入\r\n  if (!newWord.word.trim()) return\r\n\r\n  // 重置拼写错误状态\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n\r\n  // 调用store添加单词\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim()\r\n  })\r\n\r\n  if (result.success) {\r\n    // 成功：重置表单\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n    spellingError.value = false\r\n    spellingSuggestions.value = []\r\n  } else if (result.spellingError \u0026\u0026 result.suggestions?.length \u003e 0) {\r\n    // 拼写错误：显示建议\r\n    spellingError.value = true\r\n    spellingSuggestions.value = result.suggestions\r\n  }\r\n}\r\n\r\n/**\r\n * 用户选择拼写建议\r\n * @param {string} suggestion - 选择的建议单词\r\n */\r\nconst selectSuggestion = (suggestion: string) =\u003e {\r\n  newWord.word = suggestion\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n}\r\n\r\n/**\r\n * 强制添加单词（跳过拼写检查）\r\n */\r\nconst addWordAnyway = async () =\u003e {\r\n  if (!newWord.word.trim()) return\r\n  \r\n  // 重置错误状态\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  \r\n  // 通过forceAdd参数强制添加\r\n  const result = await wordsStore.addWord({\r\n    word: newWord.word.trim(),\r\n    forceAdd: true\r\n  })\r\n  \r\n  if (result.success) {\r\n    newWord.word = ''\r\n    showAddForm.value = false\r\n  }\r\n}\r\n\r\n/**\r\n * 取消拼写建议，重新输入\r\n */\r\nconst cancelSpelling = () =\u003e {\r\n  spellingError.value = false\r\n  spellingSuggestions.value = []\r\n  newWord.word = ''\r\n}\r\n\u003c/script\u003e\r\n```\r\n\r\n#### 5. words.ts - Pinia状态管理\r\n\r\n```typescript\r\nimport { defineStore } from 'pinia'\r\nimport { ref, computed } from 'vue'\r\nimport { useToast } from 'vue-toastification'\r\nimport { useI18n } from 'vue-i18n'\r\nimport { wordsAPI } from '../services/api.ts'\r\n\r\n// 类型定义\r\ninterface NewWord {\r\n  word: string\r\n  forceAdd?: boolean  // 强制添加标志\r\n}\r\n\r\ninterface Word {\r\n  _id: string\r\n  word: string\r\n  userIds: string[]\r\n  definitions: Array\u003c{\r\n    text: string\r\n    partOfSpeech: string\r\n  }\u003e\r\n  primaryDefinition?: string\r\n  primaryPartOfSpeech?: string\r\n  primaryPartOfSpeechTranslated?: string\r\n  usageCount: number\r\n  wordNetProcessed: boolean\r\n  createdAt: string\r\n  updatedAt: string\r\n}\r\n\r\nexport const useWordsStore = defineStore('words', () =\u003e {\r\n  // 响应式状态\r\n  const words = ref\u003cWord[]\u003e([])\r\n  const selectedWords = ref\u003cSet\u003cstring\u003e\u003e(new Set())\r\n  const loading = ref(false)\r\n  const currentFilter = ref\u003cstring\u003e('all')\r\n  const searchQuery = ref\u003cstring\u003e('')\r\n  \r\n  // 依赖注入\r\n  const toast = useToast()\r\n  const { t } = useI18n()\r\n\r\n  // 计算属性：过滤后的单词列表\r\n  const filteredWords = computed(() =\u003e {\r\n    let filtered = words.value\r\n\r\n    // 词性过滤\r\n    if (currentFilter.value \u0026\u0026 currentFilter.value !== 'all') {\r\n      filtered = filtered.filter(word =\u003e \r\n        word.primaryPartOfSpeech === currentFilter.value\r\n      )\r\n    }\r\n\r\n    // 搜索过滤\r\n    if (searchQuery.value.trim()) {\r\n      const query = searchQuery.value.toLowerCase().trim()\r\n      filtered = filtered.filter(word =\u003e \r\n        word.word.toLowerCase().includes(query) ||\r\n        word.primaryDefinition?.toLowerCase().includes(query)\r\n      )\r\n    }\r\n\r\n    return filtered\r\n  })\r\n\r\n  // 计算属性：排序后的单词列表\r\n  const sortedWords = computed(() =\u003e {\r\n    return [...filteredWords.value].sort((a, b) =\u003e \r\n      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n    )\r\n  })\r\n\r\n  /**\r\n   * 添加单词的核心逻辑\r\n   * @param {NewWord} newWord - 新单词对象\r\n   * @returns {Promise\u003cObject\u003e} 处理结果\r\n   */\r\n  const addWord = async (newWord: NewWord) =\u003e {\r\n    // 检查重复\r\n    const existingWord = words.value.find(w =\u003e \r\n      w.word.toLowerCase() === newWord.word.toLowerCase()\r\n    )\r\n    if (existingWord) {\r\n      toast.error(t('words.wordExists'))\r\n      return { success: false, message: t('words.wordExists') }\r\n    }\r\n\r\n    loading.value = true\r\n    try {\r\n      // 调用API添加单词\r\n      const response = await wordsAPI.addWord(newWord)\r\n      \r\n      if (response.data.success) {\r\n        // 成功：更新本地状态\r\n        words.value.unshift(response.data.word)\r\n        toast.success(t('words.wordAdded'))\r\n        return { success: true, word: response.data.word }\r\n      } else {\r\n        // 检查是否为拼写错误\r\n        if (response.data.spellingError \u0026\u0026 response.data.suggestions?.length \u003e 0) {\r\n          // 不显示错误提示，让UI组件处理\r\n          return { \r\n            success: false, \r\n            spellingError: true,\r\n            suggestions: response.data.suggestions,\r\n            originalWord: response.data.originalWord,\r\n            suggestedCorrection: response.data.suggestedCorrection,\r\n            message: response.data.message || t('words.spellingError')\r\n          }\r\n        }\r\n        \r\n        // 其他错误\r\n        const message = response.data.message || t('common.error')\r\n        toast.error(message)\r\n        return { success: false, message }\r\n      }\r\n    } catch (error: any) {\r\n      // 异常处理\r\n      const message = error.response?.data?.message || t('common.error')\r\n      toast.error(message)\r\n      return { success: false, message }\r\n    } finally {\r\n      loading.value = false\r\n    }\r\n  }\r\n\r\n  return {\r\n    // 状态\r\n    words: sortedWords,\r\n    selectedWords,\r\n    loading,\r\n    currentFilter,\r\n    searchQuery,\r\n    \r\n    // 方法\r\n    addWord,\r\n    // ... 其他方法\r\n  }\r\n})\r\n```\r\n\r\n#### 6. api.ts - API服务层\r\n\r\n```typescript\r\nimport axios from 'axios'\r\nimport { getCurrentLocale } from '../utils/i18n.js'\r\n\r\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL\r\n\r\n// 创建axios实例\r\nconst api = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  timeout: 30000,\r\n  headers: {\r\n    'Content-Type': 'application/json'\r\n  }\r\n})\r\n\r\n// 请求拦截器：添加语言和认证头\r\napi.interceptors.request.use(\r\n  (config) =\u003e {\r\n    // 添加语言头\r\n    const locale = getCurrentLocale()\r\n    if (locale) {\r\n      config.headers['x-language'] = locale\r\n    }\r\n\r\n    // 添加认证头\r\n    const token = localStorage.getItem('token')\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`\r\n    }\r\n\r\n    return config\r\n  },\r\n  (error) =\u003e {\r\n    return Promise.reject(error)\r\n  }\r\n)\r\n\r\n// 响应拦截器：处理认证失败\r\napi.interceptors.response.use(\r\n  (response) =\u003e response,\r\n  (error) =\u003e {\r\n    // 处理401错误（未认证）\r\n    if (error.response?.status === 401) {\r\n      localStorage.removeItem('token')\r\n      delete api.defaults.headers.common['Authorization']\r\n      \r\n      if (window.location.pathname !== '/login') {\r\n        window.location.href = '/login'\r\n      }\r\n    }\r\n    \r\n    return Promise.reject(error)\r\n  }\r\n)\r\n\r\n// 导出单词相关API\r\nexport const wordsAPI = {\r\n  // 获取单词列表\r\n  getWords: (params?: any) =\u003e api.get('/words', { params }),\r\n\r\n  // 添加单词（支持拼写建议和强制添加）\r\n  addWord: (word: any) =\u003e api.post('/words', word),\r\n\r\n  // 删除单词\r\n  deleteWord: (id: string) =\u003e api.delete(`/words/${id}`),\r\n\r\n  // 获取单词统计\r\n  getStats: () =\u003e api.get('/words/stats'),\r\n\r\n  // 获取词性列表\r\n  getPartsOfSpeech: () =\u003e api.get('/words/parts-of-speech'),\r\n\r\n  // 获取随机单词\r\n  getRandomWords: (params?: any) =\u003e api.get('/words/random', { params })\r\n}\r\n```\r\n\r\n## 写在最后\r\n\r\n单词的检查主要是为了解决“单词库被污染“的问题。最初我的设想是由各种各样的用户来逐步扩充Questions Party的单词库，给人一种”共同学习“的氛围，但随后我想到”如果有人不小心，或是故意输入错误单词，导致单词库被污染了，该怎么办呢？“的问题，在经过一番调查后，我发现了Typo.js和WordNet。\r\n\r\n*愿众生构建的知识脉络永世长存，愿每一个单词都能找到它的归宿*。 ✨\r\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"mO0HfhVKUIqGG57hUXa3f\",\"p\":\"/MilkWind-Website\",\"c\":[\"\",\"documents\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"documents\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/MilkWind-Website/_next/static/css/fe7e5644f748258b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/MilkWind-Website/_next/static/css/38943437573ce53c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_d71c80 __variable_744f1f font-sans antialiased min-h-screen bg-background text-foreground\",\"suppressHydrationWarning\":true,\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"$L3\",null,{}],[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$7\",\"errorStyles\":[],\"errorScripts\":[],\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"div\",null,{\"className\":\"z-10 relative min-h-screen flex items-center justify-center bg-background p-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-center max-w-md\",\"children\":[[\"$\",\"div\",null,{\"className\":\"text-8xl font-bold text-primary mb-4\",\"children\":\"404\"}],[\"$\",\"h2\",null,{\"className\":\"text-2xl font-bold text-foreground mb-4\",\"children\":\"Page Not Found\"}],[\"$\",\"p\",null,{\"className\":\"text-foreground/70 mb-8\",\"children\":\"The page you're looking for doesn't exist or has been moved to a different location.\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-col sm:flex-row gap-4 justify-center\",\"children\":[[\"$\",\"$L9\",null,{\"href\":\"/\",\"className\":\"px-6 py-2 bg-primary text-white rounded-lg hover:bg-primary/80 transition-colors\",\"children\":\"Go Home\"}],[\"$\",\"$L9\",null,{\"href\":\"/works\",\"className\":\"px-6 py-2 border border-primary text-primary rounded-lg hover:bg-primary/10 transition-colors\",\"children\":\"View Works\"}]]}],[\"$\",\"div\",null,{\"className\":\"absolute inset-0 overflow-hidden pointer-events-none -z-10\",\"children\":[[\"$\",\"div\",null,{\"className\":\"absolute top-1/4 left-1/4 w-2 h-2 bg-primary/20 rounded-full animate-float\"}],[\"$\",\"div\",null,{\"className\":\"absolute top-3/4 right-1/4 w-3 h-3 bg-accent/20 rounded-full animate-float\",\"style\":{\"animationDelay\":\"1s\"}}],[\"$\",\"div\",null,{\"className\":\"absolute bottom-1/4 left-1/3 w-1 h-1 bg-secondary/20 rounded-full animate-float\",\"style\":{\"animationDelay\":\"2s\"}}]]}]]}]}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}]}]]}],{\"children\":[\"documents\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$La\",null,{\"Component\":\"$b\",\"slots\":{\"children\":[\"$\",\"$L6\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]},\"params\":{},\"promise\":\"$@c\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"$Ld\",null,{\"enArticlesData\":{\"articles\":[{\"content\":\"$e\",\"frontMatter\":{\"title\":\"All-Chat-on-This Configuration Parsing Implementation: Complete Data Flow from Configuration to Messages\",\"description\":\"Deep analysis of UserConfigDO class design, prepareRequestData data processing logic, and complete implementation principles of sendMessage message generation and transmission\",\"date\":\"2025-01-15\",\"author\":\"MilkWind\",\"tags\":[\"Spring Boot\",\"API Configuration\",\"JSON Parsing\"]},\"readingTime\":\"42 min read\",\"fileName\":\"json-parsing\",\"category\":\"all-chat-on-this\"},{\"content\":\"$f\",\"frontMatter\":{\"title\":\"All-Chat-on-This Endpoint Monitoring and Exposure Implementation: From AOP Aspects to Prometheus Monitoring Ecosystem\",\"description\":\"In-depth analysis of the complete implementation principles of endpoint monitoring, metric collection, and user activity tracking in Spring Boot applications, covering the technology stack of AOP, Micrometer, and Prometheus\",\"date\":\"2025-01-15\",\"author\":\"MilkWind\",\"tags\":[\"Spring Boot\",\"Monitoring System\",\"Prometheus\",\"Micrometer\",\"AOP\"]},\"readingTime\":\"15 min read\",\"fileName\":\"metrics\",\"category\":\"all-chat-on-this\"},{\"content\":\"$10\",\"frontMatter\":{\"title\":\"Specialization Time Halving Calculator - Algorithm Explanation\",\"description\":\"A detailed analysis of the core algorithm logic of the specialization time halving calculator\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Algorithm Analysis\",\"Arknights\"]},\"readingTime\":\"9 min read\",\"fileName\":\"specialization\",\"category\":\"ark-yituliu\"},{\"content\":\"$11\",\"frontMatter\":{\"title\":\"MutationObserver\",\"description\":\"Browser Fundamentals - MutationObserver\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Browser\",\"Fundamentals\",\"MutationObserver\",\"DOM\"]},\"readingTime\":\"4 min read\",\"fileName\":\"browser-mutation-observer\",\"category\":\"basic-knowledge\"},{\"content\":\"$12\",\"frontMatter\":{\"title\":\"requestAnimationFrame\",\"description\":\"Browser Fundamentals - requestAnimationFrame\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Browser\",\"Fundamentals\",\"requestAnimationFrame\",\"Animation\"]},\"readingTime\":\"7 min read\",\"fileName\":\"browser-request-animation-frame\",\"category\":\"basic-knowledge\"},{\"content\":\"$13\",\"frontMatter\":{\"title\":\"Framer Motion AnimatePresence\",\"description\":\"React Fundamentals - Framer Motion AnimatePresence\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"Framer Motion\",\"Animation\",\"AnimatePresence\"]},\"readingTime\":\"9 min read\",\"fileName\":\"framer-motion-animate-presence\",\"category\":\"basic-knowledge\"},{\"content\":\"$14\",\"frontMatter\":{\"title\":\"React.createContext\",\"description\":\"React Fundamentals - React.createContext\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"createContext\",\"Context API\"]},\"readingTime\":\"11 min read\",\"fileName\":\"react-create-context\",\"category\":\"basic-knowledge\"},{\"content\":\"$15\",\"frontMatter\":{\"title\":\"React.memo\",\"description\":\"React Fundamentals - React.memo\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"React.memo\"]},\"readingTime\":\"4 min read\",\"fileName\":\"react-memo\",\"category\":\"basic-knowledge\"},{\"content\":\"$16\",\"frontMatter\":{\"title\":\"useCallback\",\"description\":\"React Fundamentals - useCallback\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"useCallback\",\"React Hook\"]},\"readingTime\":\"7 min read\",\"fileName\":\"react-use-callback\",\"category\":\"basic-knowledge\"},{\"content\":\"$17\",\"frontMatter\":{\"title\":\"useEffect\",\"description\":\"React Fundamentals - useEffect\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"useEffect\",\"React Hook\"]},\"readingTime\":\"8 min read\",\"fileName\":\"react-use-effect\",\"category\":\"basic-knowledge\"},{\"content\":\"$18\",\"frontMatter\":{\"title\":\"useMemo\",\"description\":\"React Fundamentals - useMemo\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"useMemo\",\"React Hook\"]},\"readingTime\":\"11 min read\",\"fileName\":\"react-use-memo\",\"category\":\"basic-knowledge\"},{\"content\":\"$19\",\"frontMatter\":{\"title\":\"useReducer\",\"description\":\"React Fundamentals - useReducer\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"useReducer\",\"React Hook\"]},\"readingTime\":\"14 min read\",\"fileName\":\"react-use-reducer\",\"category\":\"basic-knowledge\"},{\"content\":\"$1a\",\"frontMatter\":{\"title\":\"useRef\",\"description\":\"React Fundamentals - useRef\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"Fundamentals\",\"useRef\",\"React Hook\"]},\"readingTime\":\"11 min read\",\"fileName\":\"react-use-ref\",\"category\":\"basic-knowledge\"},{\"content\":\"$1b\",\"frontMatter\":{\"title\":\"Tailwind CSS Theme\",\"description\":\"Fundamentals - Tailwind CSS Theme\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"TailwindCSS\",\"Fundamentals\",\"Theme\",\"CSS\"]},\"readingTime\":\"11 min read\",\"fileName\":\"tailwindcss-theme\",\"category\":\"basic-knowledge\"},{\"content\":\"$1c\",\"frontMatter\":{\"title\":\"Binary Rain Curtain: A Glimpse into the Machine Computing World\",\"description\":\"In-depth analysis of the complete implementation principles of Canvas character grid, radial masking, and mouse tracking\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Canvas\",\"Interaction Design\"]},\"readingTime\":\"12 min read\",\"fileName\":\"01-background\",\"category\":\"personal-website\"},{\"content\":\"$1d\",\"frontMatter\":{\"title\":\"Custom Cursor Pattern\",\"description\":\"Analysis of the implementation principle of custom cursor patterns\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Custom Cursor Pattern\",\"Interactive Design\"]},\"readingTime\":\"10 min read\",\"fileName\":\"customize-cursor-pattern\",\"category\":\"personal-website\"},{\"content\":\"$1e\",\"frontMatter\":{\"title\":\"Floating Navigation Ball: From Mathematical Principles to Interactive Implementation\",\"description\":\"Detailed analysis of a draggable, snappable, expandable circular menu system\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Navigation\",\"Interactive Design\"]},\"readingTime\":\"30 min read\",\"fileName\":\"float-navigation\",\"category\":\"personal-website\"},{\"content\":\"$1f\",\"frontMatter\":{\"title\":\"Foam Background: From Canvas Thinking to DOM Implementation of a Particle World\",\"description\":\"Detailed analysis of foam background particle system implementation principles, from mathematical foundations to interaction optimization\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Canvas\",\"Interaction Design\"]},\"readingTime\":\"26 min read\",\"fileName\":\"foam-background\",\"category\":\"personal-website\"},{\"content\":\"$20\",\"frontMatter\":{\"title\":\"3D Case Cards: The Interactive Revolution from Flat to Dimensional\",\"description\":\"Deep analysis of a foldable, tiltable, and flippable dimensional card system\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"3D\",\"Interaction Design\"]},\"readingTime\":\"27 min read\",\"fileName\":\"living-card\",\"category\":\"personal-website\"},{\"content\":\"$21\",\"frontMatter\":{\"title\":\"Particle Text: Digital Alchemy from Pixels to Particles\",\"description\":\"In-depth analysis of Canvas particle system, text pixel sampling, and mouse interaction physics simulation implementation\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Canvas\",\"Interaction Design\"]},\"readingTime\":\"24 min read\",\"fileName\":\"particle-text\",\"category\":\"personal-website\"},{\"content\":\"$22\",\"frontMatter\":{\"title\":\"Skills Constellation: Universe-Level Interactive Design for React Components\",\"description\":\"In-depth analysis of dynamic bubble layout, probability algorithms, and SVG connection system implementation principles\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Interactive Design\"]},\"readingTime\":\"20 min read\",\"fileName\":\"skills-constellation\",\"category\":\"personal-website\"},{\"content\":\"$23\",\"frontMatter\":{\"title\":\"Skills Galaxy: When you sit cross-legged above the sea of stars in your heart\",\"description\":\"Detailed analysis of the structure and principles behind the 'Skills Galaxy' feature\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Interactive Design\"]},\"readingTime\":\"26 min read\",\"fileName\":\"skills-galaxy-analysis\",\"category\":\"personal-website\"},{\"content\":\"$24\",\"frontMatter\":{\"title\":\"Style Injection: Phoenix Rising from TailwindCSS Preflight's Destruction\",\"description\":\"Deep analysis of style loss issues in MDX to HTML conversion and complete implementation of style injection solutions\",\"date\":\"2025-01-22\",\"author\":\"MilkWind\",\"tags\":[\"MDX Rendering\"]},\"readingTime\":\"24 min read\",\"fileName\":\"tailwindcss-inject\",\"category\":\"personal-website\"},{\"content\":\"$25\",\"frontMatter\":{\"title\":\"Complete Code Analysis of remarkable-katex-plus\",\"description\":\"Detailed analysis of the remarkable-katex-plus plugin code\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Code Analysis\",\"Plugin\"]},\"readingTime\":\"29 min read\",\"fileName\":\"remarkable-katex-plus\",\"category\":\"plugins\"},{\"content\":\"$26\",\"frontMatter\":{\"title\":\"Complete Code Analysis of remarkable-mermaid-plus\",\"description\":\"Detailed analysis of remarkable-mermaid-plus plugin code\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Code Analysis\",\"Plugin\"]},\"readingTime\":\"25 min read\",\"fileName\":\"remarkable-mermaid-plus\",\"category\":\"plugins\"},{\"content\":\"$27\",\"frontMatter\":{\"title\":\"Prompt Alchemy: A Journey from Templates to Intelligent Language Parsing\",\"description\":\"Deep analysis of the complete implementation principles of prompt loading, structured parsing, cache optimization, and fault tolerance mechanisms in AI services\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"AI\"]},\"readingTime\":\"16 min read\",\"fileName\":\"prompt-word-analysis\",\"category\":\"questions-party\"},{\"content\":\"$28\",\"frontMatter\":{\"title\":\"The Double-Edged Sword of Keys: RSA Encryption's Security Protection Path in Modern Web Applications\",\"description\":\"From Mathematical Principles to Engineering Practice—Analyzing End-to-End Encryption Implementation in Questions Party\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"RSA\"]},\"readingTime\":\"32 min read\",\"fileName\":\"rsa-protective-measures\",\"category\":\"questions-party\"},{\"content\":\"$29\",\"frontMatter\":{\"title\":\"Vocabulary Collection: Building the Sea of Words Together\",\"description\":\"In-depth analysis of intelligent word recognition and storage system's full-stack implementation principles, complete technical pipeline from frontend input to backend AI processing\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Speech Analysis\",\"Spell Checking\"]},\"readingTime\":\"30 min read\",\"fileName\":\"word-recognition\",\"category\":\"questions-party\"}],\"categories\":{\"all-chat-on-this\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:0\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:1\"],\"ark-yituliu\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:2\"],\"basic-knowledge\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:3\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:4\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:5\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:6\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:7\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:8\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:9\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:10\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:11\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:12\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:13\"],\"personal-website\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:14\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:15\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:16\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:17\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:18\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:19\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:20\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:21\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:22\"],\"plugins\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:23\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:24\"],\"questions-party\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:25\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:26\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:enArticlesData:articles:27\"]},\"totalArticles\":28,\"totalCategories\":6,\"categoryList\":[\"all-chat-on-this\",\"ark-yituliu\",\"basic-knowledge\",\"personal-website\",\"plugins\",\"questions-party\"]},\"zhArticlesData\":{\"articles\":[{\"content\":\"$2a\",\"frontMatter\":{\"title\":\"All-Chat-on-This 配置解析功能实现原理：从配置到消息的完整数据流\",\"description\":\"深度解析 UserConfigDO 类设计、prepareRequestData 数据处理逻辑、以及 sendMessage 消息生成发送的完整实现原理\",\"date\":\"2025-01-15\",\"author\":\"MilkWind\",\"tags\":[\"Spring Boot\",\"API配置\",\"JSON解析\"]},\"readingTime\":\"53 min read\",\"fileName\":\"json-parsing\",\"category\":\"all-chat-on-this\"},{\"content\":\"$2b\",\"frontMatter\":{\"title\":\"All-Chat-on-This 端点监控与暴露功能实现原理：从AOP切面到Prometheus的完整监控生态\",\"description\":\"深度解析 Spring Boot 应用中端点监控、指标收集、用户活动跟踪的完整实现原理，涵盖 AOP、Micrometer、Prometheus 的技术栈\",\"date\":\"2025-01-15\",\"author\":\"MilkWind\",\"tags\":[\"Spring Boot\",\"监控系统\",\"Prometheus\",\"Micrometer\",\"AOP\"]},\"readingTime\":\"21 min read\",\"fileName\":\"metrics\",\"category\":\"all-chat-on-this\"},{\"content\":\"$2c\",\"frontMatter\":{\"title\":\"专精时间减半计算器 - 算法详解\",\"description\":\"详细解析专精时间减半计算器的核心算法逻辑\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"算法解析\",\"明日方舟\"]},\"readingTime\":\"13 min read\",\"fileName\":\"specialization\",\"category\":\"ark-yituliu\"},{\"content\":\"$2d\",\"frontMatter\":{\"title\":\"MutationObserver\",\"description\":\"浏览器基础知识篇-MutationObserver\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"浏览器\",\"基础知识\",\"MutationObserver\",\"DOM\"]},\"readingTime\":\"5 min read\",\"fileName\":\"browser-mutation-observer\",\"category\":\"basic-knowledge\"},{\"content\":\"$2e\",\"frontMatter\":{\"title\":\"requestAnimationFrame\",\"description\":\"浏览器基础知识篇-requestAnimationFrame\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"浏览器\",\"基础知识\",\"requestAnimationFrame\",\"动画\"]},\"readingTime\":\"10 min read\",\"fileName\":\"browser-request-animation-frame\",\"category\":\"basic-knowledge\"},{\"content\":\"$2f\",\"frontMatter\":{\"title\":\"Framer Motion AnimatePresence\",\"description\":\"React基础知识篇-Framer Motion AnimatePresence\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"Framer Motion\",\"动画\",\"AnimatePresence\"]},\"readingTime\":\"11 min read\",\"fileName\":\"framer-motion-animate-presence\",\"category\":\"basic-knowledge\"},{\"content\":\"$30\",\"frontMatter\":{\"title\":\"React.createContext\",\"description\":\"React基础知识篇-React.createContext\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"createContext\",\"Context API\"]},\"readingTime\":\"13 min read\",\"fileName\":\"react-create-context\",\"category\":\"basic-knowledge\"},{\"content\":\"$31\",\"frontMatter\":{\"title\":\"React.memo\",\"description\":\"React基础知识篇-React.memo\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"React.memo\"]},\"readingTime\":\"5 min read\",\"fileName\":\"react-memo\",\"category\":\"basic-knowledge\"},{\"content\":\"$32\",\"frontMatter\":{\"title\":\"useCallback\",\"description\":\"React基础知识篇-useCallback\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"useCallback\",\"React Hook\"]},\"readingTime\":\"9 min read\",\"fileName\":\"react-use-callback\",\"category\":\"basic-knowledge\"},{\"content\":\"$33\",\"frontMatter\":{\"title\":\"useEffect\",\"description\":\"React基础知识篇-useEffect\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"useEffect\",\"React Hook\"]},\"readingTime\":\"10 min read\",\"fileName\":\"react-use-effect\",\"category\":\"basic-knowledge\"},{\"content\":\"$34\",\"frontMatter\":{\"title\":\"useMemo\",\"description\":\"React基础知识篇-useMemo\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"useMemo\",\"React Hook\"]},\"readingTime\":\"14 min read\",\"fileName\":\"react-use-memo\",\"category\":\"basic-knowledge\"},{\"content\":\"$35\",\"frontMatter\":{\"title\":\"useReducer\",\"description\":\"React基础知识篇-useReducer\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"useReducer\",\"React Hook\"]},\"readingTime\":\"16 min read\",\"fileName\":\"react-use-reducer\",\"category\":\"basic-knowledge\"},{\"content\":\"$36\",\"frontMatter\":{\"title\":\"useRef\",\"description\":\"React基础知识篇-useRef\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"React\",\"基础知识\",\"useRef\",\"React Hook\"]},\"readingTime\":\"17 min read\",\"fileName\":\"react-use-ref\",\"category\":\"basic-knowledge\"},{\"content\":\"$37\",\"frontMatter\":{\"title\":\"TailwindCSS Theme\",\"description\":\"TailwindCSS基础知识篇-TailwindCSS 主题配置\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"TailwindCSS\",\"基础知识\",\"主题\"]},\"readingTime\":\"10 min read\",\"fileName\":\"tailwindcss-theme\",\"category\":\"basic-knowledge\"},{\"content\":\"$38\",\"frontMatter\":{\"title\":\"二进制雨幕：向机器运算界的一瞥\",\"description\":\"深度解析Canvas字符网格、径向遮罩、鼠标跟踪的完整实现原理\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Canvas\",\"交互设计\"]},\"readingTime\":\"16 min read\",\"fileName\":\"01-background\",\"category\":\"personal-website\"},{\"content\":\"$39\",\"frontMatter\":{\"title\":\"自定义光标图案\",\"description\":\"浅析自定义光标图案的实现原理\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"自定义光标图案\",\"交互设计\"]},\"readingTime\":\"13 min read\",\"fileName\":\"customize-cursor-pattern\",\"category\":\"personal-website\"},{\"content\":\"$3a\",\"frontMatter\":{\"title\":\"浮动导航球：从数学原理到交互实现\",\"description\":\"详细解析可拖拽、可吸附、可展开的圆形菜单系统\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"导航设计\",\"交互设计\"]},\"readingTime\":\"40 min read\",\"fileName\":\"float-navigation\",\"category\":\"personal-website\"},{\"content\":\"$3b\",\"frontMatter\":{\"title\":\"泡沫背景：从Canvas思维到DOM实现的粒子世界\",\"description\":\"详细解析泡沫背景粒子系统的实现原理，从数学基础到交互优化\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Canvas\",\"交互设计\"]},\"readingTime\":\"36 min read\",\"fileName\":\"foam-background\",\"category\":\"personal-website\"},{\"content\":\"$3c\",\"frontMatter\":{\"title\":\"3D案例卡片：从平面到立体的交互革命\",\"description\":\"深度解析可折叠、可倾斜、可翻转的立体卡片系统\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"3D\",\"交互设计\"]},\"readingTime\":\"40 min read\",\"fileName\":\"living-card\",\"category\":\"personal-website\"},{\"content\":\"$3d\",\"frontMatter\":{\"title\":\"粒子文字：从像素到粒子的数字炼金术\",\"description\":\"深度解析Canvas粒子系统、文本像素采样、鼠标交互物理模拟的完整实现\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"Canvas\",\"交互设计\"]},\"readingTime\":\"31 min read\",\"fileName\":\"particle-text\",\"category\":\"personal-website\"},{\"content\":\"$3e\",\"frontMatter\":{\"title\":\"技能星座：React组件的宇宙级交互设计\",\"description\":\"深度解析动态气泡布局、概率算法、SVG连线系统的完整实现原理\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"交互设计\"]},\"readingTime\":\"30 min read\",\"fileName\":\"skills-constellation\",\"category\":\"personal-website\"},{\"content\":\"$3f\",\"frontMatter\":{\"title\":\"技能星系：当你盘坐在内心的星海之上\",\"description\":\"详细解析「技能星系」功能所包含的各部分结构及其中原理\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"交互设计\"]},\"readingTime\":\"48 min read\",\"fileName\":\"skills-galaxy-analysis\",\"category\":\"personal-website\"},{\"content\":\"$40\",\"frontMatter\":{\"title\":\"样式注入：TailwindCSS Preflight破坏后的浴火重生\",\"description\":\"深度解析MDX到HTML转换中的样式丢失问题及完整的样式注入解决方案实现\",\"date\":\"2025-01-22\",\"author\":\"MilkWind\",\"tags\":[\"MDX渲染\"]},\"readingTime\":\"33 min read\",\"fileName\":\"tailwindcss-inject\",\"category\":\"personal-website\"},{\"content\":\"$41\",\"frontMatter\":{\"title\":\"remarkable-katex-plus代码全解析\",\"description\":\"详细解析remarkable-katex-plus插件代码\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"代码解析\",\"插件\"]},\"readingTime\":\"40 min read\",\"fileName\":\"remarkable-katex-plus\",\"category\":\"plugins\"},{\"content\":\"$42\",\"frontMatter\":{\"title\":\"remarkable-mermaid-plus代码全解析\",\"description\":\"详细解析remarkable-mermaid-plus插件代码\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"代码解析\",\"插件\"]},\"readingTime\":\"35 min read\",\"fileName\":\"remarkable-mermaid-plus\",\"category\":\"plugins\"},{\"content\":\"$43\",\"frontMatter\":{\"title\":\"提示词炼金术：从模板到智能的语言解析之旅\",\"description\":\"深度解析AI服务中提示词加载、结构化解析、缓存优化与容错机制的完整实现原理\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"AI\"]},\"readingTime\":\"24 min read\",\"fileName\":\"prompt-word-analysis\",\"category\":\"questions-party\"},{\"content\":\"$44\",\"frontMatter\":{\"title\":\"密钥双刃剑：RSA加密在现代Web应用中的安全防护之道\",\"description\":\"从数学原理到工程实践——解析Questions Party中的端到端加密实现\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"RSA\"]},\"readingTime\":\"44 min read\",\"fileName\":\"rsa-protective-measures\",\"category\":\"questions-party\"},{\"content\":\"$45\",\"frontMatter\":{\"title\":\"词汇摘录：共筑单词之海\",\"description\":\"深度解析智能单词识别与存储系统的全栈实现原理，从前端输入到后端AI处理的完整技术链路\",\"date\":\"2025-06-22\",\"author\":\"MilkWind\",\"tags\":[\"词性分析\",\"拼写检查\"]},\"readingTime\":\"37 min read\",\"fileName\":\"word-recognition\",\"category\":\"questions-party\"}],\"categories\":{\"all-chat-on-this\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:0\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:1\"],\"ark-yituliu\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:2\"],\"basic-knowledge\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:3\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:4\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:5\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:6\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:7\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:8\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:9\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:10\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:11\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:12\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:13\"],\"personal-website\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:14\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:15\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:16\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:17\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:18\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:19\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:20\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:21\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:22\"],\"plugins\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:23\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:24\"],\"questions-party\":[\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:25\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:26\",\"$0:f:0:1:2:children:2:children:1:props:children:0:props:zhArticlesData:articles:27\"]},\"totalArticles\":28,\"totalCategories\":6,\"categoryList\":[\"all-chat-on-this\",\"ark-yituliu\",\"basic-knowledge\",\"personal-website\",\"plugins\",\"questions-party\"]}}],[\"$\",\"$L46\",null,{\"children\":\"$L47\"}],null,[\"$\",\"$L48\",null,{\"children\":[\"$L49\",\"$L4a\",[\"$\",\"$L4b\",null,{\"promise\":\"$@4c\"}]]}]]}],{},null,false]},[[\"$\",\"$L4d\",\"l\",{}],[],[]],false]},[[\"$\",\"$L4e\",\"l\",{}],[],[]],false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"-aQqaqXirs9zCkbyedcJy\",{\"children\":[[\"$\",\"$L4f\",null,{\"children\":\"$L50\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$51\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"52:\"$Sreact.suspense\"\n53:I[74911,[],\"AsyncMetadata\"]\nc:{}\n47:[\"$\",\"$52\",null,{\"fallback\":null,\"children\":[\"$\",\"$L53\",null,{\"promise\":\"$@54\"}]}]\n"])</script><script>self.__next_f.push([1,"4a:null\n"])</script><script>self.__next_f.push([1,"50:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n49:null\n"])</script><script>self.__next_f.push([1,"54:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Documents - Interactive Portfolio\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Technical insights, tutorials, and in-depth analysis on web development.\"}],[\"$\",\"meta\",\"2\",{\"name\":\"author\",\"content\":\"Developer\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"portfolio,3D,interactive,web development,Three.js,Next.js\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Personal Website - Interactive 3D Portfolio\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"An interactive 3D personal website featuring work showcases and technical insights\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Personal Website - Interactive 3D Portfolio\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"An interactive 3D personal website featuring work showcases and technical insights\"}],[\"$\",\"link\",\"10\",{\"rel\":\"icon\",\"href\":\"/MilkWind-Website/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"32x32\"}]],\"error\":null,\"digest\":\"$undefined\"}\n4c:{\"metadata\":\"$54:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>